<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Informações sobre as barragens" />





<meta name="date" content="2022-08-16" />

<meta name="description" content="Informações sobre as barragens">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","date":"2022-08-16","output":"pagedown::html_letter","title":"Informações sobre as barragens"}
</script>

<title>Informações sobre as barragens</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: hidden;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>



</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Informações sobre as barragens</h1>
<h2 class="date">2022-08-16</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<div id="objetivos" class="section level2" number="0.1">
<h2><span class="header-section-number">0.1</span> Objetivos</h2>
<p>Este relatório tem como objetivo apresentar funcionalidades do <em>R Markdown</em> e do <em>Quarto</em>, utilizando dados públicos sobre barragens de mineração no Brasil.</p>
<p>Os objetivos específicos da análise são:</p>
<ul>
<li>fazer uma tabela das barragens por estado;</li>
<li>fazer um gráfico do número de barragens por categoria de dano potencial associado;</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlh3ACrAPfgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AB0dHSkpKjY1Ok5KTlNBPWhRS2xaU3pfU3xvaIdjVYxyZY1sXo+GgJF+cpN0ZpR6bZx7bZ2Edp6Ng6aFd6qNgKyWibOimbaajbetpcGoncazqce/t9TCuNfRyebh2iH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgDgACwAAAAA3ACrAAAI/wDDCRxIsGC4cebOnUOXbt26d/DcyZsoj169evYy2ruXj5/Hj/7ykRM3bpw4geJSpiSnsJzKlyXHkSNn8qXNmzhz6txpM2bNkwNTGhyKkidOn0iTypzJtKnTpwoVEiWKUCFDh+siUpxIb57Gjfn2ffTYj1+6kuVMhrNZTuHInmhjGp1Ld25JnARVTjVYF6bSv0ufCnYa9dxeg1UVNnQIbyvXeRgz3uM49uM9muPSroV5Lt1blUr7ih6d8q7eoKcP5x0NuPXg1zOjqg46rvDVrI65XrSHb3LYymXPZnbZs/O5n6FJK6f7c2jq2ZtFtwYMe/A5loahi8Me9bbE3PK8Sv/WJ5ZsP3/8LpckRxx053TtSSJdTp8uUaHQUUufrrQ67OyqkcSdVegwBl54kfm2z4JkoSfcTD+R9B5Npc1X34U65acdafz1559gAB4mYGGdFejQd7klyFFYv53njz2YzZSWSbWl085xgGGo43Maishhh0l9KJh2MpGYDjrsnCgPihTNI55v+URpnllpsQRhSZ2141mQFO6IYY/5KQfkX0I2pV05A5ZY4DvuuBNPbk5KtmKUYpX14nXYQdhWO1oy5ZNbEXp5U3QZgrnhj2P6VCZTZ5KTUHfoIJkVPG9OhGKcUEb5Gz/ozZPOp+ngyRKfNzJVpXGfCUqjXqfhZehs9SX/quiiZz4KqaTwNJabRF5lWh6n6OUzD6laKtaOk8UWZmOpgvaU01qovQorfbLOKqR2jtoWqaTrtDnRPBO1E16vc47lz7n85DPZZMMeu+6woJLq1Y0WNmtTdEVJuxeG1Vrr330FbWfrQtsmmRWvTiZMrqYdgYRuugzfAxaL97R77DxR3kPvX/byBZS+zuHFWr8yrVfdVB+vle2t3GoV51cbzdmwR+c+XNmvHqnr5JxiCTuYTzuGDLLHg+rXF8kmw4byx9uRuC233mK6bqZSmlvz1ei6WDM/+1Q9Vj7tYAfqdRwrJ/TQRd0b8HJIBzbY0kIVqS1DSWo17tRUe00z1nz7/6P11pzS7NE9y84jcZ/T9QUw2oTidx+iJCsNt8pz042bwjHnTWdlfgPbN3qfXz04ZTl7SnZrcz0+dNEBDmpX224zuu9JArPMTkMIP6m5zDh7Hjp6e/uOtdb82OPO6estJddOKKPNY+tiwh5763IT+ClWCMtJ9brq8mx16JV9D77GoULI0thdEiriOCA7Hmas0jtFfZrcKik13txn7JuCH/0NeM4Ma1g//Oe7nJHvHO4w3GTs4ZnnLe1VDpwdq9gWP9ntaz1Oq1ubspe5qcEMfzzrHcTSBUKv/W5r6tobeugVwbUFDHrQAtNLGrcf6cUEVtUj2IncIa/7weyHH5xaAP/1J7GN2ENqevPb1f7BRCb2LV1bMo37VsO0KXqsRy00Wl1seEMfyQRUoIoIDy+msIpl5GVn/IpXXgbCBSrsjUjUlPCa2MQnMhBP5UiLFTejHx+lbHIy3CIX2bfHCiEEjN3aIJ/giCxkEeuRjxzWGg33Rkj2kFyk45sTwWcPLY1NLQFjH0pAGbI9ru2PEHydDRtHqJigKR0bjOUYLSnLWrYJlrI8FrEsZslIJmxiwjsherq2ok5SKC+gJAkqN0PK2TEubUahEexygpaZPGqWxJqlLWMJxm56c5vZbFMvF9mrjgjziYJj4FsGUhKUaIYvNfHjMymItKMs5T3ipOU227T/Dm9+ymkMAdUO91lLSO7sN1vDWjCfOA8cEXIka3knMptJtGcSbWT9uklmzodNfcoSK92MVGHMQVKS2uZ6BN2nvCTTovCF73dgK19mRJmZPypzmdC0aCmjNyY9giYznekoJGvZT39GpaTsyaNSTWqV67VjgwNV6SIzIkeXWvWJ+TjiOfJ4kpKd8nGm1KkWa9ghGSGHo7uUpJNiiZWiHmlbCjFHUpVK16XaiiFsTWRKV7oiEX5kZg7jW7q0xD6vrgasOBXrTgU5JlOhJSGwfGruEiZZdzQEjCKNa13r6hO7krRAKd1mGavqUr8uEYXtQBPZgKLMnSoWi2Tlj4CsJLbQ/1a2qOp4q2Y3O6M8IqWukA1tLd/IPZzZ7Krn2iR6CPdPCt3llGF9rQS3KJ/Ejeg9uBQuVNPBDriag7e//YtSOQpVvRb0kTHbXGDLYlXPKTc9nbTsalHzXOmmkp7JEUc5IJtdok5KjOXtp0i/y9mZdkipQcWdO9qq0nKqF1j/uBp7Idaw5NZxmDoL1YzmY199wS85mYGseW2JvY8WVaRKnemGpUiSFaNlv2BcsD+LOkYHm9AfFwacpsRi4Tr+tWJgvI5PE0ukeFqUWiDe71UAvMFc5arEHw0ygX0LNKGkpDNKySN2r1fUqI5rYlVzER0jrOOq4piO/1PXGUtlZBl+0f9G7oDokT8slzzyV8GxhMc72hrVNsGjraESModD+VNXni/Gn4rlxfoqlq6Z88xjrllZGFYeSJP5fyS80YyIfB9ytANKGpPznGnI2BebI6CRYkyenQxlErtV0PVFWVJe2U29PmlTA5wwp8aMZnQ5Wo49Vu65zjNYPEa3ILX5dAA1Vg7pItmVbWHIttShwSazelIL3uCS3PHksQma09WF9pZ5uDOOLKhO/gs2r8nMtSHuLcfoClYnZcpplaVDgTKLUjrqLS0675dg02ZHkiCy6j872cn+DfJWKRrK37ZlWe2Q0+ZwNkCsrTvSBsxfncAn72J1yYr6TQdY8sewfdv3QiX/ScjTIkVtgR+MV9w2+MFzRVQZo88l95n1KyMumfSG5dybstrFMa5m7bUo3VvbB5Ddkr61yCSB3CN5xszBbw8jeeUBX4fBaL7WmXv9O9wGNPpizczOng/f69JIvs/NOUtf3G9KD+LP+VFxTQbrgAsvjTk+3cYA7gNGHR7r0VD9NGprHStcn4efvU5zioRd7EeCtcNVa6O0s+uNPv95o989dB8X/Sv8Q7oT4etxoEa8jWsvHjkCL/i6HOmtWedz4hUfc5oD2PF/PtGJA32Okvo+qJisWLsUqbsds12FnY8wCYGoIP85UfkZDlXlUZ9vTYWt6qtbDtbVwX2XtxUiuYqH/8LiwXhvLcng/PSnQLt1rCNWsskOYdO3YqYP8px7425f93J/KJ6ja1L5JARqbaQPxrcgYCNRHVYf6oAO3NeALWcwfPYQlDJ+XzcR9rBtNMdWUfNLcLRt8Pd9uSIPGNEb9Xd/+Jd8fqMzmJM5YVF3NXNhY0FMIFR/mlce+2ByrEdqfSFwPNiD3heB4AcPbzRz5mcptvRLaqQwRviBWud9IUgPvIEP9UeDLaJuvOYPSicePzQZ5fE3vfYRMog/NHh8wSFKrFcfPpiGERh/Mzcu4FJ7duMklvItcYIPjLSEq+YQPNhyD/EObxIZ+BCIk0EedGeFaFY8w3KEG0GIXvhemv8ygPaHbunhDmaYg8vRfTzYhBAIhIyXMJaCcLxyRHQ4SZ64FYs3c3smcA3Yg+/gh28ChVrIhXU3dMv1VKASULhTTvsgZr02ad2DNyV4brmWD6GCfc5ziZiYiWuIeHrmdZBxERhoN2fUJEroeNamZ62oh+zggA8ocK3oivQQjpDBG/ewi7y4bsUTaL73WbgjDxtBd+cRaRj2i+sSjOjWDzeIczmog3SRhj+4jBARhE72h9DogRt4INYIh3qGFarIjS1Hbd/oh+EYju4nhQtyjmPGDw01V3Slcrl4D4V4hfM4NVPIdsTmM8ZodTxBRS8Rkam4iWv4jYxHKRMBjYvHKwj/uYQyt5Bat4DTloze2IrxMJQTeREYcQ/1N4tXuJFU9lgLsRDpIIT5oJQwGIZIGYl1kh59kpKG8izTpRICyZMA2YrYGJYDKYL1YJBgV4SmWHsR6RAL6HsM2H0P+I1DGQ9FWQ+9IYuG6A+Ewx6B8m+XBUv2sItW2Dn7UH+DiJViQThbxZWwxTp+pBJbx3hYAX5kWZYuGYQSkZYeeHCZGYK1V3t8pg4ktVRzuYBAKZREeRGBOIbxiI6I0yoP5yQNYTjuhWZl0TVTyJgLEmeVKFZeqSE2oYzhVymniIqb6ZIhiIe5smdsOJNiqYfoMGX/1nuf1Y3swJoWoZevWWn6xw8s/8Q0ReIOxrMO7miYlgY8BtibjEk4+iickhmZKbGKlUmTFEF+oBmRrMaflKKfytmHoamc0Kl1kXKavGUO2rmdrTmCFmmY+gc2TUc5sLRtGBObm9RuUeKe9/eXwXmMpXFs06ISyRiBurIVAMp4AyqdLNqif6aK1ZmgSJKG4GiUvEEeGFlH+xA2gSliC/ZpdIdxv8ahBLgPDcVw93VTInoo9emPIFgpuTGULjqlVPqcL3mgKZZHM0qjrIkgFomhvKaRDVQaqsWAiVSYbgd3muKeNOihxxgoOmUTy8iJzRmlVXqnLAqd2xijdMWAPYiJcYkk8ACF75h/aCYs5TMw8QKS+f8XLGsaQPrgDsQBMvUSeDNZoHwWhFCKouSXonh6p++wjXHZp/ZJl+iwVOrwDuOyayhIQt3jfgoEoVe4mzv2iOhAO11ZZUvKOAd3l566mV7nq/Jwl5/qor4KoKHaXXyqoA7ZgNapZAVSjoYokr/zfJFGqwYYJQ2VkuGGpDnIePr5JkM5rPu5otLpkhLYjFZqrv8prsSqZzCanc06qsClDu7AY4aafMKWr07ki494PB+ac1S2q6MmEJdplsf6q/yZmWT5jWP5ltHZq+I6Eb7aijCamvNKYKemDuiJD1M5rfpqrZv0dgGoM0mFpBVyJZD5Wj54sHeaqRD7sBALrhObsMn/Kqrz2oDViST08KVaE7K0CLJ01A8BdBb4Ql8p1mYvtI8E0bJACKwEyrCb2Yfxl43LSbP5abMWm7PUtoo9i6MuCLRiS4sBeKSs5XQbtWlws7JDo4bfN6eZ6qJQa5YzuakJGw/fiLPN2oPxgBFg+7NjG7gZyS55p1955CfRNUNMWxBOCrcxSbfFirWOobWhmrM8KJQZUYKF+IKC27khEWqHS1umMZmLaxAtC5NzCrWRK513CR7HqpkN6YCXK5FqB7ac+4I4JrTwpq/p4SmgApj8prily7huG3+P65+ry6Kty6meircWq7eYyJ0a0RtVeGahA7S6+w/pckdqO5kE22HF/wuQApq8d3q3Uupkmwm9l3uXhCpxJ3hpFhey8btuRkovI/q9CZgSTvuw5Nu/XrecySq73si+HzR3SDe/b7evhpoPxzNfISMXw7s048Bd4Vu1kOu/q7ucf7qaBGyU9cA/hZhrmyu05zS4ffJx0bE8bKtYTZMO9/CPAnrBxQrAzFmlAOyDq+mKeNmdromUvzJAYxG2b3dCV5hVyeJYyxPBKEMO90YZESux54vB6rqfoKrBGzy7rImXHkyCfhXEnKt/wyZ6hzpvgYYZWRTB2+HC/cMPrJuwUhy5UkrDN7uHWKzDaGmUPswgQOwRDDLCQ9w//1dHRtx7k6rEe2F6pAOGB/9bw28cuXLskmlYl3bpqx6sl3kMjxP2w1/8hYC8RBl5pN5qyAeRbGBGjy+cuo/cyOf6yM/rj9sZkcdayXtpf1MCHDm6SROWa5vsRB66wizsafYwRI+4IhWcyqo8kM7LyhHpyqE6yeN6Eb+0l5dMd7Z8y8MGHLvMRBr5mKJMG+bgDmtngmBYzHJ8zMeZzMrcyqIalM4sfglDkaA3zf2TaznaOdjMr4gan8OrX52hQMJMkmu6v4sMwObcrum8zLELkbB8l+8cjvggd0FHz7o8q1wTWEM3WFviy1iEGU2MPyyiD8BYf7xBzsbcyEN50Aitt1jMvhM5kTAjzUV6j7qsbnD/p8fZ7Hk8GrDSVQ7Sh3agB9KKyYVTiA/1INAxXM6qfNIHvZ17KMCvrMM73NIvDdMG7DfOV0f4aNM3HWFZpTHIw2L4lRQIhEalqG28cUbgshVGnc7HnM6u7JArzdIt3b5ROMsGPNObXNMXudURpg/tUj6LYipokrTUAXzzgJeyxJOtiJYUMXM9CLPK3L/K7Mr+uLez66tz7dLTa9dk6ILryV5aza8YLXmJYhQEMcHeMq7oqocP0S3PWMlOoowuW9LJ+8hvzbXrzKU6nNnwXNckSGldmFyfrWtCXMSmc0yvJQ7mEJVxPMc02px5uRuyPb60ncFWjMNcy42UvdC83duB/zjL9vi+uqlr8OjJhwov3KxYh3R4lO2DMqkrHpwR043SMjyl6bvB2W3ZzJzF3R0ZGSGIJXl/m3utXNPHmGzeXI3eehSn5RAp6QCUf6rbEKHFNmoP8x2QV8vWcpvSTZ3f+r3d4NjdX/HdAU6GwYaYxzfPPdZxlgUhGs1O0cZyuO3edhyONSnfj33U9I28q6zOCe3h2t3e7k2UmQ2I332VBt7Jh2iCJnmOGulJnuQWC+5hp/aTlsulWtsY9GDUrZ3Oi9yikNzhQD6vQs6Kuz3X//3dUkjL4XOOw8Tk6NZj4ukZg50WqhUVyN0jtQFw+e2PAPwQQ1nB3/fnQDi+Kpq3Yv8+5nBd5kNO5EXp2yRIiNSs4pKW1Uxe3nRkFt9VZcy0Mi5eK9W5sR7u55NcERYh6IO+2oWuzJqo6Pq9oIwe4kWp5gDOiLks0UAM53EOaf2Q0RHUYk6htHnxb9UJcBj74Y1eEUbZuMcbs5ma6lOridDr1Ixe7X4e1Y+u5r1pjuwl0WCo6+UNaf7Ao7tKpk3RvcNRUiwz49e+w8veuDmu4+LruNoo5tZ+70IulEWu7SU56Zi8x+dW4rtORzco7BuSNIf7KE+jcjJ+5TTq7lBYD/bpytA+ndnY2o6L7xof65vp6OHooJEe3l04QEwu8BPdRNts8LBVpnSzpyuX3cwcD/b/cBH0UBGqCetJooyqTrXsXeb1vt877uPsDMBybRF1fZUCn+IlTx60XHGZriWFTKn7ZVIsl9t9buZC6Z1G6ZM4z9qLPKc5L+QDnaxBX/btjO0gj/Qir+tsv3FDO29RD0G8ZWeRktv2LuF+WMncV/fwTu+sXe0WrMx3afZQbb7YbvRHnvRtz3Zw7uZg81TXsbItNvfAVVIyXsdy7Ks62/VthbrLiOo6nvmGP/qkj9mHj/gkrviJqfq7aIJO70TEuGV5Dh3DQfm2X+WpWfjmO6ybb+1+z5AxaegLjbelX/yjXw/drdlqjvQLwqYc2vya22jmaGn7AJxYgir6LGu2v/12/4b7LVf4ExnVOuunvh+Bnt/sNGv86t/S7Iv8yb/Zte787lmP9tfv5kH9LDRKTMwnGa39AFFO4ECCBQ0KNJcQ3UJ06tg9fPcu3sSJ9Oipw7jQ4UOOHT2yWxeSY0iSI0mejAhP5cqVFF2+hPmSXsV49SzexEnPZs6b9ez9xBc0qD6iRfXdQ1oU6dJ7+vY9hbqPX79+/v5d9bcv3bly4sJ9/SqOXLp2Zc+RG+cVbDhx4w6+hUtQYcON7CLefSfvIt2GH/3+NSny4UmSd1myjBlP3mKZPHPudBwZ50/KQpsqZZr0KNKgl6NKrerP6r9++dKZ67p27bixZbeiHRfbbVzab//NndPoEW9NdRr7Agbud91gwutSHkbscrFknPWcP4funKf0ntEp28OHHV/SzJYvH/XuFCpV0Vb96Zu3NbXqtW3JnUsXPz66cwlr30d4WyNGjnjl2WOIobqCA0yk4ghD7jDFFtOLuegehBBCnSC8DijvhMJwu++W0lA88srzh5970uNqHPZOFKecdNxZzB14BMMoowDpSwg12vSjK8b+4KlHnwB7+41A4Q4MCa/jkqOIweXoYbC5CJ+EEroKp8xOqMoy/I6opZyaCsR//MmnHfnOUutEsFI0Rx14WJQnHpXimekdjmKUcaGE6qsxz7n2w+gdeGrSp58fcxNyyCKNMxL/L8SUbJPRx56cMEoKp6T0OgwtxDLLovb58Et/+sGnHa7e28pEFNHETaN1GrzJJTkfohNIdG47p9Y8a52RP53wcUpQARkq1FBEE01wQUblkVTCZK2rtFlLg7KQs/A25TS08vaZJz1zYnuPzDNTLEc/Ou2aECibbHK1I1kZqrVdXAXEKB4PnxqUrmA9KjJRPxOE51hWmZvQoueclK5g55xFmMpMMdRMvGpF83Qfe9yJ7yxua+1qtjv3Y6eig+vBEN2IKHp13RlPzk0eh6FCWcd7QRr2SH7/VHLgnPz9NzLIJmvWyoQrXJhhoqDqsjx+8pm4vorLceu9hd7tC87qnsPH/yd70GXHIYlIzhplhhRSk9dAnzKqZXvvzVfmYhd8UC+c/QWYnp8zvPRn7Tq7B0tqPxRNYorTYfo9c2AzJx2WWMRUKJ8Ghm6mrDuSSM46Z92Tx0Cpwrxs3052mcC0Z34T2Z1vert0Bm22KGG6L4UW4dX19tDa0uZxB1dyBLIVt1Xnufv1qrEb3aKJXv0oRjuBpadXzDGPCl6TOw9uWND/BNh00x+c2/e6Xffds4f7Tk+9cuCrdUV55jkY7wyx06dq6nB6iXhYs47VoXjsiT2qfojms/5xPTfMzJYkGesxyjmiwx73tOcz7fSse0P7UD/ukY7bCcQtZMlW4oQWFOdkZ/8nFGlVPF61NRGqS0cRoQevxtMPfnzmKb7Kkf/4Ez3jTE8xwbtZAU/3pOz5roFXUmDeMATBquwPH4CLDULSwTtp0Q1TkRIeCGdSwv5wbU5RA9kKMddCsjVlH7+SIfSGtC8Bxo1JOlwMD3uoPaBlh3tCtIzyPuU3wI1vHRnsHd1sop3GRTGEEZmT/Yb3qn7hL3ZbZCFV9rGZe/wojGLsyOf4JTUz4uR6CGSW6nxot0oxrDNyBJU9zsci3k0JZNCykk7u9j4pihCQ9NOaRM7Yo2ot7zP8mIoi24cPR4ZRWNJDjhQracnSQclubOQkpRi2FND07TJXa+PVQnZK9/VOOiT/o4hdAHlCWaqwlrYk29BeuL+jAMmXBUqb2t40TMdcT42afF0ylVk1sRGxb/roJAep5sHoKA6KJYycNuUnS+x8M4KL1NJQnjIVqPTmnMJSVLHYaUZ/ReiYm5SnPqm2tyIucp5XW9zBfgKhqnkMawIdmUtARsTlMW+RQsSO9xpaP3SiJCXqXOdEK7nDScHTjfI0pXXEpsX93eNK23EjyCBDNepIDV0VcZzWXKJKFbYUc3NEKBw11DAWQvIjhDES6HQ61uZMJnUKZGA+X/ecK3lxnPtDKGUS6kZ+EuyDUOXJID1WVauCEzOZ2tJTHiccmNk0ovwia2IF5iSfts6BGZLS/92SQtSXEuWoqASpzqaIV8lk0aDkYR4jtdTE74RzHzUFq75mptjELquN21NrAoUmzpbuIyk/RWrrULezpnK2J9787BajwhQtGcWtpuXHXw6kL5yuhLUCW1aUQEohJ7qOmq/L0lt1mTfK5G2X0EKdY57qGL721aVQYSSHjutCzP0yZkcKYIJYG136Und9aMVudg360ioRha7gfR9zOFvQ4ILzM8ZF5XFbWp6vFiesK4kvcuZbXwpbrbqPXV1TGuaw2mppldCdLmTwCidKTjGF2jWwC8MpHg4pdJwgEo17D/vgSQKswjdm6zxhqzC6bXhlC7Wlh0e61OiEkCYgpKbyzP+rYiYjdLQcthaDG2xTeZCRxsVy1KNwTN/GOiu/RvmMVcPJ3fAWebMinKpnCwxORVaLi00eDy6jLOVILjcvi4HHlYPpqAEecMuSumhaeQw7aqH4zUXhZ4Cr80ck44Oo5k0xnHGZyzmDiCr4IlJEGEQs0E3Eelpu3JY56Vi1ElqcWuSHU4yyyz5OB35Q9eaSwwznW1K60p+yJabt3C955PmwnTYW3CqJ42M2dlo/rqWTjwKeROfEqaNb6crETGsXitPWt8Y1VVqoawczt7n80qGNRQ3UZ2VYv0CG61whq+hHCUyc0q4ttVUMaXpve8qG9fb0EmQ6M56rwuTOY48bpj//qiDYiewWXqTE1uYwR1reoKG3Ilv45tPK2NvfFmAB40bsjC5wS6denlIAPOSdOGciTd1VoZnMcLjSut7jgbNyu31xfSvI0xofJpeT6XHiEhXBERIYPmYCvHOdWsWqZjKY591SW1N8lz9GLUreG+Ga/ylJnx52dDvevZ7v1yjuEy91eNXBoSZ9Mw5btdEJLlx0r3g7KgcOkaaOcWAHu3T91nmg86vhe2hX2e1D+Pu+C9yjgyftq165X42e2w1DhYYz/3XVD4PGAeLdtWv0zsC/meqvg128QVe62Y2bGbUzPNn8refg3572xxs2z5KfHuWVxM7LN5b0Q+uSLtWN8EhF/7vwh2f2UGg77WpzJkt5Q76PvVpYfJMR9vuW/ewnCmj8Epe25SGnfwH81BK3Du0rBj4cEf9o9KIX0Z5cpnFjdW98Pz/j0W/SGXNuzJ71zvovNprIpxvFEksT7UMDvvMTvsPjlKgIwPb5rrsBiibCh/XjtvZzvz2Dv2OZPunyMrzRjBeCMRZCPdTBK5/YFFU7QAGMI70Bv9sDD2kiqbqJIfZzvQhMjgnkN3GjPx3DQLfiG+zjr/3jCaEYwVVDJuy4GwAcPaawEqvxiebQqHrIkTpjvtSiuue7ORnEmY2rwUG7wXzAPxhLNTILHgv7Qe2LJ1MawrRjQAZqNQj5n5F4wv/CiBkYbAkqfBsrfCcs3BIthDgYE42iyiyCGcDO8x0p+akQS5+h0AytAq8qmS7sgCKcmKEHhMIolEI5rEIaTCAsnBY8vKry8BQ+/MJT8i8x1B4iW0FUmi04EsIKsRpC3AkGeURILAw9k0K7o8TK05mewsQOsbYctLR98KDpAEUEVL21Cpjeoyak8Ikeu6/rUKUG8jeLaBM/GZA6yzRZhD1arMWcCbtLxMSGwcNc8pI9TLXsAEYfHMZNAsbrOorrqpLWwawha8akoo42MY6ocz26qztspESAyRb0iSwdywxNmbQo60Tbqhr4mRDhW6BFlEeRAqkBVBySK0RWdMhmg8b/dxgOeywMX8PHSZrCbIw/nenHTHqtrdI8dNPDT8kHcmQVOIm2c1yffyQ5Z1w9DrIH0gGxq7ErVTwX0pEfWNzIyPM1fbs6kAxJLRtJmSw30ssH8bi2lDQiUSKxoFsgn+FGmVRIsEMytuItSqGOInMvKORI5Pg2N7E6fZRBB3mObFHK17K+plwoOeOUlMwKfGoTimDHhbQZkUo0C9OOBNzLVSRHgfkhkoMu6AhLsOJI57vGj6xFtXQOtsyxo7I/bwQyOeNF8+gHwLvLlKvKJfQ3ZmEjsosnQezLr7yOetDIWOS053MHNgHJ6fDHOtQgk7yHfMBNp5QKzKTLuhS6mSDN/6qkvnY8uGREO+/yQod8EJ1oRspovWp8MMacGdjMxpzox9nExdokrtzUxN3ENRjzlE8BvH36TKCDrtIUql75u9PcJ1KsECGRu+aDPep8zMPEzgdBHx4LyNvMzcvkh++EmKvACvF0n+AcTUkpTuwpu9HavsOkPs+JTwisOvrcR+y8T27ElP3Uh9x0yggKx9HYQ32Ajs/UKGPcmUvpo8gyx2l6n8qLEgiNUJuaT6M8Hwu9wrbaT9xsyg4lyN7cTPfRpwVinOVsDkLcSdzSp8M8M5NqNYt4zhiVxOk0Sou4UIvSz4DcUA59q0+BGB9dyWnyocBs0pIzMyiCFBOLopSqif9i5IkYhbxdk7zXlFM5ncDrtFN/1KT9RAodhcvdBK3e1EE4yksUHdLdKtQiYxwHfTXmEqYzQiCLcNNIdDD3m9M5hb87vc7JzCc95U8ddUpwxDYQaSFUHEUxfR/6a1LHcBV98a3IiFQJhTDXlIdKfc1LvdN6SMp8iilO5dOokLM9BNQ5Cj5T1CPeCrUogSw/WtLEaIwQOqubeNV0egc5XRPX5LVZrVRbxVQ8VStO3VPcXCh020QfRb1UDLg+dFApgZSQ4T8SY1Z3ncrI+AlojVYjqVTJmwg6xVZLlb1bJcmS9Fb+JBo/XR5AVSRpGTINYjehWsKeMEYj26xKatTFotf/+AwrMqJVfaNVo8zUf13KgBXY3STYzNzAohLUQpwmUEvGI8ShXRExmOgskbkLvOpMSLVYPctYfnGRw6BQKuxYTQXIgNXRuOQUzPxPg+1CFrUmdHXQPLKZNHvamLjFa5pZSppZm4XOw6LVnZ1Qjv1Zh7RBb81ScBVZbSsaHyUnmAqxdTtVFQXNKUKhPiKZlNIZf4KJuxweOLFY1lSJreXammOTno2+r13FC+RUohhaovVTLmXcDRxV3WIrxSlQgznXvuS/3mtXNS0xwkzSqZLavcVIjFwJv53RWaVEO23LTuLVsb2lRyvYXjRIiURZImVHinzZmgCedn3XqaFazX0JNbmLCMVck619PiURXNOZhxpNSqAFGiG0TaboVSa7NnrbQfriXKuUkFbB3HeVWp54paolmYAAACH5BAUKAOAALCEACQCyAKAAAAj/AMEJHEiwoMGDCBMqXLhQHMOHECNKnEixosWLGDNq3Mixo8ePIEOKHEmypMmTKFOqXMmypcuXMGPKnEmzps2bOHPq3Mmzp8+fQIMKHUq0qMZ5CtsZXcq0qdOnUKNKnUq1qtWrWLNq3cq1q9evYMMaTSe2rNmzaNOqXcu2rdu3cOPKnUu3rt27ePPq3cu3r9+/gAMLHky4sOHDiBMrXsy4sePHkCNLnky5suXLmDNr3sy5s+fPoEOLHk26tOnTqFOrXs26tevXsGPLnk27tu3buHPr3s27t+/fwIMLH068uPHjyJMrv1lvufPn0KNLn069uvXr2LNr3869u/fv4MOLIB9Pvjzh5ubTq1/Pvr379/Djy0+7b779+/jz69/Yr2xAACH5BAUKAOAALA8ACQDGAJ4AAAj/AMEJHEiwoMGDCBMqXMiwYUNxDiNKnEixosWLGDNq3Mixo8ePIEOKHEmypMmTKFOqXMmypcuXMGPKnEmzps2W/m7q3Mmzp8+V+X4KHUq0qFGO944qXcr0I8SmUKNKnUq1qtWrWLNq3cq1q9evYMOKDeturNmzaNOqXcu2rdu3cOPKnUu3rt27ePPq3cu3r9+/gAMLHky4sOHDVOchXsy4sePHkCObDCq5suXLHsdh3sy5s+fPoEOLHk26tOnTqFOrXs26tevXsGPLnk27tu3bNuPh3s27t+/fwIMLH068uPHjyJMrX868ufPn0KNLn069uvXr2LNrN2xPer3r37eLYR9PHrVus93nngeLD1z79gqTJscHv7z9+9fr49/P3+Q77e8EeF2A/w1YYH8IJqjgggw26KCC4T0Ikn4SGkdPhchdiOGGHHbooXP9fCgibBqOeF16Jqao4oostugiXvy0FRAAIfkEBQoA4AAsNAARAKcAjAAACP8AwQkcSLCgQYP8DipcyLChw4cQI0qcSLGixYsYM2rcyLGjx48gQ4ocSbKkyZMoU6pcybKlS4fzXsqcSbOmzZs4c+rcybOnz5873QEdSrSo0aNIkypdyrSp06dQo0qdSrWq1atYs2rdypXlva5gw4odS7as2bNo06pdy7at27dw48qdS7eu3bt48+rdy7ev37+AAwseTLiw4cOIEytezLjxSHyOI0tGa2+y5cuYM2vezDllvM6gQ4seTbq06dOoU6tezbq169ewY8ueTbt2Unr0XuPObbu379+O5ckDTry48ePIk8uErLz53cqw7UG/yBzpPufYs2vfzr279+/gw4saH0++vPnz6NOrX8++vfv38OPLn0/fZj+0AQEAIfkEBQoA4AAsAAAAANwAqwAACP8AwQkcSLDguHMFEyocmG9fwnzkxI0DJy6cQXIIx4lbSJDcRI4gQ4ocSbKkyZMoUwo8SHCdyYb8EqabWE5jQozgym1UybOnz59Agy6UeA4hOHQuS8JMeM+jwIoFyaVLF1HkR6FYs2rdClJcOaNHUe5zKHMiOYpRp56zyfEq17dw46qUiFOhPI72GCrk13RcOXI6B46Tmg7cOLdyEyteTJIu2IFJ8S6MKZDfTHBn2Ro+V9gp48+gQ1P8q9AlPJL5Ftpzerac4HPtMCPGLLq27aDiyJ1FOW+k5cMYAX+EDe6c646Zd95ezlxk7t0JI0te2E+gPePFaWMmTnWlQJwelTf/H0+eou6eefeC88evXWGB53ani519oO6pmMVj1V++v3Ny5sR1zzz0gZMOQu30Bo57AxU2X3GH+SdhbbkFOBA6WvGTzz0DEQiOPRwKxOCC1g3YnW38TciYRQNVSBCGW6U2EIf5yAjOPe3ENg+NMc1zYmgpqqjYRiwaBiBYMILmUF73yEjZdRSCU6SQi4lTEYuDWShQkqBRtlA7RRlYIJVkzkWkRVm+GFJ6cFHm5Y05fiijO9CVaedIVkoZzmCPKTRmiIm9CU5q+XhpD5ieZRXknXBZSSSffRakIGP8CMoRjj/SVhdPizL6Vp4WAWghlwK5M2lINtooF183TUVfoid1/+rpVnlipuVCd/Gkqki7guSPQj4u2OSgC8KKp5QpyTprV37VSSpjvfbEjz+/gsOPPZkmNuWyjfkVZkvccpQPmChtG25ch317Lq+IlsSisusC9dV7ZTa03kl8jfidshOZm5C/8ZI0L6OpWYoSmMcR5Fa/Acf1IMHT+oTjWgntxHBBEjWcUrPxRotSvnUyPBG8Gi80JXCc0QuadDwB6tO17x230WDjAAxwyS2K9xdnY64MlMsSF2uYecjivLFGM8/rTs9j9hzSrRxBzfJJ84CYFYcRDYZWi0aXlJlNGKWzNFDmJGwSZ1ObZPXVCGVEctdRWVjOcWL3hJDZKXHmTk9AB/9VIKw3w03QzpGepPI5Zf/EGU9rZ9Ur3oKHxCd+e6sEo3GQo2QOfryxKVedXEeekLfprFO5T5iXNBFirm3OkenLOY2VX2X6NS/sKtGLTtk1WVXYbPCpXB5ZDYK+sVQLnqpi60bh7hM68fVOEH+HzYwY8j9VCxe2xptUTjrK23lOkuvAczrqZUdoZeApLu6TP//Eha1gJuUGvkKXCWkOOlyuU747uerJ7oSzPo5YaTab4kn8BDQmksGmbwM5R+Casz/hCcR8QSlKeMIBsIwpxH12MpZCzCG7ghTOP88aCAZLdT6URK9m/vJgQogjEAgGhR/7sKFJSjiQ7/GQIPPo3rn/3HEau4XnSiOZj+cIMiyhGKwk2jNID+9HknkAb13uaCFHivhBAtZqhoUJX0F0mBIN/SRaUhEjSNqRuYBlcSRc7KJuADO3NlpHNTcSUjuWOJJ7aNFoRAxJHEECIwtW0R74IGNJzMgUkkTRJ/kTXSCBBY5JguSPKMkVPnxVkhDxUSD7eCJWTqixAMoDHoMERwAxqRV6iIRavrnHJ0XHHFZ+hh714EjERNIPj4HmbeuSR64CCESBEDMxuWQiOPZRnZHkYx62lIs5hEhLYXLxLr1R42f0wcx7gWRcKUSHOmi5HHloUZufwYc+wNGPZoqLTiOpGjlDY06CyAOdKRlnSkJU/51HDsQf+chWTqJzI+LNcyFpS8kwLQkUUulTJcz050D24Y70XcQo75GHDiVaMlRqZZhY2d3ctiROgrCDI7hUiDsT0g8fiVBrLkkoQTi6EEOS6R2pBAc81vEOnhzzJ+oQ6UCgJs6TKiSZCuEoP3ykmR4KpDcuwec8TxMPFQUVcSO91f6MqhBXFsQh/eDoPsDU1KGBYx1SRQkwVQQPYf50PEItiDnU8dCEeFUg6rQWSNpjjrJCpoU0DckPwxUPYU7IHIkbWjlKilJ6ePUe3AwrR/zBvSsetGsidc1HGLsQdbDjHfKgR170scuFANSlNSHNZYXy1ttk9kIgOY452BEPXP/aIx/wE4mG5kGgHPkWHGld7Z12l9gUCiSx4Niq/+5R2pE0s1LCFRzUFDJSguwvj8xZa3SZU90tTXS7W8npneq6EMQKybLgVVFV08teodQjr+2NL0/eu85QrpQxipSvipLZJH7cV78ABkmI7BvYz9kxwP6hUW1miWAyNTE0NvUUKRuslX1Ac8IK6w+fghu5Td7mQJiZG3rHMw4S7siXB/UweTIzoYO0A8UUlsuBRDgeiXyPw6tVMWhgnF2vPCzGDE7MPDBcmz09MMYECbJc8gHP8YSDKIMNsJLj4g8/9vU2T54XjuU7ZbmEKDAr2oiPtwyOdca3y16OcKOOG2Ukf4j/ORyiCtKuxME62/nOeLbz1p7Sou9F081Jvk1+BVLHwxhaJTtLCpkpjOa3uGyOkJ5jHSctGENbOkIYM0cRWwtoPJJzT8bttEgaHS6vEFnU0d3TdFFtEqQ2Z4L1GzGr9TimI8JaJAeeNUlc/ZmiaNDXhEbarSuWa12LhNeJMahB5vYtW6vO2EY7IJ+CTee2QPsnyC6PRAZzHsMIm0V7ujZQSP2zU1fMxn/ZTfWytGpxlyTbZEJ3QjgLlLu6WyvkLsn4YMRV7/7EsPcWClW0q5BwWxexSeq3SnQccKG4wzhQScmTR4xw/mGIHQrX9XoJAu+4tGNs8dHIsEOnOWjHY+MJ/+l4SpS9EBkBCD9rKWDD7zSWr8Y6bAba4M1GzmqUh8bMJXEaXR50IJFv68kzJ4i9Ww2aApua6DG/EsEp7FjH9oflXx10blJWHMTSsbuM4TSjli46xxRkHfxDrNrXrnatxEPlVCI7t64Vm5CPfB1vfUfGo+ZUk8CjHkBPOkpClLK+2izLWirfZ0BbD3sEXvB5cw3yIjKliZej3YtRBz3gC/mfsMZtHLRxaRhD13g8vvMpmUphjGOW6M3tVp59xzt8zhX+0ZYep0e9SXD08OIUpnd0S4c4PdvWxWw1Hvioue574qArB4iOrlMl3LfCP+RjHWfT90++6IM4wPi+dH+uvf863oH75QPFHegAcXINVLfaxH7zuS9Z9sl0HNpZJ99CoW09Bm1+rx3m8ugQfm9BV+wgD3l1ff2nFJV0IJwhdnIhe/LgeGSBgBozfypiD/i3FbjEeQqhfAkoGhY4EONXWPQlEvrAfx/IHJ+1gfEnEP+VgupVW6KVfCFBgQeVgYqBgiqhdwVRW/igTjYIgz/BcFwxe471XiLhgSFxDzp4LjgYL1VHX0FIEk0YME94LjPYgkExhQlIhD/BglzhEEoohIkxg1yoEFq4TOxEhmV4hDTIE/FXhWx4Evb2dj+oD2kIh9w0h2WIhHERSi74gil4hiThg3mYGILIh4W4gYoYLyX/2IjnkkuECIn+4YWfkYiUKBKO5XjMsQ+HmIkc54fL8YmgKBD1EII/8YL94ImkWIoDYYnb5IopoYWTKItZsXSoaIvjkYs1qItxAYsogYeJAYxkmFJBoU5y6IvKeFktSIw84YzLmBBpaA+8GI2gMX/QmBAYOBIOmIByRx7VaI3ieFDZlh7heG21OBDfOI7NYYygcRe0VxDryI5wUQ9RSI94pXS18YP8mBfAmI0NJ0p2tS7zaGzpOB73lYwBF0oCWRAAKRdj4YkhcYrn2GkNGRI/OG4PiVd4iIf8iI9acYopwY/4QI2uRJFLF0AV6YvTl22naJKuVHX0EI+miHoFthwiRmmKKwmSKmJ1PDkSG1kQsjcQNCkQBfmTBJGRcqGUSLkmQlFYcpeTTWkbVTeVcqFyR9lp/UROMykQPWWVYLlajbdJ9igSAQEAIfkEBQoA4AAsAAAAANwAqgAACP8AwQkcSBCcuHLmzp1Dl27dOngQ5UkkWM+ePXD38u3jx68guHTjxpEzSFLguHPp0pETJ86jwJYuY8qcSbOmzZs4c+rcGfNgwnMf2a17B07iRIIW7d3LuNHjPXLjykGFaRKlSpY3x/HcyrVguK5gw+4UR04hUHToHMJzZ9SjxXvgNO5zCVLkSIIi07k7N46q2L9ivwIeTHigSLPg0KobyvYo0osZ8+VzaQ+qVHBaTZJL1w5cucwmC4uuGU7w6NNbD5ZVmBitw3eOC1rEKLmgP3D86pYNnbczVLzkyJVDTbw08eM6VSP+iE4oPHDu2HqcB1nyZIK37fEFx1oz53bnyg3/x2z3LnKeps+rTy3V7FmGDqEXnW4P39LaA/n588ev3UiUBG3WTjsqgXPXakAZ5Nd6MqXH4IM3+eRea80xFttAb0WGn3633dNZSukIVBZn83BnoIEKpQTUghC26CJPZP2kEFroqCPUO/BciOF9km3E0X64edjOPPN0hhKR9szjzkcoEThkZ6CB9uKUVPZEjowLKSbUQ43JQxB1SkXmI4dAdmSdkPPwCFc70RWZkYcmhUSelOs5+BeLVeZElntZ1rjlWvIQSaRAGVo3Zj/7lcnRPpJFxhE/kxU5Tz5LbQSXYSFlKqdYeHpkHHJ25hmTSDLSiA44f7KFZIY8WvdoR0AK/+RPP/28yg+is3Z0H6Q+TjZScMAGp+mmg5lWWqgwdipqTqSaRaM6qHIpEZhLtWpdPq+CE6usiXbbra2P9iMQeCkNSOA5d2laGEvHhsUSVsvqOZBgh3VHY7TRBUpktdb2yBFu4CBqm7fdcqsfh+JiNOSklM6TToJ4ZUYsVy19SvG78Y4Fk3H1snavtIKmWa11NG0b023Y8UdmwpK9SimBMmXaFVYWawwvOMfWnLFLGHOMoECKgcNlyGFeKlq2LhHcEczBiRgcuubZ5ODGBCnL8805I7tz1T1j9vNH6SzmkDuCssoVyi6B+6hHBMd1T5EqjWjuwzdNLU67yWGd9dYRdv/9M0MNja0qq0v95fK1kZ0s60Aqe8iZhvmApzHOWvd0s0B4843TuzD9Dd9a+SJptEuXVovRyBseTim/I9v0z+v78bPRt9flTbmCNXFOkM4FXa75QO/21XFr0ppb9kXgzEYooWDONhvriC9lUciiE7R2Qf+A8zrsSn/kmabK0vyV7x5hjHnmXFstWOUviqMpgoBzuTD1A1Fv//0lJiV9koIOeD9BrqLJ9tAWFyMFqy88Q+BX+kK13ukNWeTzyqd4RyWWhKQ9IApcdIzXmYKY64MgDKHxqCfCD5aoIPdZHAFp0hG4DehhWrEb5UJSMZ2Zj3J2uuHuKLgszrkvUyPSS3T/NgjCggzxiEhM4hBLyMQBsbAjOuHItexRoN4pUE45Ax4Dd5ge3XHxd1Wbk3iCkxAiDsgdbOogQZKYwTa6UYhKVOJNrrNCbskkdvvJxwmrhkXP1DBi8EKfghYkSDAa5IJXskq5iiiT6KzjjSlBh7Nm5D0jgi6ONWHK4nCjtqQlSlx71IpI7magGJrmhzWsmRfnxb7fRSWIaAwhONToEYc8so18Mocud7mcmkTnJkqpHSfVFq6BoS0lUPkNWUypxVRabJU4NCRNXrnIEg5kSY5cB9jaKMlz6FI44gknQnRZmGCCoylrsxXAMjkPdA2nJSvBWyDlucpCSrN81PzOBz2S/81bcrObuhSnQMVZS7CIrCBQBCBCTwYpmMFzHO1y38Y+5UNW8vCeBTmMXs7YGVoKxB3+zCBazGKOgQ6UTgIxx0e0uSSeiGx02NnJrK5TlpGQUqLnG58Xs4jRm2DwiDHBpkMiaSpvmjScmJmTzDwzHr10xXTnTGiirHcTlJ1LqakcJFV42tObpGgdQDXiL90Bj0eqo6jhGShelCoTAAkkRDkR2WSwBcWCCaRWOrHHC9GlwJZkaqv27KpMQIREm9gyHTQyqnhEmVSXTIwg5kjJWytZkxJB7lGJ+gfaZqWTRhWJryb5jPgCK9jBgrWwN3kkQxKT1s+IUmYMDJ5LhhNZuP/C1SZpupaPMvu6rkhRj9tUyWdectG+WU1UDUEtToaKWMW+Nk7sMk4VPVIOt9pkSMG81o/8sb3tIXSu2Mke26TIL/Dc5bg02ZNVVgLGlIBuK/FhbUmTKqe7ZW2ZJSnIZm7Lz6JQy1+Qmox+utvb7+KnZLEjr29Eizk9naQdkXkbUFo5JfiAFTDooq99s2accJCvupK95pKwe59DIQqz3O1u2khW1f3UKnLTTU450pHbMxmouFVCS0PeixMdDUSlxN1bGB+7X++RjTpi2oePcEUwAsdEdquD6UzQplfurCgr52hHdg/sDohS+EWIjdZauBJf5lTNnj9cqmdQssGXykX/bQlDmYpnAil+WY/JdRTIZAYEMdzhM8vQK0g6SPk7/nKppTdB9ENkQmh8LnWMJArTteSi5LQNpMB03sf+jKaRW9FqhSiD1AmhNlw+AhqqLjkHenNckEPDV5sOhi0Ga7y65x3YI//SHqZlUmflDcRfCbONtur8WdC+ZMYvLZyUMUIOHLN6IGqBCKJtcpQye2QkCLRgpqQit6Ldg39la/Gun0wpX+uEP8lzmECGk5dkw/TA/HiKs+Nly0UPcSe2JAh/gSXQREb620ma5RKH1OI8s03T5t4JpQKEEm/f5Cmrpne+pS0dansJHM+RSWLNkpIjU08e0YGIyH85kHvo48kC/6sJf8rNk+ytcEhvKtzDr9LVehuxLTPR10dlctolrkpQFw/5O+oN65vgSrxTRjjytpIr2TFq2eA4eUza0Zd5S9wlRgl6xgui86kHKilJCdlEjgiRdQiFHUIZSDzoYROTMTQfAe/KbRY1Gai7pFZUt/rVY5L1nXuk6/PR16rAvUeQIxEiQ0e74h8+kJSXDO6D8pJRkBQXnNQdJ7QCxzzK8eXSVnaP8zneoIoikZBLW+TwSDza1WEjl8RDNkufS9v3YQ9HtvEhX8+ITcBrk4SxCaKezwk92C6fL43+S1w3PFlR/xyHKJ4drIdWTepB/dhv8mT7cNhISarjtSB5NOkoR/+jf2dtnciD+MUfCOCxrnzmE0Ugq4++9GcyfIHUgyBSdzt29rGXkg7UHPFDNoORMPwwD/GkHhF3GkdxceqneQzoEssncgUBfaZSIzHxDu/wemuHfgJhcowjEEgHQO7gf59RguMBNA1RGPGmHeM3GtDUeaNxcVsnEJL3gAQhgROIDrsEgPPHDgXxfhs4EBWBD1Ine+MmEP3BV8OiFQCYgtBxQgaXEwWYEgiEGvVEWsfhYwIBEelXEDhIEOrQWgjBE/WAD2YodbhyMg4DFbFlQdxBY/OgTReXZ1FIGeFRdTC4OTslZC9ig61WdDdxViR4guCwS6cyE9R3hie3DwITgvn/4TCxdTtA4w724CWUmA/Bhh21wig10Q7m4GV5mDsVhUN6hxwMOGYCAYg5wQ6SNF8DIVCoIhMcKBBK1hFH6A/74B9bZBgjwoBpMmCYtom35hIOw3mhOBPBU4Vc1RVA+Hpg1GcE1XoxMYv6oBGOJ2z+UT4/ZYnntB+Y9lvC5BThZ1+cYkEPdIw8hyMYR3peyDeb4ieyiEKToX/5MSq7kVyah4nchVCyNxPgUXXugkrOVIrBRxM6OB6ZAY8xYSPvBw74cFfeeDIeAlqvxBqSNSn6wRPaIVroeEhqxmHrAQ/OmDEU6H8pxXrQ5xL+Zw7qQBQVgRv7SGdwBx4pkkFoZA+M/xiTOeEO4teCNpFmNJRTWIgc8eCHU1KS48GDrOcR6CBOAOiDZJMP9EgQsEN3jaIhOXmEw8ZzwNd5QKlAHNaRBWkTFJhSNbKUHkGCBLEQ7oAtmTgTA0Qw3eKINkFFXZk7rxSUIDmWyBF/QBN9KolUhciW9nArEXkTBIZ0dHkTD0OIV2MXWMSHfHke76B40id/TGmIsFEP97ARR7eYyGGA7lNqfASZWrFh8jSZDwJ986dxqBIPROiZcwmax+EfqPkSryQceLiMEaSax8GaNcEO8VCG+sCIeEabxNFOVagZwmIQYQk8geSbDMKarTkQioeB9HCGSpaGOnke5RZ+ohQs7/+Emjk0WtI5nWhJED6IKhmYnfZRnIYpZw/STghyXnuZPll1ntOZkhPIDhgYD8NZHw95TtizHuJyEQ+jm+RZnvMklvrJFdRpnf6ZgRtoEQ8pZchZGP0Ad+P4LoGlO8v4oMTRkKiCmajinwC6dtW3dBrRIv3RmBtmOZsimSL6IOk5oSk6fEPYgQSaa7Lylip4LtiWQEs1lAwiEtJ5o/+ZoxWBPEtxcj7KSec2pb4BndomMzEqKofhUXzZg0SRogJBDy95OvCZUMOUE3WYNAPxMArBb/VFoy/yYImzjtKJgS4hpi/5pLXoEf2IeWY6ZZAHM1Z6m3niPucwD0v2p3U6jdT/14H6UJx9ynRRShMcag5T8ZyFmhf2QFc1ahN42oEmt6dyh1c3wQ/aQUNGyiDuIyCJc5Uy16kewYH2ARi5khP3UCA+SSXj8DjDqFCw6hL3RygDWhNAOjCZpxP8lamAhh+VRotj8qt3OhD4sHRg4WJ/GpGLOYVR4yIHcSS6VxBRZnKPKnW+WZ3TKKzUKhPHOmWkCpFpqkcqgVLIIVGb8VI5Maxd6qXxSCjpGhPXeH2MIzuMk6ZoAxTyOhheJA4ocWqwZ3fneVaHyJ4kOpKPYXRpGjACa0eUehEEgm1/5UMgG7JLOLJ/pRX+s3T1QCRZVx/JUw9Zp4VdZaLXqXZbEakl/7OJjXexpupECRosPvuz4rlYwxJGrxhZgzIPfYdxsAZWjToQX3ieiwdMMkGubdeuAXOxBBo3rkWymxKynBOWe6MXFycPM+gSM0h9aBus0DoTCTcQVOsRu8ZZBFGsbBMguwm2eJu37EOiMpEjMLu2MdG2M3F0IPijPMEfcIIc4wBkQpMTOEKxgButbhEWs9IPzVpVOxsi20oYIBa5qxgWYzqqNstCC5dSLlgOESsWRrmasSgq/UpVKme5aBo5TiQQbRqUYXESgxEPqZeBLhK1y1KGMeEjsXu5MiFe/kBFUBMsVuZOyzklJOq7q4l2VTJ8sjq8TeERmTgro3tH9Ak+nP9DKgkhLAl4GkW5un1JvenJIDlaf8vjEtupvQVBK4pKE/bwiW0Ylu5jIAd0XIv7oNRprupBoe4LDsJbEIu4rrjmdAp3ZQ3GRceyv/wrLLgbWiIawC+SoxSBvXS7TluRrDRxX/DCb67lmJ7LvhSBrwXRvbTIdB+xuaTBYVghHgCoGALcFchzfie8r6F7Hv6QuGCRM6OZEBHLmqsHFiq8w7EarCy7Hre6HZzrlDUMf1whvUqMiMLKIHPRsQe7OVFREAK1g1O8Eyj6t1d8wOrxomBzhzAiHjRxVDV8lgWRomB6xTjxusSRhE8DIlNRvlsRTirVJ9Rrx1vRw+fRD7fakyH/sV/I9LyjQYjPcp18S8gyIbg64YGYR0V3EcHVNTdTQRwmPBOQS8kGjMeowR/a8RsWtSezxMV+cRCDEcqkbBOGLBpvGW/t1FgSFA6HscaWCk6zDK1p+Gu1Z2wxURqrymbZJIg7WIi75MzkBBhqG8yjwcKIrCQ4gcy6e00ih4GVSZ3UeSqtqFKM+2M3UQ9vS82MdxPdO4UpEh42kZD++XdeMspMmVjlTBP0UB+MqM6o0b3AZRkowV48Ix4LMRDSaMD3Vw+zWJl/QQ+P2s/+vBMOaxMwhaTh4RdRoUupuxP2bH6QOtEQEm+CmmEYLTzj5HpVvJ438Q5iWpwi3SIzOZhg/4wgB+20eDrN9lcQ6DfIAuHQwSkPxUkrCiwQNxzThuM4IRIVfSZijbGjwhcPk2wT6gCbxjm3v2rKokJ7pgvPtsvRGdfE6+HSMO2sSM0g/VB7yGS73vQR7RAoOh0TSQwWaAebZX3WLZJ9anki/jMlwxmbNIHJYVG2yDGLhhSp+iAPBrtu+XwaLB0T8WAPdz28PFpaCx189+Al4ZEQ8HB8EPLXIU0Tsht8cd1VcIG0g/MiFdGZRT0TxttVpS1Ycw0hkv3aCPykVGvbeP0X+jDbW2HYNvHXrC2/BfGQA8rCghXbYJTODCKmsYncyM3cu32vO7PPsdnaCBy5TZs8F6HVv9ZKD5BbhsbZwTsh3b7p3WLh26ISoIBNE/pQ0SeM3rD63OTdFcitmsgj3+d53cRR39O9NcR532Dxaf/dVfxd4KRshmeI4MH83AJes7fC4BhFhMcRbFMp4dWrFBhOykNo3hseue394Xas3iJe4iYuTVB94idMhB6u4lvt4jAe4zI+48EM3zR+4zie4zq+4zze4z7+40Ae5EI+5ERe5EZ+5Eie5LRtyUpuSI/a5FAe5VI+5VRe5VZ+5Vie5Vo+GlgroiS+5WAe5mJ+1nU15lVSv2buIthtxwEBACH5BAUKAOAALAAAAADcAKsAAAj/AMWNG0fO3Llz6NCxWwcPnryHEB/Sq2evor179/Lt28ivI7iP4O61S1dOnMlwKD+OK1cuHTmTJkHKnKlynDiaOHPq3MlzZsyeQIMKHQpUYLmCBhEqZOguYsSPFjFm3MiRH8h781zaFIcyJcGWL2EGFUu0rFmd4c6qXTuWYMGDSheuc9fUKUiL+DDm06jR48d89tqdI7e1q0By5Q7C/OkT3E3HjNlKppmW8uTLmFeSIwdXabp1DOXVffpxXtSMe6la/ZuV8OKYm8+l27oYZO2PkTGvvZnSsu7fajVzhpsw3cJ3dOM5lXe3ot7UGz/y2xdSMGHaAsGVM0fy9WPIr4Ff/64svrxk4Z0TLn0Hb7RdcPVMX9yrsep0cPmyDh54Mzs4cumAR5aAA5pXFnkGJmiWZkkdpJ46oDm03EPgMEfRfNDt05FVVomUzn4DDfSRbOfwdxs42Clo3ncqqsggQg4mpI5cEi4HknzP2beaVfOMVGKImp3TDopACjTOf67l1uJlLC5p4IvEPbhQexGNVpppOW7oF36BjXTdQJuBMySQQHK2WYpOTtZkmuVBGaOMU7pHGjjOoaahljJh1Y6XiB11UDpabbYZSyQOVttPSorXW29sNpoTlOpJydSEzF2FWl9argYOP/d06c5gsaWzp0vDgSoboEnG5F2ivyHo6Kszuf8ZKTozRjjhPPPIRF9qmYLTz19S9QgooO3gOtKwyO7pJXareqeoq2se6CqsQUEaqTq1NgTRPA/hiiNIe4Fz54a++vMXfZ32OI9eeirrbkXLkmmiqidixihuanVF3r3U7iRrpDTW5a23dYKbj7iZ+qOwuZtuus9ez3UEsUUXsWudvPI6ZttjrA4FbbQ96QtSV/1We1SDsx5HJcGnXarRR+Py08/CC8vUK0gS75paPiL9SOaZIW7sbL4IdowWySWf9S+tEDLVlHwVS6UzfTHPTDPNPU13ME0iCer1QV8G3Wy+PoF89LRJD+VWUtc2TaU8uEb93NSYdmT11QqvxfOHf7r/q5W8zZp9tEyCU8Zv2gsi9SatET7trVQu47dzPgnjbTlNeN/966b2iFosutaFjXG9IaMNFNI6FYg4TgSZwzY6gAYMd9xS081XzB1Zrvvu/fR+t7mAXaQpp3xiTNC8XMlkOjiHl948bqqvjtNRbykFe+PuDBy17XzVvWE//Owuvj+Zhq/w5h8xLJ2HogsKKm36Ln/v8iM/D73R0oNE/evogDYXXXGrk8u4573cjQ9v5bPb7myGFVIRhjPEWtZJ4ocTpKGugvbLn1n2F6Om0QWAOIIcAek2rgMqLIFa+h3ebMYPwPCpHRjqmk3idzhGpYRFP7kgTR5DPw3KZG2eAc0H/2+EJcjNbVcD1NmGMpeph+kMd+ObicQ+Nzx77Oc1F7RgWr4jlgx+J4M+/GFsTvWZ9tAEakZMoxoHiLtM6cyIvNKS7j7yjzqykCb5aAfQFqPFyhiGixMMI3Ba96fP6ARqFOtUIhO5RiXmDGKQE+ClMqVChdXxkpesGc7u8SHEFIkraSHZH3FYOEGexU+yAYk7zggO7VUkbq6kmHNkuUapvHJgAZwbFK8GDkxm0h//wFp+Oum1csxQlDfE4U56U0pTzmQ4AeIJrlrZSlway5rYxGVULGIsdxVLe7XbyxJNiDXpuNBvWgEl85LZpDWJrJnOfOap1oGTIcnEm/j05jX3mf9NXObzm66snQHJicAW7iow6ewPTGzCPBQVCIzx7AlCyhiUD7pDWRaly54++M+OetRd2pTaQOcoPinyTIJiEVE4jMQYpMEzojQB1BBBYk+dZDSj6bipTjPajpuC46L3BGlAMyKzBc5kjjYbJtBEBBkTfeSd+NsYTGmKz6H8D1lYzar/dprRn/60plS15nw0NEdyyeRyICFffvYEoq04dJ1/FEr0IuouMX1klTnxn0wA9RFAzUo9yIpQQ3TanlUa1qtD2tNMckk582lqU716LC+TyrNPJelIkCHZXMtmtJe+SrFEGZZMzjGizpg2Up/BnkX/11WazsSeWPKedMrX2KP/lpOFPQOSMUF5E6embrMfiQ1DfQjanmQ1Heo5iOvA4brmNjc9xQGH/+Ah2MLqVEz5zMmOaPuwO+HstjPZh34EhTwU7SQ8rAOHqC4yj3N4lk10MS6yipNc17GEJR8ph3ZY8twopdYd0x3sdYdozz3RLlw405IT6eOXcebtqC30Edj4w9ScoFd54RiHkHKFn065N4zx5QlWYYcOuJjjvijWr4pR7DrTfsYd1FWtT716UX1ub7Zu3BVVIDtQO0pRT4AajDFDtCaToOmpGRbSRQw2D3IIcqY4+QxySVzic5w4xVhW8UBS3F9A+Y+1rb1pT5VVxLlNR0skhJkCLfkPKRoU/8ht5Q1uiGw4cZAje3jMD2Z9aFGcgCYd6oiUcrN834yFiMsGgV1qwYzXn3K1xmW+VBunc6fo4KeEvmxzgiHmI09i9pMzQYmdYZiTvbRjzxpsrXQ/8mds1ZfQKTbeoVlSvWEJEcAAZrRODSw3O6HwzDuO48wyrT7wtVAkEg5TTrpCECXrZC/uQHX+6CLgmdDTr8mFNYrJZGQibfm+bwmsYW/9aAOvS4Te84exy/eXqrAZkyx8s7A+9B9pr1QciSmWPZ69l9k8GcZmpAk92RHohJwDy7LGDks+vRJwG0S0GdU1T2mH7hKeb90bOpiOw5dpTeNY3p02poAIkg7T8IQv0f/+N4wbLRPQLIQdBi90wrHTOjLlhIw5nQtoVClmXMHRYR5hYsbP1Zdh+/LBCW7hR0IOJNkMad88cWLKQdxnkNBTuut4eZCvvJLRgZLZ1zHyt2lday/vPCeQxtJf7phWmq37YZLjldF9OZN1n5RvXhMVh3tCn85JW3ozXrXV/YdcKy+c21/Xl0BOYqSGU899ijakNMtytd5pTeO7Ml/Hz6puic27b3sHykbuUaL3wre1DYFHy/+Md08TmYZ/FLWRyO61pPBVlY5eZbGKhZFz2ezBHq/85ePOq3fDu+7TaZeBh0KdjtzDHM60boihPPh1FN4cgzIR7BUv9oZ7bTO2j+b/XS1q7iPG0fjBd/ub4djYd2uy7RKTGvOt0rt9+FuQ0gc49WP6Idd5OvGwt1Bb9n3g9ycyMXEVQzUbwWAcl2mcd0IQExKdkiWVpD7pc0KPFRTU4Sv9sA8ioV/41x75F2I6UXhW5kkTtH3d530EaIC5d1EHpiMbcifod3zgsDDrp0jbU3QqhDls0TucdH+mxFUiRmKGN2THFD8r+G2154JphyGTVj7A1HGXBH/HpoOMVB8y8zs+iD6iBxK9kw8k8XfP0kM6kX+DFRTW51egsnDNYjxkl2jRRDBH1Ebgs241SHfwdzCylIVFdzUelz4NIxTUMTPgY0VkaC+w11BCMYIk/9gTaxhkJ3h4M+d4fhJN+uYcUxOFvrMwVOhjwdeBwdOHdSJ34JVWZbGFnOJ35SEyZigUOwWJkWiCg5JlZHIUR8FXFGd+GZJAveOJn3h8EIiFtKQXd/KL5mKBZjEuWeESpscTFPSKsFghohF4O8F6VWZl2EeALRgg+pZGtkMVGlI1wBiMvZRW/cAzdEKK23OMd0MTwaRuXqhdo5dQ47GICrJ/kDhl2Wha2mh7q7SLE8iL9VGQwpaHenhWx8aOp8GDSCcTdYSDO1Fp7XBiwBUU2+ckjzgU8/UgxSFaV8KQLTNCdYOQDgiGPMNNYlWKGjIzOBGR53MfNCGO9uAOYbEWNP+0TuKxkbrxZV92gN0SQCo5VEnUPeLUY8FYhenTQvaQK1XiHqaBD/rQkspIRzAJPhsoE1RxD+7QHURDQQYSiyoyO2I1MEGJRgTJgOYzhUl5jubUlKKBdbZmKziSlTPxS+RDaSBBFYChFWaRkfkoluVxlv0UehUilOH0RA6WlG3mYzcIGPIAD2yojeCAEB+heh9xD/vgknd5lR1haQuoD+1VEkKxfdJ4GY+mj0ThFIWJSxQyE/IwEXhBkFVxN4zpmP6QH+6ADvaFZYkGIU+jmS5pgb9kbNGBLunkPCKzOnRhI0IREYU5IRWyE/JQDxSRF/qgD9ABHXZjm22ZVuJ1cDL/N2vW82LrspnweJW9AzP7kJ3zsFvLhI8YljaUUinUSZjW9B44wQ4LMROyKZXamQ8BWh8t6Z3m6GP54A5XtluLsRLmEHlCtC7zCBLx6DuUBjHuUBLuJJ/98prPKZ0ggZ/cYpak8RAs9xH8uQ7vMBPWiQ8ueg/ZGaPZyRHIyJab10uaJoYy5x3jkGg6BxryYA/oiRMXh5UboQ+d8xIYxqHK4yjOCRT1GaVRqhP8WaUrKhP/6aJSiRExSqMGepIeJ4b/tyrbATuiEaH6ED45kZeUNnqWxRtMGmqnCRxTGhRSKqU8UaV6+g5X+hETcSFaqqUwOpVbWI5055j2h4JvCEEf/xQamlmVN+gw4sgz4vkSYLlsEJUgd0opH7GpT1l1eaqnVuqff2qdeIGdU7mZX1qFjskPF8Ms9+agsrFydGEP+TChN2ikB+VeMKFDhpOpBuKpwlqndwUUonqs7ECq1rms1wmgG1Gjmxd8eeQSQ0amcnhr80A5kGouC8gz+eFQZnipsJJR8VCuNzWsnEoUVTojyMoOfAoS5UoP8jqv1zmoz4qMehiITBk6zIJvcvhiMLSZ2+owE5Oc8ZkSc1oeAmFRqdewH4SnMpGuQsGf2FKx7CqqMxGv8/qnLzqjBWqjjmlSwoJ9SCir83RRQoqrabWQFcmgmAqsCmIS5NBTH9Swl//paE7xsPaJGQQXaBaLLceasfGwsfJaD1rapVRZgzjBssMCF8gCg6ahrToRkUxJrW61pKGUNM3WDvzQsF4rYHJyorpBcLPys0ErE+U6tPTarPaatNGqaZqWM+kilFAoMzyRSR5okwwKp+IKK3ZWcprZtV/rsM3poeZRcGX7s0CbrEKrsaVqD6hKoyaZkDzWRGvWE5kUYSDiGDlZMhrWDo0lM4LrtQe4SoZrHmT7Vz5rtoyLtmm7sS3qoh5rNbcZspljFpnUl0TSq4jzuaFLLg0BDphJLfyZEIlmPYnbuvD6ukW7rJBrr0UFst95gUc1FJjEKQpqXmlzGCU3NZCTPzD/px4ParzNJSPqgBNpq7bNW6+pSru1q5REmozAdLeX1A89o6jPiBl/uy46I4HPoUGuFikLyl+0khPvkL7My75u+74h+4BsthOYlJteUq0XqbAAYqsKqJUz6EMVK76+eb4GXK458byEaqi1G7/BBL85gbetMab5WxZGcQ7ugCEIlpkfkar6ILyDO7yw0rMxx2XYchbXSTm/w8DwyGYgu8KXxCmdhIRR1ROrQiAalj3ssjVXkRf3cMP6gA/2sMOIE8ADvB1BHMQ54WpACw7xcBULbMQQSWyYW0f2a1lObHr0EjiOMSjpkBHfu2T+SxNcXA9e/MUFN8Dm8LNlTL4P6q5p/6xm7svAgYijEfzG/2C/E0xkzRQ4mCwQw3IRLkon3gI3RnsPf4xNgYw4qYtiTFOxOWG8BKzIe4mvjvzIMPmQUxuR04p9lvxbmUw6KGIO2fPJEEFtEbKs9GCiO/y1Ipw2PWt4D2qxHwHCzxxovZnIdyGcJpxJ04ujp1jL5INQiMEk1poOcFMpXvsO/vOu8FEPOfG1l7nIaXK6MpG646vKOIEtzkXN8HERU7mqv/SdeAmpL1lHEUZvFLzLjecToUQy6PAU8MCnfIqxfeqnIHEhXUy6wuvOCvKkZVxwqgzNMhHAcPIRFAGjAnvN/fyJVhmP7wfBttxpTqY2TGU2LRG8fP+adchKE8qxzhbdIhAxr8uBwGphviINubNr0iZplSmt0rSMiimdm+PlepUYxTRBEEsBDkHLnwY8whUdvO8spQgcDxEdFOdLxvRA1O0Ly0dn0m6Z1JPVdkjHwsRUsrI2NKyDEBQ7I+DArkKhzjRhs13t1Qj80GcxEZG7hY28O1TYxuq5por9D/xQk6Qi14BzYTvUowlxGfGgLZfJ1X/d0xMS2OhMFEOrwB9LUDfa1MbG1AEdkR7yPsZD2TmRGJZJxmfh0HwKD8rh106yHMX80+nr0MoLFKMNudhZmwSVhxQakeBjW8qYafuAUCAx2bw8PZYpGXy6yBKhw6m3JMP627b/Hdw6obGAWtylTU6JDcmdx9zJmNSs7dJORdf+YhCTwbhpXKqArNtnwcP3KazeDdw8cd3iPZupWqiW4zs1Kr12lEnLLRPvmNy+JF584lB8JBQOCn2YEZsibZ3snNGe+tXAjdU7ccAJzLYeS+ALY2wGfoMmHcGpDYYrDclL3NqucT+dixP4BoIy4TqXXRbqKxMbThScLbywia7ygMCp59BBIeLiTdGRW6AGbnndeYGTS8s12pkRDGSpgrXyuRI6YWXoYBb0wMWdGpk/LhlpS+Rf3RBInuTp27yMNOBPjnF4QjPBmN51R8vEtlYf4rK/uoggCIIWLhNfXhZhjg8hesza/63fM6HoH1Gu/P3V6RvkbD7iFNPk3QnlvkjnVNh5MvkRVmPl14tQIBJVoXQkhDYTnTG++X3MO73onN2wylGfkB7prT4UCLy+Ap6qtSnnKVTEHSePn+niD9lxnCIsX/LEN75fWVa+BqfqPXHd9AASrD64ff3qqRfrlDLrabvda5G+senmAi6OCYQ7nYiQ58NCDe7gMS4so144RqFiM+GbLbY4/w0OIr7Z0x683I7v+n7tUQrUQK0bQ/vtpprr4qga4v495Y7gwTSP0dvcvlTsnTYvqdNwPLFi/PVcOg7k+a7vQo7vie7vsp62bFGlVq0Txby2lT6oun7wMmjgRj2hDf/OMEfHM+yOvxWvFhk/z4vLn2vu4x2ven693aSL2/+O0WfRriiP66cRozp28Aq/8NKrbjjx6SoOssTTlZ1E8TqRiEKxHR9t1SZv79Ue9GbfEN6u0Wqh9Etv3xUhqFwaoC6/6wduozFpl57OMIbqD+LFN7g8XBWP42sR6Ab882d/+GcOomWBzu+ArKGtE8xKJ3Af93Kf8IatQke3njuh6cHED/pBsto3LUaGX2wh+Ptp71da1od/9tiu+EJh2x8uqrYtFG8/+Vz69O5Y95mfgTQxnLmrH0JWsofy7r9B+DtRD/qw+mbf+mr/7LD/0Mfa+NcdFKdq+06vGpcPiCze6Tj/w4Ff6vldeYJ94m3f9hFJcc/of8+XQQ9TqfxBn/hFTvJJ/vyN364+D+AaqxMUAw6BaugAcU+gvnz7DO7jl7BfP38NG/6DCNFfP34GwV28uG/hxocR+dlr5y7duXPmyJVDWY7cxXPo1L28yE7mzJc1X6LDic7czp3gemIEGhRcPHn19GmEl1TpUqZNnTaNF1XqVKFB313FmvXdTJnquGadSrTq2KACBRY8mFChQ38RI048GNQgv4XgOkLsd69dupEkTZLbeS7dOsKF1wl9NxamupyNeZIdag+fvo1PLV9WClkzYq1cPX/FGpbe5rFmCaKdq5Dh3bcU42acy7Ht23si//2SI0nS5bql8sDVAw784uh4Wz/bDIoTMrzJGvtdxBzdKWnNWq9+xi5z69Ww1KuaRp1WNVu3E/tZxHgQ4ULW//KJ/ItbN7p17+DJw19PMj58F/uPxaormDRTBxx23sHnNeikYzAp74CyLsDsJtyOO6keLGug8FIbj7x/Gjpvn/TUo2s1t/7hxx2dUDJnvsHuowe4/f7bLMDFNGMnxgQN0qfHHiO0r8GmMARHwgmP/EyrqIgEaqCj1ENILdnYApEfudICZ7XZ8JonHXBYbOlFGPWzRz8aMaqHNHYKZFModZhzri5wfNRHKyEte9BIJPf0DKwlwaEnUO+cfJJEKdlzaP+jEIEiUTa3+KlNp4vWcQe/GPUDp78zgRrtoqgSq4om5MCBxx7K5KzKOqawYpA64/a0iU/ttFNSqkADrSfGzZyEMkrV2FM0RBFhi8tRiSCdxx1lwZmHzE01C/RPstgBxyav6NnxOXCG3RY2IIGMbjNZrX1J1uto9ZOoW3EVDrJ7fIRSrUMXoqsi9Ii1yNgP+8lHIP7sscc7euIB6tOtICRLnXeMMmgjbtFbyLD6rJs4yMumnTBWAa0191XQplr31uBkrAreXu0tkaKEoBzRojgd+tAffvr18Z6LAA64KnrkuRCj4l4lLZ567jlI26B6xEhipd+p+GKMPSOXY1ln8hj/3QrfAVmedUdOU6h3TY53XnsP0qdlEV9mi6J8fKyqzK6JlGmsA7F98jmjL9LW5kmVNozpirXCEbtypZ46yar7tHAqrdkNbiw6e23UNfWQ7rHXKeHaZ22gyg7qbSbjxgjroYu++ztwbGaH76UjBAoeoaD2qtwjNS4cu1pFuzS4nI+uHHLfJ+ccbLQnqqhstoXanUmMQKc7zrvjOjsjm+2ZSem9CbvqQdjX9Iqm42qqPbtvbWW8Xd57//334MFGFMR9ehSILMnQ1B70i0Z3zvGB5MYuacI+F1z3wjdAqqUrKlvzXJO+hr5eMZBlc6rctuiSNn4gjT+QuSBZCJYq7ujo/yioOpq/kheU7CRNeeBYR3YESMDCASks8RAZWQhVObDRCX0ZuQgD2wcX+P3nWUH70waHckBTNax0WdqWPu7Bnx8u7zMnFEphoMZCxHnMON9KHPka950F2tCLX7wS6bTEQ39hsHOeW5cW69EcEMrleN6hFhSrYhgKYZFqoMEiFl8IQ8bJ8It/pFxVijUl1yiROp7LFadCtsa6HTE9b5RjJFEoxQLm0ZJ53GMm+agrzQCScwuMH0a8iDdCvk9vm8mVoMiCKzY68pHvkmQsi3RJWt7uZ1jTZC63RhrjwS+HZjGLUEbpPBCdh3MCw1VVGNnIqtztlLKMZC0xmUtqajJkl/96kBKBGUwu2nBbinJfv6jTKbIwMn9IhGY6l6OUWlbTnbkEVFCS+aBn7mqG3+TIQvZRz81ICyhs3Ay31AlNViUlNFl8Z0I3eCtAkRMo5lMnML1JTNfws59CAehA0anRqjxFoR/1J2kSCE0mLrGLnAuWMcvIJB01jKNI9MdLO7oUkO5Rnjcdjs4cqlEmltSb4EiZSpfIRCJVzpWRFKhMvZNL/IQ0krvkaE+l2kVS0suUQ80gaZqjVK4yqTv48Y1GdzpQqZbVSRhR1PuU2NMRjsWcXI1pV+U6V++U1aywzEha14oPnEGUU2mazFHoWpWKDNawXbVrT/G6rTgVb4kA45r/MpuT1MNW1rIyTaxiR+QwQ6LJrxiZ7GVFO1qO4iyxp2wkj57V1kw9ibSvha0kTWvXUxaNR/rY1Ge3Glve9vZBAPMPbVtmTNw+60ySiaBvlctVokYSuJkSLr5MmVXQZiqHy8VudpE3W8XW1jnTpa5/QHtMud5rTtp96XNlirMZ8WexRlzIXssUFBqRV4ZNRC9Zwkqa/aqTvewFB2tPGDD2KhZpsOEsE+f7T85RNr+S7C9k8KNRMv33v7Ek8GxNc0z4vo+vARupfaHYRo0eJp0RvghY96tKSSLSwi/GcIHxQajNhgi3Wxyvg5nksqPGsjBy3e+E5TjS37wYxnLMMMDc/7tAfDmWrxCdjBzfCK8ey9EwLwVrimXJNS4b2cKxvGvvGEu24i44wPjFED+TO9Arc1TF4ECxdxKYJi7LyMsAlmSYxQylHv3raC8VbIl/HBTXxfLNQcYQIuusuzvjLM9lfRx6yIZVH3L1a4KGZpyzDGdOxxkyil50hRv96CV3UT2M3Ss+MIXmdB44nUTOjCw37RshPwjUi260oyPZXVNLuoeqNpOIiaRk6LJanZ4+tpDDiuxy3u9+dO5yrgVMHdrOEHrTddsaje2dnG1b2LFMjOsKDUUVM5tIOD7jyMaiayYRldcLdGkSi0tn8arT2OFNp4NOuGmg1Pqy7MZQe3kNL/+6iHKt8x3NtpV3XKAAl7VmJg08THxif7/6s7+dtmaUXG14g7DMXVP4wss51hPGAx6gmhSEK/5g+XF3ql+LzdH+JZyQt9vVpCE5zoXIcsPK+OUw18h3ntzVm6f4gNo1N88D7PKS8gqEzynbh+dn2MjWW+ks/y9fm86roAPlPBiZulLxXeyxVzffy7k6t1+89d6xx+tJrXk6LdLZmwUl42k/rJe1Xuq2l+5uZW/3gzJK9+3ST6njxnvDGz3wJxU8KF+Hriz3E3kMBta8bs0dkRPP1VxvHegkhvw/4965GWmViZA0fIpZvPm5JvnOfG+8K/cp2vk196EXF4rmWS9b1+vyfcYairkgLSrW1f+mXVVvaLSavXuNOrrzvwf6OUXLSc+OLOfMp2vX8Lx46KOvylRXZHUugnJUYl95I5N2gSVaqO8rdfIYuX7BWIdz80OGoW+L9vO77/3LAsf28feUnukZTumc+huL0UCgUJO27gIbK5k+bYM/6ti5gdmgxdkp/QBA1rumULOz12NA9HFAoZiIudIROSKOnRMKhjJA+NtA4agz7oO9QkmIsYCLucI9ZdK8gSG/FbS/a8od4+MaGNw/8SALfZIpCkwM6oOW4rMuQCkOn+FBnfJBDhS1tWu6BoSMipIpg/mNE/I/+QvAgRGKgAAAIfkEBQoA4AAsAAAAANwAqwAACP8AzwlEh04dOnbrwClcOA/cvHn2Itq7p/BevnwLM/JbmI+fR34X7z2EeM+iyHYo55W0uG8fyHnnyMkEJ7PmuJsZc+rcybNnz3BAgwLNONSn0aNIM+JMurAmuYEE0aVD+A6eO4cQJUpcefGi0Y9gQ5bsmq9kRIsXXXrcd69durdw38q8SXcc07tGxYkTGlRnOLyA7y696xQqQYTr1sGTJ++h1pVjyWLs+dGfZbBgW0pOiznfPJTtID5sF5Nc3dODAyfVO/TvwqKqY8s2WtOwusSK3TV2/DiyZMrg+FkeTtxfv85dMX/0/NDkPXuk56I+Pbu69euzydF8ei7q7cRWd2f/nTiR62+dGxUKL85eufuwyUHmg57O5k2n0u1iV+gaXP/9AGLHXVTpJFaVbiP1Btl5lK3H3nCZSfaee2V9lk5ptb1VWmrW/Rfgh9c9RSBu7rjTjnhnlQeZeRX55pV6HlnWz3HwieXihP34s1ZZ9AmUDmgoXWhaXdXBZpSHICa5U3cFIWaViSONpyBkC61IJUb5qMXPPpKtqGJkWlZG3I7zgaZSSPMIidpsSPLUppJwgtNdOt/lBmWUUkYkpUJapXiWeWR5aQ+ejoGJ2YM6ekRWWJ9hmB9P4hwZ56SqRUViiSaGRuimECkkmlZ4RtSiWaJxmmB5XWmJ6GViXpZPkAJh/8ihQpHSWis4t374JqVMEVSgnSUC+VlPDXlq6md4GhslSgoBmVKhvrmU46qI8jOoW3BtiJRevOa0a4A40cXTr+tgiqmz7RiF7rrsMgskOO46OxJWXMVILaJltQWaXLPuxC1RAfalml7/CrbmTuCZGyyQJiqk8MMQQ9xuuu1kyqxPKnZ0b7UgQUafaUcRnOu3qhkZGMGA6acyT+VGrPBCCuMmc1xxtezyzeYyZiZvFtmbqEc0fjStjIoG6hbIkIp8q8lFknxXrgb7hDOmMMu8Ds1YY40bPE9OLfHOJPU8oXKsUgjdOeXol5HSIvvndLf+Qj0bXV4vNPPV6UQV6957S//11qVeu7zzRBeNbfh6y6V5jrjjsK2023ADhvJ1+rkMT2IKWR0XQXx3zrfff7tTLtekA+uyPM+iOnZLYYLVnmdqosZ25K+9ndPksakNzsOJiZ5Q5njDpbc555hj/PHIGx+rr39brRjpXUOMuqbgEN5RcC1hxjqXWbY6pmdHT/c4gAJLKrncsrVcrswZ0SwVOrEiX8789NNvTjnKD9S88+BxffOzxQJH9/YRHO1liSyqas9J6pO2urQNO0Kp3U74cj70MeU0Vrmc1RTiNwLBTyDGq58IRzi//I2IfwkrEeAsBi2WtKSAZeNeWhJYHJCcTSbzu8n4cFWwu0SQaW4q32r/epgyuihmgwrJW1Q4B8L7kfCJIiQek/zmPOhxbYUl4hmYXBIcCCnqI5rxHoRgJxDpPA5lFkQKEI8kxJDhbiFEPIrzMmKQJTYRinisHzlMKJUqQk9mCkvJn9DSEY+AY0zaY50YXWUhITVwKQ9kyl9sx8anETFSaWTZHBXCjiXCL4R5TFsO66LHPUIFLjIrnc3OlboFFTI9CkFkASXjkuH84x+MDJIjwxVHn0zyP5FU0htjo0rMgYMdnbSjE584nenoUYon7F/0FnYqF3GRJ/4o4I4EmBzL3BKXOuKRhcr4KDiy8S/iGMdTNESOTGKnl4D54+8W4snijbCZemnmTehn/8opomNr03THqTKWKkN+ZTkS8uYtWdWVBcbKPvqxYF/EUY4fQYY07nyndeQJjoQkhh3qqKNARCg+pemzftDMWwoX5pCcEBKBBvVJNovGzcJ5E5FbushndBm7YPLHP+Igh0WNdo6M0q4n0AOezJLJuWWWVCjp1GFU92k/Kf6ta/LISXl6opZ+LOSWDepKTR1UnBwt5zk71VDafEorobZjRV1ph3aOqpqkdtR5IK3jMkcpVb6EI50EO005ajOnljEkK3BN1QvVk5FvOhY9YpkMDFeFUIcOaXKuoeg5BIqql85jrnSNp1UyAo+74gaZBrFn/ejCGr+alC7zMyVcMlJNQP/NEIw6caxuNdKxl3aPWpXFVkwat7R0ujVsZZHMZ0MbmNLuRIMzaypJievXoAR2nzIh3myxwpuMvTR7mMmJbnVrGfXYiCsEHFpZGSXcyypEnT9qjivJslzm1pVrpDXtR/N2x1G21rVTHaxVMyKe8Vhphq2L6XjHW15wcMksGSMgP9SLUx61t4HH/ZKLulJf+9rqKPg1Cm7Awd/+rnUvAIYtd9KxEJQwJlSJRbByvAqOBTMYHF7l0VbAFJwZsYdGFnaHkNbZDg1vmMPtfI190edO5yLsd0wEJXHZhl3unIPFzTrRSFD0pc2AN4E2ZnA2daygLKkHUcdBU8UyZeQjh8T/He3065KNypR56oR+qBksaGGWKcYUeKDzRfArbRnmb8pIgM/pU4R7zLHzWsm2mglJOsqB4gguGSlXuUpOSPeOd1gNpMNTiHZqIsU5waVE02OMbkoEjhd317YwnTChCw3Ojil6x92T9YOAHKhH60MfWdoeWxZXXQ/zkCfOzbROrNjppbJDeJ9jHm7S8bDdKZvArX61m7s660IbBxyJvjWqCkhhnHLP17/Wh7C51I5xyNnYd9G0ta1YTOftj38BVbW8d+LqHfs219OitaEroqco1eNPGNE1x3KaL8ikW92KxAo53g1vqS1bN/GQRzziQW96P6/jp1M1UvrdZs44SOC4//QqWh/i53kcHFXpLfdwaPTgFQEb4hF3R0woXnGk5gTVfpZHifznDtIVPaAK8/PD7JoRdvC7MRLBBz5WopDsDQ3l2USr0nWzG5grROasOvdKfp0PnGdvH591NwVBRMl4ZyTTgbuZqvWNKeg1G5l4z/tO6vFyqdsDHwoBtrQCTmsdVW8eLkPsPfTxdcoy3OG/XrdD0qF2S/ccqfvenbWnFnSh50zodLf7aVEb0tIj8x06oQffRbWTCecIrGH+tj18d7cnFUrdh3R8QxefbmFbm/I8v7xOqKZ5r3V+65az4kfxXvrmh/T0OaGH6hWyesCDg/E7ib1nhCw8AhUoixPBPf/YjZPTh0eedfMpTaXbKHzSEn/zcj++5yNGb0/n3fn4xzs43hGPjNBDHtJ3cFK3eDxhY9k0D+vwQdFWIOFBEgRUHIZGftxzc2a3O6bxX+zXfnwGd8Z3fIgHMfVnf8wXUuAQUgWBfwrRaai3cRsHgNWHD5EXUwqxYP6AdheyVyWkPy0jDxNBQLmnUDPHOgKEe6xzD5PWOMWmgc/lZDgjf52nMB3nactnglEBDieYf6fHfyy4cQH4d1MXgzT2VeTFD4qDg/ZzZb+iG/agDxvRbUSzbkIIE0i4dkq4hBsYMU4YdFBYf6dFhVXoSVeoDninglsYD6ongF9odeKlWxtxIXj/BlsCJhVFpxjzgA8+qFALJSNwSECztzjrl4F1+HPmonkO4zX+03HwIIXrkFdMpBD+ZA4E8XxZSIgs2IVfqG5As4iG9iox8UgBtk6D0jsq4YM1FoESiH4V0Q7oEGdJGIqYN4pvNzWoKE+rSIUC4YpRcTyxKIh5xw6dVou2CIMQJ2u6aHg610Ais0/m8CPBuBj2sA85IobgdBzbUyXuYA5zGHzOuGnQGI03M43UiFoEwUF60x3Gs43d6I20yIWICIbxKI+XcQ/nOGX5hD9X9ndFJ1BsmE0zmIn0KIR8coTVtUb7CA5E148m+SQACZBLZYIEGWX3c5CmN4iEqIWGiIiL/yctDZZN4BSRpHFigbVH6cCD8sA1w9hgxfiG3MMQ+PiJlleSm2ZFS7iSAKmCH2UQdaQ36LBMsNh8INWN76CQ/GeLJQGPw5F7P4hL/NAWDHQa5FAO57AO+saDZtlYRJNTVSIP7eSUoHgydEU6SEWVgnmVfriVaGM/gciNCZl3Y7l696CTHLkQQAgS8MJOpHZlXQMR8LiIx5gR9lAfldeMsjFMwieYVbmKpCdSqoU/iamYqemV7+CCPSgch5QRQEh+GJFWcSFQCfKYYfhV2dQPxOgpaJOP+mhJpKmEpklvwJOanwRKXYmFr+kd7AAPGVcPPfOQtmmMRSNZ/kY4dckTsP8EbnC2ViPZdmvjOMlZmqa5EFyjgszXVE4kk843goUpiPwnDwf3W2cZS+R1l1siQwpRUEiZEwUqkRfIlxXkOMdGKU7mZNUBoVEpegK5ldDZmtzYfEuEn7KJi0PTWGI2c8pRdfD4m+IVmeSZoMfpRuoJT3DiXCG2H1UZlqCWjdqIfxlaehvamH/nocQhmYX3Y4ZkouJVmwI0e5e1fk/DQy26npEjoc0lmKhXoYCIo3mlo96RcaoXfpDZn8UYpA9yFOB0pG35X7fzQE3aopfHdIG5nHa3EKy4oVZ6pXX0fDf5dzmpcEjZbQJXHEaxUNXjiBSJSeqJK0yKpoTqosbGpgr/4aYpCaULoaHegaOUqg6NOYBW56WxhIlY56c9AahtMVyTk6YMWqgaCKkTupJ3caWTWqleyQ53mohdipZpiXLGWKC5tVCwMyTiQqpp6oyoSFrtiRd0WqmL+Y30gKc5qRZ7uqmc2qeemn3fFKi9eBq+ekZ0BiBSyRQd16iC6XOkhXpw6qqyyJg8KquQuanOaqu3iqsgektr6Rbm8JYOdK1OGie6Q0zDapJJEaPjaqxgiawCuKzpupPEwa6ZqKm6iEuVGRPgEC6DOj73CicUlS5IwZyP+q1RuhOuypgKyZBeuKy6hpYPgrDsUYADlyYsxqus5au0E1RXJllG4abBKlqo/wqws8iFhziA4wh2P/is3hatC/sP1iJkG2KtpAo3FJUO81A4sgGYGduteGF34kpHc5qzOlt9vMdtJLsqnfqjkvmuDJsu9cGyUsUtbZOt1xFU6WAPQjOe11Gz3Eq1VRup0imW4LilUyeyPsaRewqBYKqwYusP21e2jxSxbCVM8OVCkbamzKaCOnG3Cyl9O1sS4wg05VVeM+JVBxu4KOqsHPlN8bpLLYtGigog8PVWvUZ1FReCkJsTkvuNOqu3e3u5m+t6m0tjnRu0kZlNQguvbFmtpYu2vDIO53AmmyFWw+lhnFYVKhiWket8x4S1htiFyip4CTYjQvObAodNZ4miRP8bvPkxZQ0aJ0GluoI2nIsFb837vDSqf3ZLgtNLiwthvbULXmOjnV86XjW2EJtrm77bWKOLQzp0qGo7MMbrDvaQvJD3axTRuu+pip22mArRfBkhriyYVeCwehFxi/iLI/orrQsBNLrrtwbqim+JjrOTJGz7Vt9VduA2Ede3D9gnfO4LnwlZwaXHFDhJsAmGGR+afRkRNCaKq/9AQFj2sBGVuLMRVeSgwFYydRlxD1JnffjAd+3XbM+7mE4nv3jxJ2b3wTMGto3lv0AMwOJlLXISNyBSURcJYVv2Yn43D3rIGBooMxNMwV68E7OLxVMMbMG2iVpCYUU6wmARhu4Kr4r/oxMHzBTisFmaMih0LHQaVBV4whhdU4cG8r7dWME6UYhaeoj14FKALMj4q15lLJlBk4vuOoOEu8hrwyYUpFm8KXQmeXQftQ6dpp9818u9HEB3LII5XII6YZOhHICrVz3gxnvYC4eHTMb/YJurrKfSGq86dx3FVlFAx3HPi5p4p8tc42eiXJLLN8w5gXrGXL3I7MfLbLmAHMiKJDRk3L9mvCWYG8C5+hJHk56NzB8RZA5Dl4rlzMUqaJ1aZQ9QScFNh84Y3IKU68vKvLdjh2DxfM/zXM/gFcIg+soVA5oGXDLvRQ7/pMtc3Mn7p4UKIcqsV5LmzEkpiM55i8wLgacD/+jOYTzGgotja8Gsn7vRZREk9IoXO/QXxnsQTlesenfOWqjBC3FwPWdMPWHScIrOKZjBACjT1dPBymrT2wPEqNx6Oz1hfxq+48SrLDo+RN0d5KoTR33SLJiKVWHH9tXNdsYT8FvM4mqT4jx9Gxx1VTx2vVfRuHvROh2g0jLW+iwX5XCmcpOcMIuhe9x003vS7ss1GRdaUthso9fSRuG+Gfx/WSXKL+eFf23TgUzCfdvKOz14tLqINtTRDmsrpsrI+TRFKBipOizZ87vUG8xceFXSd50Uem3H69x3fl27ZNfVuPvVQ2zYJWqbrj0fZQ1HK8zYIsOaHKQOuK3Dkc1JR//NfxW32cAt1Ucx3ODw0L6saKX9cBW9uYQdHCSKu639VR0DK2/pyFSG3bDYqtptFDTZf9JHfUc13vfnmnnFFFuoEFct2qN93MyMc9ub2kaxvpzb069ttDNx1um42BmxlUvEFMhUv/UQ4N3yO8BteuTa3TzBggq+4L7cy31S0+x9yhI+4WKNY5oamW5BThyuxPXaoiUEDuYgJwf54QMZ1SFOfVes4JRy4oKY4tILGMdMuQw+2jIe2Bmd2j2dE1an5SPcFpp2DjRxuPrkOOMwP0K+EMSz38ODDj7hdPtHO04O5ZR6F3r9f1T+4laO3MlN4++dEYrk3khpLTsu5guhTyX/deZorhDGI+TQpIBFXt51OyklTeeuaufD7eIvrhVX3swRntOA3uVBHByKUxrvhejNVEJDDg70k+b0FD9s/uavCw79FyeLael1nhRiacwLXtwcHLLmJ9hezhNdnbuDrjgEfOoog+qq3uiszhOwvqE98by1riRzjus7DOK7Xoi9vukdzOdmt71/vhCB3reSKZHDJS6yTWW/iDyuzhMfpDxVGNXUbu23ju0WTKw0uZCzK9p+bdM3vdzjXu7TohE/OajWveHZ5exqvuo5wfA3Ou2zDiDife+vap+5jhQJ6dkxDeNRB9jhjtq5OyPEzjqCrhGfqaJPeai4oug93hP280RF/97fO9FpIDLQBF6sdK7xAUvt/e7xpM3Vyi3yuasTwuZ6n0u4B88aldYT6bToSIFHRe7mcFPxBI7vKm7Xszi56M3BVXyLAR/ht7sTR+9jtvkqsUNckOMvZ54UL09CU3+Cuq0Q1ncdVn/1WJ/kR7H1svvzv/7XMy7YibS8DiZsZi+ZaE+6mfT0Lx8YVUU8807Mnkn4qrFBOV/gKa7QbE3BN2yTef7rIcvMgpwZIMnl20PyXK6ypcHhw5tPLo8UDH9n+LPqTJLb1PeORHoXKITzFo/xT06pSb35JX3DW9j1nA72YWzKpR/qh+32eLTwkA+I0m+hEM/oHe7mck8POSmc6f+z+3hv4ATu3W8+/Bzfx0D/9YGv/MtfdYUPt1+XEYY+Qtm1PFIxk3ml84Xp4e5+/dmvbgDRb99AcAUNHkSYENw6hg0dsoMYUeJEihUhKsRokOI7jh05xgMZTx49evVM1rOXEt9KfPpcuhwYU2bMl/owDuSH0J+/nArL/SxHzhy6dOkcMnwHT2m8dxPVPYWqDt3UqefOobOKzuBUg/T0zQQXEaPEo2XNWhSLtmJGtmEjeoQbUiTJk/VY3q2ZV6/emwr9CbzXDmM5c1cZKnXnTt7IkiRJMoX4lF1UqVSxWs2K8B3KrwNdgtMnViFZs6UZqmWHEG1b1gbhdpQLkh64kif/wd1deW/v7r0Fbdr0KzCfPXfprJojV7Aw0XXwFC82aQ83vnr0mGqMCFUruO3mvG8PK69zP/L7foe+ODqi6bILH649+Lq163dtPcYOCS7e7ITTdfMG8DPQBEyIp3uIS8c7oQq6yijnFispJZVQqsu6+jQqKDVw1GFLHXjw2Yc8EQXaB5yBUKPILIMami8huMC5kC2PWsMvtsUwkhAv3u75L8CMeELwnJ/MAaeodZ6T5ySVWLLHIJNo46/DpxBShx15WgpRpoIIcgvF9VRcqEWFZszotfviyahGuSDEMcfcXuKxxzjn7HFA4BQSaJ51zjGHsHOMUiw6CaVbia3H0JSS/7LNOuOnH3649O0rL0ljUUxLD1KTqXdi00+hGh0DNcqDBmWpR33oRDXOzwjEcx89MztSnnlQWvIug+yphzZdx9LQIA4pi6eezkIUEaF72ELrqEtbzLRZThHKb79Q6RL1VlJz43E6bfHh0c47wenHH4MAmyexdqAb1E18ErJOtmoLaiojDtlZ9KtityzRoEIPQrGgdZZlK56lnCVYTYxCzTVXha7dtmFueazpoHDHNe/AJq990tB296MNUX5Fc00ee4a9d0sTDbpnXdUkApg1pV4uuOBprQOVrbraZNhh3OZk1SBxwd2HR0KncxIchdkFqSCPx4JXZBCJHdGgzwgq8f/UlgF+GZ6YZZ6565bTHVpn3MD5T+Jwf94nn2z3RejmgurKVdSk2woWyxHJ2/LUN+/s+Wq2soY5pMWaXaxwwyHsOvGvwRabaAL7AXcncB7Ve6V0VS6IroNI8jTgkuy+G3LQ1n74WDv9PggejAJf83DXX4c9cdkvBfvyxlW+U0TJ+Tk1ZcsJPcgkx7oCSR4xPx8v9Eh9L7Vb1MHJWiHAtW4ddutjl31auDNurfacHcZzYhN7Z7LJW42ujubZ5NIM05DoseeegULHe0DmdzYd9egTmt7G6wvPXgBrsz0Cds97tWtY+AxSMebdJiXBi5vB6IMo2QjLXvTLW+9IZ7nS+cb/Uhzhn/SyJpL/vU6AMyNgCmn1wLYcEIHbSsi9BrJB6YDDfG+L28aeBa/6BMsu+qBf/cYXJ249rCCle8nJWsMQSwGOhCU83AkRpkICpostLnyhtsiGENEJhHyFwpXR2hbBGrFrZBcMXb6qNie2IQQm+mvLwJ4IRQBKEVRUXKH3rohFxtnqNqDhIr6+iCuFaY5d7dJPft4GOgyazDwazBbKfsNF0T1PenO8nh2zh0cs7pGPtitUqW7yRXwQkj+GzFzm2Dc3RipPiY+EU7ZqGKnOgKtklkSI1uioySlyEottXNgnB/XHI+ZmlPdr0tE2t0z2oWx+IoLUAj1Tk/yl7IYw/7mb5HDpKTpiL3F4hJsLSzlLT9auIJfT1xFvUrFxJgxgFoRaefKFL5lELCMwIdZfdvKzbSKkm97sGjjrIk6VdM+GEjon2A4CzISwk5A5NMjcupKQH8oEmgiZST0B+S18xoQ8f7llPw3yT9dtUqCC8t44MWfAUbHwVgzFqHlWYptQNTOimcPS/DyqkIzOk54ZDSJIRYqRG5GUMd886QptiJBxWuqGGVkSW6ZZygqBqllGe5o8o2minvpUmjHhR6OyKdShJqRwI4XiSE2qQhzmyqULfaolEdqWR7KkqoeiYCIXGU8SNbSn6wyrWF1ZEPI8qqxoNV5BEgu7Q2aOc45Jof9Tt2nFtkDOJUw6Cec6tjQn5fRu6/TqOm0ZRMKC5bCtWWxiMzI8m50vIW/FJWVFWzW73tUxEqWNZwXSV57GpEVBrN9fTztcMck2tnOVaok8U9vqZFZXHkNeRuk6Ta76JrSQ++xBYNmZbxHXu999bVxFWx5r3rU6N13ksHzLGlhuVWIZqWdvwDtf+oq3L3jTRzszq1mKYmlYX1WiG5OIkZB+1SU86xt9FXxa+/JUdHrDVaigqpv1Si0vPuVL+CD3SKo9MlUD3qZqFzzipd7zKyYSXdCoyl99UUc6L3Hv6LgVoO6azUQp+49niHgXiNUYdSImsYIbHCmuqrG877pNKVv/AmOFXBZbdEowRvTW41gW0XcQEymQgzzfIScRUvldcZNXgk8To2rGUY6ph6984Ps1L39bhvNpB5wvJxNymXbSkoCTeB4QqzEhvLndnOI86MO+UYmVC+NEARzaAQGyxfPJi6nymzN1sYTQl+4nqw4MRmW+jZ5SZrPK1rXSgjiPlrHEcnlVOLREhxDTr77UGtdm54WC2I3/iWQxiVnMN9mpR2M7J9x6aZuMqA7Wx2Yv2XwnHVof0dYeFNC2btjH3bTZWtuDrPBIwkTpIdvb8CXfQ4M3ZgHt2SbaoiwoyT1gZCLXhlXV9kj+9S9XP0/L38alT9fmtiQP2MmhxBxVw8lr/23h+k7lY2GDaxoPeueyn/fG9/O4hOjmKmzdLU4gdbZ30FAS3I8LHeeQHUsSeVyn2C1bbMT9RmrrhkhqR2btkg8utofy+yDdCjnwHKgvdyeUhY4peYy6Db1LQVzlYoLpM30jy/Rxbsy60XWSP66QTpfaauhbYciLa1Zjx/HoCmb5lu4V7vRxbNcYCXtrzrwuKuKwNp7GZde/7l1ySm0fjdqJZZddj6OeHZeWJlB1BjcS7tEDgFWf+9Hrjq+z/UXGK2axnBFi+Aoq0/Bsag33Eg/nBs9vn453srbl2mzWNL3q6WuRzTe/5bh+Be/7lBrko575YxN79a9+5ufhet4ki/8J8WpfaU71hmbW9Pz2g/Y87ClqPLtYCsnd494FK3bZd2r++HEej+4pms5ttrHmFlcvmDHS9MhP/vqXzr02/xJamG6fNVPHujJljmbKF+/5qTw/8kOk/NKm7LDA1LZOAza4Ix78qJaayT+RMr7kOhsuUjFL+b35aDqKIrYI0yy5+AjcGrnyS0DUMS6per2DWD//K6sniUAnwbbH2JTXyI8DHIkOFClasZR84idwWL/8OizbywhtmxaQMBPBgcHvOkGp+qgYkqmhghuq64rECYkflCgODEJLGkL4EiKJKZG0O5i2OBrr47WI0qG50KFN0UDzi0LUsT2Rgy/C6oud8xv/HUS7QsErA6QgszOUMmxDt0FDgOkJ2KK6+zOaxVO05nMsNdGsA6wWRbLDluG3PAQYm+DDxsoILERAaPFBMVzC4ZGwiOKsTklELbQNzXtEqVLDFhpC1FuW90GyShwj7eE9peGsMexEzVI98GLElpELPxS6DYQs9EmIpEHETqQ6LmwZRtsmYcSIStxECEyYKNEUX/xFYDwsguiJGBTE+fBBj5nC8ZuNKDET2IDG4cKJRjEo36tFzUhGZimTjoCRTeHEbwyeBfOx0sPCgDlHT1maHaIPEIqRXHTHbGyRaWyLeNTCeZy8QtwVenzFZ1zHF4ERd4QzYpTHFqmZbfTDY8SPBviQj4IICAAh+QQFCgDgACwAAAAA3ACrAAAI/wDDCRQ3jhw5c+bOKTyHDl26devguXMnr908cPMy2rN3r2O+jx/BiRwpkh+/fPfAtVt5saNIiyRLoky38Fy6mzFJjsvJs6fPn+DCAR1KtGjRneDGKVWa1KjAcAQNIqzZ8GHEifIyat3I0SPIn/1MinQJ7is4siRPtlP5cuW5nkiNyp1Lty5JcSPF6QW6tG/ToeIGFjyYUGFDhxAlysu6tStZsyLz7RMLzp/lnCb5/TSZL+PYe/bavfW51y5RgUFNq/6ptzTcvkiZAm09rpzUwobVsUtMkfE8ri5Tlv2ar+xkzT/9EeUsnHm7dODIDY07l3rMp6uzk8brEzZT2az11v8uV26qYXS6Ifa2qBH45473ioP8SJnoR48k/WUeqZ/fPbfRSTcSUgaRA95R1o0klHYM5tSaazF5t9NSs4lHnnkMNaQOROtMtBJ7v3F1FnwkwjffccjFFBJ8jhXHk2WWnXTPPCtBF9NNNBlIoWqoibRgg6kFSVRrdxHJk4R++QSVUuXVlCFiHbrDklaN2RMiV1iWGN98IY0EGpUaedVlfv6EdRJKa4nkGI3nGCTSgXP9CCRPT9XZY0wPPggOhBEiuWNOA13oZFUcejglmIgmeqVjJY6U0YcfhmmiZCnCGKOM9GWWT2jpFChdgkXdOaePdtrZU56ocvcabEn9qSBUtuH/9qRVEkkJ6a245hrpVp55RpKu7TlWn0iWFgvjSTTS9JaboAIl56hBlVrndqny2aefCQZKzkKHEVqroZDa+uFEUpJrrri5trXSuehSyVE+JvWTE4wxxbjpczcp9OlPQqkqJLTRSosdtan+hC2r0RJU2GE4qgeOOw9PJJLE5qpXqDscqkduO+dOTO7F7E757n4lydtTjPvM+GGOzYoKMKDTBjzwqdX6e2RsA/JkIUM4NnxVxOxy2PPQRN+UMbsVZwyyoRltiWJmUENNrKb3zUNTOT0tuNezo/4ocKkV5knXdxOOV55DRisNDjzgrNNTOuqgfVO36GRoWM8Ok9u20kp//8v0u5RGLTjJUe+Tz3MC5jwgXjO/LLPMYIdX7XRl7zgOQuagnZhIEJHkNucjpdOtk6RT1XNMn4/Et9+2hjnmPrDvA47hgaco+H/nlJPkmzvFbDOQjX993Y941fx7ThK+WZWNP6UODvMi1a0Q5uaQZ315mHOLE1BKh2xRV5KN5GJk88XUj6Wdsfxn7zMfT9ezXH/tsst7Gt9d8px3zv3zOKHDU/XXC+D1MCQ37nEIaOSSVHx+Er7ZzUs/nXlOm7D2JlIRr2v8EtjwdGa/VfkFTkNpiE8AKMASXmgqyxvK0cylwPHxJywqkt2wIMipNomEgu1znJJIlTWu5YVIqDJY5f+aVZcS+kmACVne9njCIXh863skcmFljkWy4RyHPyfhlHRssydRuU+HqOkR/RSEJyOJjS+7G9XBmGQ9FIoObupg4m4YKMUpWopkIJmMySojI9EUqH46HAr8Ypa1MnLnjAz6nP6iJz0PrtF6B1GI6AjVoH8UC4bko1R+soij0XCQQT604L8sGEZAOahmq3Fe/tbBjrg1ZHrIQ5J4JESeSDrkMD+RFGT4449/+NKXliLJiVLExwhKkBy6804gr0Mn7BCSZnqq3xf3l5OMtdKV5zDHgCSUqqXM0myyYt5igiWm2MkOHJqxzC/XGczhzIcfeyzml465LX0lzjShDBUpg8f/QSBK85924ZvSpKdNnUhTLwMhCDh096ClxMomI2HPRqKYR5PADjnnA8c62XkZL20JXvWyKEpoBCmWkXGUp6oNMnuXncj50HhB7Mkiq8m3d3AobtOr3g8DY6e9jCNPDt2WSBI1UTFJBnazI+ZINgpM5XjpLMbhh1OJ1R/aoeQ/OdLdq6Zzjim5gxw81U7jRgnTaNZFoEqb5PSst8868RQqs7TNW0CEKHBs5Cxjykk8Y9JUkoAGfHqcKhX5Qbt5uIMmIimND/s1jq5+VCXnCGtL4+c7VBpJLqlDa1pfiRDytLVU3yzHOaREpZxkpB53BYtPfhmTv4KPUv0w2R2dI5J7/0bLQY1tR1d+RY6xOqWtzdTa5PaUnZq+w6YZe2U2ycM+gVlIOukg7TzkMRJ4JMaJ8ZAHPUIkPvnAtjIk2egUkYMlwF40P2bKYg/vIlp3zAMtES3HGOsilGcGzJCXTSSH3uHE/nKIHYdZ7k7e+pTSmOMmUlrMxJz4X3bsZh38pUiItKQPPZ6vo0yNkZqsNOH4XJSYytGMFClIxsulA4rC+ZV88/k+UzGzn9bKi+dU1zYmQoS//XUictmh1uUmMy5yRbC51sZgVl5THUjWDTsizBgs4eMe+qgwPOklko1C0K4cbo9HrhgTwt7reRP8DjlO/Bv48KQdK+6ai2dDsNIIVP+mEXGiuaz737lJL5s1EbLeVAcRByf5z0l2MH+zq916oNYeT5ZybDuq0V9qeKhV2vKwwCEvGSWrUwUa7ZVSbNo0q9m3OrvLTh90QNDVmImsyzGdM+Yz1u2Zcw4+8mEArWQIY3cx9DA0oqEMuwuH19H9GB+Yiho4XvbH0viKbpk53RM0z3eyRplmnjJ2aqCo2h3fcvW5FrOYIecv1kd2Ja2RLOh3xOPc8aBHrnetaEY3Gpj+gXSkP8JlqlZ1pMtmdk/ukY5ySHaZdimeXh7sPFXGJMdIIxe3Fy4PchWZz7FGMt00NO5yozvd6070PhY91XeXyUUXmW5jJP3Ae19V3z3/scc5fvpsgLe5NeqAm8Fzomptm4vhDi+yIhsscYJOHD1/jvVxzZ1uXeMjyoHtuKORM91u92bCiq7XpU4yF3uY460un0u1NPTgav8k4Tdv+Jz9y+c+X7MhncXQkygO7iUTPdf1SHS7lW7JeHPMv7WS1GRKPmmi8PvfWZcLqrjeuZnzBOxI66+N3XZ2dJAQe9x6JdDJLXRzqxu1ck96eD/+MIjY+SGKKbMeX0QXrI6j5YGHZms0tDe3uX5vPUl4zX3iegf3WeI+biP1zDP5thO96Ow+TkaXapn0KVd76pEHR3qtnXx0CvCpL0qe0vb6ss9UOw02MjYffyEkTj7obj93/67xofEpM9oy+7Aa9U7Is4fIox683mtdOgNW1EOLsmNEJOh2rraAatb2rJRknJVNnVVC30d5FpddmBd/vuZU+gFmJpRECPYbFSZ/chFBkWV/cyIq8lMk1qJINWZc7wAUQ6dZfUZtMRFgBYhEtNZ2giZ+cYd0F9ZRxQcOYdYXgoIYFGEP+qBUVXcT9cdi9yc/kfNDqJNZIfhmBwcPJWiC/2V4JIF2EXiA46Zk7/B+iNaDvkZVwSYaDAUbZ0MryrdxptEOBoJ12ZFfGUSEY8UnpeZ6TtiETnhApUYUUuh9VShxmKMblgd/k9FO9iIaP6UUFpIQ4CAP66Bs+mCB9tFvCP+lgTA2TcHFhlxjMyjYenOYiYsEhZ0TayPheHhYhaAoKOmhfBUYTDDShUlBELQhVPbwPOsgD/hAhnMBGunAcqBGMKtBiRpIh5r4i0RxYzbVdtGzgmeTh6Ooe+jQIfawcTNoRx83DyvXUGfDEW3jDjzYExaVcu6wcvYlOWrYYhq0ZrSXWb84h6gTE8elY0PXjuwwEjmFELNGa6NoNheCDvDQjLElVcoBI5bkD+nzKYPoimvjXvegVGVCWIbDE/bwfLl4SvpHXx24IPa3iefohOlIEu24kRv5juDwc1QYN9yXRLohi87YgP5oGcHGJgIigZwjDwepV2cCEvpgZlaHi6H/VFaTxYsPSVN0aH1o1XaqpEocyZHgFkcg+X2HAUCZww7wkBVZCE/PaEdNBUEqwzF6AzE+oR9WtSXC4Q7+Bn071RfhiE9syEOY1X9AyTcuCIXgUJQdeZQf+XOARjdLRg9ZGDvwRFX21ktVaXJcIhnyl5BW9RH6gBGRhYYeWDCfpkEqhI7NozRtSYJweVwuyEgTV4V3GYOzI3wd15eW4mhlElukSZruNhJhwSWHOQ9BKCeoBEZEGJn9h1ZwZmQu6JE/UZmWSYyY2S0VZ3mvOBKe+SLFkmHGAohE8VUsl1jDFXiOmRMPFmsFp5ZyxJty0Y5K8w4uGEe9SXFxRHmWFxMX/zV8JeeXTPWPx/mZPqFyZ9gq3lSW+FRIclKEREFwZtd1zXOZdHFcAnWbn+ib3GkfvbaFxNKX5/mXxXIyZeIoucMUPxZjPEI/QjgXRiaZtheMtombc4FcDeaf/0lxIxF+GFcPJKEPsLVovGRvB4qexqKgD4iYBsI78CmRPekj2YGfsKahQwFuxXWbnvih6KGORFdohjYSFWZhw0dllbGiCHqaVdZXkBWjzNkgsblV2GeftTdHRnGhN+qjOjqXQSoSIlpo9FCiRyWVpclxS7WiLfoTliQvfkQdkihIwsOB+lV2qwSHo8I3PeGjAcpIJFFuQ0pdI6FxwgdDmaGm72acgP+onsTSD7iDTKIWoR0ILbTJp9RZFJeIp316m38aPSEqqOdGqIXaEUc6OJnRTosqmjSopPWCVZ7EnGY0o/VFiQCjWZhIbXwqU56jPxZJbe+ooR7qE4JqbiRhdLz2YahKoE/qS8TpqsJkNbH6T/DJk98IJMDYer1ah4+5lhmKm9ZJrG53XPEgEtqVcYaql8sKrVtpRzyRPm1CRCThTJAjRrUKiZZ6qdyqq9SUp1nKoyRBbkBRrCKRXZeHaE/mYeZkTlAzlT4hW206Ev6BOLzTQ7H5nDoknW9Gm9uaqT6Jgp34ozzxpX1KEoS2brv2UUdlOOpqfk6KmmgascQCq9FBYvP/aq01Ci3glokNMpusBA7W+an7iW7nemiJFph5hCIz6KjolKim6ar+MCM58kM460wTqrM7663ceoSaqpYeGbSq8XtFyxVyZ6Jcoq5LyxPpFS9P23H9wCnV84hVm7NFAlD4JJSbqq2m4YuGF67gILRG8XsGa2hGCx9meyIfxnHqGRbKGrNuq34MhbOi9HIRKZHiYE24mkq72qkiOxKAOxTkOqpEqmsbQX5QdrZ6qbgyybBsq6QAGadyy5MQWVYzehpLMg6Yy7GqUXCc67d/+7k+MXREW7SEmyWnm7RPo6oiwbism7YS25BnSGDkqHowBUpLMmbtkLvZ+pYjSBdeepS6/xGwfypCnSq8RKtul1e8KZtHZ5qoUFsmCyuV/agc/yA+7lA9abRNsvSaG7gkjlUc0omlczh0dvG9fgZov5tkH/q7gSqqw4u+cEe6HhFlK/s0DlsZzDueylsSVrNSNss7adRBwCMY53AREhvAb5ir2dm93vu9eZjAUThrngu0DjyqEBzBpFu2rBsvUJvBx/GZ9Uss6ZcjkkoaqScYY3YRnJFX/mqCXeqlL/y3P4FkobqRF3eu6au+CRtlR6qsqvuoCqnBydEZNqgjZhV9JNwO+mZmR5i5XQp+4TZu/gMUChxHlWe+BgvBhFu4pop0XuywhJm6ORHEGjUS9qCV0htGV/8rVlBBDtiYE7LTQAYEe6rRdnkogD33czPsuS1YrA+sx8Vrun3cvBfsw6P3ayrCKUkhPLAJK+kQnMIEycvkqZeclL7JE5o5rqFLaFgcwaVruH58qOD1QmGMVIy4VPeSDtqUyPgqkQVhEyasIp8hElG2eHkrF7Rcl0mZOZnZE3l4x8Pby1q8xRScuhl1mvF7zCRxETYUVtPLyOLRVbA8FFyMD9bssfUJvn9my4axdjIcE5esZEJ3ceJ3w0ZnulzcxY5rPrCzsnv5smNBsfsEMOGwE6IVzT5xD/iwEYdWpLRnGttJj3TDzdxcN7JyHp8a0L4nuBgHynFHfjqcuOSJmg3/LZxoOkX1chaIY1sUHQ5jBj09wTYGhM9bqs8izc94NihhysnfvNJii2vom8MxLdNK2g81bdNPG1Kh0yY68mniUA7RRRQsbLKL4aOrEdLiZsvdIo8gCbhUnMCdrMvnG9VSDWXBfKg0yLivg6Tuph8zAo8FQpYQulWL1cgQpR1mXcC0rNY/V9JLyda4TMWXDG67fMNwV7pTTdX9qNfjI9MEiizHdEM/Nh6EeLOs/CpgbRrlGhOJ3cIhzdiwfcuRDde5PNCim8WYfXR3rbQXFlsNvdetyx/7UENm7C/YYtprNhAFRRThOxKrzdrfOxd+6kolHdCudIBS7BPcad0CLaJ5/6y+CMvFCxs7pRnGZoG25Okf3RjYrUGfytQq80oqXz2tsy2wJgsOJBqqAOtgRRGsNIzW88jd4zYUkm3dlC22uI3Zdj3e4+nDCR3M8ZIWXvigzGxfSPJPojXH3ozA9k0S8vDc+snf+TzdAl7iwFvg31lxfubAWDzOut3F8WtRsPPg4j2cJWGGgi25ZeSgPJ0TQsudJMs58KCfPyHiYkriJv7WqjHZPiq8LV7XNc7g5kTjNc7DEiuIPxW7c2tQ5ZHdzP2dNKyR6wgP8QCwgTqyXwvFSQ4w3f295kvXRqvDMD7eVB7le8kfzneGc8vKtbHkYiqmQ6puZh6i0G3ABxzHA/+esYYu1wXt4nXO4HUO4fIiWPwWlhV+saDV51O86RoJnUZe5IvuwgoMcG6unQlIvHH+4pG+6tVsTvJ3OFdDiLz4WQOxUF2eExqi4UUuEsaq3zr6paHupUALvK7tu39emePa6I7O6swunOcknoalLPF66bxojx8MqmDKesFbpr4e5A0c7IMu3aAuqD2hm9oZuliM36lu18we6UMB6wshEvrSRVVr0QLkE3Sz3UAOtDFBD8Ze6J4o4mneub0rsj/6pXCZm5WJblGt7rnN7swOzFw8FPvgR7Vkg50kHdTeUzck2m2E77gkEnYc5ERe8N4e5gNr7rrJvRwJurtM0A2P3w//ryU0D9MIPfFAUfENKh7RYRM4ovF7cel9TmIDtHsxgdJKrpGrXfJobvDC6vIqH/UrTxQE3dL5TboIm7A0Dx82T87VvJX8YDWRC1e15fOYljjS8tXXY+smVPQ2qO3B+9/hDvAnD/VSr/LxgMfl+tw/ccUx7+JdH/iCf/PJwQ/Qe3qR88w2wdVaJats1faQL4+Z4+UmH/BOf/B1AZfoxpEEzdJV//lF0dJZjPVZP/gbXV42b9dgfw/d6G+OGRULAUAx4VkkAfkeP0Bwz+8jsZuLfuSWD64fzetDx4Q49vnGf/zI/9x8nxNlennqDt6BX15kG/imuvqH1Zov9iZyZRAU/7R7y80T1+7xSfR9P8r7oS73/03oCj/8/ZX87v/+FwfBPjH6e3xo0n//pQ/TUEacVg2rAFFunLhw4MAVNJgwobhy5ByagwgO4kRzCi1eNFhOYzlz59ChUxcSHLuR7N69Y5dS5UqWJUmOdJkSo8J1J0/Cw5kTZzyePX3+BBr0Jz2iRYvONEi03lKmTO09hRpV6lN8Vave06cPoz9+9+a5S5fuHLmB4cyanSluXMOO5yoqhHhO7luk4DZy9Pgx5MuUJ1n+XQnzpcuSdcHVtKlTsVDGPOU9NmpUXmTK9JA2xdx06mZ7VvFh1YqxX752YuWCG1v2LFqkHdG5bd2R7sW7HP/NfUQHTp3BvvAA/47JW6ZhgzbfKdbZON5jeT+ZP4c+ubLSepYx0sucmfNUz6AV+vNnkJ89sQ7JdUQNbtxq9qvVSsSNbnbCcsRrc8Ste+9xeb/9tyQuIeOQU86x6JozMLrpIsPsuuy0284zq7wzqB/wDNqHPLc2csggcsAhqD2z1NLovIREMmgi2zTC6D6N2tJLHXaWowef/24czLABCVTuQOYSVHDBojK77MGltqNKQgrBsbDCfeZJ57X7PFQvxLNIPM+1j5D66K357JoyoRjhqQermHD8izjjbuKRMR/fhE5II2cyUrMIlVSonybB4Ye0sDYUaK2EOhxIHCzJkQv/pMC43PKiiiKKCBzc9qonoX4SSknGRQPEaE02cQIHueTgJBUyBpvC7kE663TqzqtCYxKcC8dbZy6INBon11zhmkguj/o6Dp54iMstQLf0MqnSfS4KSVOVOIVWJ4sILDXIBTFLlcgiWUWys8/usQi88PKB0hyB2MI11xfPSSjKj9JZZyfm6JEnwC8vOladeDpbFqNmAYQ2wJymBaraeYXM1kio6mK1Vc7wAQdiDCsMD5x73DlHIEMFBXPdXw1S7OCjZnpHzLo+OkcdeOyBNeAA13F5psd6Ame55UpFeClwHpQKo0oTatjhqCS+6MIM3UFH4xHHARNGduJViCmiEuKp/+Zh9duN09s+YqcerS4Fp9+JYyabOOhqbu5scKydjtuofLYo6COlIjrPC8mN0pz1VnsRHXjdgcwiiKuzjJ6fUMIaxeEk7XJrlfHRR2yFJC97HcstL9ug6G5+DCmRKwt6YYzsuUhu7iK2yEKu7qnVXNUMLeecdOAB3CCm6jK8J7/YabZZjOJT5x16Wr4otPhAQpG4yzM3iHPmFKpXZlMpU1VVaE1/yiDS667w0gxrTVddc2Z3x+efZ9K9ZIN63y1rmAxCfmXiLRL7eOJkehpm5mnO3Cjzb4+bzhhWutCRDhwGvIiewJEPeyDNdXhJB+DOV7qd1SUeKFFJ+xTiPqyxQ/8ekIMW+zh4pjSRDR7My1yDUIi9uuhpH/iQhzvWIR+PRNAd85jHBBNSuMiAwzoKuWAG2acb4bwjHjWaX9go1y8R/qslm3LZ1VDIvKZM0XQJ4Z4CvQKPy7nDi9JRYdQEGDDfZa0v8mCZ5MC2j30kcX1NdFZhoDhFOgasinXcGc8UUjewecUdtJNHDomkMx3+7IeccuJJ4lEPfFDOe200TBMVkqM54tGShqkiArWXQsxoEnUVMog+7DGPyTyIMsS5IEZyxBsjLhKEqVNigERokVVe0pZkG+Mmb5m6S+kDH3VakAUxBQ71ERNYJ8HOKy/Cxqwgcoi7hGY0d6mnfrQRH/b/qE52IvMTpFytmMVRJE+SSbmEkJM4kpRmOtXJvH0ocB/3uCbhUrVDogjlfgISJxIjhxRzRox7BrkHuLC2ToIWNGDt5Ac4fPnLQSYld0EpDlKAhZ3O8JNsWWlZ8gy6UY5ODmwL1dZFeLKmYRmnU0ZEYj9DedFYvrGjLzXoPj8Kz3guBTsXsY5PbHJBm9RMIUpRJh5Dw0aVwtSo0WRjrKxZU3mi73Brap7Vkkk8sBFHoEiJ3D4SelSuFpSNCrTYNbEptUMCsUDDOiIj3ci8z2CoqF2Fax2H2s6PVoWsUytr89CKVqv1hChBdVkSAxrQZr41roedIlGTqlC7ynNkGOFr/1TzybK1EieJWsmKYh2JWM6SLaChzCpRQ1kVbBaFf5xKK+QMm7l+VrWzBNWhUEMT2sUyNp6m9QnJJJvM1/bWkrGt41UzW9us0NSm9eTmRcJ5RJYZZrW+ha46aatQfdB0cA5NLmRTW9mW4tG10U1I9FYIwHUON6nVtW4FffjQ7EpVrc4VrULmx13wWqRz0FMbLu8IXNkq1mLWfcr5pgZRKfK2ePHtV23ra8node45ayPOIalzR2iad1nVDfBxtZvT5hl4JlpZVj+5+90F3xKveS2vZgE61h7+tGoW8bB8sUrfzp6wxLc0r0LucVz2+jApaQVaPSqKERonpMhHtTFnUf+8y+kC9LbI9StS/qnQG7ssyYhdsi1znBB48ji7ZR0ykY9cZTIL9atiCyiLoQw3g9QNo1Te4yeNPOYyG3WelsysC7lcUyif1jITlBxGQwMu7rW1zoeWK137RdPS9vnFQPunoNcKsSkDlnk3NUwtyXzfAP0sl9ACjVb1tFVGeznKSQkzaJt5kbqRLnusprPnoKVpTn3TMFe+pI8gjMmLRo4f1OyjWI8LFNtxD7MWw+K2ZmLouohO1pyidYBs3U1c4/FN/rtkVlXnj35sVdi49QmmMXJV4nya1Vwmt/lQGG01TStUA2tetTMn3rX5qMVy9fW2ud3mAINbnIwMkFWKpN7/FAItj4Sb9SWvnGRQoZDe4cVZlmOWZ3GBx7UI72tqA+ZJgx/8gBxvs0I86ekpstsw+lMfvOVdNoPZe2p0xMpXK25xoB2yJwBPdtkyM2UsSszZPy25QfQXsKEXZ2ArF5h9693yg+Ex5r+uuKyqinH39rzN/wRgg8zNKSHb7q5BP8wUg3VChlsZv0xXkCW/um2DcLtf9WgOEOtSFa9XKpvkvfSn8YrHoiuvUw0ne6jMDnG0x0ntUBeXpd5ObyDnnHuoUkodwXgd5j0Lj8EC2btjdmXnFX4yMQO5QmV+IZ9Fz68TnHKlKsOpuk0QHpO/yOfj2lPB1z5gNr7a1TzP6XLv/yz0+RA16Uu/10UK7jKrZ3Py1yZu/K77fczTybSh3/DY5xfGL+f62y4CfKgveyniZW6c6bTeUyp/VdFcHNlqUu2TdPWxATIgx7PC/e9WtbRRxbTACaizH957dBiBHOLhuW5Kil2yHOmrI3grG+yDP12yiNCKlePrMPiTGpx6PzECwCM7n+ooqOUpMQoTuQ+DQNFICHuwDN5jGJu6DgbsNEtzwJlgQUS7JRCMPxFUMEsBG7CBO+wbQP5bMusQslfbGQmjI3GiJ3qBpr7jqufZlp95NZDDKDbaqjxpu2pyKOsQwgBSQUyaIB36If6yHVTysTGUQWixvrqjsNCjrhEsGv+p4wdRIrjQIySJ26GvO8L1wkCzQopWqry6UELOejC4wTsR3LJwCQ/weMPr0TCuIz8Jw7aYaT+a+SEULMPqC8Q8JDikCDX/gqVD7DZY6UKfuUAL7LjrOC2XaSUa8aGZIUPm+cO4OkOvAzUL44cpnAkrjJsiySs6xB2rcZmX4MNWrMQAucTMIazQqkWwukWfkUNhdEZO4cWTaj+9erhhhJay2rq6AA3g06pfoyaksEU1JKtnjDCykSKfEima0b1qtMbYY0AwnIljJKpkpKbwALbxOz8fi8YdqpfCMUcEJCaqebR2NAzpiDx4vIhj1Adu9MZ6BKXvEij+2sJ9BDpUBEj/i0AcAQnGcyTI6/MsgDIvelRGUBIPawpDdesfgUTIaTwiHQFGkyKmi2zHGAwQcNnGeWzIkaQfX7K7ASpCXlSkgJnGoZRJ9euqaqRIHVNIxRJJsBJJPnmnsZJIylvAPYxJI4KsexIQl/HA3uqcpIzHY+TGbvTGCKzFs6zFNroHFstF/sOpqtStmFRHX5QmzOnIsLxJKbTFulBL0uFAMRrFLOOv3KPD5cqtgYyoYSqMXzS5dlTIsUTLvbQIfoCkIXTEveM1f7SgUVSIb0olaCMMxrzLsMSosezGAHknhyJD/0MKzkzHU9SRbyrK9IO2xnTMKGTKWiSOd7om3KFJg7vACx7TK9jszJJLiYAAACH5BAUKAOAALAAAAADcAKsAAAj/AMUJBBeuoLhyCMEpXMhw4byGECM25Mcv3z179+4tvLgwH8SH6UK2GykR3LiSKFGOW5mypcuXMGPKZCiOoEGE5WbK7KfQH8V8HveBE+oRaMl28+5ZtKezqdOnUKPKFChuHEJzTjNC9CjRnz+F/Pp9BZtSaT6K+zS2PCm1rduXLF2Sk1lQ4cqqV7NG5Eo2ote9Einy89qPX8O5ChGDIzf3ZFyYbN9Kbqv4ZcFwVVdexToTY0ugFEvuA8pXYemFg8cqZBry3ELX51o3jTy5tsKaOiu3vIxZs+6YTFtmJJ1vn/HRRjMGb3ganOqOFue1iz1ynvV2s2nb3s7d5k1ynLfb/2Oasbx5ji9LPwcXerxSwc3hau/+9rHty1XDb38Ijv9q6wBi55ZgXq0Xk30MhUOfVAhKxts4v9k20oQUViiTgcItlI5L8y2k4IJQddgWbpdB2NY6DaHIkDsLsejOiyyC2BBJdkVEG24y5pidY1bph9KLCsUIUUhEMrShRO6oCJVgZAlmWEQZ8UfOODiaFFmVOjJokmQ4LWYOZ+vAGBM64KBj5jlopqkmOkdmmdKT6ZxD5UKPVaVQXW5GJaJMc82Fpo8rxpSmOX8SCg6a4HyJJpkLKakkcGo1pVo+7aQzpZUn4ZYpnrfluWNuiSnGZkhufWkOTqjiROii4LTZKDjrPP9a0jwYRcoQkyWN9dc900V4F6cpYelpQys1+BJjisUaZlunJgQRqpy51qqrMtGq1WkFpvRcWgIuVBNLnAp7m7jDEltsuRHlZGOxJ0Fr6LQyIVWrWUL1VOBf2ppmK0tTioMnueSiC9G5OcrKEKCYRsYutNKmY2ZK7sgDYK2k7RPavV/h65JFrZ4zJTnljFPXQHeOG7DA5jqGLsIlsdtuOeAZSW2QEtNKccUE+vPPzv+4JNZHcS4GzkB2NkQVypDt+ZayKBo8FUPFIhRzRDXbfLNxTlLkFc87v4RhpUHPdy7JSMNVo5XbMa0QmYieDRFVJFMVNcwtuoOUzefhnHVqXHf/7TVEGnWLGMyMhezhh2WnxK5dSsOkYqwMqa2OOmayDDeeOcFtl7ruAGjdePMSVxxaFmutM88yDQalPdK1RqTHQxMke+JrESwV5LBCBA88yrJz5pfOHs2bgnOJGxutnk8culEQpXb6TKk1D9Q9yW/Y753AvkR2li6rzN3uu8fKDuV/OnsZ9uFQ+aFv1AEoT93ySDzeVnyJpTNMkVqMoULIReeOx1SqSfZQchByxMY1/spT92bCjpmAT1khQcc5TtUh/JgEZrGBkXXexztlvQN8NfOMQpQCkZ695CLLeVNopOOxfvkLcQQkRzqSohU5wTBHC4TJ5BroQPC9I1YOQxNC/+ZkLvCE5EXtgJE7OsiOJqqjiU1cBzwiZjV82GomV8Qf2AB4Mjqdo3PM6885Ekifo9GJJcYqyeSeOBMY7e6HQAxis6IGngzaLYkvggc44OjENa4Rih+M3zzqMR58WFEf++BJvsCBHplYpFKHMslAbmiXc7QDI1zhij3GKCMzMg5tOpzchgwmpIjkMXxMI5IEF3VEJbpRj+Ibnx9n+UR2fDAe8aMHIe1hSETyZH8NSaFMeMUi2JUMaubonFYgsklKugVLnnyKmdiUu4ZMcXclyaOydrfEWE1RifI4Je9gFUtZTs5MtHziOt4RD1zKQ5eExAci6/UZ7lRFhpccTkTmQf8OZ45IWF18yTTTwQ6ngU+PpVxIOJcIo/g59KHxW+IPybkOKPpxmg9jyA7fwc52xoMeuuwIPVGSlqYoEiUG7FytZtVP28Bte08pFkZTws2EKjScDnWfQ5Wox0ahyJwSNEflGFWSjraTHjqpSH/887eSZDCfLeFnQJ3yUu1FEyUE/alBbXpTiHo1oY66KPDK8S6UNJGjT4mOdNpSHREyEiXtIMdUp4IbmAZrrg2J4uMWMsWUvK8lcPSpLCWYqmgRSoIQaeKSqDePv0ZlmTBJRznI+E+8Gi12nWpJRRWCu4ZwNZtcddo5J1hYU5G1rApRLFTywTrsOFYiJ+2JVNIhMn//0lVz2xkHRw3W2aYc1GmchQhpU0Vc/awRKv7YB+uApKymjGYm7RCZVF5qWd9ik3YLIW5eNKqOhrDztS3hB6+IFMGQoChiMIkPSuwRV9u6pCbUra5ODtpTdFm0cuBAlVXUpVGGAPKj9ejKre7hDnSYSlHnMFM6llWb6ZTDvSWJr123w9F3aBZEUHQifnGyX3B0NyLnRMcTASxM2XakV8U9FFEnY48pQTgi1MVu5HrbFOByNsMhBpSIJWImnIj4HfIgpF9QQ+BzoEohzorIz55yEdq+2FvxzRONUYJWlzDNxhHpnUUpZ2CG7DgiBoYWOgrauQyBUmn3iF5TKPU/6bZE/8LD0uuUUXLlOkslw74LqkKEOjkwN0vM6FhHiRvSD0ph9mDoABI45GGPRAJTOJZSHwHlFsDJ1HVBdp7MOvtoYIz2GSJzdFegwZGPJUPEH4WmLXwHYsBLuigp+3h0SuZhDiJKBG53mfDhnkwTKMu4mhLZrQc5qmGMZrQh6DhyLfUIa/t1xR/5kGymkGyOdIxnd4x2NERiexS5+lMgAbyqh7D369tR2cLAJnaxZwpmMj0xyIa8ByLDki2/QHselmJcq+0hD3gwWh/OXkhh+GEcuE72hpTGbYLOV+62FBTLZu0jl48N4nfQg5fzDEs/7PcXEzLkH17JB75biKYFYzMpav9WSGGeS+p9OpkmmRE3+hjecKhAPJQhNis7Ly5PrG2c41uLyM58shTpTIiK9jiLxpxTEb6chsAuHlpmikWu4Q0wSzePStZDmZKzAlieGd/4X5beEJ4ViHQVS6RY/KbysqBjTlOv9K6tTnNPlTO1qj3RWz6s853HU94+Jzs4PP5xsxMGYwVCnUuo55oh5rohdK87yvCc95rn1Zbf1WUh9aEPgcu68IZH/L1iEleQ3QUikb+65S2f4Y6+sx6w74hOCD900beRi5Cn++p3vzaIfLiJ7Xw9Uhky0mHZw1UKSj3vl1+mhewwtXsM/jtTwu3Pt8UdlVG+m2LMfJ3skIfRd+f/S37+y+3QM99Sf6HkQcR9x3W/IX3mIbrjEcxBowZXtnlSqy4VwPUr3NK4pWtZliLNVTBP8WnggHklgQ8ogX/5Bw7Hx38kYjT/9xZRxnuPM2c6lHfoFhHzUxKh0R39UGSXAk3tFxWrBmdLkzYlUVHgFxNs1BJCRlLFJykmBjhxMiVs4TIVSFUSJl8oA1x4phMv6FxDUYO1wSseYziOpx28cVs/CIRB6FMGU4REuGamgYS5ohPjtYT5BS51EYZPOGlReGjvpxDoVmG1YYUL4hMatzHzICT8lXrOFF8BFG4L0kBsSGF7pIb+5RR7qBD0xx2oxiTcdmqUEmkCQYcmQ2nd/3OCDbd1LaFagehlzRdsaNVOKWFFWRQThah/1IdvLjY8WDI3pseDPXiGk3h5C8GGfOdlK5YSg1gSbqUThaiFCsE1/lAp5qCDcYETyFI4jyiAqpgSvZNYPISA/QWLFPcUHygpK9cVqNMzBCYbwRgyqOggyad63CGJedWKzrdlyqgQfuRhazNNIAKKfhGNp3Y6PdMz/LBWi+GLMtcUdMhra5GHIJZOx7UQ6ISO59iM26GOp8aOKsdxfeMcSmg49sgp96h7UUEOTLWGioVj/LhGxpaRsIg0qNYPxbd2CWka7VBrxOgdD/mQktFqBPkWlHeRGGlsQqWRvocyhcgQ9gNy7//ocf5wD4qofif5k7klQ/YnGXjmkhOXkUjpe+MYg7XBcYO3ELdok+6oZErYfz+JkrYBIe3AFyvpFhY5S0hpYDEZVGqSJuT4Yf3oYd31ipPhbDppkOAQcIPHduzBFf1ylTlSE+VgSWchI1/5kmOJlBO0KmVpjmzJXYf5Fjf5lgQnlaqheGDBFYrIiPjYFhAyQ1lSlGAJk9M0loFJJgIJYuZIiFtjQrdIT2K3EHTpHKzVOpciMAeBmYDRcgR4Z04kS4aJjknZabFYLjUYdD2xcrj4lAwBbWBzl+gyDucwD/ExnF65Zc5nbP7Ym3s3jjNRcA3xHF/hkc6Zi6jBXjmYRgv/Yift0InuBxEF6BJQhGwAiRJ9dlxpKRN8d1YycRzasnHYSWglUWhq0RqM8XgLsiHdQmphtBCINEL2kHcaCGxdt57sCX9GmU7e14qV1xLz5JyneSGPdCTBiCwA6haOsZyRAjoYoQ9ZZEjbUaEQwSgRepETSqEwwXn2KWC3qF65wlqVYmRoVCzXKHdQkSYDyhA5NZQJWIl0how4N0ua+X24KSMymp+wRXDGYaN+oVw5qoOL+CF4UTin6KOQkWgOgRLDp1D19RQOmmHyWUuUt6ZoCiKcd6EgKKX7wHmemIgAZJW6x6MemmsCaCfpAF4pEXsNMaZNsaZmdZFsmqgOqp5G/+qBGyGjb3Ic+UCnKFGayXV8QqQ+Jzku3cMuRHMbMoQ0lBdxEhd/ipqoFFqReoiqWPSmKXEcb9p5ldo1O2kpHuqTV7k+nbowozZ5Q1gSRdmgrLoQFeaHZ1WsxSqDgPMSxhGrsgoOzwqVtLpJPDiGC7epNAEhQtU0aOgUgmqmepiAwqqqp6putiSuDIGs6rquyYo/lEqDsQoRqKkx+SAni5ilEJarxDOJFXauHKWJCgFSCgF7ASYTo8qoicquCpuGariufWhU6soQ9IdU36oQrtoSc/qusAWcu2hkuEoXdHgQq+hdRnVUAqsQ00eEi9p1xNay7OoS7OpRMjuzNPuvJv9LsTNosdFaEhorr55nILzIkE+xjYiTYIzCosAKDjRLfwALqDChosBqS5jnsBFRYUt7tVibtR4FUvBUsODQSzvbEM4atvwzUksnXkbXGiEjhYfTbqBJnSgBsF5LH7FCtcRqtVqbt3o7s+8EUgTLS18LdhZ6sRExUqbGHvg2LSIRabamE2T1FrPoJu36sHtbuZaLS1zbtYCrs/TRD/OwhDkhQ+TFRdVFVmZZqIO6EHO7IFVWYfDAUbtzuVrLtYKotFfbt7S7rChhnjDRM7VqelSBQa/znyW5OaaSYDORmCFVLvQFD7KLtbhLu5k7vdRLqE1hSAwYE0PHkzpKFQVhFQb/1Bp36qU0wV9fMlTumZgL8VHBYb0gArvgAw7O+7w0W70BW732qxPYa0gkqr2s6Q4UdDkGcRIlB7rYeHq3ERkJoSgss4wSAU850oEfRF+2S79bi7/3O3z4e7IMsboS8YxN0TX74GAvNDRWd09o8p9zg41JdjCsokbWOajuS2EWBr8vIbMONbMbvMMcDA71kLkNUbERgQ9E6jUifHxre628UTRLKDdXkWCD2RAHFpPni47x6SnIelA3XMGaCLCL9j7Ry8MEO8awZ73LKxnR2nF1+T+TFRF0ZydeiBeHNU0JdmB7NsWrgk4xnCXFSsGTIcZkTMYD68H0gS+FIXKWMTwQ/9JCSHbHE2S0fyIRisJuWNzH8ntdklG9PxzInCzEqlvIY9Ga1yFZLrHEBCwtR5Yok9yZERGYapknWYzJ29G1nVzLTlovTtkP9mBgsQEOlYIY+TrA5RBovpNfXXLHc/wloBaTZ1kSTtsWzTssnUyi9kDIk3GhQDcU+FZrPZIO7mApATXAPTJm6sAZxLUQhxXFyPwwV7wQMwzNfpwnnEzN42HNb3EcQPcV+bAODjNZeDEtcrIbmdElrMwQqXy8B2a0esyUClXETxHN9DG331qw9EzN3TFPP6cx3Nt4L3RPIWEOc5UqZYJf2YUSCGa0f0Ssq0G2UgHRC0KwPgzTDFHREP8IwtdsHGJnyJgKGyaBHyeRg1NVWGrZm8ecX47sabUkvxR7oLWhxTki0z4sTBa9EDY9GTjtlNqcgzmBKOqXH3HSxi1ROUKFhu8wPnumXeh8vtzFDvRgRd350GVqG+4L1R/sgQ4NFbhcbyLXvT0CO0u8lyEBMjmhzOwZn2jFlmN1zCv2YfHA1N8jz5480/Z3109RcLlMYKfS1fNowgMsQ9/sMHBbpOR4tyXRLIStUewgD/ggFCztFs0ry8ZHi91h2fgiXmyMqycBMulnFa6RRx1YtWadWDD4DvXQc1lyUJHrKZRtG2qHLyK3DslWwhbUi9RGKOngb2V8xhL7DurrRJr/VQ/zJLaeEj85stz0YTHOZtukZWsW1HxGu2AJFdkzCaNxu9qHmCeaSN7O/MDvvHvoPRb7gA/rYGRJnCAiCxGv1xBErLIRwdbhLTAPJRMORb2SUdVW3dxDQT0FFsA3FCFrCH/wYA+OvXwRHsa52xagc94Y/twOcygevmgvUc0BNnzJbVatqNqtbbEyRt4QtcMdHMj117+rwRTm7VyO9hX3IA9ydMeXOLAd3BIc7MXqaXH3AKXEt3sTTuEZXMtjHOQpDiLNjeTfPFxB0g7PnBL9/Yd7eHEjnhI5jjQ9DBEzzMnMZOHcEeb7MHIIdiS0AhHyfYUNEQ/GjRJtXowySNeS/23nN53RyjXgyFsSEp3mci4RldfWiSQRb+7aDUfRKVTkTtF5ascTAd5vffUUHlxlwr1HATvoUGLorg6t2DwUJooP9hzEtZ7qYlrcmW6hr15unYfNhjHr1fwSZfwSFlaJ4P3WgP4qEeHSve4Wb3rViqQP2Evsxf4SbKjrJBUVFQpc8fvs1xzt5JfhCw4T2Z2uv/2NARtghS7eixe1KVIScQ3uUhGrPrdxI1Tufh4RunTiVMYQ8uSXjUrvtiFvTxrqinQP2RsRczummSvlEEF/8ZTpu07wDWfwF6p2DFHxhArEcR7EviQaw4miG78Qym7xC+Ks+IzvG/EUQCwRrN4Qyv+uFctBqSy/IDWO8iPkqhl/89Dq8igR8zJ/8j7bdjly5jr/68dRgxUfETm/0q+KhKy98b/+83F5kOOt8xDR81Tf9C5R3EOh9TOB9KsH6iuv4z1r7Azf7i/h9WKPNK46o9wh9DIf9lvv9m+PMhgv91bvFhgn8rhIuMwH28+uEQfPEBqx8E7uEpGr61rI95iuivNO74cP8PXsjLsuFFZO9Xn/fk/KbfoOE42v+G2P953fVXD/+QreFLMY8Kf/+lQP+W8lEzMO+7a/9VjTFrcuE4IfEaZ/+9whoyGI+C9BqMPOs8CP8vJ2hGEB64zEu7Ub/QxI8luf/Hmi38GP0fg+p4z/RPou4fow4f1Xbv1RQfaf/OlXvXTiXxJjurO/T3xEnxKeTv4u4Us5TfxGiMYwUcS7T/8AAU7gQIIFwd0Dt29fv37+HA7cZ1AiOHoTBeqzmHEiRo0Z5XUEGVLkSJIlTRpEqJDhw5IVT74MWY8gPXkfYd7EmVPnxn38Vu4E2hFfRpkygx5FmtQixp4/J9obGE+pQahCh07FmlUrOH0qG/qzWDXeWKngjE6tSvKsRJdb3b41qK/rwoYhywqsd1WpXo1rO9KreBfuYKxyvYIdiHigvbYDG++t5zeoYMKVdxpuWtdivcDgykouCBV0SIz4ItMkall1ZYQDMfvsl9GeUcFr//kWfFxSZm7cIm2uDvp76lB8reXOzWzxHmObnwvexhsZZlWa8eDBYyuPMu6KwoF/F4lP/L17x/Mp5OfT4j6+ZemlBQc9+s3ZZikC1g24pnfw/TNeJe84hXpSD6S74CMMH3ugEg9Bg/Tjzz8JDQIwQH3OQw8chgzEyzKO9LlHvoxoinDC1RaUyEK5MMyQodg0KvEvnfDpykQbX0KwNRWRIxC2iRA7a7QRRxKSK5BidOxG8NIqTiAVByTQRcU2U7IgJKuUULwmDzJvwPRgYwmcKcHhRx8RsUTzRuKKK+84HmH7SrExyzTtJt6GvDNNPS1qckfk4HQo0In2MdOtx7bbc/9PFAfqc0coARV0UI4G6wzRl2pKNEHy/MQQzjjBGlOgiCpzydKJ3nkn0wm13NTNTj0tKNSETMpTJM5qJShVz1R9q0iCWFWRRU9l1QnX3ghKC9eyKBPMVF5hkk4jYC3MR1gXX9SIn1GnuhM/jciyVNeCnH22pEUp3LRNcISF0z/B6FmL3I7ELRcoByVi08J1vfQRpH627cjXbwnyayyB6O1rV1QRrne6xSbKN0CBWBwI22xJMjam3aICh+GJisq14Z3OnShdiSHSyGLgor1JYJFFWjDm/0yWiyCABVJZIn5INYoeeR+EN+OXQYoZxbTs0TI+miedlaSdBaovqFrb+tknoqqHlq1ocI5OOuLjbC5JW6hdhslgrCcs+twFk07XVZjEtkxonQICACH5BAUKAOAALAAAAADcAKsAAAj/AMEJBCdO3Dhy59ClWwcPnjt58uZJtEfxnkWL+TLmG8iRo7+PIEOC5EeSZD5+4Ep+LHmS30h+99qlIzeupsCaOHN23MlzHEecPINyLCiOIFGiQpMqXQqOXFNyUJkGLXgw4cJ1D+W1kziPor2LF8Ft7KgxqD9wIUsOHNuxX7+SLkXClHnuXNSaUPPSzOlzqc++QKV2LGj0aFHBSfuCCxzUqV7EPREqxJqVa1evYIVm3ngyJUqUazWCvZexY8l+Iv3xy3dvHl2E59KlaycznV2dfv/ihky48FHITG0uzQu8t8By5qxShuh66+Wg9gSOnq6xesaLXrl+JT12387Ub1nL/3Q3DyNr1zP3Ku45cLfAw8UNA5cqPGlUp0zPFR5YTrm7/xDRZhlP84Bj2YETbTedRfYc6NxE3FXXUWorwZQRSSvlg55d6gWlGGPvFfeefPMpxZdU+DWlFFE1lYOQbJQ9JGCBOzVH24043miZVw0iaGOOl92jIE8UFqlaa3RxSBN7N9UXIm8D/VZiT+u5J5ReKXqIUznITfbffzoGRduXZJYJpIMS5ajmg1zdI9Z3RqYGkz212QbVejc16WRR8PHU22HGTWmicLop5dhjSXEJlTnJXUXmjR2V+eU6lMpmKaWSPurOmF+CU6ZAOErEFEgTjrTPeTfaiaee9UkpWKBMuf86KKEg7hTVU/gR11FddV2a6U7ueEpppZYWWyymZAokqVS0ceTdfG+ZdF1rM1XJqmKwTsXntlIZRuKg7a3aUYq6PrWTQulkmmxHw65TLDrw8iqvVbJx1GmwgrLFk1qeqQVXSafKtORPNrXa54h9civoYLk5ORyi5uqq7rIDrSNQOuCkEy8683ZcF7wYL7yTRUqBJtC/KanGj1sk3VNtfYGJ6y2gvsXHMFKJ1SoYuTxNvJRsHMvLKJeMmoMcoyILtR1w/MqZj8D46YQTYVTPTNDVOC8MqKxUiruzYwORo25S7wY9NJdop020OUl31JWbScsVk5136jaOrFZn3TZ8Cgv/VavD495qbtjJ/icUxpbGe47RanO5mFIwWiwVvu2As9XSb3LUD1or7fSZRyMhmV7UNeG8rd4H771T6jsBDjhHWWapolQYwwsvOIszjjZfJ/KEzuRfauXcV2VtZPJZAr1E0kD7LJ986OjllZNxpyfc9lLZUtmRlVcKjljIAi3eOO+vD9Qo+EnRFlGQ1rEVF5yqkdU8aGkhqR855bgHFJ8IX78ifU4qlKEEcqjv/c5s4+vdTtAmkOQopGKSG8iDKmKefZyqVOD4x3fQwpPmDSQtGrKNXfJHPmyNyH/+e53OeAIxyNRFbYvpHevSJpnIOaQyCbqIRub3uedpkCP/CCKp/0wmkHx48HkZ2tCSSlg6qqEwheLymq3KtZOG+M58aePdtxaInNh8aUaY0eGF+AW6HwIxiM9LSUfm98GR5INOslGSXkjorSdCcXsokl3PBEIpjtwOd4z7yVHCEY6iBMYg4yBautqxvssoKEJGJGMbzdiRIJoReWRxHucyxCA12YmOXNNWVQZWouxp7yd5mpLhDAeOCF7sd3UJ5E2IQshwvMcmhuSSFw/EE9JwRJOgY8oPMRkaIvrjHxU61bREV7ctRmY2b2vHOVj3qhP6LYDtEZnh+tgRjcXLHPgrx2IKUktb7scnLorN5biyEwrCDRzPetbJUCMVDZ5FnmKJJOg+Ev8tgGnoNU3U2/bO0Q5IhpCavEFoDL1WsPIF5V5kU5z4uGQTc4YrkY3aFII4oh0FlQaeniMmJYGYPCKCAyMYamNaWNIad6TDaHfjX09mY9DrpEOKrwrlRVdFPqXgy1PrEoq7FHe2KLEonenaFJsGEqxgMSeH5tFXGZUixLOwZiAYad7m9slPk8ztNjFd3TgIap7QsOamSRPo9nTGu6R0Sllv9ZRcd+IuoMUSnLgix/mUykiIyCMoN/TrPOrhTjEab2XEDIolVYNPcGwnkiYNSXje+Jr8UW8c5nDHY8liU5wiJnWpg1k2V8jUt6pLHoXDV129ybGBoOu0S2lIQ3DIo9H/6MOCK6NnUqq6Go5QMCNH3Odb9iG6Eca0IOWYDeY4e1bPflah2XxcDFMplDLdsHB+zS5ElBKjvroDHogZ1jsaEg/m1IOwYbzHbedHTw2i8YzI7IdUwwjcyL6Esi41bn/IQ7KgiAatqoPuTh0aKYgCFbUc0a5flYLayinlHUFhBzvWwY53WBge5X0qevFhkfWSZKu7RaZJfZtVY64UVSJU51d2oq//OhdKiFFgdZcFIFYK5K8I+qtARCUU2QpGHRKWsEAsHI8My4Me56UIh/Vx25SAWCgiliqJS3O8TVYIVZdbMVmY67IX2xGVwPsVarOiYwP5aMfAkRw7OqKONrt5/yATfkeRiwwOJCcZH/hgMm43d0zFividHJXOWOx7YtG4iTUG5YhopvnlGCtwVRN7CDiye2PBDggyFqPUms/lZnXsxMJyjgc44kGPUhN2ybfNbZ8VeyQDaeZNhH6JMj9axLIo+jrkEHCjS3QvMi140jiWyFODbeakuBIcmxZIa20HrzaDw80SBjWd6YxkPKs31ahJbCX9QVwa9ZI7wVVpMkvz0bFIVSP2MIeud+2XhaYWqJIG9qSBXWamfBe8PGGHs9HBNnn9sdltjvZA5Fzn81rbw9ke6UCiHJ2dRAQz2IafyiwoZSlTfB65ZjdkQOSenypLwdu1I7N/Bw5mzwsdAf9HNqhDbepT61mrH1F4BpH5xgIhmKnMsQeHtSpxljCF4u3IuKAI2ei2wtXhIddu2zbdZma7Nmi8QjmQg7zmUJPazjpX755jzhNk7qNB/+FmK8HhkIdr/clIVJmUd2LBgOlR4yUibYLLrHSRJdvTyrbdQPwtdaoPec6ltvPB9+GWj3T9SHUiOUcWAg956Py2Tz4mSIa7dmcBXZyQIfpgTJk0EEG0qU6Fe971Hr6PQTvIyB7yqAFP2A4TXrfb7sdXi8Y2tpUcHZiax86fXNWJN5azMTmHlwVSTqM6E4qf8riv49podcDLHH/EXUKk7ulNJxvZQS4vPbKeasPvRMTzeOn/Ah0Io8bbo8lcnbhQ0J2Ocui6nBad2Z+Esu6H/rSpyoK3x9nddNshTdlvlnoCcXfQJmfVdnbeVyohpEdEoxzw0BX6gHYiMVz+5XbOBX/GJ38yNRRGMRTU41MUYy/71xFWhELO53QA6GwCuBPOF3Ckdmr30DwJOCGrEX5Z0iLJwUcMoXuEVyqTxw+/Vx3th1DwR3QaqIF+8htV84GIcX9J4WOQUYJCMXK/02kDiHcccYIoV2FIlnVHpG0DUYMzQUIEgVHp0kpYUQ/3MGJyYUFcBmA8UYQIc4THZ3z7cTVGJXqCgW9C0X+kp4ICgYV+1GwVJg8wGG5CUYMyAU45QQ6//xMdlFIePfhBm0SBwDcPwheHxTeHUqKEarV5dcQweggcfMiCWsgT1fd0JGiI8wGExeUUXZQOXSEP5pcPIDaBklRr9jCEvYGBGfgtOpUUVjOKTFGKJAgPEJY0/GZ7QPaCXggZbyEkzXGGlhMdD9cZArFY/vAWAoFPGhF+7peHvyh/vlF/2kKMscURpWiMkCGIynZ7QPYOR1YR6IcY2zhr03FSHWYy2piLytQamUgidIgUeSMinMcT7Mhu69iOgQiIbAZkN9Z6gJY8JUIS8tR2KwNfXeUdRqRM+nAP7qAfWTOQnygoR/iEUAiFJSJbKikQCwkcVuiOzyYYM8g0cFF4lf9UVcPVdvnwkfbgDllCkiWpNcMYWywphfNxlEhJgiWChZ4mk0ExP8gDhk+kjdFCcT7ZfsdFknj4ZaE4ikq5lEzZlFYIHRxGGuxFKkshc5BhlUB4KhZhg1s5jMHoP0XZY2K5h2HZkk80dWsmZB0xJPNUk23ZlotFeUIiTSQ0NZ4IK3VpknVIdgPRkixZjEeph36pcqM2EDAIbk6WNO4lTL0HhKyxi/ijRV/5JOioFEhZmUbpmhoXcIC5egLRhfjwWMbjFlxlmGxJUodJmja4mAGVLUO5mpO5jnyJknn5ZagHYQR3dUmGm7jFhoQJZe9VT0IEnGPIF1wTmcapjseIGLD/WSLJyBSAKW2jBhFYd5ZG1C8+yG68tYDCWTqb1z/f+YTHmJB4qZ8aR2RFpp7RWVaICA66WZjClI3Z+TQvpR4Og4RTYksWdZ8SOoAc4Z8ZhnVZB27A5Bloh52haZ2WJF+VRX/kiBhyuCLFOaFLl3rS9p9HhqE6hFth6BklslhruVj7EH4jJE7TQ4dKUYS19FzmqKIRlhTJ1qIuameEpY/AJU8mM2IZ5GfuhUyi6XU/aRsU1aM+yhFAGqGcWJIpupr8WSJ+Bw5WZ2Tn5VhnyWTtmRTZxnVSWp3fJ0RfBzXzeZID0aWal4R46oFDumtjuhTXN4BChqQuWnBK1mG0ti98/yanM4dMVJmTQkRZO8qdXTmOQYqiRLqpWFioz1leNwYOd4ZqOxQUKNGhkuqo8EVzP7mjCzWXJcqB5Sgf3tkt47mpSgGIAnemC4ahZwlJQlGgIEqlNzqp8xCS+NMeW9o/83cwtSoYY5UOl4mruZpy2GeoRmZqSoYP0nFSledksDenQuSh//BGIdktX+pEHeiVB9EOJzGt1NqH1roTcyZqk9ZyFCEQZ1kyBIqqCDquVfoPc8EhoOSjjqlx4tAf7gpMgfpE5Wmkfzmb0CYUdAZsLbdhOjcQTBas/vqo8RWGwrqq5Wqnw1mif6o15CCLLeES4IlCDfGwK2h9HKFvVFezWf8IlfSqnkrKI+BgbeplqlR1mGGYkV0XorsIVkJ5kCgkDim7hijTsho3qIQacKdnsx0htRwxZzq7s17hsxs7H0LbjZMorkGkoDCVtHBnEORQUO2jjz7WsP6TbDXbadA2sUJRYUNmoaBKDwWHXtt6EfpQo0IEYhYUsqs6F9UilAibsmwrGvp4EW/LbnIbZHRbuZZ7t1UHaqv3n6XGEX6LZ78auMBho1slo2ehbYtFWS8Fq88qMmori4lmayAletdnubZ7uUmxcg/LuaYmqgOhZD3LrVIhUjoptlC6cJYEE9HDuqKXXDWlL20nuquJd292u282m/mmuc4parzbuYHZcML/uxRop43MI6MUuaqy5xrIupVpO1aNWxZhwRH3cJvf+ZSV+2wBSLfYO7MVprvJyLlKE7yCC6me46+WxKobYlkb+ERMKxvlESFYhWca27P2kKYT6pA3q79YC2f9a2FmWq98mxQNJ7g1yXNSKrCis52t62hj9cCZgVXzG76OVQ+/RrsBGBQq2KlwJqgdrLcZpjQyzJvbGBSoesDyRScApaUnuz0vRVZCEh1csT46V8F+pZRPtMENSbs9XK+g2hH14FjbOrrFKxgH7A+URRfgkD96kpqIkVzrcDkGAhH3Bg8MYYg0DHL1ljT7i8MLg8VXi7cQNm326rmiGsYT+XsaOcRk/5y6MTGivcOYjxklYxUR2/UQ32VhmQaznHlncUuts2mhPPHFYCzBhxxikNqxRZudjfxJQGF0r1qyf7JflOySZioUeQzGjzeKQvaUexy313emV7cT6AUcx6STx5vKQaSIrOzKu0E+R1EO6EBmZKfJUAsd8erLm4atR1ZnnjvCa4TIacdPStGoHnskSgRKJRscLXIODLGcHTFnA2FnApGvovydfmxHXExqL8q1HQTOVibObppt5TwXAIW2q2M+uCd2SlGv8RzCCWacVquHZ0oP+5ym3owYblF43NiNPCHQxUxzMZFfNLHAwhgoibSF95y3XHzL6DioKa1xVxd4OxuV4/+c0brZdm44ox4doqqrKmHqIf1hOzg7H/V8zaIX03zLt6Kcrxw2wTUNhPCE0zktEBlteDwNR3GkwPORsAkx1CVyXvUgwbv2l0Y9yJz5uwIMDl+biETkHTjdFo360WaMHpbCIWH1WQ6EcjO51/Oh1GBd1E80LEatFBet1kIh1W6N2Dth0zFnrPnVK/KyF+vWRQfEZlKRjAZ4Xt472Jx92G3HPMP70QLbcHi1KLERR6fJeRilH20TD4RVzw7dn8bozp2dFP6cFKcboiA5hhQlTlAB2XUBFY7ZRaydNKRWwYBtR5ituZPJ2UvaEdLbQaBNzGexWLsNi2312/Mi2VRxNMX/XdsdsXIleKu4mmQ7Ed1JwWTovRRWPakudZrlCBQu8ttxJD60xytS4dUDoc8s7T8ebMXvvKlgXdjprd4Gvt64/a+qIU2neTezShX8cT4LoW9UyBTUKxR6q3HglZybSaRgvRNBDN0ILhgCfcAwocKmE4oGAQ7QN2EURuEoKBURS6SlaK/cC8+0iY4WrK8CPJFqPeIY3V66vb4qLg6FZBziBH1+ObeKZ55KsX2ASrErDXLz9tD0hkI7nq/slpG5HUTyFX5n+y1ySDQsGG0S5mZNXqQbjGRALjLurGADgcfaJdN03jbJ3RH91TaT2Nj/cMSL6H4lSUgJ2xE5yL9Up4VB/5OF2Ie1hogPt41CgxxyHSHnkn6vdW7nxPiFxWzOtSE+Dh4UhZTGDNRASPPd+NtppJfFMwth8BDWUz0lyFhFQbFgLD3npba1nRt4mJ7phfvPq4HVkX3XrSNOMEToaY7qTleWVUd28uDor76S4/WSWWtkk75dIUfn3pvrvuu5f/3hm6rebaebknUe+QVO2o0/oJVIxJ42PMEoqU6FdAtnrk0PeWZBbb4UrE52fCiW1E5vIJfUly7M3i6q3X7nxnlt69WDktVtMoE7UaEosbQeBjHqok7xHFE00Sd9A3HD75BnCb8P9w7rSJcUf3Xtmx3Kfy0QKU/w0aHlguLywAHur/8X16qBX7bBNsKZTmCFNvdtO8VtNhg/cvi98dZaD4gd8rmLkGKpdP1dmycv8AVfz0XNIwRO4Hb0cq+XdogrQuA0n4l0Dv+hMR/TbNQHiGj+fMkRdUXDZuzg2hEI8upt2Cup9KVYd5Vm5XUW214c9QM/zLgM8441ii+X0VrvMqW3OOEk3+aQVN/14hQGavqWwxt/e2if9tGnDvFwfq8H8hyB9EpP93FO6bXJEbouFClf8L9L9VQf+OgoujOPRP3wdVjq20WTrN6NexGh2Uh260Xm0hfuWiXn7rbzDppv07HvLK1dZC1J5WWG7Xq/yXy/8vOs+oDfTiJc/YKxsVpF87H/D448CvEJ4W/MfmpeoftmjYrnYjvsQA+Qh9PC2uvGzcXV/mv77PxBEf1/XcHUv/oifP0AYQ/cQIIFDR7Upw/cvn79BvqD6I9fvnnpyI0bJ25cOXDn0q0DCXIgvXr28NkzedJevYMtB6pDhw6cTHTs4tnTx5DfPp77DDJ06FKoS3hF44GTlzTpQaX0nDodCZUgy3pVrV7FWhXlVq5bh34FGxZcTqAPIfbbd69dunIYC6KDJ4/evKtb8d1VuVIsQXV91bGTh49sQ7QDeeq7p3Cv2HiNlT6GLC/qU4Mks16mOpBlV69cF38WO9hhxH4T7bk711acuHLm0sUteTdlQXwG/6seZNdSHUF2NgXz5EfYIGJ890B/PYo0stKRA5m3xKz5KjiqmzlzPr649lCy/Mz6Q3tvHupy5c2hcydPq2yTJl1WpUcw+cDeBvuCexe4J2HvB+/l3QueoeZbbimC6HnuIJKoY+m9BjUb6LqusttrO6ESYgicfs6aSK110gExnfToKulB6CijTqrG3mHnHRdzq+yenoDyyTD/UJonQAHBKrAppxIUykTbTHxQQpQo/OwulzB0qCHw9kFsHimnpGslIaGTp7EDD2LRxXfkqyenhoJrqKeEElMsu6LWBGfHlnqU6ykU5WwOSYImtDPPgQYDB7zSoLxnqxJvy87EFb/8cv+geOj5jTDhxrrnv+ISsnGsNF3yck1N3SQITh/lBBWroazSs9S9MMzQzw4l9Qy6qa50SUtFF2VUTEcdOizSk4qLVKE0a2xpHS/fEVBTlyJTzkBQl71MOgZFrevIg6Q1iFpTLxRNVcR03U6ga+Uj6TegHs0VL7zAMc5Sl9YBByQv2yyWzTc9XfYgzAi91yo8I/Tq28XQ5GlDPwHl9rP4hJKV1noaHbMhw86MVFILD+LJIJEISnQgY+ftcTKwmn02OiPBsdbfsDAcyFGCJbUNJXyuRHGocEUjrOKVI063IMUqDq6giwni9CvIkjUQtOleBdlIz6z11mSC0Mwp5ZqJU7L/oH5fPmi+lo6qddyafcpVYl4JSois/RwGh52QMv7sMeckK/paUflttd+Wmva3tkkp1bA0tKDU59xRDwaL67sCvvXhssXWGVWvCVsb3oHY5tFtpy8n2WS8oK6xTDMDr5o6cDUjfFSTzL4V7LIh/g8hWwmLCLzJC5KXdnjmMyoeyzHn/drNy654oZ0ABz10BT1WdNrX/w5qIeJX587r2GU3qChiNd5U1tsdA7J375GsrVdUDat4W3PDoozWgxfWJ/XgnYdS3egRv9VP/KondtM1GytK0e6/ByBotrO6nqTsMMUTHPrAASqcPK4wzrMRsBACJfrBzlEYcxF+XASP/G2q/03841TcAjhCseCFgBIsIEFUIpaDyYl9AcuQUCT4kxmR6VYXHN6wdKg/jWmNhD9M0nagRpaCHGZii9HSzGaUQootRIbAqZ+f0KY4Hb6rWEDE4rWg5sSC7ORSe5kPScS0RBmCxYE3bN7fElLFDOpJMlmE41ie+EUB2oohTATNGS+IqyWukXJxBGSe0CTHIg6PjgtEH8PQ0jyC1GiGQ3lUS5b4uT867Y3oK10gQXNIMsrMJfRo4IxcArb3DcWGFJsR8EQZQLhl8kCgispUNHmc4eHxk5V5oS2b6DqF+MRRPdPQQAx5JuCZ6n8Ga6FUKvMeTeZslKmk1BFHJa7gHVIsvv+MZBEBh7PEXOuYs7wT75wpyWomRJpBEgwR98S3JY2yb0FBDKU+9x96jtONlwTntPDWuy/O03iEIknpaiVPsvlKZwcl50HuMkSqLTSfI2yV91AIOHNhTaENqspdMPRF86ULZ3R85MPMhSZ6JpA253xoSs1YRIVUlFRgOslA0lm24aBLcDj7DKAqej6XnARWKgXqV0KalYIsTG85gd6e5GhSbXZyOKtLV1dkczdCBdVUPzWVNWWmTBXKFKkSVAxxsGW2GS5ukD69ilP0daejWbVUWL0WO7mo1ZYIxlLsDCtdwbK4bZ0JrfBBkFKwQie3FtZSFfOcYlo3KvbdFSxKmpj/bDS6zm1xy1yCSiuC1FqPHyXFlYZ9KKq8ww9DDmSxrzwpXp92KchGqDYC4UpxTIuzioIjL3p5FWWe0hTQBjUx+2FpV1+JoqQSUqEqmRvJXCZEXVlNQrRpCT0a45jefq9kJ+MTQh+bVK0itzpC2qdtQ7dCK71UpjEtSJY42EaiVNdU4Q1LwIK71YHKta7lbetXzseex4quIPHg4M9aEjT3xpEfdFXr6fjGVKRV1T8WKtK+7DXhg6x3KAQucJAkiq5PGjWdQ0GveQ0ywNxiRiCAdXCEMuw0uGIucNDh6Xnt1WLamJN0u91sgwL72a/UA58rDmr8FBTjHpfww7Xh7GMs/wPQpPyUs1xlEI815q8fw5HGparRlRg84RR/JZp1kouG6Sakgx0JPhcG8se+J2TbbNm2skySYvC2K5IRuc5m7tSP4Yu5KgPyynpi81RSgtLM2Qm9vzFnbYt6JIHo1rl/LpUI/ewvfyBnKna2mp5KclgjJtq/ENIxYTcD6UhLOotdBqCHCU0yUk+LUGRN9HZgFR/CfnqBUlYpruHISJnNZigogavxhlTV1RVvKsn8Ucyiq2tv9jnNB6n0T8Yp7ON4uDJPyQxjQz3d6UL52tVFUG/T8qCFhaXF1h5uModtFafQSlFeaoy3e9e/Z5sKSt4y6luLWq+CLOsph4rHsGRlkP8fM7vegdyHrPdsGwrB7NbLOlSLBH7wb4k4gGnh16ptXSp/SzfgAh/48ShutGyPkNcaz9OekxNvj09XKIST98jVbLL+QPIzWL2yyxDGba3BUuZ5Sm7vol1tg4/qvwZxuYKWjGutOVvmQb/c0AslZggNd2t7WTJnMRarkP+8qCUqrJR/2u1lYt0yL3vy5CjHba9jUeoG4bXJeE4hWg92QMlr+928BxGD1Pxy8/HhYmjtLKZ3Pe9hWTho3h53kx2Mcro2vK4TVcnDh5N3bweHF1FOddAU/r9aS7pQKN92RgPxtHuB+leU6UrABx4cc6ccjO7nNAz/MMKwve5ivMP4C9meE/HUBotUWP/618cb6cV3+ejVRG+gaqUzgCYI71uCGKOt2uJbWmDo8W78rbnc8EhivlXtpuJrST/zY9n8iPV2S3XLR0uuB9dn5+6v8Dd//IX+lvlfHEQKI3Ik2n+9d3k5IKq/lCqJ+0u87Jiiljg9I+s/ORm4o3iR3ugN5QMjUynAfDrA+6O5r/gPUjMpmGk3g5jA+tCg6AIj+BuIgAAAIfkEBQoA4AAsAAAAANwAqwAACP8A2wmcR7CgwYLgEipcaK+hvXv3wEVUmC9fwor5IGp0+PDhPYsLFfJL6K/kv5Mk++3L2I5gy4Ie56U7R26cTZsLx4HTmTOkQp4hxQkV6rPoQnHghiI1yrRpU3JOi56bKrBqVZdVfQoEd3AeOI4aE2qE2HBe2a7zIPoEqbCkP3D/FpbktxIixrv32s0kxxcq0KiAlS4FnFDwYMKIF0L1CXWxU6uQs4aMjPagvYQc7VXuejmkXZJu34Z0y680v3ymS+fTPHMq35t/EwdNepiwYdm4jS7m2/QcuMgC3QkP6Q6c8OO/IW9eXplpxH3gQov2GZpfP+kjJ7am+XrnzpvenRL/pd209lHBudOHbOzYp2/jx+MPT5iuvvz77qz+3r/wJXPCpYXmlHQlaVVffdzhBFtRsc1WHlPoqYdbewnx5hR+8x2o4YbrrCMfYvK8RJhXFJnmloQZzWNVfd0t+OBh5p2nEIzmLRWjUQ1KSCFxwnnY4Tr01YfOkEQSuWE6QEoYFUEPVWRigeqtpFlVe+nk4ouFiWfjbRAadiNOiFmo244JCQfPOgeCI+RUbLbJ5pE+zZceZJh9lM8+pV0HZW6qZTRlleDJdiNt43lZ1FDnDQqmkgqRmdCP6ShEpJuUUorOoxgWF9VWRjFp551PMjUSYKNKpFdNgWqZ6I1bRoiYoouC/5mjU2KGFKma6QxJqTm89uqrm/R1CE+mc3r6aWqlNpVsdNN51g5N4fXkk1K2eTleUNZmieNfsspmIYUHTsomr+SU09e55ZLTa0LoIPnjOsPixxSnyVllll0V4ZlaUcuO1mxIMjm66rWHDszljDPamJSEs64HWLht8lrOxBRXbPHE7Nb37rvEJtTOfsDBpBFG+pqW278J7WPPs04tOCjChVlL7cIxU0swU6km1LBitRYlbq8XB30xOOYUeSDHGH68FXD+NTQyRsiWuiej28L2MrYyb7nwzDXTjDOOVKMzlcRCl02xQuZM1W597AibaTuaegxy0x7ZZWfJT4pmclMoh//0XkiwLXpUwjUXalSrSCGaOKJNCa7zzoSNa3bgN529UNrnEKlO2x4mnZVyIo/1Kaj7npiQafukXlTffvt0ZVSGej1t14xz3Tjk6Z1D9sWU9/7XxGlrznnn8oXINEx1jw5S1FP3g7rqPvEjWlxFzeR6eTRm+2rWUeUsLWHt6S60770vRHHw7f4YnzzGD4QWWPhiFFLe/D4P3fwKUb/QPTKBAy3siIudkm52uxw5DjHis1jvvOS486nNXcXjDJOSFz/5+URPUwNN1IwiPaPsg396+d/sdLY1mVFthAX7ToPAgzu/maNi5GNggyj2wA7Fxz9mcYjonnYXfmGwb9XZl1H/WNcvFaYqcCY8oYwg9LgVpkdsL6TYAq3VwIlNRWPxEog8kLdD5Vkweszak/7CWBLnleZ+1JleUVTUmr6YKyHlMOI4tLeQcNjRjrazDcwGp8LrTUhsuotiOayWNXHExoprO5Nw2sE+5FHwLiTDW2lORyDqjRE0bzEZWxbSwYRcUiIr05Br/OdGnNDxjuEw5DjQNcf0vOyATYzWU3IFSEHaJGupNGQcFVKO4CHJHVls5ATrBsk7rUSSqfnhSZaJErm4xYwr8Ym+pnPJukxJL5FCEF8GqZNs3dGQ5DhHOiJzjlYmhnF8/M7XEsMOdUzKHOWa2C1lZpOzYa5dNwSdDnmY/6/URS01oWEmM9M4F7pUJCSguo4lOTmSitxDM8nRJjfniB5x5HKV4mxJRBxqj3SQ42opdNDjlIirXI0NhvMUCmzO5z9xpkM+oMthFyOJzDxJR6DNJKgZD3qRiwSomSdBWTS/oqIQomqeCcGjUMgxzntNBCN5KSdJQSohIQEynlKknLnUFaSXro9OExQdJFNX0x+aBKc5daY/+nRQO4EDTxhcJkmMkiJsvtBlQ7HJOdxxr4Xg5VktDKlISaoQWgIykBZDF+beY5/8yMMd7ONKQrjIz37WVHoBRatc/TWXlWREIcfCrD/+0Syh1rVKCVMlUz9WlL+Wk6qDySNhmdIhq//qKpCLfVN9FgJZ9m1RIZZJXjGNednMahYlYyTNaTIykYjcLUAnEg3KTsO/uMmxHOIkUWuhCliqjtC7s60txNw0pDQtBCFe2YzTKmjZ4rrluDh1pvMcOhGxfAqupmMdY7Bqrr1qd7sO7a56CHhC3BUHSEfSUOc6NRmDwI+9/fynceG7WQ3WRS1ikQg48mUy/YKWjZR66X8BzJLXzpZRgVXIfGzoDuJZFzAO3mdliUs60Y6WwsiVi2rI8hWFXOYzeEpIP+QiTRBuaCAPaQokBXxiJXkPMPFxMWHkoZAtDlPGEOYwdCeMVrg4k7oP7QxmknwRixSxtUUdCGidsmQTN5n/alROSJzfrGLIgsPKjnxkMUt2Uxwnd74PJZFD1oKaPM0VjH4SM2HuhJF2mAO8dJblebvyWznHOb0k7S2eh9nFu5VMmRT2sgaZ2xBQcuQr+NLXdRBjkU0yhawracdHI42b2GyGKQgBWG6G5Vt50KMe86jHg8cS4X6YFceiJgl1S52ZfWpZT4RJnas9SNZ8yBrS4AiHQrStxCf/Z7IjJghhkhSSd4ADHvCIR6/pEWxhOwQfDYF3qvn8XmSPcdmXabaMSQdtp5wRjU2BdV5mjRhUcpukr2MOiXJNGHj4hNwLQbe6ffvreri72fi4hz70QVab1tvPIvlgqXOo71R7PH/1/6NLVGD9wWsTRtt3pHOqFI7pg8wZMezIec7BYW6ex+Pn8aCHryt+cY5kfOMchyuoka3s1VgmuE0inelWt9YzBlxfqRu4dw9O60DRXNw2j2xT1qHzdm4OHOzwCdB/PnSiW9zi9sCH3DWedOvE1c8oWWuK0qtejxjTOqy7N/SKUrKsu2OXTrFjHbmeG9nK8ethT4w6Jk/5tBflHfEAB9DpwXm3w13uR6+7sT/OdOfxD+y9buQW422XffTbk/UD+EJYnvV2IN4oig9JzCWkOILBBvIESb1vE+LwkJid8sgHzM87z3y4x33udFc66buc7NNohn2ZgmwOj+56MYqK2rBeTf86UkxndDYR+MJHTlGOj/z2Tx7tPsH85plf8efPfeP+HP1Zj5vsDa/sOBvzI7y2ek3SfSHxSdAkTdW2Gu4gVYyXbUmFSrpHNY5nE8A3D6mnfkbhfhx4dkWxdvNHdKAXev4EeDemWV6GEiqxMuI1JOBgNMJyZ6jGcUOGcnERVGVkdQrBchUxD+dwe9u2bQY3gQPkKjmBfhkYH8UXEsiHDh1YefEHgstHdPEmd0iXf9NHfXGRD/PgDghCKf7jhOoQKek2g0yBg/5gbJN0P7RnbTUhhLo3hETIewczaV8nfL5lJkVBeUXSh2Koc5cnhZz3du92dH93d/xHEfbghePiK73/kjnt0jZLKGQ+wUw5OElv1YaHl1TZxm0Gt3tKpDVGCG7MgYfpN4kKMXl+6IeTB4gfCIL053wkiF/7R32nkxcetU1Bgz7pAw9bhA/60C+WeImpEX73MH6Ll3udCIonJIox4xM0Z4pJuIequIqaow5oZ3lGAYvNJ2z3J3pZmFbgcBoBo0CV00uQ6C6+WA/4YIALMYxpaEb/lnU++BcSOFXnhE7jIHwGIY2m+GI5x4d+qDZDsjk7xxRSGHSd93kQoQ8JpScoKBcfNBMotVLoiA5l54sP4XqVuEzPJI/VlhfmwInL+IC8l05dQkI2wY++hYH+2Gt6qBABWY1F807BY5Da/xiICbmQ3sh9tHiCAwUXcaF3MvGD4zBRFlk06vAu8EAP7ViD7wiPavhv4geE99h45CFAstMy/uiS/shb6LYQM+lOReKIf3iQRvEOaqmWIDh07sZ9HleLNzg/XJgOd0U+2LWUZ7IO7yAP9cBxRuGRZQRN1iRVdUSSgjIzhURgDPKSjjlnN5cQY9mHCcQrTuiKTrGWazl/b6lxPwmUFSYSdUkTeClOnSMs9XAPHFkUpDWYhJkiI7l7V4kbCrOYhgQY+4iHd4ZnjxmZkml2RAI0wKOUmNkU75B2B8mZrEeDxxZfnMSFRoWUR4ld6OAh8nAmvviUTmFsIMlctmdRn0iHi/9TSJSjSkABFC8ZfL25fjM5JMIJPE6YjYSRkwqBeezDkKmzdAJ1QXXFiG7EFy7VOWciD/YQjFDZf6fzPH6yibPpSrbZROSTM+nplaZIob6ZjdXonr3US2LITk7ha8Lmmfonl0H5nA8lEAnWWC25kVAZmgkqbSnyNyXZeLZ5GBF6Sz4xoTqaej7RnujgKxxKebnhgiGReXXCnOEIVAvhPNaUZu5DWXdyoLDHUDAqkjQTcyapJYUEODehUreUUiHRleopjQUhfD3aTsH5o5aZfIlxKU7xEBxnd0nqnKfjWZ1GbMa0aikYPWfkUO7QHjDXoFhjQrXJQl26pQvRm6lXpi//qXliCQ4ZapliiI3wJ5lN4YeQSp9wOk0EApoRWXXDNVb5944pZ6eHlyPMmFqGEkA3SjDml6iOyai8uai9xhSReo3vhxirSKnAVYBb1mdMR4z/hCxSWhTQ5FDpAISHOagVRSgzE0OOVxSP2Y+zumlDN3zUyIrtR59M0Ye5Cg7sdi/81qkgx1kCkkGAEY/L1VHl4qB1uBS+o5XbMq2MyhydxxQ+Oqnt16M+04cL8Ws6JHWdSqJdpj+dGpifJF90wT8epazYky2GUT6H4njglA706pX2ynnYanyQ2oGQahRoKSnXqBAA63eqNrCeCl/UER1tcYBn2JoqEVXtmo+1IUPl/4k4ifIT4dQO98APFytMXQFs9Lex1CikQoqvlfqC/ipnJdt6cUmueHdJpTV1LupJHnkazzKzP6FHvnejFDUoizMO6WAnpaGom3YQ9Nd5F8qEudq2vHqmInspbop5TftcI4qyUfuyaJiwVuuR1rYXt/c6i+KM5jlF6FQjSWEu6VBo1uGziroZaauxakeNCfG2/Gqp7OKmiVq3eWpWcxpqCIuGTmGJ/LCIDfsTXoujhRKvh9sy58CzhTYXu9mbkBu5kWmkPCcbZZe0lVuf6gawGWe3nkuweMeawxgVAsUPuGiUcuS1zuqlh1o7jGlI5zAPjLsv+2C2Z1sQkSt0VSYPuP+bED03nzK5fvIHvPMmp1AbtSUalYLpYX1LWlzYgOWSukhERXR0KGJrvcVoEfhitrWbtjcHvkDHc2rJu4BRnD73u95ociaIssDKdO4ruqPLTMprVNtkv19boxCyWoyWEf67Q7QbwBordKmXkGuJnNyKr2VnbvLnlw2scc82vBBcrhPcvnr7D1jbRvWrwTVKYKuUDtZbTEwxwpXRdiYcWeyTkPHgwiGbwOygmWwJojHskPxGw3gbapeUiE1hifPLwz3stQ86LeJQDrA7VilDVvrwFRY3wtq7xEx8wLkhxfLHwFUowzWGxTXMf1sMjwnbLKSLi3vhRtJ5s4s5LeUgxET/HBJrDA7wZg/AFqZvbIqzS8AgKMVPjK8HXMcKWbJxl77qC8GVxMdjJFBTV8En0Q/WhsHncr8/7KqKmxY9JBFztxDw5o2QzKOTXKvCF8eamcmXq5lr55bv9jQleLeiPKdTGr+tia7MMsH+AJ3+mcGu/Mp5JcRdJBbQN2b1YMLAtstfaWmWLIWYzMLlxslT6MnE9HemoccDi4JpBY+nDBrQvBooyh1hnFI/nBSvkQ51A1ETJHcNYcLC8XPo9g58CavgDKtMbNCYzK0eiHZS3JY8iWVa1s53qyfIDLqWhIYCQmQdSVoXHELwdFQbvM9JcSAkt5tmMizCZnHMR3EKvZ4z/52jCYlu8EDHZWe5gDjRw1zRrDdveMOdRF3UEbyfFebR6PoW/3K1RobPhXzSi5nIL6HEwITQfDmJ9TBmVQh64Ey04nzTB13OIJtzdEzRg1h0wetp/zSVxLq++5k/OKh/VHeAQUWOrOw6Ui0zvbQOwacpB90hbUOy9KAQFxd6G/eY4syjMz3OQEfHv9wUUSzMUuiWam3MJTiszDPKdCqUMCtkxfrMcn0S5ChR23Mt4sBUvQVMYz3Z42tpCbHVY+bI37vQjU3OkC3Hmelz6Mx2aV10PNRxmk2snhuRnk1aUFmsp8xMqozByso9gLNXrA0Ogq1zPafbbBcSpfZ29aDYlf9sprPb0DlNx7lLGGyZkOzjdjJmxbQ33Bh91EntkaE9GnYtvzKRi89tLd8kFNjlLkCyuwhcx3fGeYbdGUrcqIv9kvEgcQaN0+MtxbLR22xHxc73yfHDcu793lx2XGkYEsbWxR6pMl6YwV0yFN8EDtjVNjtXditswOMrdv9K4I5Z246J00Dn4A++lhHe0OnN3W8ZvFeI4ZeVTM1JYWXk4fqVvMvbwwBkUWWslO+HjS1exL4W246MD7H91Xi44Azu4Jv82giMkDxO4RW+1kGO4cUoSRuNY0c+joBhytbmn4PEmLJzkZarHvU3gvqg5SfM5enm5znNKA39u55XiA2JdMT/Jdx0oeh2V+Qc3uGng7xevDJGpc9Zg1FEyigVZ+XAuOd8Ps44Pt6E1ZZt183cfceHvnGJTnuwhtH6qVlt7uaovEzK6xKAsphHCYmaKyFEVxTFQ8kq1ssN7uXlTTUFrNCxKItrTXdnzurCrYZ3a+SQLusgbsF1pRd36aURi0gy6qELwY74sNWyfeW/Xqs+kW69duM4DuaRhsRUaH+ig3QO6ezP7jxrDuvxGOnOVN8hDkL+qUKqJBhHGTyXc+cfi7lqB+4+0RDlDtY2DoKhPta67RQsrsBOkbYVDu9jgej0PtTcueHDqIbUXu20DkIfkyBW0ju9hDlsa/DGuXxbXdg8/3Ic4K0QDr52ES/qEHemFc/ispHsh/18G9/s7Z0nRA3fgimPZ8bvqcwS2AQOJq0g9aQubOITbEoYTWykBO5jDQ/jxJfzoc7uZV3xOJl2Yt8UMt9uGNdFHF/0Rv/xc0qMhIFT0Wzy1hPVcGSZmcMuC7Hrbmvd4uuoCRF0tuzpwB4SYO/lZ0+fPd9Ojm/dZx8VhGjo8U70rd7o927Kabg3ku7Fdo/PzYsx3d4U2/qb191zP2fYwJi9ppj6iI/j51Z8qGh82tj4Y9nCke8Uk9/VGQfkzC5tRV/Urz7XZjT3OFXr9wzVivGIYwMY2wr4gY95A86OrtcP6fdYYYn4gI5zuv9t+8cH+ROPGKdeiKBX+aoe/HAP8jCLiUN0wzpsz9iEz1hF9QmROcDi/GVf7JqnbtTPnQAhT+BAdwXhwQOXUOFBhgodPnzILiE7ihPBUcSoriJGdu88QgQJsp49kiXxnUR5T+U9fS317YMZk9/MfjX93cT5T+dOnTf7zeQXEpw/hzx75rs3r126dOfOkYMa1Zw5p+gSonOaNavQhOq8XpSY8F28ePLo1XtZc19BtmwbPmT4kWtEjuw01s2It6PHd3OFljQJDuXJlS5fxoQJtKbNnEZ3+vzJb19Iogod+9uXtJ07pk+lUq1q1aHWc1NNm5sbFlzfePTo4UMMri08dwz/bSNMGLcv14oT63rVaxcvX75k/UK0l5CkwsErWbZEnJjmYpw3Hff0V1PyZL+X+SFVyrlpaXJa0YE+B7K0uXLt3U99qO6iQ7KvY+OrfVs/7tW7/eL1KkABgQuOIrnEIsu445RLDqKUVHIpOukW66c6f677B7LtQOrnIe+QskepzsjLCquspjrHKtESmso9F1FzSL75WpPHnn3U0ucee/KLC5y3FqSLowEFLLAu4jyKB5wEgfQLn8IijG466hq7LLufuONQoQuNwgy8dpYaMTR0xiQTq/PIBKlF+EJ6xx4nYepnH33A0Qef245ksreJhuQzwCINPDJJQZmci7DnoJNQ/zHGtrxOQ5g47HAoRh/zEkymLmXKrj7REXBMQsGh5zC1JmvpnjvznE/PPlcl8E/i6Cvr05CcPBRRxBRdFENHsUxISkkvy0cpSzFNZ5261jnIo9+GvOohTmWM5544H02opdzg4UtWkFgd8k8jX1UyQXlApSehcj819FAJ98HVwiq14xUcX6mkdLNLEzqHqXWQ3Xedd2w7clkBHRpTo3jQwpFOw3IDd0HVYuSW2wKPLC5BsgbSljla1Y1SygrpxQ5eh9jlZzFJrePJn3zsJRacddgaiCy+JMLIN01XZScee/SxqSY6QcITyLsiJtrP4Ciu2GJ5ynKNUHwSehDKjkumEP9kR0cGqmRwPp40w33C6/dlheapp+x6zvVrU3Xa5JlCn+UE51GY1pG1aLuN1itg4ixW2jW0gUzJsMNuxZVr66rT7iGZtObaMX5CnGeggeZhU8+Q5BswZ3zaplYhON3W9u67J+aIYr4vJvesepg01LBEs6bacMRF9nzCrUH+px8QSxppOYiWfufhGCEG7rW0fop75MkoDL0r0SMm/dtA+/Zb9dWbpNV1wmGf0kIr1VI+sQ5zTfk751AKiZ54gnfIchkVUkeezW80GaI55c0YnOft9jbv6eurnmvKdpzsaU86sJvO7BZTMl5FJyHk48lP8lGqkwjlXP7xDUgoEo/5gc7/ITl6Wv6cB5zM4Y0i0Ovf0f7HtABer1BOEtz2gEIyt9UQfAmR0NYg+JjtuEQwPzxOX9jXPnjUgyX0q99D7oGPBoHjHqHTyF1SuCxNTVGFe+ubQPy2oALaimRZ+6IN3YalHFataxmaVqmeSCi5hKVGg0tiSFQSok89zGhgsWIevWW6LJrlb3OBkAET8zoxyq12MYlb7FBWPpiUCiJmA4cLH5IkhRgPiT7z3JyspURZWa59egRlkZDGt4H80S+1Gpx0OlbD7UyGOzn8XOMecyU5gTCE4LCH2XLpkHKdzj4exKEtuXLL49RlPngMZTKHs8KL0cOPAlxQrWIyrXV9sZWI/zwkIqfJmJTRUpjEjOQuQcVLAXaQeZlUCTiFEjbeKNOdKcTi6coyri1GM4bVxKcDcejAbX6sm5JpSQVxOZJIJmSAkTyb6k5yvDj+DIR+eRQ7IRIWmlF0Lw6h2GreCU8kyfNifhwnkO6ZT5JmU26xrNBjstPIJbpJKNfTpTmBqZBNziWWEo3IRDGIUaT1VJkBA9RYZCZPkBJqpCTFp0n3GUsLxYmCTeSK2WTa0GrNRWqMCRvd8tdTrnbVp0FVFjOJOi5CSVNCXkSMD8OHTZl0LzsAbalDJFnJssHwkpF6SE1/9kFbmRGn2sJTYL06WMIK1aPiahqTjhqTVApOKLGJG/9KHRXQ5EByruaqx1SFkiP70RSRbrtJQrQqQnB9RC6FRW1PD6s0WaGykdARnGPzCh3FMdUncA3h6hJaT4NOFa+fmhO1fitCoGULIqlFLh9X2xpT+iW2z4Xu/Wi6sEOacaV1IidCd5tZhlJVpNDBZEgOkhvizsViXl0uV5drscQaNbrvtZ9sI2vd6+Jjri100yUfK5Q1TjduFeLKbcrrF5l1db0HXm17mYTK9/Z3tjmyVnDvijg5qfMhMh0wnbhjE6EgxMMZJjCCRTxi3ir2vdQFSWyXSl8cMfG+kdzcOUGspco4JLwzlhXfFKJjWI24mQpecK0CieL4OhaOi4JMhZn/KNeF6lchw7XxgqAckinj2Mo95lsAtdzcIOeIJdVSa5HVemTZXalOJyEJd2MJkSoLRWsPqTFIOndlOoNEckt75pahSdw1BtKqKiZzUxs5mCbf+MmyMvRQ3KywOjeaK/XUM5fztxJOMnhhgZ7sElEiqjYjurz6cXSoyVkuSV/5idCtFkortJhaahrDD+n0XJI4vkMfR8A+ErWogRzqIUPYh4gq5HPhpEPvHsdns5ZVX0BdXrLm+lNQnTGlFeblX3O6hpkJJGSLDdE4ji9S8ZrLfg6ypN8JRCF3xpi5wJHnUjubzoR2DoQ+qGrt2HJwtQX3cZAI67fl+yUgETc84jHe/3U3O90FR3f6du1uRxP6QQ7W8F3N3GRsJs9zWzP2TOW17apCBNQeBjm60y3yZj+k3Qy/cgUd7qS80vu1osr3xWWuOA/eGE4xD7BtyEtwhJOc5CgHOkhWjr7pWhtefe00ooIp3W0+8JynrjiQbo0bBfnc6iVn+AAP6uyhC3TaRk9jDi3OV72GT8Yf7G+1F3RrHwlcXFe3eiVPHnQQdz2EvRYfq/XJlTCPLEtyJPsmpQvwjx8E7oc/VwDp3mi7392ssaNm1EMiXU3GpoFr5c4th64S8QZc4Ie/euKrt/h3Nx5qHJO45Mc+Z8+ua7+sf0jZ3ER0uHh+nqAneaRJP2OVd//dIWa99sz5rknKp3KzfQcJSZasENnbyfPwwL3PIz16KzfId8i5fv56P/Tfay/4r6wdXx0aYSfKt7MLKolcuft86Edf5NMvsQihChj0a18wdoda+aE0RlficPJqXCLOS4hTKzuosTAmKSd9YD/QO7eRg7+F0y6zkUAJZBDAsMALxKWQgDbW8T1iwrub46eYq5Mzu7+neSIBpK7BIy55GAkFDDgfgbuHkBy5g7+QmEAJvMAc1EEMHLDksEBCA6L7MyvX2yxXGwyoOTEBzDAWDCFxg8Grk0GMkZwaFIkblL0dxEId7MEL5D4n+kDImjaQMELNWyjB8zLm4KIgNKjrkYf/8WLBhfi4GHQIq5u+KrTC3snCPEw/4tLBlVOIXkslRFLBagkh2iO0XzPALqxABxGKgdupttMPOWzA3NO9R7pDPNTDHMQlC5S/HGQiIBSMJwlEailAr9OYQxzEwTAJr8ul7Ls/86o9/bg9n5tD6avE2LvETOxDJuLE/MnCIxzAISTFYXIQVCxATNxD5ttAYtq6DhOwz4PCSXw/UtMyO7RCXfRENHNFbcnDI4QhqVE9h3gaUFw5InuIbVSIBjnA9InFhphFWpTG0KM+XLxDbORCbdxAWelGgRoyxEgjoRjHgHS4ohvEc2Q+FzJFZrysdpRFSey5O0udLXuperTHVeTF/3wklEzkR3BkoPspyEQEQmMsxdlzCKgiOmYsqM6zvY/6OWnsuYTQomqcyGusyNm7yE7Uw41Eq0ZiNKEzvfwbRI8swFPMwCbSOpVcybhzyRmEyZiEwIO8RGTcR170RWysINSLDk0CSEX8IdoTjMM4jl58JKSERHGbRYQLCYhcN4h4yjWkwKi0R320SqLbSUF8IXIcR5AkDCTCObnKJUiCystiP9sgN6E4uLXMmKhUzCZaDh7MyLm8yrqspaEUx0ScFZRIjvlJq7mwwoM0KIZkPwWxM7Q8t4LTlgl0S8XUQHT0i4o8QnBMq4/UGJC0Fs3bwzKMLYFKs+upHsDULsIbr//BXJCDm8G2XJDOJCgc28WL/MHX3ElzPEd1HAzKzMAS9MMIlEj1W8iyHEz+kJVxKar8AUyY2k6cbE7mBIzm0B5A40y99MrLRLPlMxfdu0OkfD5CwbqmdI38/BTU/EwQ88F7HDrlCxzim8xLeylxRJ91tEQKPA7rGU/gdEIgGbnRNM7j9M3WrM76y8bGK1CFOVDZFDrrFChVtMSUbEYLapq3XMjuxA2e27GHnIu5qz7WTL4d9NB0iTAVAxyBHFF1uq8LPQsI/c25Yj9ba0r+3L10ZBIczdEh+7qakk1xGsj4LESQSDxySdFd0zN189IjDbdxO8zfWVL0c1K7E0Xi00r/iBum7XskU2RLLnPQcWqaeZzPc7lPvwjOMi2vqew6UQQz6docYgxJOJUqubKgO7ylxKJGk7tQJoFRPjVIIMnJzeOY6RpH6hwJgYRT9SO6hRQgRa2g+JPUUv0LP4W3QPRIleNM33sp9NnOUL1BYDTVWuUKjVy55wDDEkTDKgRFv9jUTr3TxJLAX1WSY7UgW6U7XczVI6q4OXnPR/JBVs2/VxVWGqTHwZgrSkoIbiUXZQ06ZnU4CIGToKiqk1xHBmVLhIpWGmRU7TybHfNWbk2SRwVX5cRVeHPWkbmfdmXEXgXWzAJVdWuv0dstWIzRe3U2wJDK89RRcIMbXmUdIJnTe2+12IIltZBS2KArzwpMs19sjiN6s0wSNf/8G2rEWDvlCkoSzY0lro7dxFb00+dIJIiI2P8EsSFNqLJRWcXLrgURlJZ1WfGcC96pVMJAFHNVCIByGm2pU9cAoJMlVXuV16FNTOYr2o/1U1uRM+xKw4yBWouZT3ctrwQJCAAh+QQFCgDgACwAAAAA3ACrAAAI/wDTCRyY7pzBg+fMmSvHsKHDh+YOoiOYbt26ihYvVnTHsSPHdiDbzbtH8l6+k/v4qVypEhy4kzBhply5L5+9dORc6hw3DlxPnUDBiRMXrqjRo0HBhUtqVOnRpk+dPi2a1OXQq1iHVuXJlefOn0nJiaVYEKHBhQ/TplVocGK6iRYxrvPoLmQ7cPPy6rV372XMmSzB0XR5surKfO3OAe3qtao4qVSbMq0aeepUl5apOs7KOajXrj5BV9WpTh2602UPKlTLkPG4tW0FZpz7cTTfvkHzEc4HmB/QfoFHCz58NylX4USRjl5KmXnmqJChK3UqlHPW0cddgw2as7Q6gegQov91qF27w4hwaXMMertkzPeFXbYczZIf/Jb9gOeblw4cuew+WaXTUMotx9xyOj0H1XMJNmXddY8Z11N5YeU00WnijddaV+KUx1VDEWEEz3pJtUcSfLzto2JKwgHFUk3vtbTSPXedI1aAm0lHWYvURXeZjwUidVV1DxrnmXZVnYbhWWlxeJWHrzFkDlwjegRORyWeeN9KVf3j5T86sYRiS/6o1FdBN+ZYFFE8Hticcz8CpaBlVj14nXBQbgcOeEom9JCTWZnH0DkTJZWRbBnBA49O89hjIkpc+uPSl14GdRiKKflTpm572vgfjkTeGZRzTMGpYKmnQmdnZy41NiFojFX/9RY4B5HH1YNdgUjoaBqRJVdVjvIFKT+a+kNppS7ad1JJJuXjm6Y6tYNmTgMS2eKBbo46Z7ZAIpXZqlrh+VN2SFbFZEO3YjVOhyCG2N9ofKLjXWmnqcPOOu8syug8SZEp6bFgAgUjs826BG1f/BkE1JDXuhnktprJCbFlq/IIFrnlurROUuMJWg61siVFkJIkk+wdOyiz8847POokqbGUJrXsPe05a7CkL80jbas7+ZemxJJJhhl1p2qbWbdU3Rlhy7FCSVevtOpUTlIHDWSRO/q6FG94hCrktZLzorzy2PHEI09e9owGM6XQEkZSsAXLrJOn5BhUFjlTA00n0kfL/wkZZkcXiFXLRl4cWmjjeDTXoalFhBBBs2UE1Funoddn5VPWW1rKYq9cNj311GMPPri5vPaXbS8Ld7O+AWtXSAJRW92c002sHLYQ/13nY0sn1ftXF7/KFV2K9+qrXJFL7tKSqnkdkeXz2psy2fKcLTrpQWl6bLFu24O2eyzKJ1hMb+uMZp0LRiX0toDXvn7RC7fIsITjaueOPMTnn3/ys7GzPDrO85pZvqY56UmPevIQ3ehMApTT/YN7LqGZXr53kpX0Qz4qgQnNpGWjAQVuKUG7HYL+BhUfTYdwofrdYhbjmrpUD3/60x//UoaOuflJSmdxXsmiJz2VvaNs8gCdo/9O1MCAoQ5nJJmgSG7DGy4NJ4P5uIf5OtigH+FORyNMH+AKhEKtdEaFLATL62Iow4ykjF7vOle7Ami5Ap6sc58DnehOtI+gbK97SsyLlgDzxAzSCE3l+ElyGBQnFFaxMpEhHKtCVaetHI4nHmkH8V4IQ/6t44zyUhKtbsiaNWZOXmGDYzzoIUQmpuSCQPGSpi4YRb3YpVF7lJGY7MFBvHmQfeD4mEHEoidD+nJhooLQ/I4ESTLSBR6zkQvKTANK0yzPa51sl8miN70fmk2IpNNHE8GBM3AcMYJ5ed0StbTNJ56EltNaWN/IkQ6RlISDYPylIa2zuyLRL3HG9AgyD2X/RnYIZHPeAQfXVhPNciQEbDw8INmweQ99nLIfbasUtGyis9d9L5YuAY6yaOmO880OOuxsh4mSmI5eytOXiwRXhB7TGHCsY0SKQiZHkBnTfVrSIpxbpjoEiiGCdrIt06RmNUd5PZPMBKJJQWJFX4k2U+JHo/aRIgdbta7BhXSkzCqp3k6qSJWCyzMvnWlMb0rWS+YUHN5Zkk/TQqiSuZGHKiPqApsI0W4GRariFEmjnOqb/Gj0nNLqz3+OUzd3MiuKMysp/Lg6Gq/SM1w7eelYy0pZzm0MHMvs6Vod0la3NpOZYItrAud4j1NCECg2yev9mkpHMuXnMFKllezO0c6R/xDMPVF0xzhoN0/hgDAcjn1s/Fx603uhbIaWjRxmOUevhGiIs53dIb0AqEN7mS2BwsrUaXVCo7rkr3qwNGrr6lqmqHpvbrXF6mFPolveMraxwV2kofqZ03slL6fKdWlOp7vZQUW3gJiDSL3ydTa+PLSuuZkHR6x2NY4UmHRNbF1G+TEw74VkiLclGHvLMci9vVdiA4qvqAxV35ThFL/805hZmQtaaDYEqNKtnFoUIi92wONs+OCNX/mBVKDYo6MjIwhHKBg+F3GXZqvL8GHvodjFDte3EUtQUIqkUh6V+MQmTrGKS9xiaC6kjUsi2XPPQyh1rLa0POZxfu4a2P+iRv9R7oAlb8CByjC5TclK1kmTnTziQ3ILxCkM7nx1Ul/KXlbF9GVHWjHEtYTAmNFithVEprQOeZhEJRptG6PK4rzHbUSPNkvKBZWFZ4JNbrfuHRyUf/umKYsY0RvzH2bnS9agRG6/0+0pQjwb6YJOKR3usIez1EzeoCRsxvWyiDz44lD6UDiKpS4dOOxxDlQzqM9ZFJqfIybiEi8XZYbcGHLru2jnssUs/x1zOao7l5EM26/FwlmZwCGtMTsOlJUenUPrHBQYQTvD7DlHh6fCO8j+0ooetqeAXFJicB/3shYRjiUbruhyq8Ysng3gaeJqNgWKl9jxxhlw6I2TDUnpk/f/WnZD68hvnWgQ4MYW+Le8+GHpXFvVjaV4oZVn64nrPNfolgivQ0vUeuCDdEY9Krw1rSnf8CeQUAeRklSm8iJPuHUzI4lwqD1w4OL8pJop4Rax2DKd79zQ/Wt49PoUdDcjNK4M1cfH/ZqfkBtMP9LC24fWnUl7waNRDuWxTl4Ljjoui0fzkLlR5CtPbr2vkMCsDlDMjmK0Y5nL82I7uqUbth8GsagywTSxyStvfwCnL+6w0d7RYeN3qKPd+GARv53IXXCUDjc0MkdyOKNtFEI+Wx5eeIiHRPnK+9zsCQVt2xFKTc9Vr6jN6g28SX+zTdHoHIHkiUHTIbp1vL7qEs6o/0b9Yntpl/8m5LAO2X35Z/VFuaviKH5yj4/8tOa60RgvIOdWBo9rNgrpKAEY00d98YZ36XAe3AcO8mARf4dmoqYSNWFqQEEj/5EVwXctpTJCH8Zw8mdfxXVWZ1QapGEai4Z/+RdKPtR/QbRXTJQiFvRadActIdcPutFRVXMX8wBDy6YP4ScpGhWBzDKBFMh7kDcZQzN2G1h2HVhWFEcaTnh/Jih0n1VNKvh8GBZ9AggcdLdmIdd0UQQs3tMoofYbz/ZvJTGB7lCBWHGBGMiGG8gwHeiB+TV5ZzQaO3V/bQdUb9Q5VThaGCYT0reFqNSFTacs71F7VQEcA3Nb3HWAFv9YhKtmKqSShCkUh3KYdvXFIyUYhTCGgikIRGfDguTUG6KHaRdEel1YHysSH4ZBaoxIUlVFIG6IKo8HQpRYT5ZodkEha3aYSZwYVHvIh6DYVC0YYfVRH3QWcqpULMf4gr/xWoaIWF/oKO2QflfBIJGYO7e4O7nYgSjEPBlSZkJlYvkSDypIjOTkgs0oI6THNgUIjfD2jD+YdeVzgNrYHEaDSH+WhEPRjZlIhxVHOHkojuM4PTUFXqzVLAG4jr7BY8p4RDNYd9vFTXRWhsziPXvmZHBiIJP4Xt4yFf7YcByIVjvVMuC4awlVX/ynKAgpigqpjgzZju5IiF1oMC6yiBv/VG24JGW9BzTwxX7udxQh6W1oVXElGRRHWZKc2FZwlVNjA2cI6XHpqCIMqRLxBjA0WZM3YzDPVhK0pJPu1T470jJfl40KMpSZyENJMS8k6RJ5+Fmb45QreWPgpUA1IxMuyEdWWSxYmZV2Z1em54o/pntd534+OU/xlG18Ew5oeVYlGVBAkVDL85ZNuX9PSZf0MA+hc4UoEnoNuZfaM5N+2TYQVCZAqGBqKIvQEWX7iBwGRzi2w5iNGYJtiZRqaUNBB5dxWU0reV2aGSx32Zkp8kQPuYyjKYNM92wYmZrXeDut6WoKNyp+ozdzMpshGD22KYIChVYCtXzJZ5m9GZXA/wmAnbkiTySTxrlKMfiXDaQfUoQT6dKcz+majLdtDrOTsmmdkhmZmQeZy9dMJNlD/nOZdBmKwBmc5XmefAmR6rme3KNp8tFKJRefZdlFr1lFYxebmWGdRnmbI0gvzOQSnSZ0kOkS9hIULKMovrkXSSacKDEc6PmOprh0pecy/bAPf6R3gKJCFdp4i2k7ShGSu5l89JIkJcNT4PhWJgoULAMU17WC6LheCYppC/pAxQJVFkSlLmMpiDGhOxpoiQmb+qihceKPRJp8o0FdNQQOI9oW2OlLQURKmZlk6fgeKiIYMlmA60h3yWiTdNalNpJ9t7IugeaRZHqPuXimmcdrQP9BMm6Zm5+VFLwIDikKFJSUmS4ppYCIH1mJpc14itwkgzTIHzihozwxP1/Xk7R4qDtpiYoKWkO3pv+zpt7Jlrt4XCszGtWDqZlapzCZjIToqcd4ioA5qjZoqlXlW1vUMqx6jxzYgWcaq2KWFLSam3eonXSIL/xXFZREjI9ip3x0QcEKgStSH4NIkZJiHwljDqY6OIm0VfnYrBNzq/O3YteZUNJKMgpjLpB6rfQ6NisZFN36m1f4kgvpjKFqpeXVihkFofyQMINFhCF0SPaZPvKqqt+mdq86dPnXaPy6edxZFSbmQ7lqqS80QcCpqSmShRQZqhDKig1kV3R2bLE4r0H/+UEXO58au7ElM0Aah39UA6khK7K8qROg2JIsOlJ/QZUrMZGC4W9MyyP5UBCBVJixGa85y0VUg3mKymsde5IHgZv/yVNreVY6oaJHO0EJqanlSqUvgzOXMiymk0qCkRgVyKo/Kq8mtDDjcA7tcA/kxrNu5TjLN5CGq0mnUbbToxP50n9PGoooW7AK2bZu67IQaKfzkRRg4g9MZg6nmrU5i4RSthMhxUCB27WedbiGO5BuNbR7yLj8VzaPmxehY5fferAWhJyX+xeZa0cusQ95ty6gm7VMcw7zMIanG60A5Far27z/aTL8OWsuAbCO+7jWU7t0urTm+qC7y7utI7MZ/3V9dzu8eHuEftO36cAvYbIPO5t8HOu88CsR/xWZSUG9sktJkIu9BQuI0jeDZei9LddAgMph5Hu15rsVxjtnGHQSFOe+SnJvYBu/q+tZ20mvJFu98vCkvLqZSaZNK/uC/huNwxLALpKjwlvAuKSq4sBOwtY6QGgSgMu1a9cnEBzBEvyWsXqtclmOsguKpKS/+/vBppiK/7uQa9ayv7EftXTCKIyNvjMO7MRAfoFk3sMXGatT+KqvUriUN9y8lZO4AdpDT9nDRytHtot0HrwiSteFiggfD/UySYWjFQWfTNzEWmsVffu3nMIj9pC8m6iv0vq1qWtubeVch8t84EnGGv8MxAukTfqgTTXBtKg4j5greH7qIkosSRP6iE08ZVe1x6MhQXmBazyUr6Ycq4Rbw+fGum7Em9bUw7sqR+PZUI8MyQcrkatUxEbcYzLrD6nVZoO1o/JZvp7ht1IcQVoHDvqgzDRTDy/EYqU8dKjrVlCIuCWzys/byp3jOWQcp7WrQEhHyw4VgFRJem0MrmqGxJMiH1IlEJ4CJY1ktWHZIbQ1EkdGxUCBD/YQOi7hDsyFxTOsm0QKSgJ9f0d5yjm8mwD7ytf1wxy8QOLswaEnkX6lIuBaZBAaviARO3liUhUbJ+MgEEsUQTrhKDqhz46Sg/KAF/IADzLcn68a09Esq43/ymsE9MD658qw7M0Pjca1XMlbWIaPTM6nhK6TsrlKzNGxWJ8t1SY8E9JWHIbeCg71kBcw1BGK8g6Xd68wLdNeTYLCEaLSSmNTaJndzNPg7NMSTc47drm1/MhqbMncgyz8gE7wKc9eF0/1cxw6UTd7wi/egz82NSLzQA/VwyuEBs2KVtBESsperYnMNNPMJ6Ak+8qxrL9HRxJvjc40YdFvDddtW3f90l13TaYWsy7jYA4ugYOCba+yttLCAdv+DNCZ9dV+HNN2KIIyDZc7fL9oDc4l8dn8S64w8tm1HNqJmNTYV8fNuhgfA2xX4g5js2JAsSgvRA/CUQ/XCdBnSnkF/1lx/oOtVfHV38mbvi2nmB3Om03UFKYixv3ZTGvJAvxHqqeaoUtb/QEPWh1rKTN50xsPCigc+szVisqhkwrZ5B2MZOPDDp3Wmi3cK7uK7w3fddS7LiPHS4zXhCQ0Ia1fBM45QaGCLULgKWngDmdICW4vYszNDd3gwaLWP03U+fDIBPPedVR4yd3OgLTUzW0O6WCUcBnG0lvdZeMShg2QKbmb4M2hv5Tk3X1GJHu/6J3eDz7h+1DLNW7cNy4cNMhR7iwWOrqG7rUUqY1W+frd72BfCmiO+iIPH27iRPlLL12ZiiZK19TgDh7cE07jGWbcv7vlAqxg7kw3OsqRWqvaqf/rWXTuP/jCkgDZoZQN5+Am5z8X6f/sQ1KO5y8ezhFt3CSR2cwC378bfmDSD39UEKsB5rKDONvhLa1CLQgNxgFqkIpC1fVAaADliR0IsMu1jQz3rCz2c3Y+SlN+xtHG559+D5we0b+RPUx2EHjDEGLxMVMjqIzRO2TeqEiqxbv2Vj4EDqB46x/aof7I603q69M7Nt3I4nduxpsebQ316Uc376BeyzguPneVetPeSS6BLq6xE3lDrdwuhQE1qYe9liWeiyWL7igKsJa44EBU7O8O78pO7xZf5ct87/1mt9ZeLq8RJeahE6odNWwUQNFloifqEgefncFotlfs8gzfIgv/PfMLjemZbsZpvewVb/E8f/FV/ruJ2Lkd7/Hj8jGqrhDU2p2sPIU6YdgiTtVh7G2TznA0f+4x3zJVP/M2H/Eu7ijzflv0vuk9//UP3iK+bLdLbSeeYfSEuzxAodojrzDN46hAIafgcJArreKW3uvflvWUODbylPUzf9aa7vWZPfYHmvgT31A6sQ8BvA/8sRBp/xR9VjdMmVY6AUCTiW6ftKb2wsMBC+xEKWuuvPD1S6lWj6Kwu9CBL/jszuDfPJ5jf3SKX/v1ziN1jSZVNTFLs26KEcYlKutR82jNNOmXmdjFp2KpPxqmz/y5OvOMBeCUqsgMfd44L/YWX/vaPzr1/57xgM7OHFS1thMhAY/wQ/uosxpUvPiUsP3yIG4ovv5Dgy+7G6jI9n/dXc/92b/9tp/ZAKFP4L59/cAd/Aeu37126c6RGzdOXDiKFS1WFJfxILhyHTtuPKhO5MiD6MyhQxlyJElw7ECCZBdT5kyXL23exInz3bt4PXfy7Bk059B4G4MeRXpUnjx6TevVsxdV6lSqVa1GxXfv3sCb/vI1PPewnMSLZSmKizjO41qP5kqKzLlyo7qD70DqA0eQ5t6hfcHtHLoz6WC/N4seHJw43lKmTqFehRzZXlatXF96nefwITmIZM2eRZuW7ehyONHRBUcXLuqD7OyCwytQ316ahf/BwYNne+ProonBIdX9+6XiwUubOn6aXHlyyY8nUx647/K+zOnMccYO8XPGtN3VkvZ4E25hfLDv4cNHe2bwvkCDuid+VDdwo/GRMqa3XP9+/k+xZpXNJn/4YSid7LLzzKLQvIsIvNFsGg8ne/SR7h576pFHPZkKy82vn36yL6n55ANJnhAXY6yxevLrr0XlsNJqK7xe6ofAhszpqMHsysnoLAa7W6vB8F76KLUIX6qHQtjwsUced2hrKSac4Hknt5826vA23HD7cKctcTuRPZtSTDExMhs7DjkX/ZMKPegEsqmffBg657qxRNtRotCCFNLBO4l8izXhwLlHOn20ssf/nXf4irKml6qs8q+XOvyy0qAsDVPMl8hUrEzj0jxuTTafo2yrm/rZ55553AmLnDuB5EwsP2fNMby13AIpHny4EkgrfFatrb3XrMQSpEq3PArTExcrbKmbyjSTMRTRTFPUx9ykLCcC3XHIHFkZLIecsMKysxxzzkX3XFrBO6mueqQ7aJ9DfY0q2PZ2AyzSg45F9tIv7TtT0404Le7MT6tds003TQWpH4PymqdOjzjLEdZzQAoLJY03rrNOdNfFNZ4J5Z2X0HsOOpk9L/viFx6klO00YE3pAYcegpUymFoWEyYVQBofJtQdHGFlC7uN3IFQpI03PsljB91aJ8mC8orx/7yUNb3ytUlbBvPlrqPNOThQbTY4qJzxC3U/qxaGcyOH/YnXnnTGyoi7iWO9eKN25HlU6ZRO4zhdHNs6SJ5d3ZYXZUIFfpRrrpPqNykTz+Zbt7Fz7onyg3d+cW30GHa7H3/gzidiHutGq6NY0wGH9cLBqRyx3Px+CZ1xOzYJ3b8OJ6h3gmaEl/G6uiS+ymMh/xpnzVMcauymlqccYf0833XG0EcHp/RzIuJOLXK8RSedddZBOicTZ0+tdtszBkdjxA7PCzbYAixsncKKJ57fwZIHW/PXbwIV36BnMOkth3ptux7c9GE6PJ0jfOuAhzvcIY95gKQeNStTllhSEpQ4sP99G6EH/AiykV6VZyjjA4f97qUlxx0PeQWb1gAZ0zyayfBMoFJbVdyEwIO8zSB0clW4ziE+8i1lHvPQDwaX0hMqvcZRG9GYA/O2jhACr3fxIxSTAGS9jaDwfl5qof68BkMboq15sCsj2nA4vanskIsKcdhBEmUdb6VDghE0IhKXYzN/feiJKgmJ+0TGMN/5zjwHmQdWxESpMIbRXy5LlsvOlDnNHacwzyMT2QKoswIyR2E+C10cwYEPeeBGgoyR4AQPtqKmxKOJxtsJTVgToXfIwx4yOohsdEkhkiFyHhS8ZXAY2UjHMfFfYAKTtJR3Nkv6BZMp0mSaNrdGA34SdHD/jKM+mHREbiozKWRzZfFkoo6YoIYd46nHrkaYy0NhCz2xgZM9VhU72+iLhbi5JzGNiazIeZOS0UtTX56JNp1Ns5OdW9jPHqZNeXJzHs+Lzyu7BKWWvE9Jd2mnDrdIKHlWbnwf/ehN7Lk1YuqTOMsDlTOd5zw1UpONpGqYwx52ngux6DgmUsxPXDPRvQAGHEm6qO8y+pQjPuYg1TvUhQ4CUhWK1Hi5GWZJTRozZo5NpSuVJifTxp//wA+bD2PSU6RpH53GhKfr+ak6g0ey84SVqHq0BzgmM7+ceHFKlWKZVGFmtjJa1SYBPQhWBXtQ5+wwlCjDR3LGltOy0kSnVxql/2XyQjL0SKUeDr3gUES51I++Rmv7EpheJZdGv74koINF7VY9CdOYHjWxYj1OUvDXWLMKhm/vBAm85MWkCz3mskUVk/2aehvh6aaFMZRhaUECWBCmdqUvdVPDQOLWNCFltmd9olo3UkiG9tYqJCxueNmjvzRqFSdNWa5znZfD5+TkPIqN7Xuu+9jsWoa7veqtb+MaV/DmZLPiBfBv7uMplDovJzRrrnoJG5VRDoW68ZXvfKVUs3RqN16/6xVNqZLIo27XbXEKcIhtglzkAjSlAEyvglXrSZtcUZuvBZV153slpFqvd7qsmpumgsSXFESmQBNxkP3SV+UGFr0JVm9/GP/c4xEylJWtjPCMexJZ3QoVx1Vra1/+O1l+dLnLQgbzwMiExpwZuGZ+VfGKX3STK45yRSaCcjxmLJjDqHOyN6bQLud1NTb37r+/K2SYBY0TZxXOoAg2cJrVzOIW5zKxfMSpnOd8kAoDj5ck0yVd+0KQH4uyRpjORz72kY9B22RLpUajctGsYJ59js9HvdASI+zYD6UVqXe2Mo4D9Mbt+tggQOMHnrGMaiwdiyiCNrNzrXWtrNykppGWtDh3Gln6GRLTu6wMnHgNLyDj+ndYfrWg8UrsAwt22S5S2KupG2k/8jQeNOPlhYNHQmxXRtNa9jZbq0ZuftvG3OfmqlxJ9cb/3vLRJ+3u0mHkN1ks0lvP8+LhpjH88H7nM0uCpqdp/w1w5chxlCa0SVgNfvDHAuXIuZXOCOEFz4fzus9XbrnLKy7kGRaahi7leGZd2+CX1HTk0V6Ua3qSTowq6YoTn5Geh6LyeldmKzJqW7jDfPG+TFlTM4TdJXHO8Q7fZEbPhvbBzfpukM+P5QNRurZlLu+89Eog7tTKRnJc9iBTal+nvokYFa5w8T435xdU5EaanUs5Yijs8hW6ztkZc7XDs9Ft1+W32+rO6WJryTcJqU3y9SFjg7bzLLw71RHDrE2V/n8aH+zffxp4m7Qt1qW0LUQzp3P6zetzMZd4O7f49sqy/17H3uUv5r1oV89yftymxqdfTg1Jg42pchlHdOpzvnqev4R+by4llRYDWxY5POnuzArbFt7jeMlm8tWbPOvl2FtuKh4nTB1fvv4Cxi/dler3r/+mxlwi5gX2zM09s60TlZegO3pzM7JBFnmALaJbvBk5P/CrHq9DOt77pN+ziYLLo7pqKqaCJePLv5xoJC1BjBIhs7P5q2YKQAFcE/YAuwRkDhPaM7zwFcrDlvGzPj3bit5jk/KQCpAoOLKhIPd7ieGDv3WYMQ7RK0nCuhKsHJpBMCNDLdULDsNzEjDJjxrEwRmEQJBDoCzUQrdSsqhQLPzgrOEqwyLsrEm7u6Eoqf8Sw7qMA6D16o+fchHBKwzsc6XFuMI32bMtpLzWM78HdCfuC6CdGRud2xCQQEP4+5D4w5/QSz4QdJy+O8QWoUNK24+u64vekjWmgIpSgToIpIroKg9sORnb673/EEPuU6LGcEWs85VE7KJFLMJ3qEXIOr4psThkocQAHEBMNCDbiCuxgqancDVf+Th3WkXnWMZPpAzLuwpC3BRMMhtqSw+0SiFa5MAuScOf4Je8i0RIdBlI4ruZASE65I+f2gi1KYz8AkJPfA5BBL/8QreeScULoUdCfEIxC6cO2ZWTYRRt5EAj/IlupL+WMZYsST6FFLBnGZjC2UckA8Y5nEjm0MT/noOvYpyMHPRDMOQZe+StfISvZgIsOfuoi7MHDYkJgQSpgnREb5xElgE90Tu9EvS3OdS5C+qcnKDHd1wK//icLbQsa9mI/UKP9dOPlVLHwGIMKhk7TFRJdmBJuwKp4cmfXEzIYjoMEzutm3gKJMks91stuQNLasQPoMSWCuOtpFQtOgy+r3QRp0CviBSzyqESIzS0DFFJlhzCzMvGLvm8YjOp5GKuofjKpVxHo5K7Q7Ggm6IkFpnHNTmo6bIWrMosTHLC3vgsq9MQvlTEkGpJD8S7rGykfyqwwsSJwxTCyzM7BGKlSDMOY7Q8UZGeoizKJ2up1ArAT8GgvNsI9fDM/1m8RdGkyTa0oSIrLqWjtJ97N6AkFZHcj7RJzLe8qRsqxJr5KzIcjt14CdoIzjPcRuIEx9J0QxNUNYGBOnlJmTdzJSpxGRapisrcmek8Kla6j5UyDgBawlx5peGKSqlEw89EQ8D8QNJ0pPLkygNLjr5Iz99ZzvOpkuYclcraoydDDrBcULniPqY4wRriUBC6oRFronV4ov8EUPgT0OE8yOKUKgSNnps7TJxoUAdlynDSw9Vay5H0u4qkyOozMu0cmMccE5Ir0f8MUOFU0acKR8HUp/KiyxSL0ZvYCj9DlVRBJAiV0AltxkRTk45DxwyVjaNcTkxKsOYrEfpoFCMtwv8UDU+YHE3kK00nLbf8YNDo4AeHoVEMOYqdmQq2PLEVo8MCWjwkccys88lCc8LRI700NdEjPcNsfEkCpUkmLabygsMEE0KQkBEq/TTGxKCe4BznUA5l81OEYSfXysj+acIaErB3+00TlQlHhVThMkjjy6vjclETnNM67Z07lSkaNbhQjU6l7CQjC4pQabC0xM2TEiDTMhGbWA9YZRSbYKq6QL5bbZnMMc1KOrnl4lGb2FRfk6lgwwsq7NJhHStXDRWbqi5QdYqKhDCSg49qbK5n7U5p3ZA/ElBFvI3PMi6txCmZQSMyQ0EoXQ5AJAhf/TFy/Sm0kcysEgrs/Kl23dP/wYqyhJMcb7W6V8VXlyjRpYJUfqWS0MKrfgnY/RuTbkWyJNJUO+20TzsZwztXdJU9d3XCxYoPip0vwjgMm2nVoIjW//xNjgXP3WgiESyursGpgWUcNbvBXu20LrNSmRVWmh25VhqsXImPoNup4hGKcqQZ+eiJjq2JItVXzQO9pHWZEWTaZ7lUiXVClkWZS+uyqA22mH0y2tykwHo3euhbwIpXxqot/OkNs6nZo+BaoQ0OMxyeNxWYPLS5t2VC1PO/BXW/KU1YhXUYqcXbmS3V03pCrJXY5ZIvxvLX4SCMn422qFzc4RMppC0uyG0WgX3SFdHJlqVbza0Rhl3AuCRW///D2iPTOb8NkXv52uOVM6CT1tbQV5eoVjbkN13tSuzM1HBNWLtNnLzlD8HSuDOrWNIFulpr1b/6DRAREXn1I9b1i5rwy5lzWzOFW+Gt3ui43oVdJwu12oINXYo9VmMN3yshEcMgnovFLg1Z35VsX7TtN11NQfSK0qLrVS+T4PslLKXs0MBVuFaarXLEifCdv9mC1cKQEsZ1X/0rMyi0pExdPN+RYC8bIZ+bWQvGzpSKsz313v9F3W8i3rKyi82jrXMajyOxDbsqYUIjIJvDRHTECdlg4RaWWg21UGE9MQCkYcTVGuL9X60hq/RNxFjq4VhaCbko4hALGKZAYgt6YP+Ha2In5qgoPsQpRmGcPTgQImAtJg7iUV+ZQIkwFpQxFp7n67+aRLAMBVcmjuAWrhAY1k3UOzkspg8sLp76sDr0jSX1qKiKGic+7mM//uMxE6C3VWFCod/MReQ2tplTzlpGjr53ExHVFVtJfhQ8ztdEdJRM1mROlkkjZuCcUOEZJWUJRpnXy00zS7Gb9Q3Zgg9JtjqequRMflXmjQmNCeOc8NgJw2X+49bUlFFf3gcX7mbpmBN7eEcapuFiXpYB/toRnDIuVo8wVg9p3mRolcVrzssyPmPdyLZC6uZgu6I5URVo+tNEJV9HToyzyhqeGJTyZWcNkYt8bQl47k55XsnFIp5U/7nnwuBmfT6IcP4lw0U0IzsvDJaxZu4p4TgMsautruVYIB6Psi0nMR7ae7Vmel6eVJNInNg9fQ607NGKX/qa6CtYRi7oAuYLO5aznipgMa5ml5hmmJDosxU3U3M+yrFpFMbpnNbpNuNoRYlQV51hlV1HnQVhW14JswKJH+5ancJkmGZeI1HqmYZmqBYyYxtHE7bnT0ayJ3WjSyskft6IOZmHdoAHI4QkqwKso7TQOiZpli5rocOXxDUrxyLrPpaJgAAAIfkEBQoA4AAsAAAAANwAqwAACP8Ax5Uzdw6cwXQI3SlcyNAdwocQIxqcSLEiuHQWDbqb6K5du3n27mWsyA8cv5MlDea7N89hOnLjxImrOHOkzJE4c+rcybPiuJ8/e1och1MgwYkPGy5cFxHduadQoU6Meg7dRYRXk25UaNGevZ0pDaJMuS+lvXntXsaUybYmOLc7w2UMJ1eoXbtAJwa9C47oyHLkjmZN525dQ6YPnVI1x5ixwcZR0UVM2NHgvMvzJuYDG3ZnvpXtYK5tOxGuTroj6/JdPTKvXtY4yT1FStnlZIRPG5fbXY4ib8AEn2pd6PEjZpAhRY7sx3li2Hzz1MZcS5FtTrqoYWvnCdS1Tr9CZw//JqzwNkKn5n7/nqhetvB1hpfKZ/gx+WbnKMGazG/wXrtzoskEnkE3bWfgdt0N+J2CO0XUEERPSZYbbxn91J5whE2E2HmSPQSfO/Jc5tU9JH52Ejj++JPTifzlY086ACbYF4EH1qjdXjZm5CBDD1H11HoUJcibe1hRlA46SCIZIZLqsLMOPAqFiFyJJ6Vo0D8ZjTUWONC9JBpQBc6VXY4GmkamUMOVd2RuBKW3m14JCgTcOUXCR1FVSjaWpDpNrvMOlPKEOGI+Var4z6EGpXiiifz5ByA5kP4UJjjYUWrdmdu5ZWZGkx64DjhKqXlOem6+aZCFu5FKUIdI3SnVqKOa/7Mnn+w4+Wc8goZEKD9WXokfP5/teuI+9vwH6Zd+iZMdaZhmWlOnNL3FLGsLgRrqUuiU6htwBEnUk1NKLokOn7Sy88478cRDz5T5lGXloViqeFKwwqoIXVqPdndTW/tOpFqzPZEGbZj8bgobce0clq1BuwUGFUYcZWSVReY8Flxjso5Lbq3n4kpPPV4x2uuhvdLbLq/+AMuSsZGOFqdM2P0LcE4CS8vpW9Lya6NCxfXs0UbgpCcbxNYyZCSSFZX6G8arzlouuh+PeE+7/ah45T/y9kclr2K5iG/LkD4Kk7Ixz7xTwTrN1K/NZ/Z8XMIGKUZ0Rx4Z9OlESU7MsHp87/+GZ960oitP1CHpQ2jVFVk90dT1mrQSWrb1ODbZlZpNM9qUjkmgzgTnWNxxmGW01c+gHsQh0hMp3XeqeTMZeLry1FMPPlO76yuKFpVYFspcfkaiV2jBGGDMMlte3bT+0lSwwasBbRHol7WT01IUSda6OhWtzltwrWtsruD02EP7yRbZS5Guu6bsHJckBk9OOaOVrV3xZ28Ol/yU2n/pgUY/b1n00qsI0OBzN9Mh6Ujdm432BoKevMlqY+aKxzzqoTuuTURRFbGPlijiu6/BD2b4E0oIeYI8iuCvLtCikfHgxpWMFNCA3WvdqMChvQbG0HV+ElTtmEMRxVEEJIw72Yn/VLIy4cVvhKkhXuVIuD8x1YV4ZmKeXYhGpondkE9JmuFv5FSOG2YxVuMyDMjuoY998FAnQAzW7jpTxBitRYlJDAdblEg/5aUQNXXMXB6NB5vTAQ6LSrJK3zIWw1FtL4zwCNHUzjiRfuzjecmpHX/60xIjHlFzrxkagCi3RJuU0IR5RCIfR/IQniAwhuRCmuoYWMhz8O2BhpnHPcyYOC5lxD5CfE4RpdMW4hmEHOlox1csk45xwJFTmMNJpYonlz0aj1ymK+VOrgjIx6SqYowJ5KiQtErWpWMd89CHBRNlEpZUBIiMW6NzVlIs4SHLOsAUpnIm0o5yHPN4n7wOJpNX/yHvYCqVVplMRTBCRXCgMpW+qVjQslkVipSKi4dcBz7KYhFgDfOH9lljWPixD9Dg5ljwI0owk2ORet4zZ/lUZieFwqAcARR1Bo0hTrpHLj7hBGMWUQ/TujUPQpUPWJk5ZxrX2I8zqix4T3kfOcDxERKNJDT31NldTqrHUUqsdXjrnkFz8keEUgynkVFoReQBIkG1q3z94Id/MoLOk6XVqI/DF2MwEpKczIMccJTqdjrpTNbUVCcwzapWAzsS13k1aY0xCFQAxw51yY52+jAIRTOSMrUGkCIgSuOWxNLRlaWlMjuxB159mVKL9JWPWJ2p3uIm0yRNU2NYzAjTFJsb7/9BDWSQfWROUuQPYhX0m5nFx+HS6pzOskREF82JOSiXTH0u8YlWjalrVevFG/IEtluVbWIjMy6O4WpKU9MJb1NmD3cUhLXABclwmVMSjvrud8nNiIvIsTwp+mulqYmuVZA2XelW17o5gaZyHQOOxXqPHfBIpA6dutvxqtW8QYuQQeABEnEW1agdXQmJGIyTu0qqiU7Eb3SvWz3CCra6PMGeTsQamXL5qayX0cxkKctby2ZLMHaTx0T5cWH8BGvDaAwQzJy7T6GAOFOAZe1/AQywhmKPHWMVUYnIVz4U1dhF6eDeQSiMD30U1R9Gda+G52kR6ExOxHossl2OHLBppZD/ukvuLx+d9KQESwmXQyTnBXnryHkohknpneWFeTiWzuYkH6HhJDN9yZoCvflsel1NnOVstnLRGVDg/YxuRzLefiAaXOsQnzzWIQ975GPQFCmJccFBZpUwtRyKBiWj18xmnsjM0aV5dGGXPDOqTMzS8MF0pmdM4xR5Wh5OSYeXIwsOWZrxywZJq3s3DOSKtMOYjKaqkWudOX0ezyZx6wmfTpk3i1hFxQfyEZ4gWGcYS03TnSnfeInlkHkgzh3q5XHVVCRt4wJZOcopJh1n3WZu25rgKNV1gGtKbnOv1kDqrgq7/yRsXJ61Iowcb8pcZA9euQgcptZ3r07ibw5PZB7L/x24mpEZ6Z40U+W3to7BM1JTdTS8Ig8Hh4D5om7D1spPf4pSpi8uXo2fJK0ZLsuX5UXyMbca5O7Atsoh3dypGmTqFqm6TmqujlnhZOew6Tlsf+6nBGf23Z/ZzyTLBy+sGbuo+t43OJCe4WoPVNHaTnjLRfhymKOZbVvnuuDBrnN0b2cx63Zx2YU+dI2unSJtJ9nbl664pqe9K+fAOxLrO/O40DHNf1/N4AtLeBPvxEeEZHfZAXVni7crlzhpu8Zn30iTdJSt5oB5dV7WeZd/Huuit+lOuq6xXd8F9U2rKdkpXlYpDT1YPZH87K3kQ5XcZyLltefAc8Z7+3q+In3HY//4834XwgslXOddMcb+ljEI2oriCna+V9B3eZPchfbV792GzyJw/IlDTu/zYTizV3W0fd1GfsP3dYe1a4ohHjihU39jWC52LgnGes7XVvXXXvFWdD3kQ8CiYfwndWwhEJASUtQxVYvmTLrHT35lfhMhfIZ3YlGhXBAYSLA1gfDXfKAzKNe3PhvIGtN2D2dxDtMBGMciZN43PwUofivnV4E3TVNRYNr1SkwjgX1yLsyXWTtoH1nCY7jDFx74XtERFS3zZqd1XyImSqA0MzWncwZheJRWbrORfgu1U+tXWxJYK+9XgYGyhSVSEfuwO9C2HRvXPsITUmTye93mcot4hnb/0YYqhj0ypWTcpFCzhXNME1Y3qIcERHGBcoHgRRGB+EhHhzhgSBGOBBpEyC+iVGQIeHVqxkyWM3j7lS3g4lroN0OMMRAEZm4Rt00+Zy7w4YmfeBxS02q6hRKMZBeKU4iJBkKfZ0IhJjMr6HsAY1hvmECwkiQVM4NBQ0NuIlau8ovb6H5YeCuBQg/rghnHeB89qIz5Z388AWagMTmaNyYEh0emFY3504R854hZBU3E1zptwn4FVhUYkyrbkxHkWI7mSIG48okXKDWs5mqpxjsV1RMpcw+8dI9T90SuuE/+GF01dUMRR1t16BimwpANGSHKxzEUF5F9yI4UqRm/Inck/yEUapVlQuZ3yTNCaiiNiQgbkthKMxgrDlWHp9eSfwNBWJhgMiklIFOTXWiKzJhq/mFJHgl8Vzdi4DeSXFWFDbgYvWgXTCkuTKKHTwk7xYgckQSIBsJbYlFebrSVBgiLAIkpoTdNf6NujwFxZ1lblkaB8MCWUjl/tPN0PLFpieMPiNJsrvRGfveReQkwewlYfSkVORKY3DWYMSmRlzGV4mNyrLFvKQIvzTY2k3lPlWk2QXld5dYsv3iQPsJYMFmBzRcisoOYT/eDOEF5bcclMQKNPumV/9iaeKOZTcaZBvY0a5mOHyOatGMRFLWMVTlesmcsMVGcxrkayBlTdCibzP/ZmU2yh2y5Lrs5mtQpFrfDQT2InY+ZD2qhed1pIN9pVZkYmMH4nOmYntNZET2YkamGk+DwmPzwHx/0mvVpjQv6LXHDmbPCiRAJnVOJD/LFmDrBY71SoIjiD45yZvdpVfiooACDbi6Ic6w1G2NZmxF6m+eZnhmRdD2hoVaDJYhiWQgBKafSoN8HemBZIzbVdYP3V38FWEvmmbcSkf4pX+2yafEoFjiJJRcUVzACFccSEzxqWj56mQdyg0P6pW44fEI6kHn4PYUZkYQzEh1FiinxpCYhd6gpFkKYFqJBQ0d4pZLCo3QkILP4pX46eiPxp06ZpP1ZD4uznoLYY1kyiIn/4yLus53cR4J4eoIiqkT/F085slqCuqmAGqh+CpPpgqYw+p8T8UhERXIYuh9WSRJFZA7bST8CIqnIQqmJuKfjcA6XRSacuqnsIKieOqTfE6rpOEHzN5oioWngEIgcxVEZFqBHVxFSiiJeAyOw9pojGCfdxxowJw6y0Q6EkqpEuat/qofkWq7lahBQVhFf6l3nOUEg5xWJSSKG06SjWHcBKo+ctg/+4RCqSaJ2hK3dV0IDJyDAlBnCAq58AYPiuq7m2rDkSnOCp5ahKqoVGq/Hqmmj+F5kdBeW5RDDyZV80RYA2x16N4Lk0A7zVK/3aiNc57Au+7IuixN6WJ6gKqyD/7Ok/cFBKkttirlb9zIq/bqaIao/alMw49CtynEfv0OaZ/KS4FArT3uuMDu1UJsR5oqFE1uoXqETJsOzzOhRICq0/kpkMXOpwWRLdjdMPYuJgnUgDzsRVDu1I3G1BgE7d2EyTseM+ooWw2mXk4mClnqruVoR1HYW8WVuweFfObca50oRcfuydhEP4CAPdoG39MKMG3cWCUOtfiu2cDSZgstqIsGzjKMPvzMPlMtVuEhpsBGz5hq1DXuO79C4OyG5qSsUpLux92dZpKNYMEG2njt+2PF/BRFJucuzZ0FWM2VQhGR6jEuusju76fo90Vu91dsTtmsXpIsP3Lu2ONElVf86Gx81Nr4XvHRRDhghT8j7FfMHX812fqlVI2r5DhMhvfMLDtabv1jYLNTGvcVqoRxITEkVUoCBIUmVhNNYtjJxssXavvB1FhYhkbdbWLKCJ82iv/irvxosuzlyD9yLD+LTwFu7HKf5D/3QDubwPrsxGjMRNnTCudpatgBiDu4APKjblqFjEIESKvQ7U7DyNwCDwRssuwlGmOmSIyAswg0MwDSGKPcQmR9Wtm8hEMIxnIBLF+OAEIYRKAlWQDE4YRUIJQT0QhJjYBd8jhnRw0NMmGEcqjaSxEpcrNRJo45pEu5gjx55Ku5hxZ5HF+JQDufwJGOsrk87EhUIKofMgPH/qx0cnMY9XBHWG8aS3MZubBGVvBMfDMfiw8Q6YZqI8iIB2LlycbRW+kHTODQEVLWFnBEJBg6FCQ8nZ6hGGps2ci4GQb/X68hsPMlnOrG+bMlQOcEV8cFxzL09sXSIgmhGRJw+Scq5Ecp4icV0AqaO7Mqgaajzx4BBjMu5jBO8DJWhWoG+PLEVUcTBHDvYF8ciLBRfBi8PppWe2xfukcIBSBQj2Bt/mhOwHF3pKhSN3BPgPM5RGSiXDMbvUHYvKprqnM1CUcKslhbpASaiXCmyuhY/MTSbqhMFdM5c1bo58cgHMs4SPNKfSBHwcNCdeKY3u5uy09IuLcfH7JhYosxu/6Qv5gsOkyob4AB05zKzgmcR5prKQHcmdPbRBrLP4GCYJL3UkLwOnLh6herSUi07d7FvM40vrtQpE+3HOF0QufGC81srnYqu5MrTFCcUJ4quq6wd34zUFaHUSz3STU12wVaY0KmO6ijVq1E1iLIPoREYqmkaWy1H6Fsk6lquP00RTbK/dTu5wmwRQZrWqgwbkmwXcR3X5YzSY/yZd43X0dnSdsHX2BeZOjoUeyG23PpN/Ty3Duu4HePW4taGQdzKYGzZcY3Xn6iOJg0PYzyM4Jzbnp3XLs3O78Il7uCqlxop+dMXYBLNtjoQZP2NEAuTPc0TsrxwhSez8LHaPMHNIP89EbC9EyQd3MGd2dErzhJJ3p993TvB11K6D9ExOUf7u7nW3GgYM3LSNClmaXqIv5I7uf6zvHDbz43b3/5cvxZB23eRuupN3uXc1lFJ3nod0/E5hvaI07BGE/ri3H+cKuAoKy/4xS8YphOhLrpNEYMT4nDotEFNxgeuE73MGg1+4pYcD5Q80IMT3OytE0p3mo6D1ciNGkeLpf+Kl/+XPdD9cF+8uElN44QpD4n9hjCLE9+d4OE9EkdsF/QwETO+5TjhyxJMDzlO4z1RRiJnJT+rVO9DOfPdUgRiz/YljsK3yJZ8ywdNgVxH4jTb2qxx5Vguuf/NE14ODl1e3hE83p7/rb36UEaUJ8DyDRjYRrBunj1oLXxbtV8frdnwAablWchlHV240hODbhB4PdWGfugjPeqYTEaBSHn0GBpH9H8JihqIKGszcU049S3TZekTCHQJ1qkxSLvGY7fijdcUIdwu7eAjUdKr0WWMbppWcg93LJl+nCzDS0NEXlV7g+tlaaQj/oawu5aFl+dSTuCTzUcyKehkbhBTXQ+njsSL3urQriIvsoqBeyplKxAz4cdwQSGp0xsjkU2sFajziyuzA4kmaulqnaV80e4treo14uytXsJWYuH3qCnDSxREIUd+4RcAnxMrGTRM/pIRtOWLDok6ce4MLxQOv+4H0mXyPns0//2xe0ogUszcp+JPII9YSJPwE1hqZbQPAqZ8c7vysNHuLm8gMN/jGiftj5LCr2qpNPQW+B0k3eHvdpExKk6z74DO+3DyJroT3J2lj70TDr/jBxLvZqRx/cCRLQPpF18aw9sbDwUUK8w3r/WG7rcO8ZBc+CDbKT/2Kx8oPSHVSZ/2Ez9eIDef/2ftAysQFj0QsbJAfQNYLYtglMtsZwH4Miv4Rg/gdwHxNhLv0M4l8f2qsbrxe2qEIEVIdthNQLLt2eQ6mH/dHmwP9cD5n7/7dsHoip+VWS0/QaFoMiH5vuYkA1kQ3LQwQUP5rJOWfT8RpuvBICzivH/9POH7aB4dwv+DdzWB+gA4NA+hluBuRZS2i9rzQOygYwax6CQCxztn/dg//+2/9tFuLCuseXKCKhiDDgCxzt1AcAUNHjyIDh1Ccw3LPYRYriG6dfXwGbyXEd9Ge/bUffwITh1CkiVNnkSZUuVKli1dgtO3r18/f/3A2XN3jtw4nuLC/QQaTtw4cuTOHT2nkKI7eSlDilS3kKHDiObQqZN3sSS+jvjugXz6UuxYsmXNoow50x+4fPPSmSs3TtzcoD+HljOKLl26devewYNnsCk4efEOsgsLDt1RqeAYN5yIDp49fQgrg9MKLqPBkSnZnQUdWvTYtDNvunsbd65PoHPxJqUYuKQ8efT/6A0u+VTpbqVW0b2rlzLjPX2XC3ZG+Xn0cubNC5bu1zadTtV1757ji7BePXvb69EGjzslb9gK1cW7uE/9ZeMw1b9vyU65c/r1xRaXOVNfu+kP5fqciyjs3DloHu+26+g78Aw7SbmPyEPHqvPce6+4g7wC5z31wPJsPvs+BNEk/GbqR5+cyImrp3Ekwq6dkujZDkbu6rmNQZUQe1Ah39Bhpyn8NLSwoK5gimkf5JKTT74QlwzRqyJJxGcduCLKKx0CDaKRnoO0BEfG72xsUD6wolKoR3uILFLDfSy0x0B7MBSJSTnnPMkr4jTETEqIzBmQoC25JCke22qMp1AwjwNJ/8yoPnpnsOLwezTSINucp1LujqQzUzmJg1TIetY5h0+94GFKvIIGDRQcQ1ct9KB3cPxIUXWAwydNIB99Lkiu5pGHqXk8A0dJTYcFrdZH17ynnnjg6Yudv2g7CVVVWUVoVXDewfZVWOV7R9D01FxTn3syK+meNgdyB1OV+iK2XZU2svPYfQqap69naQMUoUFta1XQVlHKVtsku7WoIHDX87TSjt60M6M2oU3OXYlZ6mojTm0FZx544sHXtpQG7fdfhAR2NtuSCdbq4HDvKaieSi2t2El9uDpzYpvJYtjiSPHkFTxpQ1N0YGcFffM5cItjWSuXaXuZu64uDtIgYV965/9mOTu6SWd54cu4546BTjLRv+Ip2CBbwxUS6+5cttRphqMOVjm5pz6IXYPYDfikqq0GbWHMtP4RPnNdztJjs0gWc2h6yM1wXpK4cntt7yoejqQklcS8oCQL6mudu/3K2yRsZeN7rIW5ghdqNdP27mexAtY2W0HLNrhczNZeOPenxYV7H3742VzuuC8Hp/POOc8WYGxLL+t0hjPamusEY8y3S0BFRojbV7Ed2qJaSVIPIY10n/z0SA32/fffPdR8+M2LN97VvUWf/yDASC8IMJLux57Y3C2+GLjStjbDGaSAYRqY7Gp2kvaMiyO5m1zqSNIPfsykgv0I3mEupxy7tST/ea66XwhFOMIQGqow7YqZ6tbTHqydqloMOpTULoetQi2uPShxILzIh6A3EecgJFLfBTc4n8+w73Wwgx0JlThCE8ZwTinc2ZpI0sKUxJB7MyTa91gCLy5yMUH2gF7jfmdBfqhHfUNcTujkt0Q2AoZVGzOUYJaUQjSFb4pHNBm3yLYRs61EXMMBZCDJ9R4g4kk9Q6RbaJCYrTaykVWrws1gIEYfOhrEjgV54EsQibIbriSMlYkUpywpEw1RsIyOs2QRiRcs0HzwWklUYv6W+EgTkmSSpgpNJW/4wO5ocojxoMx9AImmgxjHjEE8JSpzpQ9VrtIkiVReSUYnQpTcDxxw/1yWG00YHvAQZpKjqZhm4DZA77iEZN1anDArdz7wvQeZamogMxFpRM0JT4Nl0Z9KtLmsaRWqKd0MT0FwmcszbWScNzkQjUwSj+Qh0VtaZKcyzfYoQOIqV45TGTwrc5GizZOecQPpPUnyDtDVryX4CxQkBfrPblKSj5uZYusOWK2AnWx2jJMUMUkSSB9ONKMahYkD1YZGVUaMiPQkqStfYs2SqPQgLa0P40giU9cdpFB5ROcCWbZMSXVSMyyD6UF+alGYFGQ4Xtxg+8RCN3bZ65XLc0lgZINSlAQ0qjrVjm18Zpj+GeqK76DHAi1jIXbudKsIURmuwmpWQcIrraxcjv/nCgK7+kCLpd9cjrFiUpLC0eOR1eLXVWHEQFAeNCVnC9d6zkquhmmEcVP7qCJdmc+zcMyb3OSmWIJTp8DdMEaF+axBZrev0XqyJVGkKNSE+r8u8pGP9YQmfeY3wpQocZu4xa1uW/a4O1XIt6G1lnBnlyXakcSrKukqOw1anAe6rblp0+D75ERNutqPif7ELnZd2JLdXqi7FZoqjahVkFV5qb8mkeqFnlvM9IrLID3UYctOh7ozHSh70Z1vCKvJP1blN7eoqp52tsKpY0rxwa0bMKuKm5IFb4WdDUbauA7itxnnrIXg+dWF28VU/Vlzrhzmq20hpl8DhpjFTjLjTEz/DI5ydmlaVi2wYB/HRZRoFsYxhhdK+ruwctrVatQlnVxFGDLbCia/+9Uyd9NEoiUfWLxX7VYN3YyQLrIEaox1rRf1NVXJ3QYc6BqNfOFHFtpWt751ve3XrCcjHHa3kMaZ82QDVkMuZaa5WXZJwzDdFRonujaY1etAzfJYznWwdCzV0r62g8MiXVDJB4k07OSMyUtrhSsq4Y6CvdjC6dlS1C+qR2LW6kzmzeabtom0ZZJMon6gUsqSjrOgdE1llSAb2Qe2cafrisvBiIw7+ABJWUhdbIRctshGRuyy2SzRkdFwpu/9mOGujaU36Y7JJNHSkE3FsULBY34W0QeHxjJu/+aJ+tciUg+z/bHwZp/3lU4cS224NO+WRa6XJiEygQ3lb7t5T+ADFzS5fW1AlTiaJgtnOLISHGezEFc7yWYJZqF8ReV8++PDxnCxc3vcmFwQ5TWh4JLlJ+2zzPQkq+5vpPEbYr+uA0efkcd2bu7LnBfcy37sObNpAg4le9XdIbqNz1z+QogT2N/aUsfUhI3z2FrdZ8dVt2m43ux8SLPsZMmX91ZKG47hqzapKrthNubvxA0NbFU/dXjQXZJWMxux9Bp6fb6tFb6XsO8fW2j+SOaXw7edb5bFF9zzQyKMG+TrYlm8xxD03MpzON7VC7L8kiTZgjSG6p4/yaHntHgGu/+THye5B68CQ8ODYz4lFtY4h38t8ZnG0ao0Hzh0iX0SU9snmyeR+Wlb/XuT5AMfwqdh0VP9IgMfP9TdHrtVCfz8kLNkbkVdyfHse1KWXH+lL2GYWX+Uknw87Ox3d4nUczIs8R4doh6+45j0Ey6Baje6sT0EGh6piT/OgTaTGpm4qi+oWon8g54iOSk4khMYgRHNMkAaQcAE/JnYwyy4ij5nwr26qUCAwUCVOLgzyZmvcriTWBYArCIerB4ZsTJ4KZwT6icePAvPe0H6sUCTYCqEEDPdu7+TGJKL6EA6gaFoCS/rKUAu6iyRwyOWaEL76R+cKRoq7KmUkDvR4Kt8YcP/Abu2nMGHLJGmJVyJMmsXpdqwQrsmbDoLG8SIMFoJmwiNAdPB8CIuRhtA0zOZsfAnLzypLCyL5xoO/FAJNiuLf9I4AIREWmo3mnMWsWjEG/FCOMo+/NOKSaTElAA6dmsJgCpFKBtDjWO/TaLDQuTBtEvCENEwKCMMs/BDPLOV3wGHC0KIVTysl/iX6jk4APygsNkgFmwqMMnCp5g6R3xFiumhDtw+9UnDHyqjY2QJwxE1ZeQ92fOo9pNFHXTEJwKgrQkix2sncFyJv0vEamOJ+hGYw7A7TlQ/56A9lOC8mxmSDsyHY3I10gMfzXgJiDE6lCjHyboW+VEJ2YnFiPTH/380iYC8GTOUl3fUOuBbSObrPHRcQOWBRhAxnraiH6vhyDRBpo98PCxxiQS0npeYKYKzKpDRm1qkD89JyYm0GQDKh6H0PWQiRpNgmWRjOhd6SHzzLMtREjoUFH7RG/rwvOPBSEVkSegZyoI0SPVRCe+DuS0hDNsav6Z8s+yRQAs0FKqcGPnbyZN0l3jpSg0JopPgPs1ok5hjkIasQ+dzFYusH35EjFxsDtqDy5GySIOgpjkqKLokyqJciXwwF15pxXqcyVUxqaqRS0KMPk2xQOpyzL/hysg8ppZ4mOLTl9TzLCdiFTxcHg8BTMuBLJRQlyVhwR/bRfsIDr9px7q8JBi8PIjg65kA9EsijEa/WkTToxuWyw2XCAgAIfkEBQoA4AAsAAAAANwAqwAACP8Ay5EDB+4cwYPg5ilcaK+hQ3v3IkqceC+fxXz8MvLrl3HfRYsT8+3bp1Gjv5Mn+YG75+6cOXLkxo2Dec4lTJgCx4nbyROhz59AdwINylPc0KNHjSIlKFMm0ptQbxKECW7gz5oCEaZDuJDhw4YUw1a8OLKsx3xhwY4lm7EfSn8E7bVrl+4cuXPp5s5NV9duzKI9lyZVOhhcYMGIDSN2ypTxz6iQB1odas7gz3ZdFX51GHGzWrETG3b1ec9nxrdwwZ2V2w4iSHvz6NptqrNo4p9Cgx7MTfi24N67DzqmPRRqVchDLWv1mbm58+fQFbbzDe40SoIqO2YkHZtvzKa2EQL/Jxh4PLhwPnlTT3yYPGHHwseBk48wMnKEysuZO4o5+kK9AAYo4FzuDKXXQj7tAw5qqVXXFkEnEYRWdzX9FR5TuPEGXDjoiWfeeki1Z9h7P9FG30HG2UeVcgSVU5OB0g0IoDs01mjjjTX+dGOADEWE0UaoYfcgUBPONRtgI2aoVG4gNjnYeO8xZmJT9akYmU938Scgjuusw9eXYIbJFzgFklkgju4A2KNFJPHDIDgcbbcRkffMk8534sjE5HwjQpkUeU4OhWSfwBk15aFUVnllVD69uBWZCAV4o5dgolPTpZeiM6aONvKoGWcVtWnSdRBqBCdCpuZjz52IekieTkuJ/xioh+UJRVhgiFIJ31SLXlnQVmcaWCOlfGGKaWUs1oTOQens2JVrH7HVFoMRLhinSqhuB047s5lIa6LipSfrrO71BFitjeU6H3EoWonco4i5E+ax+x0HFbLKNUvjgZ9CNNZIJQGJ2j//kIpSnAedptI9dX0HrlCJosdhh0yNS265tmbcm1K5topliipSB6ZLvJZj8skn31QvX2nO2PJcmv0rqpsoEWxzwam9ha11/qhkZ7czWdiYYRNrWNuHFxO6ZHvy0dexx1VWheJx9gom75fgFGsQylx3nSU467xMY5dkw2O2O/LU4+9abZ5089sFL9jzzm6llA+3UenJmDjhIP+Z54VJh4j0oeuq69SJT0lmHFI0hnmQOV2XQxvXK9/4pTqYq8PO5uvAI48886jtr0XWwW1zttnRnNI9st00JWCw0rZn4IIDGp+JwD29a9T2LVVjOpYq6xLKJqL8ddY2EovO8uhkvjk7naNNj+j4jEWz6QSXqi3PcMnl3XcwHc2u7bQjNvvtsBrVm+5LWTkXf41biu85kcNUmU/phO1Ol3wtu7w5zGue894Bj3jEY3qis56bsPcP7SnIQSjZjlz8Er7ayKSCSCufb4hzoSixD3H2YhRBAESQ2CgEfy55iTleYr/KjIlL8AIKOla4vMxhbnPvMOABpwcW0l3PdAvKiEX/IKizldClYU3J204mpkEQ2UZ950Pf4by1LkWB7CeZOcg8spZCZL0wTWmSRzvGlpwXIYR5NtQcO3JoQHnwEFqnwZ6QLkLECK6EQjX50pH4NjGKNfE3UawVrqjorfGFbDoljM50+neQl+lFHmPr0lW62CgA1lCNa9ThG31EErcBsWfRGlVKsCUR0SBxiX30I2KYCCIOYQxwROEYu572scVtKzqwic0YCZKm5oxxf5KcJOROtkKCrNCSAsRhDunxxuqJZIGf5MdFfPQj1JgKHBbxHjkkV5tUqtIn3mTlbVyJMd/YhoqFUxefqMJLfj0LOmrqyi/3RxAv+WSFkTsZOJAp/0A1thGB9nAmkOTIEbRIxIfUSs2EGoancKrSoX1MjDgJFStBpUt3hPOJI/0jzzHCTJc0AhvYJBnDfQ4zn/tcHjjSmMl4uFFtoRIYEIXYmZU8U3UHUwlaWic5VEI0nDvppmBSqbQMJkk3F0Wc4UC4rXhyNECfy9FByFZPdlwFn5G730pZ+o6uunQe0OqkHKV5D4fY9EfTegs2KYQnPv60bzPBS17ulMGIvjKDUBSUB6XUMT4Jx0w0+hzonkqg5JFtHUDZ3E+wyjWf2HClm9PcOz4X0FC5BYjVKSuC/qWRup2kH2vl6dEgOpO8+IRbSLPrucwpGIxmFCE2guTnniPYG/+RCR6HRSxiE+uT4J3UZGdMozoQoo51TBasFRko3DKby5hx1rPVUtUY02EO8ACGQ+IgRzq2iJB8ECQd4/FmUdcjq726dnyARVtsBRtVG001t5IM5k+s+pP/nTS4mFvp4+pFmk568mZkhQ3MRocR6FbLI3ViKDdNdA5EYjNaWWPqecg5KPKej0TnnVIj0cRhePgEvvGV74eXArne9nO4LTJZZdDBDs8RZB+efRtzpbPF0ZHEwAfOBx5vYrIGczdadEzHOChG1L8Z9WJ5yrCG03sjDyMExFA+7FBEfBAUy7CG4FjWPil3Dk2tQx7VqdnNqqMqXWIGHKNLa5DIXCeeanf/KBAWcjhfFUXaHYavruUlmswWYviKtJ5RBso6FFvl/MqwywRB8W+J2WXE+tcfp8NOncw84FDBmFovXmhf3MFdCR0kzkOO6GrtDKWj7UnDSz7I2WpkNkDv9ihRfrVPrPq856lDy4iB3DH72bytYOS/Dfy0gMcWUuQ+E9PSLPOBSgPnB+dDzkyssJ13s7RR+8RpQ5MwQTy8WynX8ycgRkytbW3lo2h5WZ4TXUOql9yaQZo7V/tS2EAHkUu/6cFhOcpHIry0o/3RVXeVldP46hsqP9nPghl3ZMsNFBu2eHrV0wfANoJTSGfvIP1gHfC6LG+01RvHqeHHWQzKbJ/Q0bvn/8CdxcqnPmprDCjopF24E65wQyPlhgSkB1gkDjAcLzezssFX88JWj3vYW60HGXlEuuvpg9zDINb9N7XL5fKNHUVXu2uStxNT6zTi+ic3XGMO01ZZkbTJwHI0YheVhe554OPRSBf5viV0cmwqCOqwknqFV35UmEvp24GS9bcFP+tx2/DrB6khDuGBtk9xlnsMlJBsXLI8jnsYH/roB46RUnc22cMgdSb17ELfJ6mDG9yEn+/C0ziUsBPwq2Dt4U1jLEe47ONnALx12eZRms0Tad9DxIg9aGfXgB9ZXKQvH+EJX2uC0JodwmX4Vl1/tsGq5aY4vRnSbd+OGQJwu/vQB/8k56EPuSH9J94d4oMlZI/JOEm8RYWl+fgOotSPFNYipi84yM16x4Zd7IzXeKAyewNDLdmTD+4wTOgwD6DFEvJgdBBCKvrmbAfRDuWwHhBFK9ZGHRuodVTlfPr3Z6g3X/sHgtHHcA4HgIw3WMj1eCA3MAfYfXjhDqXhD/YAOvegEhKIHerXXT2IgQ6lgfSnV9WWfOuRW0uxdSBYZdB3grjGUtBDQCtofQTWNgkFbA0kTbHBaSqxD7BhdKAFFMlGR5/mXWRygas0Z8Z3fBXVd+TygeJGaCDYfAjRhCeYZdPnPFFYfY7HNtxjgGPmIKQDJ2iBEUMhRB9Rck4nZEjxVvH/N4TmxIZOAodLoXBdpzknmF8nloJSiDZUSE1odYUWF4hL0SCoMnI/CBKKARQZ6B5642+BI38XY38H8Tyqp1iGl4mZc0nCtXhTaH3OxCYl4RZoF3lIYYoOIndkSBBldQ6E8VbokWSyI4ui9yS3oYRxWHN2qItoBIVrZDYuJVixR00zEzAF+HNLEWwJo4w/WBVulYFJdjLWJYmzEkjSJhi0WInaOFy6eGvdqIffWEDsNY5+GDCihIWRdhQJKSRK10jlAI95kjILZoR/dC4dmBhkg4vOV4e42ITbmF/RF0D/+H9S2EazpW6gaJBqhpDqOBQydoogURqrEmpFNg4CgRN6/wKJpqd8XaKRJWiJq9ePNud//xeQOvQ59OAVNqaSxPgWmAUUaecgCFYa85By5LQuUMFNFLmTVUeP+Ddo47Z/NSeUwtUoBNFPtdZVBWSS06OU1GSQTSlm6IgQDBRsHHEWVJlyQRMVWsmVTnSP1BGWYgmUq5eHISl9RJmWr+dS4QhQX8FJw6h5MDiXBFGX2YOIC4UpGOSVfqkkS3OEUkaY/MePuyiSAXRzRdlVbMSWobMZ5DiMAsOSF0eXdYkdI7dFdqGVW9mZfimaH/lY+pVlpol4DZeCYqdD/xQ66rZukBkwkumUlAkOlhlsycY6FsKZvNmbg3mJ/YeH5NKLx3mUbv/Umg/BbsIIl9D5kgghmxdXUJ/XTXyUnfKZjXf4R8apmmyElOTpEOwmM845mS3pE+lJilpoIX0znwi6FLoodd4YnvqplNdHFhO3Ec+pnj8xoLMpTe4QEwnaoQoafVzpjWrJmhB6UBIambQXoNhifqOYkP2AgBWDnR76b90ZoqSZluAoWEmpEPXQoxEqLZ2VourIERiHoRh3Ny2ibTOKoMApn/e5luKonCgJimbXWQBql9cEXQTKOnaxpPOZW7bYhCFaZcTFia+nozzqo5UFihNajAmZpUZqg6yCSl7KlTMXgpnjl9LncCMajp/To8rJnPegD/pgdmenpW8zStiCqNr/1w5/QVR1+m8gRmtiWaOCQZy+QZqFhklexV4IpKZrSqhm0RZCmj1x8kCMejqfZ6DFF6mBA2VjmacyZJggaXNNmqkkKZBI2aO8KqiEaqjDiJBBJHIKUqqX2RI9FYSuOouTOpq3SquJth6YenOLx5ZJCaoRV6hlEaxYyJAKojqYtSqPCo3L6oEZSWhBSZbzqUwm+VJqym7auq2ilKhS+a1yGYh3Qz/vCI2tuqzf5Go92ZG/uaAIWq062qvMKaqjqmbax4NmWDeRxxL0oxPwx69X6aF9E3qIFaaXGJR5uKQA2JifmrA8R6wTJ6TICCf3Omb8UCfy4jCkZ7H/KnVFU2eS/0SYYWepMxqyIouwEWcWo6qy/+UPYSgkEPtJ+1BWk9eleLIUMtuvF1OzcTVl8jWWdFiu4OBV/8RM7zqoPAe0QepJ1fJiYcaSBJFxCQYyUAGLQ/W08LdKPHFB26WPQPl/S1iuWouUIwuvXyuvmmdgRPpiN7ayDdRARTKxPSETN7m2ObmbE+a2EMUT2tUOFVEdSBGrstqRg+mqq+lGe9ufhnqyf0uMd2l3PUe4l6ljdDGuRZhEC6ZyMgq5eUIO00Gs2jIU3EmaiFmLcliLG+kT73AxIYgQncu16taflia6o3u7wFqhciRdczpRuDElPOYwjeu4CJFKEdlg9oBW14S7zv9nZbJ6FL5piweBnxfTVT+hScZbnhIhIdu6vKqBEKP6t7IJdHVRDj41f0XhWhZpkQTRRzshEFtRjh3xQLhra4ZZguSrmKqJQ8CLvrOivkPBTAQxpe+bdGenEQiswWHLki3bOhQLtbdxLko2RRd0DluEVgpSFsvYenn6rLiLnzSsmkcRvMALIjYcDwjBTPQADhg8qGwiuCUxFA90qEZ6N6e0rzNbjxaJdXE1txBGGu1Yh7S6u0BRwzSMGDk0K8jJw415wbG3NkI8qvLqET44EqphpQO6Vvk7Wsr6b9i1vYgEZNFSVj5yudO3VbehxfhpQMAbDzi8vk3yxWF8wdQTEQr/C7RloRou/BEL+5xiJmnbUhUj/FPlE07jkBdrYceJyBmCobNI4ceqqUPgwMM3HDjWCsSJrMh9C7SCaxaQ3KaSfHEtO2x3EsDkSi4CnCcG0clA9sho0VyXu4k3TMGk/MeATBCD/G/00LNd68qMbHKzLKF+C7Hv5g+qSxeNcyS6jMnv1zdvxntUSnJ33Bn1IFgfemuac8zBW8NmE8/xbMqofBCGjMr1TBDLvBQ/rM9626v4wLfTbHITUajB3HO0Vx120hdyVSzblHffrIbj1BTcCxoklxawwatgRr5DmcUSrL5eJc+thhD3jM+GfDFICQ6OKdCwfBCEunT6drJyiU0t/8FCU3EpDg3RBwHOjRgOd2EOrfEQzwIRm3FCnZZwWHy+6KvM8QCOBhTP9rzPJF3S5PLPiUyofVt+4IDVFBHTZ3ev/OCokmMyh0MTYPIXP+GIaR0O44AONJIZkCTPLIggG+YOfGZ/vevOUijPOuTUTT3SpuwTJR3Ys+K5XYvV4YfViq0PE7EUMg1sK5Fy1+VKNnkXDo3W2WuxxtQskBRYnR2w4OA5C/E54EDaZoJbBrcequlk2ybV+qzPgx3bpc1eG93DSNHPPnzYi73YEoG8SxfQLl0WtQxgG9pNcxaRBLzEmf1TF9gl8EBAqmlcc2hctD3XW9SjgUPBsO3apwzIsf892KRd3QfRz4lhwT4a0Ji32xSB3hTB2DCtsMOtqtHbiobhInPlFzkZ0X2kpNuJo1N4reUZ0A2hQVA91fQc27Ttp9Wd0kNRD4lx3gHd2+hdPRMe4Y2NECUb34YrG5ccx7N7F5eCk0KRShcIPcNLgiqoq6Gzn+g9fFwnGB6Wz9/9xex1FDrqwxb8qbzq4LfhrgFV4UA+4TDtE/Ct4fwwDy+brK4k0UwB4hTETZIDDvrBYmApppdrXDnqRoO142jm4uR7t0dRQII92Nvtpz5h2rPtuThuvDvOq6zM40DhZC7lmAHOnxV+D+zm0l9LocB25K1TMbs8IntpvZZdIILcVc7/OhR7LeYEUdsH4eiJZb6+gZzy8N1ors5nruZrruNtDsS+8adtvhlBHuHM6LWPPWb20BK5ySeX/Lhv++EPbZMAZFzvLMiJPhRm08yBcuIIEeP5LN5fnOYLDul6u+ls3uZwvhSsXdrHDqrrNupOt8h8rn0S6xcXeDh8s9zSC+vkgCz9lLXv4JtT9hODJW4wLuf7XN3I+ejDfunMbuyc3quIUdvLjuOhHuBAjuHSflmnU+04WTgj8lCQ+ipyxTx5SKnK5Mdk83oI8VIPMSsjPRQbTdjkXuOY3sNrjuzO/hU+kexn3uzLaefATRqIPbgsizeKu03zkSfuwYoDPw54MWgg/1qLq2lANFx9kM5D6K1wXnzKj87upS0YtE0QuJ3bGr/xD48QHu8Tze4ZXg4UXvu1/G4zGTenM+EhTSMfH5JK8tFla7SNKsWRN9+uCARmZk89+MDzgbLuDX/xEh/0TE/0IH/vTv/0tt3x997lA74Upj4SU3+AwmEUN9nyGKLTEa0UK6ZGXmerrte57prOB7tuPE+phazgn2PSsw33mW/2s23BHe/pyF73ILLjHA8UIx/hCqtcF1caSMQUg7+KflUb4DQel7R6I0mSi6lz+FAP9HD5Dm8Pk+8kYOxSmt/j8E702H30zo4PSX/bbH4QProUQB71gyudF6djDE0OS3L1VP+nGPkNKGi4T4nXPAtnmveplmTH+76fNmojsF4snpnvG+St0p7P5UAR8szf/A3e6UNhVgABDhw+ggXx3bunT98+fv38+RP4T2C+dunOkStHTuM4cR3HgSMnkKPAcB3BjRspsNxKgefMnTuHTqY6duzUqZOZE93NmzVrCnwnTx49efHgCUSaFBw7pQLXrVP6rmnSeFWVCsUq76rQqeDoff1aT+zYekrtnUV71iC+s13JvgWXNq1AfAMNJlzIsJ9DiEj7zTtXDuXHcRlTihunkVzKcCURoywHztxkyi7RUZ7Jc2dOnjSTPn0Hryq8owLl1auLlGlXoODeSZ0aD5zVpln/WXcFG/bt7rhy7aUm2Nbtbt9yCdotqHDfvr0P/z1Hyq/d4o7VTxoWB+7xxuwkSyZ9CTO8S/GTY+rUyfOnQKavScs2PS/1baVHYSuVXZU2OK2m+WvlyiuwmvpKILB2400g4ZIKbkGzziKrOLQKQo4g5Zjj6zmJJmrHHI7EaayxkxJLKanFknpMIPNgKg8dl8xR0Rz0MlOPPXDWeUe//lADpx/66gOntNj2+88/rojSKrcfBUIwQvrW6kqusYozqEJ88mooww17vKedizoKMUTEqENRpKQgQ2ql8C67bDLwZuxMHaVwFA2+gcBhbkmkjiJNINJK089OrKZCUsAC9QSn/8l65mqqLoMWlDDS346rMKHlMHRuS37uScci7cIUszCUujMRssFYQoqyymAEDybO4mSPndeIvNRH1W77k0+q9Juqv62EIgrRsphsUsGkjGNLUmXTolCpC5t7qC9w+LEnnfAi8y5E7UgktSRsBStsJXHHRbWryWjszKfQTCvr0uVUW60pqXLtk7UA+UuKK2BzO/S2YRNFkFEFmU1W2UWX/a0pSzGNFql9vFSMzGxFHOyjxhArR1VyN+a4KRnT7Wm9eOSxB89LFfrxtSBztXfQXofad8Alh1UU4QYNRthBgRZuKNq++KHoIsgEIxWcMLcNiaNwZWzJHDU5hrpcdGsMLf+edt+lC1Gt7+1qKH4PpcfApMYCuCzilj1uWbHQOljgkpt61meB9unynA+zI1qpMLMLKdWP2VkHpxllghGdGDcGx9V02ctRq+X0YS3e+oTcU2sCv/6RbM3fsrlgSae0p220kHpbqYX5eqjHfOZxJ51yQCxpsKKNvvgjcNIRKCfAgbKpM/qcFlcyGpdix+q6LgUH8iJvbepPy1v2WsnM4SobLknrQhh0J0kvPanT5aa29XNOgn3EUWn3KCOmKw9SqZv0dGncpHqSJzV3FbrHnnslT4rerbMCYPRkhpR+EUtRvJHUsZaFFOoNTDip+V7DVpcOxYxERBirmJpeIpN1uOP/efSRHzh2IitfzW0fyhvIPObxI3rV60cBBODXwlagAh6wWAnknrIYSBYFPpAgloLWQzZVEYycjzUsiglN1gGPEl7FTlpzGmbU8Y56QG4frEHIPVhILyK1rzYwxIoMMTc2G1ovUj3UYfXEwr3eTOogC0EdRPJhj9YV0STZKsw5OpWOmixxZGHrGq+awr+pnGcd9EhNPx63M2ehkDUttArLXgZGAYpRemU0Y3GaskAHjm4uE/ohHOXWJYtgpDp7K4yMlkhAf32FK09knlIMJzx0sAORftkL1hTiyCW1sE8unCQYLTlGemAyQgjL4Rnb6ElmulE5qFMkHa0VmbuBSBwZ/0vHKhl4s38ZCCy+us+PZhKPutgKlwK5kLv48UghAVMggdIRJWE4zGIaM2Bn1GQnc+abguCFOc6ByDymCa4MkiMdHmQSsZKVrG6yEpZVCSdSOLOOf+XSYQ7rR5b2shc96cpPdaIKAP8DoHmK0Z5NWqBclrlPZCXnmagDRzvQsZKKJQYd2SQjA0M3oTX2Cj/xUFlSJkoPFObyiljDU0MwtFH68KmdlMuXPIVp0pOeDYcC06fN3PjGvEDLR+4ITMXIoUd3uMNXZDPgWNhSD6KMMSk5AqpAbjKT4tkjIXPbqLuumJSlctRyoumaVEsqw6paVZkDQyMoC8LPtezyUvxYJ/9S3AG8jOixg1yjWVoVJBbdKOmhVundFOuHMozmNZda5OtSm4qoqgxKpFMlbGGPyUljJXOrj1LslSCXFwwpiHUWmQxO8aUU6vFQjWzlFyyR8o6avOOWU9Erhk6oxQUh74NdGVl/9KXdAFpStrM9LOkSu5a1bBUvF8pS8uYBjyW6A6pNQZBuOPu1qtADnqqZVX3nk0t+nGyXvF1kolT4tr1eN6ou+xVsY3vSffawh+SFMDr/WyuO6oOOmE0UwAy0mwON5St2gs99XSOrHBVzvxs1qvJCmU7lqXAedt1HRNlXnydul2sJ7u4wq8pS3+gTwuSVMIA1mjz93XiNENowcof/GWKqBPU1cK0oilE8XQZxNS+Qs4cKUXMP2ES0NM4L0n5gCL15VpJfDObxJ1v646Q49rFMjYsK4bu20JWFniLuClxNfM4pP04fqNVTwfAh44+y7D2BEimZKUlPe6aZUWuOMFLSuZwhgyN/KyRuopBsKAPBMz9Mxq9+6FG6K0o5xQiZT6MA3eZdEnplhq6TVbZ7G8EmRUkdxqSjR7fSH1dJwnpF8c50luGDDQssVvn0OwP11uLFY899VWSfedmVULJGKjJu4UffqSfBupKeucm16HR927Vk0c2PzVJ/6UKpHcKFhiAOsSCV7ezfWNHU0Z12cEx31wL3qGFACWr73mu5/25/+2toHje5+2nuSTMkstYdDlkGZF/svtXZui1tn0/GGnZLWilBlFbADZxg09jY4AdvdMIVfhCGA5jSDuv3nCWe3Nmwpr5V9IvJ8orvqSxo1U0BubRaM/LASvXk8s21Sru3UsaWO4vnjS7WdMmaAx0b2SLO73NNKHV3KQwp2EuYpafdnDimzjVD9+LIESxPfnlzwTZ0oHg3Gakft9zlEE8eaQlF36vL27mLSrXJ3jV4pFoaKagumNj7vdFogXzoru7fwAOLFNfGUIwELBDC2/ggutcdIf+9e7+zGHhbu51I+ylmU7oOcbx3JX93xeVDGD/7vTwZ4CKPvJ9++rysFP9QKWHD5HF7ytJeP/28d3ckeUs2rM/W/KeAXCryoquU1v/I1NffqO1do/3mOXX3X0Twkm6tYTLysFi27TyEjT/h+ymlvAm9jZ1IbDw83VuveEot3mPeI+z3P/tOPjvcSzuPmg3lGqkbo7zamDjfa7c1MhvjcrD0I6/1O7fC+7q1Ch2vEJumkDf66yqNqz6Yg7mY87+NgiyHO8EYEznIS7vveyeSgsEYdDsAERBO00B/aUA2YjpIuwu8gLquO5aB4SEawi47IbWomz50gi6TwaUS3Dkk5L6zI7qroDzb0BeZESAB4Sz62Bwe2qfie7p0mptMSysl48DbaDijuj/8Uz3/C3TCvUhBR9qlrpC8/rku2yg511rAA/GXB7ynzvE8hrPAsdkht0IK2oClCkTC/ZO0/Ys2J7wfR/q55ZpC56O1KrQ8QNIxhEOburO0z8OSyBK/AdoV/RiWhQC9RfSvhbioizLB/usvvdK7LMozFgSSeStAgstE/ji5pLueXqMUc6M0v1LC2+iXzLOzsEAnP2M/JGQ/l/O/qOMt0PvEp5MXW/yRkfmg3vumXkw5KgHGIMMSOCtGqtPEsDiO1AuyEwK9Cvyv1BI8KQM2fDu+dvyvSRRAy9HGJeGaMPomM3M73SibgTQsHvS1cyM7PJk2+siN4zhFe9wtiJzDNqQwRXLG/10KQ3t8HISgQ3dirSa6xKvIjZihp+pJqHuqLYIBsrz7wNTZh3xYyMv5GnaTyIhcOFA8N8GjMGacRvy5B5bDSXvkyEdCFDCTpHuxMZAEyHOcIQbkQoDpsV2Li6zJO72AKSr7kTMzMZSZQ6FEPAp5I1WkR2HEyB4Myj8bvUl8Hv95tT9BShkUybZjSqfUmpJpJrt8ILFbiJ5pGKBRy987M3HkSYz8ybprOLFES0f5r+Awy9GDkqcYOf9xnj/ZxyLBw3zBHE2sxBxSIAUBDn/KErnBE4RYOvw4lH9xR9ADRt06zEi8xwZZza/ssRuBzOtiyz15D1+ZNZA0FBnizesqC/+plMrDU47Q/Lf+yh/4M024aUd2LEtgTAjWREXnFMrgCE43Uot+YigXK52nqM21lCRI0k2SGi7AFKPf1JPMCsLSZCT0KjuH0Qe2sLmmFEeI/MrjADK2sBD7NL7CpBniwC22Eop5+BfvhArbnMxciSc8pMFgSjQDM5sHkTs3+jwKE02B4Ic/k88lqUkNhZKdGja6aEdadBSDUE/Oq7OsINC3MVADgzXKbK0H/R/0jLieslGs6o0VG8c4or4/Y8/ZAKSBkMjCfL8lYTm01CIKKZkGsbOG0iwAAjyCaFEE/SUFjdHLnFHLKS6awVEKdbOgEzqFZM96WtJ6vBI2c1KO67X/4mgg6InSgvhOXGGnKvW0ANpGBORC4+IcgakSf9ILn/k3aYnPICWgbmrHXjPS+VA4pasztsow8uuaKlKIZsEVMJsKWPu0K7VTfpTR6UGrPZXKm3yW94QIoYMcJ009l9olCIOQNL1AdpsU7FSpsgGkzblU/rAHVMyfH71UycPUAtTUTlU0GpU5RVmmVwXFYXzPqcgfQjWQJT3TSVW+RnVVK0kslXqLDtshqriRdam3+Owpp+goXwImytSurqEPO5WePDW/TbqTgcBJZQXUf8OTOUrTsmis+AzQBKmyldSptHBAD+NDzfqM3YnSOvugKmVLwEpAfMFTWhOpdZ0KuNAc/01zvx86PmUFU4fJHzxdzbUy1mFZuQ/ql1YNV6BYh91Ro4R1KkkKM2512Bt72AP0R7o0oHZ71IsFSvbTqLKTFrqZh6KYio/FB2N91NvS15wdqXpK0yA12SANG6PQPok9UPoIDXL9MqOAKpfhrpktT8xzVm+a2JPtV7sLRRSb14kIHXmAB9goEKJFWOGbksbSt0NsLXAjkGKhz0OsQhfF2nQdrq6lUZAkRcwbW7lbN4ytxzdjvLS1NP0xCp1d00Ytwwj5sdCJ2rutWFsrNoHtzWq1HFusQ0wEP247EkJtyrBFENIxy2Z0uMZN2zkKWtogWob6F/U8GEexkrjVjU3j3P+22cLUrafNnMLfDD+IbVCwHdvtiQvtPEvegizYBSiIyNC1hY/abVViIb+tsksTpbN3pTrRQS5WEsipyMfVukUDO14yM88aOpuBEdVURDcwvdBuqt0hhEA3OqBvXVXr/NRsDZbPrcG3Ot+/It6Rw9sGpLPSiV/5fV2fFU26eZvsBMa2OFm02qpiQY2eXCyBla+RPDhXMjAWdNmQPOCAbChQZWDFdWDIMs55/TcJbqOPzamBTNw6GxDNkc7+xeGjkyFgNcCOrMNfOmFz9L3MK78F3rX4zQd10igYBtS5Sc62qeAabij/LdxE2U9pLdr5+jD7ai1nsyS7bTukMFDIxEb/3SvizVTipms5dZJeKDa7x/XM1QxY5SQuLx5bCPNiT1s2H+ahM47TNSbk4Ui/lmtieZVjx6XjlevgbVXa8pNYt+MwZ30oIL08cHsLQR7kDwrirShkLpUQJqa0F15kejWWj6XWE5U5pm2oYdKT+vq23eDkqjWwLnqZQiYWNcvOMIRj+pXjoa3i8yvW1f0pUXsidQmnu51lga1lW36e7HKtyfugalXhtqBgUExkF47jtEVl8apiDUOrbc1WtSLbeeui9ri2eBNjH6aHWiZKSwWSeDArr/UP4gWdX9RmdHviU248dwXGzMJdRZEvgqhWeTPf+4AnHz7jLZLnqajnr42q/xMGr1m1i30u5X72Z3/IqMOD35WM0IoVXw+up4IA3W0rRW5d6JEkydxo2yhswULzSIEoK2LFUq1x1XyWELrQ5kRGQY0+ZXN6MArW3kddo7Ugad0w6FJENorTQIlVaGa+0q8pirZ9aYeWPIQaKXuRaGH11Jw5Un3Ih2124YYwZRjmKMg6FnH7DcploEftYA/2JghEZ7f73HOeN6EIVlfSD6tuW6wuXvALP9Wduy/s6SYu67KGYJ/JqHXqN7YG2BQuUf8N1/xw5YS+L00eXw70486WWtJYF9fwyBK+04bdVGDRMhtGvwT6jZ7O6MTmh0Xu6OWdrXvdV7L5sCTDa2VTNgnCcmqmvi8/DggAIfkEBQoA4AAs2wCqAAEAAQAACAQAwQUEACH5BAUKAOAALAAAAADcAKsAAAj/AO0JtHevoMF8CBMqzLePH79+/iJKlNjPIbiLCvdd3PjQX7+K4Oy1Gzly3rx26dKdO2eO3LiXMC/CfClO3ExxG3Pq3Dkz5sZxNYPuDLdzY9CjQnEiBbdUKM+XRaNKLbqy6sV0AwkaLLiwa8OOE8NWdMgv6leIHvnlCzlPq8GTKc+57Em37tSodsGNM+pUJ9GiSAMLvti05lOodxPvPAduZeOqWbdy7bqQLNqwESuOdbgvH9l9ZzM7VMiv4cV7ItvJ7emSnGvXeXEq1ktXJl+ms5k6FRyYcG/ZuHH6zJ2Y8eN0jS9mdTuZcsKvDy9P1EyWM3TLHjdf/1g23715Kl+L/yd3LmU62D0Jz667l3bSon9zLvXN2/BgnYZptyd+l7Fj4421JZBkzTnHUHVkZcbdZqUhBNp2CDqEmT/g8PMdSiqtZB5JKI3XE3BT5aUbiFIl1duIvNF31E75DccfOORM5R+AAg5IoHcHUQZahDw22FWPCU6IUT72nFSSjQWhJNdrMOWHl0y14QbfVCvudqJ8V56434uKWaXcckgSKKZXD4LGUGcKFXjgaJ1JOGFEF6mFI2X3YLgkelviFdNwJN5VWH3A9ekbfkpxqViMOv0H5qKMhnmPgQiJmSNlbr5JYZylkcWRdxhmyGSeOs2kl3yG2geokyUGqpuhMG6E6GzGmf8k66y01kqro2IKVCtzXOXEj6WXbtSPVESSFNdKNPH0E2JcVnkqlSyyKu1U7ZjE4UgXXQvOtSWZBKat1nLorT1S/YpZUcEWhaORI53nIm3w/iRltEbRh2KKrAoq7as68bsTttu2Q6073HYLrqzabnTrgAhVOtFODxeFpndFjnSOqFDG+xOq9fJ16n386TttVDG+JpXAO7mjclEqt1zwyxzqVO2sNnrmsEQ5WQpOuheh+Z27UW4JFGBYPjuyxyIf3a9rxLWcUlHmpdPy1O0QDPNGL3v7aHVvXqQznDvJqdpcGOfELNIq1jeybKpiqSeoiTHtqmJR161T3ea5I3VKU6v/HHPAMLf16JrmnrszsBs97FCdS74b74pIfzwtx4CRCCLcd73qb8p6112VlwCCg3fdU4Nj9bW1zjzPZNBVJOThX4dVYT7g3Um2vCgS+jHlL5qou+XMYs6qyZ2b9/nxjx2vYU5P53Q6SeAOxNWOCL4O+0djUSikWnCtJJ7ZQFm5O+TSkp9YUGcrfRGidaOzkjnwt+Qa/K/Cr3zUGz0P/cJuPVe9ztdDkHQURzs7iecm4ksRyMqXtKjU5GzCY5V50OE++pGjHBjMoAY1aL+VoKN5ptsfzaQ3KQddB1hgk0iEYCc7C6WmQwcMX3toAqhVqW9eVBJU8G54FQq+zzUbDGIQ/+enIeSYzmr8k8xCHoQdzPzjif/A2eEggiAWEhA13fsUxprkLPOp7y/xuZcOI3ioorzGfe8TohqHaI7lHdFg41JiRng0QCjaMYqXokgVBwin0VwoPOOZC5RqyENwxCccYcQX+MjIH5NVBX5rjCQGydFG5FBthGHyCo/CcsdO5jEi1imLFRXXGbhk6HOvouECifah2YDxd+aTzZ4YORV+kSeNkpzJBilZnjeORB6yisxWMnKdJkqkk570WloSUpbCvY5TJOlc6EalyIsgMhw2cU0RVTK0qFzzm7C0j57MFqrcIEqbuIwkTDjYxnN8MFsirNEwl1hMhyHznp/0EUMqhP84cFAMYe3iDyLRRx7kIIybgiLKNxHpwFXWhpZdqsoFczmODLaTgkasVjxJqKYz1XMi9wzp4fS5JidKUU4FKVIWN8eiB5aDHCmpFjgGx6mL9WmhYaxciIYD0eJ8zhyS5KAHm0cwdmFynsT86DFDes84TQwhFZIOFE8qJxyJJDyq5M1LCjqze/gzTekoB4kWqhjeLSt9R0PjIyG5xjZiNCfd+uVRkfqcekqVqZ3E1EIqVKknyo4jDfrjasInmIrCtFpa+Wqa3EEO2ZCVOKYiX3rU177jdfB4RsxfUechj3bIA5jB5GhH7QpSvOZ1dpEqCDi+0k9fccpTXERfRctTLa//5mQh92CsOBR6zXxpqWw3jBoFhwsOtS6vb9UC7Wc/m0Q51pV6YImIaU+L2kk5hI8R25RI9DbYnrz0HEXdCWXaEaPHlio4Tprsk8oZqpe4YyN4k8o6qAZakyz3vpi0Bz6c+9zrlna6UNwZSg3y1dB0DbDeMeVrMkhJqbWDXBtZy5AclA/yGpKhzWog+KTy0Dztp28rey/nkOvZ+y53ass1ST2WIxl96KO/0ZUugP/hVBwRmJlBMlyNUdOu+yE2wjqhMEIsjOEMs+0ujjsrYoI3Qw6BuG9H7JuJP7syeFgZHipj7jxWvJz9bsXFHo3OfwEcJ6ve2H/+/StHOvPHuiHW/7a3xYiZhszSkHlRWeyByhbbCxN2Odkd8gBx1Vo25ZXp5MqAlgc96sFoLg/EywZxMROxt1Qyg6MiFEupV2lqMzFnV6/f8bNMc6KR1ZbpqeTVsJ/uXJQ863mWO7zIwex7X5JMmcp3sXI8PksPesjK0fiAtIv1QT1Ky3i6XisNalAzkJnOMcZg85VaxBQVUXJGIalmYF+Q7Oq95HlZ4Jg1rW59X0PnGssp3jKwg12QYe/I2P6YMY0v7UIwzZR1aVbzRTCdJozopNSmfpB33CHWQtJLySJa5KvHIe5ZkTvQLZvNOt4Bj10ruteNFkiwg+3uhhhb3smmmK6ycm8017Eopf8BuFl6VibvpKObGS5rfoTz7VbDWtzXuvXU4EGcd8Tj57xedMY3jo9hExt7l7H07LDIv/55XN85GVZiQBNwM93j5arWqYa3LaUova3Ps865ifvG856/w+e77rXQuUz0ohPb43fFa4RDfTAkeebkipHwRk4t8KvD3M45VIqpUJTww7wE5yPJ8olBDI93rMPsaI+H2te+YqJLGu5jbmqcsBhNlwlMQIPbh1TLtROA891M9sD6DZ+1QMsZnuEHgziKZV+6shOHHeA4e+QnL3R7VH6/bxf9RzJ/WrVU7MnhFdw99HHpTz9x358hNctPnWCbKianlRvffdg2HyXPmvbId8f/lRv/+J2o4/zqyAk72PGO3J/95/CffMb1u/y35zveTMXIhdYh3JTMF9AmAXxRlS4BJhqlUXqnxynm0FOpon0jci9FAzIvoWW09nAmNn5X5nhFgX5RoXvw94E/p3aMRn+Xl2+mVSF10imfg1HssA7wIA/14GX6UBbB8nzggEebsXenZybg0ViqNnhpszstRTmRxXUWeISBhoFcwn4eCIJOiHH0t3zFVmmaV0ApUUEdREHq0ILzwG73IHo7YUd6tFpVR325ZVMzF4FmpX3voR4gozYXcYTht3MZeHbggHuKoXt66IQgqGiVt3wOYk8hRSEJpiQsAUT2Q0Hr0BYbd3Q6/xFgU1QWO/ggqOEu81FNIMKG3WcvM7eJGxFoSEhu8YCBjdd+5ZcYTKiHkfdzqviCi0Z/gehMTAUnhRgXQFQOF8UO8qBfGkdsFzFvvwiMw5Jyk/gzYhUo+IIqmlhNaohkoRiK4peBp4iKqaiK1khxu/aHgyOI+EQhbNY98vMa8IMOuxhsAwKGYQiMmFKM4FFwzChGy7hKJjI+z4iE0Xhlt7d++liN77B+HvhZf4hjVNiNPYNF3MUSLYGL6OAOgtOLolQUNshXxNhyVwWPnKiG8Xglg+KJgVGPckiKubGPIjmSZ/eCMAiLDVM4phVt6zIPxVMVUqN85yh1d/EZfFdA5/9wjJ3IkRk5hPUyj32CFB5pgfdYh3Z4hxuBhxeBhyPZlBQHkAwTiAOJTFK0WqllLVRDEKn1hTRZkwkoEuvAL+MDj8tokWSpjGwzlA9XlFamh0uplE0ZlyKJdieplVJ5bIOYXVVVEDTDaQWhcokhiX3nkuhQDoTFeoIXj+GUkTWhljqnMqSoh3I5mU4JdFyGb2gxY391bXRVJg+ZGy33He6Qk4fJmHA4GKbZkY45di0zfqpImbCpj0/5ijJ4IEknb3jkKxPjmVUkFXBCk8SYYOdhmKnpiRF4loy5mmv5c235mrE5mT7nh1H4YgaGl5opbRGCdI84dZRYJKRZmqnZgMX/yRvK+Ziu6ZzPSZLRSZvAR533h3+4mZuJE22PaEdRMSw7wmYi8Z1ZZZriOZ6qWZ7lBpnNiZ7p6Y/YKJ0yaH/QBp/xGZHosjN3FBUUYh0UM5qGiUDh2VBB2JNHIaCFdo/XeKD7WJJp94cdl2PEF5/ooj0TWi4pl2DuAFQaKjmsxqHIyYYoAqKsiYEG+pxNqKAcV4KehkK4CZH5F4b+wJngsYA1iphmpVM5Kjk4JA48OqA+KpmxeY0hyJ5ux6DwBixRpHS/eINJmhN+5UdX5aRPqkA3KqUeemRGcaUnFplaCpvWCHS914iXdxbY9SZkGoxnuhFTpWxXRTaxpaOzsZOa/5gqdEpldnqncXmNaIdxv9eewWdMKOSgIlWfnZqOHlGI3fUhiipzHVqqQvmobFmKWqp+JcqlkrenXtinfrqpU0ldhDqoaOpX+yCaYcUejbqo3MeY8PiozJmlraoTsqmKH2ip+jWrwdc6f+pEJ7irnwqqFuKSQEMXwVoq4zkO5CCgTkiKrCqZRYGgTainvadxC3pq0TGtnCR31opMUwFF3KM3E1UXpeqtGfkS5XAOJbaaH0iuBfqa51qNfWipwBZpJlRsw/ewgCqvuUqv9foP/UA7+ApE+jqW2raM4JoO85AP/sCaKsOHJkuwBWuwHfh+Cbt2WVGbHvVuSBemK4qrU//1olLhVxhrO9zqgB07PuAKU/bgGRFBshU3iiibtOU6olLBsn14cfNnd9TJmwL0p8hGqNYTFbxakf6SqF30ppA1PuRQWzaDPUZ7rEpLrpRqrk1rskEXtV6WD2AWZkASsRI7SjwDqsWiEheRoTcROatUPkFIGwDbae/aD2OXtmm7trqnlB3Ih7znshpXQkyUKQJktyt5YDn7DxYiOktimBuDiVEKeC11WFvDHdc1LIynuASrexdxdhOngXm4ivF3cWq3ZY8mbM9VudUxfPE6XQC0uZ3bGBrrIqfSW6unGxUFsoarKc5Dh+MHgkqre+twitU7jXeRrh9ou72mbuz6ZR3/x3eWcTOaGby+KWGf26bDWhM4hVPNorwwFbII8iBWmRBkx7op63jXKy3a26WTp2IvC2ntBmbuerm/O4uWAqGP6A+0cxEJGRNGkxPt2744gX1Fphf/2g6P8lRrYWORIhD4S67uB7vXuw6Oayi0G6sXp2Lr5oWRRmwxW7UHnJdLykf2GYb8IBLE67eKORQT/MM4Eb+UMST3plrMFsKRWsKzkX6K8YHgkHYr7L3s6sIDTMC8m7ozTJVpUaTWucAVBkiJOqWj2zEXxlADVQ5Y0bD0K31FgcSqWMLYq6wj+SLx8MRBx8JdtnHgS6synMV3pCBIR3y7yg/aiic9nEMttbwh/6vGgJkTuvIlrEupShwVlEnHd4zHL/usL0yr22HDCLwg8EaxU+VVttifPruoTHFYdqkQUnEPG+d7G1EPkfzG1kvJuDeZSDkbFrdcCrsoLmx0VIvFfjxVWyzMnGqDNPZEegcONNqT6/ES57A6cjQVzMaL9ZATSSvJFxHH53qHcomUJxwV8HdfvQwmvxy+2enJWrykvZuZE5rM9vodFyEXUOK1cHg+VSHNJKcTr6xSv8Zo8oDNKEtxBVt+3LwTsJnLugx0F6GwI5jHewxd7TzMeMTOluHOLyqG0LTDr8axiTEODkZy80APKbYcnKVcn4Vun3UR2fzGirF+3vzNb/mqiv8R0G/baI6myRF9xVx8zMRczCZ4w2Yaz1zrt+1BrISxvKozD+AgDyCZGORyzQKNrCR80OoX088Z09ICtVH7aC1mxZ3su9b50wwSXTg71FEkqjHCradKSOJgDlKTaAHN0vpre0KnEwMybAWBD0VCD2rrutRIonOsE6qoGCKI0zm9Xwv6YjFszGNNzGUti8k8r0tqhauhH6UpxkIxDgvZmiM8yU3Na1L9aEbnYnzNaH8tu3exj64qkks5069a2MSxaOCA2Lm7yTB2uLda0RXhsJWWjk80bSchF357lm2NPubgghP3ljuBjbtc2y38pacNDkls1a7a2nOsj1i9rNe4E3X/HBX0cBG2PcUtRre6fat6ZLliHW9IqrN/hKg0hJxBOA5wXb1wedUsPc4XB90CERXXnKXWHdiCzbg68d1T0Wj8/awCDNYXHcqelB3pXFqemtZ/xKakmqM/8a/XG86ETdD6Pdc64YeI7ZrWzeHYzZRbKtuJ8XN38dB6vNOTFshTqSARDlLA7Q+9mkUbO5YFZcIcfsImCn+zAWHjx82naOKwDdMEPsJumRNHmRN17MQHvhEvXsXuOrMzDMhVO0A3nuNKckGkeiKD4U63DA5MrBhHa+CxbNuQ1uTyFeDTyLiUuhGA7d1RLuRTPsXCxskNXkcVnR2RLeN5O1Ve7ikYtONf/ysO5YAO53cRjQ7THe7mdlzOfDpskr4R1fu6/GGNTN5+WqriF2GyLA7VCg6tfNzn04o96SzWXS5Y6dttkFNR5qCFZ54bRyl5iP17LiaF+wDaKwt5de7kS557TyzqKx3eUlHqex6tYf2nqr7qvoukON5mS4LZriZbMcLoG1HrxHGSOK0cmOqL25zpmH697fe6T569s1HYwR7qTkjOd0F0m1zAfY4ZC1IdlRvIN56tBnRB9dxt/jrrjE5Btn7uG7Fo5ggOyB6F4CBpOzGN1XuUl07Y0yLb382HJtbQtI3XVR6+Eo3qM4vvBaydwG0hVeMpE8Vn7PFdBF9cLW8ozRbLCv8uhUVhvbFL8Qbn6d7t7k/Ly/JXFOfM7HY1s0hnHeKbul05sSZ/LH0LXCvPS+6EDhcxXFJvKFKtE9dcdFSnE49XfiVJ7CxtZYVkhzrPsjtfxyb28478vfUn9Dx9uNExkacXHTkjqJxbJ7YIDqALXNb+UrfkQS1P9VW/snh+8CQdy1r/EQ/v5Ic2fizNQ/HArKMu5G7LvVcfEl7d9m7/8dcl8pNoGjpBIX+M997j79buYVvVTghpDjsh+CuLdiF++LVddCR/ik9O0BuBj6H+xMWuNGqO51K+Ez6/8Rtx223/+VSbn8hPoWid1koSjuUwKv+OGH4P+B5UFOgQP4OvrNr/C+Kzrw8zG/Hn/uRlZ3s5Mdf3ZXB3brIhbvlRYeqbj/yfvxOKP7E6Cx6ABET6cfoYpPoAcU6gQHAFDRoceA4cuoPg2IF79y7eO3jx5NGjV88ePn37+n3ct29dRIrg4MEzeFJlQ3DyXL5kGVPmTJry4ll86RIcRp71ZOIDeu+ePqIdQx5FmlSp0oYfnRr8F1Uqv3vt0hEkl7VcwXHjwHXtWq4cOXMCzdFEWJCgzIg33WbEd8+jU377IEZUmVcvyoIWW8KUh1bw4IY5cxrMiDbo0KJGlz5+3HDu04JSpfrLZ1UgOXBawX712jUr2XPo1tIcOJMdO5JuL9rr6LRfSHD4//DuxQ0unm6dhg0eJhxcJk+MwoM2JrrUMeTkdg0epQzOn+WomOe528zZ8+eCY7OWHWgO3XiZCVW3vimvHj6PScHZs3cbd8WVvwMX1Gn/vnD+MXnyjws5AQcsKiTknCsIuo/A6Uc66v6xzp2rRutOLAu36qwcc8oCT7zxxjsNnIQUYqutm+hh7yiiwNEHH/jmUym9/Vr6Kz/8gOsvRx0bYoxAH31EUMEGG5yOOn/2uW5CrQwa7buBPoQyyig9BJFKdQ5izTV7kNLnHqC+xAdG1wDrzTDgyMxvxobo2bFNcITq8Uc5k3supKeIfPDIJM9pUqzOnEwn0EBXW00dQw9F1P/Q8dSR8tCG4sGoHn1mC+kee+rR6EsYT8KpzJeIo8fGGkGl6T+DfGIJUzdjgjPOOYGscx9+FiyoyMsiVLJJchIKdB1fTyIp2IgIJTRRRo016J31YqtrH33eq8cln+qZz61OzbyIuGzZHBXU4mRSNVxMUQWH3FVZbVUootJV98eDFKzVVgj94SefPckRi6yyxuvVHXfMtNbaYIk1FtGH2JEnNpAMfPPSl6jNK+D0bszJW4sv/rahcTfm+FSPz+WRXZFdHTBWWv0pcjp/Zrtnz3M2FIhfX/2VZx6O68HIJoEHXg2cgg1ljR65klrx2YM00kvi/czE+OJxZ7o56lTNPcj/Hje9XIzdV40GB16UU155H0vbkfAqmdeB59+a4dvoS/hQtfauiBwq9FB2DJaHPZCKYpElZ7s0iVMZ0TSs6YwJ67jcjfmzeib4BAPzSzi3ftdOIr+et1575iFb0HTQhucim+GL3G2fMLpp7rsecujKRBHWWzYEJXNP8MGxrdjw/lDl/WnGzy19KJJLNvlyzMPOZ3N/16E5I41IB7MgoNgmd+d3GlKnbnXegW0y2RNEih9+GPwo4tuxLcjww3XE9O3fQY68XTkrn0u6r1WeLfnrXJpnHuhLx8fRFmeQnRmEWKtZBz0cQylZNaggsoHg15KGu8Nsq2kge0/jgqNBlnBw/zDB69Lw+FanWRlPZfTah/769zwwtS1yp6LabgJ2vYIQqoYKtByl6vRA2dwPZSiJEQUBoz5urepxGMwRUAwiPBGuyGT28+HeXMQ2F34pJgGUiVt0I7CGsANFCotOQYbSNaf48IcRE+KnLoZENh4Eiw2xomAm56OGKAyKUXRWqwD4Ro0VZHFs0uJBJOKQd3xxgdGxi1CaIh2D+GOCadSWS0yVvp0gpo1I5ONgmsi1gtjRjCubTQiFskeoJW6LBaHhFjMytKQMyYFSXMzsUmK7NFpQjUW8ZC4NEsA4okVd7ZJJchz4yb3BKXq16SV/boKY7kGQgTMBHOnuwZKAUZBUa//UZTZrg8zgzJGTBhnhR4gZSi9hzW3cPBphlmmRZXlPNixqDG0SZLT+eXCL5+sNEXFZyXRq003H1OQ0OWm0xvBwnHks3ak2AsPBvKWdzqRVl47jxK6hpR9jwp0+i/gtbqnKn4RRohuT2aaCltGMlJLoCxnaH7iA0ZmdNOc0IafIvkBSnwI0JQyf5ruGUNGnR4Sf9IwTE+SQrx/HA6WBzGnPmayPmcKEqAMRakWZysRAI6yl7nay0agNsGPjsudPffrR/hzIqFFkoNE2wtThAFKGLXXnOzu5Lqw1Tl3gA0cJo5rVa5oqY87ralcV97z3FESsYyUrYUjmHHHej4HOMsj/pajWVlAty6VynSddl+jNHB71k3wlzlY5yqaeBFanNwOqYQ+bWiNmkj/yK5BBv9aPZv3NsE9zaiUz0hOOCOmdDpwnnA7SpQIdpYSf/JpN+zpa0QoWp6hd7WGRyNrXukqejUUZbf/mRMmSi7R94VakMHXZMD6nKDSNUytNilx/KFejpRVXP9PZvuj+NIOJ/Qlsm2NUz2r3vFgbLNwytputboS8tKrjf4dbIGey9yDWfK/FPCq1mIC1vmJVTEgvOdER8hCCSlXp6dL31hO19LLk81tjaLpgMLIXZYXJaIQtdlqeaoy+F7bvTEaKSQ43RK8fqQtRVJrFt2QEqpjVkVFm/+VifxzEKRCWsbcCezM/3hjHiL2iFYf8Tw5zEoJBNqcVJ6ux3saVJcB9V0W75pxnyeq4n4zJk2Mc5dBWecq9e96VsYxOZPIyoatazAhD8uNmpXSK02pqb6NaXr9BJq6ObXKcmwVlOpvqzhO2sp6pu0slbrlNgeabcWX3Ny91t8Z9gRRHFo1mNMtzzYOWlfccGx00F6S2+8BWqKLMMfFeGrqapqKG+wxQTMYJfG4G8lW9dLM6Q0pSnY1zTJDyHPHRtodoPcituUSUXNOZ1732tYWBzbZeAnDDPTq2m2elbBd9u7KKRjJhZPnja0c621fddgi7veuN/SfcGxt3sDVMSv+hAg/dSKHtrVNqapwRZz1lhqBgZneU56w6JoUekDH3XeniOPzfeQ54QkXu2jYxJlYeEZ+KFj6u7261zHPRa38QficEsyTlV6VoXe3BNI5j7OMgH7eW/UxskHX41UDGeF071vHuqVfmvn1pupVD0V3Ch+c8sSDHfx5wgcfRz9tEItVfPRl2t/urlnXP06Fe85PnYzmNhnHusE5n0cLX11wndws7/fWiG33mKG3R9MYFFEwBpTmu1lFn2X7s84qd8XG/Zc7oLuV/4/1/09s7n69WUKk75apfAmtIXy5L4aydVojfrihnAlnIzznCdbf7nS1/+bYNW9g6gq1zlLIwQ3v/lCNzTTt/0h4dzsM0hDkC7eslHO7ZV7GKnu6PNzsydqWEEPSo4khzph9MmixlNixR/VyFq9iqJv+9sAe37Jvvtj1+/fZylJ/umbNUVBk4+ESVNsIRVOuuhR+e3+wgtnmT1nO9yQOsypu99tuyN5IcRUKvkmEOISO8SyGd/QoStDg8imMQwfimZPqmeqgnpqqlrIuy9Pk5oOM6BSw3N3oT4aqqAbGLxyiK6wMTx+CP4nK8/sikMfKj/vEfVhnBniOtA2S+9VNBLDqmkFqx/ysu2qi+GZxAw9uvGyy+c2EqTFmbXaqqGhEiIdyqE2y+yyO4PpOerHnB+NNAnINCfCi8/+yzQfxCC6oZl3kQozDDoiDsuS/cujB8ob3TMtuLi2mSKeFpwlhbs3WJC7dpmwzUQZbAohwUjE1TnMQ4r2PCw5yRO8oLLSIsQiNUwTLkOx45EOMSn+DqM3KLJwCEHDjKGqMjjLVqHO8qjqExtE4awWyhoP7xOEyJPQTkwyO0PZlIL3VLtiWqjbfJFAHRwT2CLZbYwiy7Pv14EwMRNn24xYvIxXnYRV7kxE70RAUMRlaJp8kwiCCLrO6SQkjUMQAKvP/iQeMAk1OzrBYxLP24RmzRxdhLP18MQzHswx0To3GMOfMSKnRURpDao6ISDg6KnFhMCT8SM9+5x2zcxoazM/9+7EdwJLo6HMfFcyNkNDBXhJz2E8lIbJw/86O+mBtM86iJxJ18TL9vAcN+FECw07JpAkg0nJWDeLG+gZbQK8kMY8eglAmGbMh+4paL6J1vcckudDjxogc6PMGoCThWtD2c1LyAbI7xaYieFKrBc8PgOEKFfEVQPMqqYTm/MpWmpLSnjMpyCbCprMrC4iY/fD9wOryYsLdj3BgphMf2mytIJJ228akxVC3J2gmYoBGD8BeaYcvIc0upjEu55LpdIsOsTDCjkAl7axFTC0uxBMe5CkCreb7Gcb616in3QZXAUBNwaEy1eUxJwhg6vMipzLMM0rPIWkGaUEfwC7DPRMj/0ISnzAy8sxw2tqIitMiI14xNyPQWcJBK26QyYDvMgsuRvYwJyfqS3oRGw6wjLgkzVrzLPWMJ4mjM5sxEUKFN6JTOX8OxNsLODmpD7nREwBSqTFoOusokcmMq8qy7jTlP9JRNi6FDjLCZ9gS4K7uk6ZA2RapB+hQpc4Oj79y2CiOsCkNGG4uaABXQ2dTGqETQBL0wXfoHacsHLxk2CDVLlPyJKiwlC/UojfkpoHhNx4xNDzXQEBW36ILDrjlRswSpFd3IKzIajjCd4IhRGXWR0qlR2JzIbiHQAj1QHRXA1epRfgCcYRtJYOyggVOtJZWsSQKXMSuXwYTFjWhS9OFC//dST12cUun0oxFNIlWUtyyFvp4SOgklMzZEtMlEnWUqpSSFISqasEe60dnElDdFUDmNvmFsIP5jiR/FTB0rQ0B0EU4jPHKRwz8NJMSIvQobLJYAItvBqHtsmgNV1PasrxwRxB4JH49sCEkluewUvaHDPA1qITJNH3oAVFSDPSrrI7iUCRhpylNNVB3NtLGSRJrIvUErIcE4UV5aRkCszxwJLUh5ylDtDzHBJ6e8GFRNVdtcVUf0JUetNkh1MnCQ1Uj8Ceib1V31D+chFdFKyRzh1mvhqzXZCXAN0TIlzX9VjJnQr0GDVXtbGXWtqnetMj67U7CLVymDL9Rho03hjf8yoZjCabmt8sEVWpyZlC7ca9ZSJAz+U1ho0dK7ZMEsWr72aTfd0Ndz2YuCgE0CvCVKisqNZck9xLAtdcaQ1SZbldaAPZUiwtbKCj023Cd4XZX6kMYHU1P029j1nMxww03/bNeQaRfj2pGgFUrRE4wYHbOKPCai3SqYPQmTYMzWRJ9s8dSb9UFEy6mp3dHk3JFWmULCaDLgKtkI9TrlXA+2mrEA4yCiFVN7PVu0dc3EpdkBbdO3ncypERewqtplVSyipIn4BM0hHVMyDdxTIyDeKNxt5YuD8BeWaEueiFo7U5ypSZWqqckgdcZOIr3BoJcJ7VqUPYgi8txdnbFT49UJe9KZmWhNcAgIACH5BAUKAOAALAAAAADcAKsAAAj/APMJFAguH7iDCBOC49evn7+H/hQu5Mdv3z6EBhNmpIiQ37126c6dS0ey5DlyKMeplAhOHMuXLF0edEkTps2E4WzmlFjT5jiFKn/+vEm06MFzBwcSzAiTIj+IL50S5XcwYtJ57ki2AzfP3jyQIlMOtSmurMyWRmeaTctyJ9u34IKuhEsXHFKMSgsafRrRal2Gfgt+nXcv4b2vJMnNRShUrtm1byHXBRfO7eSbQeNqvmxTJEulTNP2AxeYrkOF+e4VTujxK0i5sGOfjTw7ocyyNy1zJjp37O7OClXfC/377eii/FJ/FRsUpXPmmdM+nqwbJm6ybH1vLi7xLsLV3MMr/6R4mOTJ5yPTgVUMW3pPhLV/X1d4Pb54zt7vo0799mlT5SCV1E478xQ4TzrOyWYfWi3Zt2BkRD34koT6GbVVccKxRZV/TSWnmleEDTfQgedBNx99NFFYl4oMVihefnTZUxxoBTlVmkQU7QPaPhzlE+BzctkGX4MuFmkkd/MoVKA9MrKVJDhMgiOciAJR9NBUTmV5UGvmJRjdTLZJ9lJlOB05ZHjkgJOmmUrSZeBBSdoDnohWFnWjRh+ZVOJYZz12okQ5uVUdm4QS5Y6h7hx64YAXvmVggQg1WVA+PJJ2550sJWcPo3oqRqRaDf5ZZmWDRugni4VOtg5MibaaKKOwgv8z4EtPcgUpnEzGSWdxHoI4YGIr1SdhfKWa6meq4pVEkk3ruOosrNC+NKtEBsop0EVUYcrWQPf4iqBKaw21GE/yiSodsjaRhM66MKUDTknrNOvsq9AyehlVv1mUnEDdtsNekAf5NttZxVonJrr3rbuuSDCiAw676Cibzrz12rvbcThuKVWmWVaUmr+xfQkTmWzdhirCdDHMcEIqqxyxss/aO61R1d7EUccTcYTQnU7lc+C/7eVWcEygpqrdi+eYo7Q5CDENjtItn6MwSa7K485W7RzK0oCDPVoteOPl3PHYCV05HnntnBTyuGiZOyFubqc1NMpPm1PO3eXABLXLJT3/C47WCkHr9aOqhTY2Vf0cvvHOZrP2cYle8nnqydPtttPcheJ9N1F7i6TsOvAkClPFBHptrVI8dgzRQ4pv7BBUjm9qEnRBTU6W7ZyRTPdLmufNeecvp9PsS/KQXvrXVA6UOkWvQ5R46xrD7vhhv56n4LEGV34QqdxjrpD3hGpOlOadSy084Ai5I0/x9ZouHGjXOtX86v60jq+VjWvML2Jqw4b97aHaXve49xbwhQ9v49vcTdCnvvY9iklUmtRAsjQ/+tlvSwt53dn2Jbs9gQtc4tAOZIg1QFKJQ3e7m4zmVgKwzSgQHHeD2rv+hj6EmI5JclLNS/TFkb5ciX7+eB7O/8TGF3D8gzXkQUxIgBa0opQwHGZRCTl8l0IV3m1tIUMI3qAWMXmJZ3EKAeJDhFgRJELkH0esSv1as57nMMeJJQwhOUbCtbSR42RVRMgUy+G/x4Ssd+bw3MRqaCYxrjFHhrOUP9I4PdmFhGHP4aPQuFeWcYyEMBj5yB2NFLe6pMkxkwuhSvgISPOdz4Y4nNJAcARGtogxSzrSCP4WiaPUUI9Tj7TehAYoR/VIRCDtMAce6XKw3/ARhCc0oShHqTmpvWxVW1kSBN+3I/vhKy2vRGRoUndGNDKSIvz60K+6JMlTUbKX7QCbRuYhzDzC5ZiTg2IlmVmOQJJEXoDryjSTh/+6wzWEec0zokBZks19MaVKfHmIN78JznAWKED9M6c8xzFHAqlTI/Y4xzAv08m3wDOUy9ziSIanpK5Qs588HJtDGgLEhTIyjKvr2SqTYiOFepOVSunXEo85jsmV45IXRc09NEqojdpkisj04yhRYk93UUufOYTf8uxnSJe+lKCsMyh/JFhTICpEiALp4L9OVdFa2WQf90jH0Sp0m+Kg5IqxKQdKGHbPhAwulcOhEg9TOraqWtUmEGloOPHCTUNmCkBLBCVF1SOpm6BVrakyKkuSZo63yhU96aGaDfV5Q1Vei0cWmWrHKrhIq6IRsKzjlg7xko+uro5jHyNnUH5qUbD/EQchPMoHZAsl2e5ErWV9yycOc9XZk4aWUqH1Z0tNi9o1hhNshWvtLF+L002B5TznIFAOjcKjtK61SMWEi8TGO0glDXdw1donP5EbWr4u96/N3deUDKMU+Xm1bB7zSoC0Upj+ctcj5/iuE1f0G1cN0lVP5Sx6b5hDfrY3fvbtpmlPC1iPzVdKnqWUa3nmIddo179p6e4mqUMZFLozSQtG8fpWbKB6DDfDymtvhG06YQoTNHE6ypCU9hlj5lG3lra8sJS4i9Y1FZBM3XOnrR61ZDgpJFHre5SLeQw/5WVJwjW2MUzBKRwZdQuvep0upjyWl6DCRF/2MLJRSEYqyigZ/04pNuuhnMXiedRjyvjAx5T0oY9qujbLC8VqRbp8kOFSubDS26COZkrkfcxDzTpJMgHfzJJbwQQemF4xPehx5ynbI89T2jNyfYzlGmO1fqmJkqHVi9CEKlQiQZzIRd4S2nlQcWRtFuAAkWXp4rzjHfEItqY7zaQ86/kex1ZNn5PLUhpnWdC2xCFnwSyi1M2PkS/FsUVuu0PQtuPWo8q1rndNKJW8iVpFiVdCfv0OTAc7HuvjNLE/bWxjK1sfoW1I8wCtZcZ5BIdwfuA0IXztqwaxIsclyoO/jZDLlbDEuksyXHprK1rdJF7rYIfGEfIOcLAb2MHe9KbnPVxQ34PP+P/eh75LPWGCdvhWC+Yxj/ZtxJceHOHcVshx7+GOnzyR3JaReMk6apNe2xUmGM+4xtnBcY9//N0il3en71zsPKM8uYBxdsth/fKvHGRAUJZHegs381dflTSJA8dFco7bbadtHD8n97gnTRvt0cysRIEHxtmh9KUzXSEdB3nI5THyqVPd3nxmdsG3XsvDfOVqWpuX2KdMU5pveSFJOatF0uq7uM/953WfD8WJknS/m/7v63431KNeeDzrOfHWXrxLYeIPALVqHSV51z1DF+W2v+7sB0n7QWLZbbQGGOK7DnrcDaiW8IpH73s/vd8Br/qQs771VT95ykmt9ZtiNR+OVJb/wtj1LtDBAxxilxG+NfgSjFmk+Gh1GpLl/nkCFutU8IGbkTAdr6Wr4//Sh3rsIHiqd33YR29XN3Oy129h5GhZoTKBtDRc9DLsAA/y4GLgoA+AQXvaMnzt9Wj193CeZxQOMnp5F33/l4LqIH0cR4DVd33EBmqwZ22rM3u054AhYTe9s0WBtC7qEC/u0BVqRxQdqHZKwXDLFyhKOH/i9jbOdyTQp3QqOIUqiHrgUH1YGA9RF4Ovl3I0iGUVRiKVtYPkIxLo8IOgE4RyonKXsWip4VRJ+ESTYYJ1EYUaR4V4qA7Ul4UvKHIuZnLLFns1CHw74xHuEBZ4IxekVE/OhHHv/6CG9zBrdbFt4IcUcSiHE7c779B/d4iH46eHqRcP7MaHW4hn0ZVSBWcTybEeiRhX9bQu5geE84APbJcQGJMQlOgza3KJ9Edpl4aCKjh+CvN/gBd4o5iFW1hsyjZq3EdLNyhWcPVH5oAO67A+emeBa3iLLKGNHphj31YWvCh0vnhpm9h3KSiMwwiK6/Z0Lqh6hBeDy5hSg6iKPsOKWDQOPzUx8yAPeheEJ8ch7ceNlJhWDRKOdDeONlGOnfh/6OiDL8FuHneFfEh4nIZD+NB23DdQL4Fqh/GASLU2c1SN83CN8rCG2nJwEuGGGdUS4Yh8CJl30NeJCkNZ03iGVvgS7/82iVlXWjeROKkGUR8JG3Okj/Lwa/6octoiRG23P0iRTEn4knWxiTKJDpSVNA55Ex0XbBJxk01xbUWBYx/jkW5EDvbULFbTLF2hD6cBa2OkM0a4P0zjlMsHlUdnFFLJDv/nMkpzhnSBh+vQbuuDgaxheV8pX0qkLJm1Du1QZ3KylmyplBKUGu5QDuAIem5GlzaUFvBwl+owfjXJl0YRDweRh3wHmJw2HhUEE1r2PDnWLR4mOC82HABpcDe3dvxiD+7yGJj4kgJml1K4MGZ4lQoxfRLRmZ+4ggMIb/ImKTuZaAdxRDZ4cwYVatRJdmV3ams0a7fZlLrZi5RGDk5lV0z/RhRSyZBUmY4swXTEeRB4iY4AuA7WVw+41ZyJZmqMA5bKU2VT1YER8U8DOQ/caRYPN46WNA/XdBlSaJzpyJUsCA7t6Z4rCDpRJp/DR5/S82xlc0jWpG+OuZEHZ5sfYQ49hX+8uVj3AJCXUZ7m6YMrmJ4bt3EOqqDHmZzviIsW+lrd530Zakg+9GM3UT+2iZuhMh10WCGLZQ9FFGeDwywLOYVL9xIwCg4rep7v+Q7ywBJlx6ODyFw/WoREWD+TciBx8T++aKKt5Rf1oKRecxN+N4XsuZU3uaI9+J7nFxwaRlp+xXi0txtgqiNiKjKUZknqIZvaqKZec6U20aZVyJUv/6GgNQmAHZcQehY/eMqj9smBN0GI44FWf9qbu2Om11SohmogiFoUTaqONyGjNtlukWJyCKWleQpfe5qpRYFWIAFDLOGpR4JOrdUQZSOeo7qPbIGXKWgUxLqokVpoXXinsCpGl2oUOlpzP2qIMME2RgOekeiWMBGs+1iqRlGsaZGCfpes4FAPxwZ7Nwqrz1oUgZYW/9APPvISQbNRTZgW2NpKGFFSo7piiMqvRQGuxsoSn3Zv+lKp6rquNiGrmVp7Yuo0eRMb3CEoTagS2TUclWIYmQclUbJkhuqv6LdiROGmdWGKCcgQBqulCKuaNmgn/CCkSNGKTbRmBtRLhMF22/9VaCDCrd3KrysmmgfxcQlBhXSxnF3ohSbbrLG6sgmrp6qYJ0ixRzxlreIhDuTQDvZAEDbRLerErTzbtfIgmvGwmRD5ppOhhUR7rkZ7tEj7Xgr7Ein7EquRg28Vs/dRDulwtTlXRgeBDwC3WR3rtfyqemJLrnWxelxIsKh4spbKtCzBuGyxRy0UHlKUDjVbFMgWJRTKFXWWYoDLs2CLab82nHRhfVJHb4i7PCu3tizXrs3loz+KECFxEB9ZIXZrUniBsYbxaQjRaeBADx+rpJ3bs1r5s4TLqDchbH5IdcrYZ8xosqmruhjaus55g7JiFw4Lbr/xVu6gY9+hDwhxkUb/UarAG7xfO7wRyR3JW3LCEYijpbhs27bYOb1j5rQowVYlESJ1aa55ZkPeemkcWyDk67kKMbhs8Wtaiby9W3jqG4+ixaErx6GLC79sST/Y5LQnUUANVyriULt4JxGC+b+aW6pW4w4Yd6gBvD45iRCYRsBFMbYIsT4JXLoWSU2i5bwOfMPOyqXSeyOYwrAeKUnkAigOx2YtMUdB2MGES3UScWzfm6bWGC8n3LXBBg+iucIr7MJYSbgfW4qepozVhnUA9U8UBMHvy4ATPL2qCI1swWZ0Z7eiUxQXeGetmoF81sT1QA/WGMWeG7Zha8Vsqp7UhxDCRpEHGJufBcbWpLZl//ylaGwT/UC/xzRgQ0wy42AOoAMXyru3KOe9UDJ1B6HHgTvFfvyzUIoQVghsggxvhCzDCxxjiGw/z7u6RMGhcOEzO6WrunaZbZaPqwKTPtu7CaG7e5sQmfuxoFy+VoxpTVfAvzzIUVeuXezFJ8deYPzKY0w/OgwT+kYX/IAYSEUfLZLB5DZHUZoQXEm4vru7xVyuLKHH1ZfMyuxuxYHHyTtvJjfNh9xe+uxPzSbLLpInYkEkT0hAlSycl0F4L9FYxky+fDzK6yYe9Nx69nyuO6LPFs1XsVxaSksXmmrL/TOiYDImlEwOCjOaUnrSx/vLH+vJ36FOwdsq8FynLqKchP8sn1NXdceWD8xLzRedXKhLWtkMF4R4RGKFTM1HQgHjTAhBjOZ8vJ98mvSGEJysdu/30okCz+Ag0yELgGxBeDVteBaZbHzmyj0tY2GMzYDmrtIqEf9woGpSOyD1Jz9FfizB1A95EPImqfiwyQXbEMEbD+6wwgdRp5up1aTMngAIgE96vF7th3Z206ZbOCiXz2U9VRmd1nbCugnxD7WXEGpGpLiDj0pzEA5TF3FczANbGNunb17rDu8m08qcEIY9nIl9ekTBryL32CSX2vfGvF5Y2fJz2TXWgfsWrQiBRmwUEykSSjA0jU1D2kRRzvTwaTIix/qrQ/jmvDwb2O6m0rH/rcISkawBWM42AbKbNg9SF81ivcmBCNxhrEg5ikZeCoaNW3uOZB1HfRD1NNosUdJGob/VrazIloEK2A/bvcJhK9ub+cfjvZ5Gcd7pvWqhNtmUbdHBLdxWlT+nptmb3dbUE7tEEx9k6TQw4d+ie74VKcfAXK56pnIcOsIwzd2zbawNvnGhq8UHIZrxls6sPMPUyd5lfeGxPGFj5MgSppHH3dbgd12fDRO+w983UdpNjc53rBD2sH7bvNBX7dBpoZ41/hbxhteQ7eM/noAXLeT9rNEu1ZbaPI+Ny9mIBSPFJFcwhEBsgZwDqBA0fRDmiuW3yK+uPdjfDRMd5+U1vthp/+G7PA7WYW1ve6ZsPY3mFUTksdZ+sIMp8s1GS1S/8kpFgIS9MDGuMNHntGwRfPbGCZ7Vg+6ihx6AxYjjCSHRu11v96x9fG3WNpzmOVrkrEQaiqSySr4pYunk+g21ZEg+jcp0gRfrd7bXLj4a+6APyAa+4K3qM27Ore7qnDHm1E3r4NvbM4h1OLylC8XrNrqj2oLcSw4WNuHpx37sJB60LXq+eP1pfp6BH7Kxb5HtVDh9oet0/54Wu93o9Qbu4f7TZLzrN9d2CMGNbgvnHw4jCUHnWvTu8P40Sz3vClEPkZjlaMUkTrzvDtqm2e7vN47Fb9HF37u3aHvriDzu3deWOv8jiWwh33Hu5JBWN3Vu8ch+E1feEBeBcnx7xzC876aH53jZ6gAP8LDOFn27v+AAiED+8gm/65BJ8+4K8Up0wW+hgzxv54C3u16IYdNuD/UAsglZjuxZ8g3O9AFvJAb/25JO7t4URM9zGfLNqUCpJjYR702zNE9z7AoBiqgsD/gQWlIC9XzOuyyhdH3H9of+cZL/9vph8Pscxrqe4WKM95yt6Y8E5RIf5XUjgX5vzmZrD4ivD2aPgfvL+AjBiYeO9JA/+ZKfECqNIbZ+8Aif5pp/98P3FnXfGllhHp4BF6AooyIBNXu5bn2uchcR7V4RmOzM6iWv2JA/gLR/jNXHHev/a+a4XvVrbvduifW2yNYL5RFZYxLkp24s8e+FfvRT6kxS/g70gOUeuGNnrz7lqu/X3/8AwU6gwHcFDR4sGE/hQnngwDV0GFHiRIoR793Tl1HfPo4d9/EDya/fSH8lS/77Z9LfSJAcHe6rGBPlTH732qXDmS4mRXnxDoJ7F1EgOHVFd8Krt9FlxXv47NWz5xAfvoEDi169WlXrVq5dByI8qPDdwngNIe5Ea/GiRo8dQ4Ic2U/lTJMs+S2FmdbhzJn9bN7UiZbe4ME+tVY0SnGdvHv7+sHMqPeeRK1Y1QnE6pVdVs1ewYYlK08ePb07J4PDyLbt25ByTdItybJtXopx/yPyRekvn7157tzFrBdceOGCh0vHw+d4JLh9GksL3Wy5KGbOXat37oyQrELRo59TvJg64+yPrOOqRN/vbtvacfvdxu1v371582I+jRicONe075Iqn2iffPR5qaL3HIpOuukSvAw7Bx3ULjTRBvtOInzWUm01885DbyX12DPQtr1w+6em0yrCbyJ6DOMvJuQ4OrAifp6jTsEaG3wwx64i3G5CCiu8ULzxNNzQPSNHArE9EUksMZ980AoOHNIKY7EriuhRKkYlwdESMQU5y0xHMbfikSEfSasQNSHJYw2uI91rqSOKRDLSIX9IlO9JC6+UMh5wxDpsK4f8S065Lgl0yP82k2Ja8DLLrMJsTEmrAktCwn58LkiNlCLPrdbejHOpiD460k48+RlwJ8L8/BNQ46AjdCP3AgyPOfdKimjRRyflFUIez8RUr6nCy7BTT+E0NkCO6FwOnDvxbO5EFSnc7h1KK8JHKb30mQqflwx1Fr1ex9Xx19Eu/W7YNY2dTaRQkxzVI2bfexY39fSRdtqJxLL2ymwBLDCmaO0h+CU6F3V2nXU8O4hcXhGCx8xzCSutWwyHZDdjOQNkTt5m66XrMXy9BYdkF7dT8b9m420OURgdwpe3eaJSrkOt1kEIKIMcfvigiM28dEphL9xUY6NHVdZjO0FOSeSmjmNVIYnq+bf/y5fwPQ1ji54qmFT0FGZnYZw/I5vnB8GC5+eyuvuxnrTULdroTjlmua0DT8ptpY6aMrlCeqq2+upuI0JUopELBmcjkUxqeGyyHy8uu4ZzhFxttoONyeJNMZbbI7Q6nTHckDnKaCpwooyJNKnpoRrGlSWKlu+JCNQ6cYdOXNwfyHfn3VpKH9+Rd8vP/O5izjuNm7adOPWcy7n0bm7w1CeiWtbXYc/oIoeiuh21eN8LPFfh+e29fLC0Kl/ttYkvzfghOd98c6RjYt4lktJruVu3Kdo/InswAhj9sjeRvo2KTs7SS1DIljafFERn5oNg73yiEPV151wVMh7p4uccmHEw/zL0mw2XXFOXaHULH/ujWP+qB66dtEx7pTmYPyoUFHCkDR7vYKBBHhhBHpKNLBX0UZrct0EOEu6DaQmhCFWCJG455Sluo5BwpCKr0rRsdrZLiwwrZEOfmc+GXOwh5LbTI7alSU1ElJ8ZvwWi+8VmPk45HepSSLXkXE9gR4Rdcz7yETVSBIw4/GIgvzhGCsJjh2FMCCElNCH+cQ8taMRjmgiURA7FJh/3KJhw6oEmh6xQRAKzogCtZ0e0fHIigoyYIBW5EEM6pIGPG2OlVikx71DPkaYRUhrVOMnmVVJvMXuiJjd5usY4Ri8b2xRFsuSa74QvIqy04SylOU1CjoWalv+q5dRuictcFk6SkeFURHwpMidqknVTGY8zhcjL3GkxLXBJSzwGec0xPpOe99wOYbyDutNtEy3hyZckE5ehRI2QhE0hmDCr1sfSqHNO66kQPuvZKokqckWEPFc28+NPhj4nfqJqY2weg1BN2sN6HUXpRNajvJMpkoGurGhMp5lRTsZRiil9jvtA2sa4DEw42TIlQx0KytAZzoxRk1pMRCNTelqwJxNDVyc1idP26VSclUTSGwlmj38VtY/Ke50M3cmleEXSIqajakSWijKZOvVy+gwaxaR607RyU5ciPNJdgPkvUaV0VlXUIHjQWleJLISi3HFrYtcK1Us5Na6s65//TSNb1xNFxn2jAhXphqWtlPZVIuq8y0C9iRo4EnYnoXlsaukBLNWmlp+S5ShKpWXZXH7rTaQjlmevatq04PFpvDXjahX71tbGdaoVgQo4YttHkwH0srY6UkeSF6A6tZClvC0tcL9TXO4SZpPH3UmUEJfS5taqmy+5Lek68hjYoTeoO3Gmlq77SIQqV7t9lGtxwfsc8S4XSBJx7nmhiyz1kipe3/srReb7rUR9a7QbY4rpnOjf+6roShQyLl314jaojLeuJhyie43kkvWqE0YLZmmzaGObZCp4wSWbiocrHNwfBY2hHaYwcy0mYEPFBaK71e386NaeDvISMgGdcZLv/xuVHAuLgCYkWotd5x4IJ6rKykxckMEnQpi9cLRVRbKSxaxkknkLyiAu4pSpTJsXG/XLpcFamHdCsCAh+c1jxjNVywzjM2uKZbeVJIk/S8rZyS4iBfTf6ezzvxca8c55hrQaB8vnPje6Yz1GkhnHk7QgT4RviPbe1BbN1dNU1qyRRnXFzCw9Sp85XyWmsqaTSTt4ZW6rpyNgfvY3acM9OtW/xpZUWN1nVsMM1u/16Aabx1COYmQyrC4isKWNFq4S29owy/KxD9TmmFzM2Feu0Gt/uhECQbs500b3nK1NbEd7ZM11DWdHh2khx8Akxt/mdrp/Xe11n1m09UtiWs9tRv+S6Ue4Uzy3Ex2tb4Zvb6sP7zfJiiVo06LxbSaTojxaydUmPhnUDd/3w0Xe7yInceBOzulzM1fA/WmchjjuJMhlrlyRj/zayaPNqSlSbGwVsM5vU1VPWqnhmTM8xjXv92Q217xoB/uReZnwrof18e+IpuhXh3HN+U3srBWLOU1/cm8RVU6pUz1NGkWR2bF+325pfd3aW/pSWtxztX/QW0/MtdOfgzmIBKfaa4d025FubbgTFIsX31Zk7u4/ru6E54I5i0Qgy3HA49mEbie80jmHbVWL3Zsf/HSwzQ5qVjlkMPtr/JgnK/Mz2xzKxKLd8U4O9EDnJc6JPjRaJo2myFf/HtXVpvPRt1pp8YiWPb7eU4WY18HTbNPsqfc9w4HPb9eDuPheP7zujfq2zQvbKa+l9pyjn+rpC776mgKnUjyo6aHNGjilWb2wx5+mJuuFyUc3P8St75z33RWnJtMceYs5iYC++ROzhyuZ4Jsw/dsx/lM/cCIsXqs/6tmvyCpAApxAA0wT6YGywdusNHJAsNs5qVCjbYo/6gkvDMS1o9DAtJKwVlvArYuyuSMi2iuZNBEmySusqTnB90OLtGlBPZOwiNOc+CGcf0M+XtsTJZyrHuQfH8yP5wDCIESpWyNCNDPCXhNBgguvm6qpHXxCqVpBJ5SIKaTCPro1GEy6DVKLvH8TQh2MQr3AlNOTLDKsCDM8QzMqGAWMuAxqmcLRPBscmr6ZwzhSFcOSkiiKoy/Ui9LLQz3cw+Fbw+QZoCJDPiAZrGBRxNQhCynJDzRhxEcELsQ5v9dbF9wqNTf8v92LCO9ywsIQDFGcsTTEPFfDuWg5NBNKKzpKHczZHkSLB1DURKwzC2DTulL8QIDDF++Bsl1kwkQMRX7aH0T0xPHrPUg7RgZ8vSGZkb3JvVVDNLUDjseLKuSiiKRKqYAAACH5BAUKAOAALAAAAADcAKsAAAj/AMMJHBhO3Dhy586lW7jQXbuHD+dJtGfv3r18GMFpBMeP3z1358iNGzkSYUJy5VKSW6kx5DhxMAXCFKeRJTiaM2PeFEew50CaG8H1jFkQ6M2gR5Fq7Lk0nNCBTYUqRWpU48ydU7Nq1bqyKzlw53wWPGhOIUN3DiG2kziPokWMGfltzDcPZDmS48olPLlyb7qH6UTmhLnR5mCaTm+K9RmUJ8HBSbcihdqUsVTJSiFjxcwZ6VevXYcaPIiQYTq0atdOrHgRbsegdNu5HKl34d6EC1W3C/zy6tTDl58upmxVtObOGxMTrLwU+carOH07lwz6c+WxebuabQiRrXfWcPO9/4Ztz126kCtNn8+91uK9eenM4QWn8utO4DOHPw5qvKrzxMIJlJxy01kF1IH+FajUZ17V9JNB5fSFG3fdsWVPW261ls8++0xlz26mPWReWu3Bdc9uDYLTlYGH5aSfUwgGWBRhBUL1YnOTORejgpiBVhmE5JQ14WkkqoZhRaxpuCFSr72nFlsRtdUaP/vkc6JpGp1HX28tHraYVWAax+OAApbpFIE5jhmZc+NsteJXMhkk4XaoVXhkkm9lpNE+HfXZj1zguCdohhfx2WdsawU1G5dd+nZVQc8hFieNW505lX5qIkdppp59NlNJpZ2VmmpTuYcURhx21M+fHekZqKB59v/ZqoYboSjSSI0ShiBwR82YoFYCXrocp5zlJFmbGiHbGUufSihqO+BAxCNchsoK6KuBJolqn6mOB86Hga2E17gjUXUUdMXNqBSAZCpnI7EK/gpvUHg5m868GikZXj5B3UPRhdpSWy1s8+yGnlfn0NsYdNLdJ9m77p7JLr6SbapVmxgjpexWJNlLMZ6w2oNUwVGCjFGf4PjDET9WFsyQtCRvVC7Dv8pLplSYUpwVTgbqPBVtHteK1EPOfSfyVKPaKVGs4PSj8kYs5/NvReCYCC16GzuK2cQvBuszVbw+9zXQEwblDmZonZ32dGpFO6p387zlbVAdVQnXyizfA855CYP/zSKNGwco43Bb1/ibsSx+TV+EewXVTtpna+XOOpSvgyXakGeedmpxy40yk9birRFgYIn7N+L84dz1sPhy3fNvBQbOlUl9Z/l42uuAE3mW6vWO5VmaBw855+CdLLq1cr12LTgFR3uefaf7B/Hq6xI7cXJ+g5kpSUg1vrd6aV++EUO3lY+O7+tknn76wj8pJbXL4w3o3Pnq7XLfRqF+3XWEY/9UjRGTGM4OR7Fyjc93DLGcejZSvoSY44EQLF/vKke5dFBwcuwr0tI01CGlXCt5oatatlC0NTPxz0zEuYzXkBOsL2lFOjaL3UgQ6Dt0oIOBEDRHkB4YoR5GcEg0XIgC/zPovjy5SitUqpa3MHIi6AELhf27lJoAJDHW7Sx/axoTScCnnvPZpnY8TIkYx0jGH5rmgu2L0kT0xa+NPI0jUFPi51hmj3vNpzHCGRwK15XCKUalj9kTG5t+NpLwIRAdt9EIGRfJyJQ8cEiVgwda3GakO7lnX23UiD826Y9+0K1uoesky6B1q8BZTEZZsQyn3LW/F55STdxDiwJ7h0gHPnBxjbwLSRhZFiFCTil6O5XAtqVJThrzjSs7GcpE2ZJSRoqPVuQPZVY4HQEGJ5qZ0dX26IWWQ9oSKYsk17jG2MvdTada3SrmMTn5J41ErVtyeaNsbPK6/V3vj2WqVDXb9f8uAhILWTM8i3r2okOliPOgeXGkQnI3MksGMyhy9JY//kFRiq5zLuExVMo0Ai6ZbewxMZSmPoMzJkBGqmHE0lwXT6IxRn2qN7tUqAXdIY+a2tROhNoXhwa2kYpW9JiwCQ/9gkJPoqAUmvfUIzUBuBX9wSt4pzENIlFSjmS59KUJLUdZzse+26lPkg4xmqDgxw9P9tSn/zAmq6pmpSnFj6jgwNVR+bnUE1omqYVz5SthiRrhKRCRPEzWYYBmEl9mDh7woOA62EFBsNbUoa3RqEbQalFOvoaJGuIHMrsnLgMKiymTWR1eO+M1awoSXm1KmogMWUsdfiWmjKOT5ijIEC//poMduMXtOt6B2MeuRluqOqtPLcuyql1yQ28d3Rf7dq9IiQWpXYOXpeparJDWSrWrNc9CankOHQppO0SabeVuyw512NCG6kivOnK7W3jEIx42tdBbeErZtG6SSpiNlWanIpGNNE9FclWlUm9kvYrtNXpzZR7c4OZV3ykFWm5T32LLi97znle968XtO97x3vfKgx6rmS+fzAoOylq2fsXj02aD+tBz3IVGw+pafkDLI+oWqFFaWbCOC6a5xyHNqxSksHotbGEM53bDG/YwPehRjwxtaMSTNbE/muQvJ4snuZ8z2K1mXMXFiCNIeyGHY2zMGZNeUa+62uuOLbRm72xE/8KVK695iUxndJg3vUdGsoc/3GR83EMf+hixWaU8nirnFLlwjJ+TntcmogwHJgf5C5QCM+Ypmjkz94EM4mLY5k7P47pelWWc00vkB9YZverNrYaVXI8+/znQZY2yiaPmL/ka0Vtmzdv9RHKfxWTnLyCTTaVLSmZz4dhYTh1dJT39aY3UFHKIdUdiJ4xhC+fwNogsMp5VzWH4MtnVgYZyiWdd3AtZKGB+OtV7minXMcsEIREZa6DmcY5hK8jMfYxOlzLNb6TUadkka5uyD6tYymF4zjYsSw4fmZALH1zD3Y7HkvuMD0Dvg8T1vS+/4HZoQUNNhFlaVH7k9BdYvcUidf+0d6Z8Y6N8twh2UxneqMz55sNOu+C4HfJ5FW6OMpoa1amGeJL5bA8/h5vEEx3ulDe+YCsHV3Ih0eUuz7EWkJ1caulQeZmzKU0oAgjHTxUeWhBL9oJTLrek3nkYGXkOoAedHRvGrXuJXvERq4yTP51yh3YcsA5K5nkoKY2UXmVy92T90mkyNj+Z05zEhI0zYg9ewckODrPHWc4IV3gut2rnh6t61UT/s7iNad+lKxhKVdcWn4KisviBKDdSKjys9uYYHqH0uS3P48s7E3kMWj538ECK5VWd9u72nJdt77yRc57q3Uq8z7D25Do1ruzVqoYifkauWVc874hQTfYmP/z/aK8I4wEv57ljkjbZNUf2slMwKAyt/PDRnvDjL/Lnyj84kdfLYXk0WfSxNn3+sHdfhRbyMBF1F2tbISj5QnjgFxbFBjanJFroxyNl137u93uSYXbEhw7m4IH2d3wKp21DtnDotVv+VxGwFk/rNErapR7rEG0ToX2s504dZCqE54AMOA/kgHjmIjt0hXtepyAXCA9ItmG/p1hagXMdaENt13PX1nAOZ172J0YfyH8SVxGpkjItmA+7wV1SqFuSJCWjt0medC38ojdqKHsYMQ/l4IM7AYShlTNdN35LmIR4SDkaEX9KEWTEh3C2ZD7a5oGNxHlwJw/2sIJcaEzFxTc8/xRBNjRTZDg3U3Yq9QN+F+GG2HRS1mV+/TQ4BZKHSYgcl/eHVEhke3FqVchLNrQOcaNR6/QnehMf98d5MYiI92B3xbQnbHWJx8VEGNEOb2hSkHZgc0g9gmOHfSiKBReKE2aKqCiFOzeNq1hGrSgPuTgesegRpSN1Vth26hCDk3h3mrQn+WVy+xIt4wBIxWiMx4iMAsYZzHh2fDgdzwiNFpZ8yVdnOWSFphaO6fOKwSWA+6A3LuaNWpV8jEVTiciCmxRUVqKDrZEn7rCOlPFSnfiOFFhazjGPujUm98h8aXdegkhn3bWP64WC8/B/T1ZWdyeAHiEbKbFLW7Ve6wUPr//oNBcFDnZTePkAaMYlfjDyKe6YShsZj52Rh5+nJiGJeQjnhCWZcE5oQ6vGZEX3atWyfQI4ZR9xkDSJDvIADvCwXu5gD+Khkw/ZSTxZJbKnD8bFgzxhFSRRlFJ0lOenIEqpallROcInfJ/nlNF4G/i3f3D3fFcZbln5klsZky4xE1rFk/ogDxaUkw+5iBzBlph4D+nQG3GFK5ZmlzTWkUn4l3e4h3vIUAz1l04JiOXzc+dwZxnWfyDmFhZnKKuimItJF+4gGBCCDvawD/qQWIgoHtNXN221huEHaXK1T3UImiA5mkt5h80YFH95cKyJbR8IdKD3bbQZbqriNIu4lXr/dyJbAiHp8GfzkD5aWJx2oyeFZw/n4Fn3RmAU+JzQmVtb8Zd6iBSmqH9guI8e2HkQ523caRG1+Z3hKZ5/IjXm4RftoDfxdnFvJErtmRHH+So8KJ8AtIl2hZSJNxV5iZ9aoZq4xZ9oZ51zFpWoNqA1NXFX+WctWVbSJ55JZ4ZRc5wo9y25KH2a9CcVyi/n+BHloBM1FpoayaEfyj8hWqIjSqJKUaIoSpLYNoUQ517w9VhNxhqIKaNNQ6NJV1k2yip1oxFomTI++qPnSG+9EYFGiaQeWilcQxBLyg5N6qRPupojqaLbhmRzF19Zmifd4kloKYBSdkyrsirq1KOtgkmC/zIP8kEYyvhZl9ZCkbp4XTan+2midjoVUQqVqeh2QmelLdpq/wejgdo0h3qo61SoAmiZxXSm4aGGHzKkdLlKldqhLScQc6qX1EmidCoZ6gAOI1lnbxeq0fZhK6mlqJJO8uOSx1RfYGpM6qSYZtWe7lFHLwEppCVSpHWr/eMTuyqivaqamFFtp7Z8ebZhx0oPKWh0AsNT1rKqGTd9CbpREIly8Lmm1YSk80k4lJoc4SquGuGrwBqsw0qSG1GscKeujnWAHbdToeMng/qlSndR0mqvLGYRcFlsCWKk/RpdSBWwAgsOToqf6cWpTwlY5hAU28ZtDEtTB4ghRvRkEDseHf8hr6zKSeHJhUqBmbNaezjyRG/qMJJql/wksky6ESUrksKqXhqRp1qRYS7LW70Vs7GnDxm1U8zapc+aszpbmZWpboGymfzqiR/rnGKBtElLsqRJsijatOaKSFH7l3x6rDF7aO8KT9dCel77NBPKfWmomdkKII0mPVFUpKCZtvfpq2v7ecH6tCjqnx4YtS0rdFTbp6vhZ8eltXq7txSrdEiBTGHLX+mgS1sinxXYOokLrovLuE96sgl7cHArrNZGuZV7hGR3pb8VMDTbuQooaz6lFDq7s6VCbyjRmc3ZR9xjq6srp63rupyBYUGRjytru1K7sAyLub+FD5obWZwbqDr/qRVpebGueirlEXWBE5oYkzHS1bzO+3uMS65ZcbJp97R1thXoir2Xe6VWOzWai7V5m5XhOxWt951aCVRvVEc65JlZcVA+4766+rzx+6tZcWpq13bWe724S3Y2ZbVHMlZZC08DnBXIc8DD606aib4bkRIepaH8My8BJFowwYQTrJrWiRQm+YENhMHTi6KfV7eItWdYmqXdC2ghLLEjHBRiai0zOn37AC5htiJCO7T7eqRi8Sk0XMN4CrvmBQ47t8NgLIjWSbeXa6Uwa7VE7B4A/K4GfMIbscSycpsEeSLmARaH02WqxKbbujrNYkGKpcVbLLlOuHBhvMP5l78Li4FC/3yArfYv/6tTIlymSMEqEcW10jqA8IG+a7qRLNTJfAxp5pAOn/bHNRy51omKhFzIUxq5ZKzIHTwP3Pmir3bE3+nGTVM3NasqQJUyXtiY7kY9HptKUWHFjxZp7aBMpBy/pmzBUqrKDeR2Ppyu+/vK35bGBhrCAmzLuKy3cowU+zBPuALBqbOvMix4VQOxyUyikWvBC9fOziyNpqzBQCxJNrVksdy9SsK5bYxMlKy1+yy68NFzm7y6W0dSGwkT5ABhbLUhG9KUvtqpzfzOqkxnpvzD2Vu1Lcpn1myga+zPtRy2U5ZE2yKjkrwR3zwbv2y0D3M9MiwOtfGgAbwPDl2dgv+cj/so0WB8rqwszetXz8iarNinxkbs0TI6uiHNISOtqqObMnWEEoPbvP/R0uTwF/mStTQ70/15sFL6XThtyNx1YYeMrri7yB8GYkCNz4BWm+BLvsa5rCRty/7Qy4Ihzt0qY8asN5gUqxaB1XIGdBbc1YANoPFsuUHMvy1q1o4sKGntz0qNTCLt1nK81BxBby9G13Bq1wjhDnHji4pdZRLB12mn1TYd2DhNgmGtW3W7yEsG1EVXxGptmyV9y+0JseDJfXEtG+EM1Zf9IuOgEBAGfv9Sa/NQU8os2qUWoNaWncz8nznNzMW6W1Rr2KOapYSy2DUb2UxSoakCnkj0Huf/8dT1OU2gZdcr+2m8ayL+wlH20GrE/dCnTGcQtNzL7czyjcjtZaV75qKJ/WqIud3d7M1ZW9TlyCRSs8KOBo/s4nVXbBC+HXsmhxQXEpak2t42vMwmKd9efGr0Xd/5y7AdVs+szb0c/b1FvWLaLWhpKbwRGS0ysxMgS012jRsfHDIN6C9NVg81pamOG886J98WluEmueHO7XnYi9/13Mj7bd1aq9QAnlEfnRX9QBf3czBVpSyMYVq4OhrkoNm7K8sagQ9Hs96tNtzyoH6Jpc48HrcUPWSk1uPLLSTZ2V3EGs2JLKqHTd0vquS0/d9wBMkelxVx/Wla1hVjdEccWVqL/5GQp0fm5zY1GtFsHTx2iHWPLZvm+ve2sZvmPj7kRM6nH17WSN7a/P29gsbda+nnF3ebJPwhLa4xcUXoc2m4XrayBogW8RB8NgUOEl4PzhaWuoOB73B5xWrpc0bsxh7PRZbsOz2gfTpxSC7ieu7Rh2qD+7Kl0z4VMXkeL+Zo9IJQL5FpcXIQfUN57yAZvv5mv56BIpnVx97u7i65g51nhT3d1G10Sr6ssH2GP9rfqUrAXshoiuFCC8M94qQXncFYStHBvf5sRrgONlm57x7xEj+FFZ1nn17N1pzW4da7qsItSA0Xak3S/l5HKF2fC6OcKVE7CZsVFKwR8KXrOa4RpP/KrpOOeSfK5mkOt6kGu5CL6RLP4y7bYQRKqtj3v0actx6/Uxr/2m8tulKjZeCduBBSvUjhtE+qEbwVD7rubERPEThe5vBg8yKZ5jRt9Sw/xj8f70cm9C26kkTs2h1N6kq/9Ewf2X6b7YFR2c3r0o+Jv0GH9erKv0um0etN5vLQ7rOLn/Jbp4q/4z+Pdhaf37Es6hyd1jENnHSv502vSU/8OIwW9QedUCur3DdU9U9LsuAw1tJdU2NuU8ROrktJpyOr48V9vexe8QOqZM7uyHBv+b2L+Zmv8Uv+33ENLs+j96CZVUpR+l7c/GMcqvD1XlVr1hLB42zLqy2vIFpcuTT/7d7y/OH2HOqUH/w/mfmKLfx7PqGxYRsroUsHzsdjVMEZ/oEZDrcuW7WsRqr18HBEjvoAAQ4cO4ICBxpEmFAhO4EMCT6EGFHiRIoQ372Ll1GePHr06tWzF9IePnz37ulDmVLlSpMtTa7cF5NfP3/+DPrL1y7dznTnzpEjh1BcOKJFjR4dV05pOXMKBZ5LiA6dOqpUH16EB0/gRo8gRVa1ClbdwoEFDzpF27BiRLVr3Vq8iDEe164iR5Y8uVKvS74vU8bcNxOcTYE4dfo8txOqQHLlEB49Kk4cuKVK0xqUKhXs1XgGN370OtKk2LFlHTJse1m1wbds415sPTFuxrkc/7uGJulXZd+WePv+jdmvX+HCOc+ZAwp0cdPkjgVKHmpU3DiBjpc2vZx5M2qDtT/avddQrMSGZFe/RmvW9Gv27d2/Zvcu4kXadL+HJIl3N+97+f37Bm4f4YZDiJ92fipnHAWTY8wc5BgEZxzoJKMuLezQkgqc0rjbSiOPRMJHIH3YGa+ihDh06r2FzLrqPRdfnE+u2jq67y4A9eGtpP929AuwARPy556eElSwyArBSQ5CyopcDRxzFosqQw053Kg+0OwRccTtTGzSIBUv+/JFMd2rz7Ya8+Ovtx1tRDMvfXwk8CbjEpxwwurKUZIygRxcjc+EzslwrNLAoS0jeOaiZ/8egfBBKbaHVltnHYG+7BKhMS99TSP7zkRzR5JGws8uNnMDbqY4BdpnnnTIkVCyyCRz6sLMHLywUoOoaoi+dw7VSNGS3nRUPbTYy6rYuGxNCNP2CmW2NtvqssvT/EQdFT//8oITIX/4UfWnViGTbjrqnEMnHRKrQqdWtJxDqKoWsdJIoJNicuvEFIktNl94LkJWIfd4bTZgZjfaVFRp8aE2YVBz61HAU8Hhxx53emLVVXClU5CptghSBx3VlkJMoPEynaseEQGjqMl13tO35X795TcrgWcuk2CCazQYYYV3BlE/mR4O8jCg6Ly4KAoro9VjkRWq7LpAt8RqI4PejGn/RIhsXadlrV0+DyGtvNaX5oBtJnvT0HgGLW2F0UQpOMKKExrPxiQs+uilkrrOHKXBMsgcpzUrcVd5wCEVMByvVjlSrLZmPKuXw86IULE1LVuems28Mm21Ndc82ruwDezhiNPxO6nGlKIbMnETbLrpJ5U+N8qpSowPHpNV2gdHtbBeeXF8G/+6X8cBvrxy4y0fmODbOGe++bPZflOwwvzpR8hziGy61egozLh175XSW2mFSFOHoF3pCREcHE8KDxx6eMf398ZfFqizsY/Hv1CAlV/eef9zBh1NbhIxdyDISN8jEt4Q+D29JYR8VomPPLCkvv6kzx71GFziwNE7F+1r/3GMM4jj+oU/EtosHocqVqH4RyP/Oa9nv2qbAAfTj3xI7DisklD3mPKk4/htgT9kCqC0QxqCZK0e+pCXqOpBjwxCSlIc/FdWdgW8D7YscqspIQlPeEKZqZAu/Wuh2qwFOgHZhHr5uMc8CoicBCJNiCSSSg97SCs6+tB7DtLO7MrHjnXEox6MwhE+6jGP72CwiaqJ1AY7CDxG5qtQWLQZE7NYJUN1kXLPAmMYe+ammIBDgNS7hzsmdpw7+kQzfLzIOtCVLgcBao60at3rhsiOeHyIfSbBhyRtIzUNQrGRv7Sippq0wo7o8ngCI1sxWRjGK42xbQrpR6p6cpwbKoUcsv885coc9451wDEz34yjT+yItPBR5R3o209/DAkPdxDMiZFSXFyAOU/IzQWSxpxklYynTGUyk1N/Ucg+7EE68ImTmoAqX6RQSSgMgTOOPPQhLMtZPnrYA4kpUZMhRclL1SySnr+8pDtVE0ll5jOZ/Fzm5sS4yWcqJJTjNCVPFKev1XQMnHXcIR2nQkt5pC9LLvnUPCSpqI66SCDAPOrW7le2SqG0mCZ1KhhD0jmWIhEtobwe6xLDx6y5Y0YdaRJYvilOO+JxKu/4I0rUZ1V58UVnIaEf2D5az+RVrktRxScJo9q8neVGNfhwR7rAh46VtVMeH3mfQhLLUISca5XoIGv/0tTxjsNadR8GycvU0tm+uIJjrsRb6vGaitcs4tWFOWMUQoRTE5vwAx86SUe50pG1jRBSICZLCD3s5y+OOdamSZMKLf+YlpWAAzBVe1NnE8LIpIK2WVkExyHRgte8JhOT/PxftEjCVk+y1ib7wMc85AGPdRh2edN9JKHeYRqIiOWb6liHBC/TtuOi6riXVa5ctxZC59a1tJehLjEl2ZHrYpev2k2tQVZrk37oQ5BLRCli37dYhNCGX7CpyCrL1xn1Vc24CGnfcX/Ej5nwI7/6ZWTAUmjS1QS4wNQ1MPMQzN0FG9fBF5QwSt33PstVuD3t3SNFzpml+uKXLwZxGIGk/3dipzROxTIzqXQVS9oXwzjGVLURWwckHBsjDML85EqFr5iR9ZZZPu2NUS1xezLDqU9eb/1VJ18mqcc1N4XNWnE+W2xlPptWxtYCpEC2LKJ7XFCXAnOKheFjvjR7JH34/bBVuXtjHIdkXknuRyLpzOQmOxLPUBYt2VTTZ1LvdYkrzY9aPfkjChqakgGrH5lltGjzZeozJUEyYC5TQRwT0h7zMlWm4fnETXPas/lKSCUPhb/o2mzPpYZ2jF+oalbnzssEm5yY4EKfiuIaIXIWCKD74uVBzuPXVBPOsItt7H6FdHCH5Ghaoo1SAZv6PqlWMIFy1x9XI4/M8XDPu95Fsv+0OkXOhdYub6Zq7sLxQ93sVm4G4+0ZKQN43vWOcDOzrGBUBRLHkmTWeypCMkdzF1VTWxS12pQXfos7JuqGJ8RfVvHORvuk1EV1iEwuoqAS2N+y/nGt4ZKRtJq8vglZG8NYghJOwjyRMof6aG1eOaeiWl5OaTlifw70S2Wk5Ce/KmffmjAY3hfS+HX6uqO+dqfMu9RWRwulJbx1gL+oUB8KtGpwOXbUtoS+nkRL2uG5XrYX3iBuJzWW06JOCHPk1XW3O9FHsvOEXHR9n7IWiHTT0nyvOt1OPw/hDR9XjiAE8XzGsk8T8mDdmjDkAY9PLSePREgrRK1AhfO1cKfaLff/XthpPxa/JlVFEY6+S6U//OlhDHfbC7IjAhuT1wGp6rivD/cJvzR+BeR53wvH4cAfE9eMf1fTKx/nGk8LwkAOdIBDnj53ryjoUL7zl1xf8y+Rc/e3zI/jgj/8Whu/y3C25DM/e/MKp7i8JdoITKGNkqO86mM63PsUpas9/esH/rsv/xMT5grAhBApAizAfkK/yuM1Q5IHbZMLB7ws2qs9BNSLCOQL6isQEwMMDDwulNDAF/ko2ig85REICns70PCzEaw8ndE693MR2WOUo6u+tXrBJ8SvASExtLjBi9qgHNxAl9GaRyoWYysbZcqtPksbA8QNrPOyQ+M6jJCRw0qw/zZrks3DHarhvQsMDM1iq5RICMFTlimiqS2kjUa6orQoITAsP9QTwqprpss4Q9fjugYEiQSzLzl0QYyCwg/LNy5zqXfCQpbRwmCaJx5EiNLipylbPn+6j7+6IGxrltmoJb9CQOJiCTfZPePCNF1TCLwAh/5IiHoQvHj6vz70RGBiForTK6cqxPMzxQlSRHtYP0RRNOmDRINrwScsLmm8L7TIPJFIm16EIh3sxM+6s+IpRmMEwyszxSvRO+d7NdtQIQdUDZPTCycMkA87uxZUCGUEB238iHngxmGTJ6zgRGAER1CbJCbqsx0DhzU7xzVTRAX8Qt0qmbtwsy5RibVKi/8iczPKsyqTQDocK7d+HDyA3JWARLZjG0hnKa0q0zEaQQiT8Sd8TIt+IykaGRW08CtJ8wt5hEUbe8BczEWORDrQmAd+BEkO8iAPag8APElLKkiVHMVlui3cCqMmubYvvJIdsUmSSAjdyBJYfJOebCugRIgLGsqhLMpu9EaB/ERkSsmDhMqEBI3basnv6BL1q5w/4hGtdIr/wKyKfEOMyo9b1BG0KDezPEuYI8kunKuZaUpynDDsgkvNgcu5ZEjVkEmbGZXAVETVgzifCpHPhMl83EeiPEx/9EXiG56B1Jco+yLUm8y47KxFTKbM5EyngCv64ayYhCsL8kgsmSC7KE3/PfQo1cwX1nRKRIzKyqTKlPu4FcJLzexA2wy3qRpNoppOkQjOTZQn4lxN1oS2j4hM5aRK6my8ZWKTJoHNRWGy9NRHn5MH67zOK8zOTeTO7oyy70ybuMKSJRIvrugcW1Gb68QP+vkysJpOkzEm8DQIZZxPpxvJpPya+jRO/ExPZDnESFKb2iRMzkmYvdRLp8gxAjMIxOoQmjOIBhXO1xAhCfVOA02sYkLIlBLP1bhMwxIj9BzD5bGLuKK3QzJQpBvLjeGqBiWW7dSKtVS2LoqyMNwxRFTQJqG+xrOcrOAInLHM8Cym5rmM0ATBknIfkRocG/lNEIkIFA3JuNCm4TFJ/+DRH09b0uhqtsd00hm1vSh9tWWjSZEQUMo8xCyVTBzlM0Y0CEAiN4YsUzPtxjQ90jV1sj90U+OEUzn9QT+lU4SoxlQcrxX7kB3NR20Mzz6lVLqs1BzDODRU0Xx0MNY7kYlA0X/8IP5KMUe9M6mBVEJs0vOaL6qRs1Q0FjwFiXukzklFxgNEUBHM0ZmE0ehy1FQiPIRJSM8wN3ugCDN9DUX1LEZlnDYNx84wTtv4QWHF1eq7RoHoTw/SCLrsyDG81TmdoAI1MBgVsCYtlLgwH9MLw2lF1MFTTGxVKlm1JHebJPc5xq7QO121RVfjIkQ5wHSVsHXVsbYrqSwtqXglMP9m8aBEkjKbcYt8XRx+zVZ/5RXk6dYffdjFo69xdTUogxaF0BywWj6Wndgqe7dyrFiLRUr7GZtgmU9w1FYlBVhRBNdkFU8ykkL8sodyVdjQYNn8dM1d/LIq+9KJ84zaaFPf4ZWQlQedzU6eBVm2zCeSHUWTjZ7eM9r+9M8/pcwmdR937aelZVsd+0Cn+EBlU1GV1dqzNNLUBMSuDS2gDVoKc6kYIttwEyqzQVu4/E4QPdwl8kBBnFtDgQ1FrSV6uNvD5MMdTNIuijVxxJ9k1bEZpS/f44d8yMehNFyXlMoQhciMs1WXpLDPRBZJajY4lZwTQtMp8hBHOUtjQU3u9CL/eRAlwxrE8wvNS+s+Eyvdocwk5hHDZwXB1ZNBW+Gwb61dJNwfyo0NvJWf+iQeggleqHLSwEU30SXcofSnxPPcsF0UlEgfOo0cDosX2a1eKdoVysHe1tDevOXe7t2I7/1a5KxTOOk9/utUQjpfGLUyh03WRfEPLk2v5xKp9CLGCdPdotxe7v1d/y3IqhNXTNu/8j1gsI0qAkwmp3Xe7sBZ+K3eB+6SCu5HrFguj/0sLwIHDR7eGHNBAQ62C8zFozXgFnpKvArDQxPYy1A09lhhCa5d1XgL0yA2/1tUO6vP4BXeFo0w4oITEtNiHi60suScEX3bBJ7UyeVBeJteJERi+R5MYTGb3rZbVcRBHPlUNyM9Ko+V4l+i4pHdqxzO4h02sS42X7QlUQQW41td4WSbV6M6YxVWrkfhjkcRCPCD1f2aZGDK4wkdYT4OnQskMVYD5B/Oz4R0WWgL2mGcGdijj0Sjn0cuCFZmryEdPHCYokpGtiP9qEu24pKtPIP1Pi2Wnk/+4ttCvFJ+JJI54vcIxApTjeBprNNAjdM4iEP1x94Vv8/C5fvkYE0WEF/eSh82YBYS5gQWYmVKZFlmxXk9ZsJr45cRvlYWlt1xZpibJ/6S4a25ZvDV5V0WMS12KW/OMQXlp8nls/ctpoB5vxWWEferH2QRPrUICAAh+QQFCgDgACwAAAAA3ACrAAAI/wDBCRwILpxBcePImTvHMJ3DdO4ICpxnz969e/kkZixXDpw4gyDDjTuXzqO4jyFRShwHjhy4cSjDSZxJk2BImTVz0sSJU6dAgz8L+hxKtGhNhjpBIlTIkOTDiBIpWrwHLuM+gfxaloN5UyS4kidRhlU5kxxMskZnhkybNChRoGvZyp0r8dzOlAkXNnw6UyrVgfuyCkxnNmxIlmDHKgZK0KVJxnR/Qo7s1ihckJQzU+66VK9Th+7aEZw3D9zUgfkEmz5X+KRSx2cVnz0obmDsyXR7bs4tM67aobU1z+0arnPThxDbKV8+8O9A1fnasS6nWJzLdLFPjhu3lav27WN18//ezVj80Mu4B5oXzp74UnLHny5vR7o0OOdVJd6T3josOYfUfccdOeQEWJ1h67HFU1q+WRYUegmyJ6FNxA0I316ghaZcfRT9ldFM+9jTDmHZlZNOO60N6NQ5Wx3oWkzEYZZTT+sFRyFmNBYVY4QT9lgQZwldiCFEGm5I2n34ScRPPvuRGNY4J6bTHYEMLcdidtXtSNyMOdmoXleWacmjjxK6l1dTnyU3X332oJbPm1cRxOQ87pyzHXdRFkilQ+3YQydrd94ZnphgShShl1/KmNSWZDaqE4JK5eUZhkWKBo59AmH0Zj77BMbPp4LZUyeB/ymXznHKtXnPPPwFKuhihI7/SdBJNcma6E2O5nqXa5EyheZnUOWk6aadggpqRiPyOdBD9An0IauskUoqeJAS6lNvHv3GIKO6dvsjpAOaMylfA3Ho10WbwmksP/18ek+bHb6L6X2p7ZORqMg5VCC11bpYG4+4Lejgjel526NSYwX5q0N9kVbRVBcNS6yx/fjjz5LpbhqxpqBeJSJ9Fc1zqlmv+quYULUWZ/DKPuJ1J5UYEkQfmxVtHHHGb1LsT7vHZjzsukgO2ySgJSPE78kpF8zy0sNFuh3MewlUJM0Q23xzxhSvm+7VnBpLUz4iRktyoAS6ehutBG9mK9MT3vS0kCTJvByrDj9cc9VWa+qpsfa+/3nRw+h2/alE/jhLp74wI1d2ySYFhytva7PdHl5wS1Spkeaa6yfVXG/99+ZsXlSTxRZn+vGGU7E6Msn+Nhi5ZJKzfNNSTRGk5nwzm4v73LnbPZXd9SlnFOmku6nRqqdGe/SLmDn+Vm9wxe4tZ/DNROTu2C93efa6Cz+QOxqCY6RFhBdeeulYybnqiGKzNChjzl+rtPS5Um/7U9srB/7+/O+fIf+WGoho+kdA3M0DXQLpR/kEQrzCOetjDgFUv24lnhjRb2myGYldvoIcAhIwHevIlwgZNpP+idCDy7FIzgY3EwcmkF3Okpdy7FQtgcDIPLh63QWFQ6BykAopHMRf//9CKEJ0/OqIAkHHCJdIpP7N7Wef6gfPWPicrAjGb03qj4xiopbH7XBpv7Ic+P7nv4egQ4lGRJO41mgOgaCJiScs4IYCt7d1qQYroFKfdG6jMo/gkCfz+2Ku8lVCd/yviGk8Bxs50hGBcEQh44LjOiaJQvoETnB2vCPQwDG4/ZRtLNkyVIMESUpwjJFII0wkIzkykFWuEpJDesgkZ1nJPl1ScBV7IUHsyMAl7Ydo2wmlDR+HE0SV8oIQyZcSGSIuRoLDldB0pbgaQpBZUhJ8a+pQuvZWMRfuMpMKvFg+RKa85c1Oh180ZmbAJzX/lRA5v2rjM7fSHbMFSppApAmm/oL/kfzgMSvEa+HFPpUaKnJynBFcHHgQ5iV1HtNRHuSf9RiGFHMUiCP2zOh2VrnBdfBPHg7r3N4IokBweJMgFutZQasINmgptDoPjZ1HPUjImTSlh/W0p4DuWY6FgBB88wBp6G65yaKkFGMr5IcDMSaikYEnUJpRVEyNQkuaGnIwy7rpRXPqL572lCTuEGrmaiaxgnptKEfFmlJLR9ChSYtUXFpUoaZKFGvCwx0zjSj/ImhRRmIpYa7iSBtBA1J5yMOJM4NYxjh5x5yQDqmb+lRAq7I+Q8LzJa45j5m4crClWfOaejXhqcR10b8a7ZHiAocS88o/a4Ijr0LFW/qIklJ7/11trcTjR9+YJEMnwShpB4HPiUbkmDIF0kefXcddNRTR+zWlr2chm3AdwlrwwQMes3wITaAilbn8Y6BY5BhuXdgxsLGvNaOc3X/mFcDJHbdHIAThJJcbrKHAs6+PnG5Ek8sOdWSmaz4RJ29vFsXiJbBd9lLdJ2/4o9ekY14Caa/avOgt+c7yunKLSn1okry9YLMdQ7SmOkbs34GgQy56g+Ho2tqmqSS1pC/05eEWHCPrnKh+DUanZqibk9xlrnsgNqXU5sM/7E6SxCM+ozzBcY4T5yQeOdFHYGry3Yvt413NGdZIpahAGUuHaLw6SDnO0SedbDAyo3QomZCTkx+7Of97+rOuNdnBjjOq44xKHkiT8UyTd0CZJlJW8Uy+29ZyKXalSprTeY+WkAf75B5nHk/jwrKyEPrEx24mzXIOi7v9WTMd/cUzOtboSHN8dc9OFgg73sHqmuiDkzD+xz8EImsry4tmdGzsQXsLzFK1aSiRVhD8QLk0EOrEsJnmUIT3F2d2DqS/JE6kPKW5kFEThM50ZvWfdSLrgVR5SaAb6gphjMc3NXVkZKbIfRq1RTV/MaxifXOQ26kTJOMZiNH86omRrI5sxyMe9JDIq709a1oTuqVjRVdguvlNL4MYZPUDCqXp+r2pBY85NanvtZOc5A3mmyMnRge//Q1wgtzj1bH/lnWtL7aqH9cMlyc9KG/tliThxAVtFBfj5diJV7ZAG9pONnW+2yhyJGNb2yUHBz5OTpOVgzuo7TgssuOVGil6s6R9s1lRWKJZiSPE3Tmv+P4iQ2cSt3LoquV3v7G9aj+bZumdEqg49+Np5YbVL5ySIkqxcpUPiY4oXJ9R8wIfdgmtwyfQNrtAhO7KJBZd7XceCDxAqsI4le/KIM6XOpRLeYwsnIEm5fvBtgiTUoJdQuwYyoihPRDGO9Pxdo42ONaIDnZwXoW6NumSRJbIPW/+rh0KzEk7ZnLISZxahSdT6nWS+MSf/fU1UTIjzSFydkzeIvsg90D6EaI6CT21BLn+/z2ynxPLN01G4Em+o0rMfLYrfvaCnYmoR41PkUPEHp//mj3SMe1GUr/26yAP2NdCc7FBhRIb6hcZIgd7ePZ+NcF22OaANDF/zVR/6LAO85AaOsEP91ASL8EdblR04CCA+gBj6CMXHYErRoNzCTgXZ5REAnFnRod4EMh6EhFyk4JnrrcQ6vAOQIURubdLrbRRTIYOk0cmcSEoLagZ88dn7DcUNSiBOvhc96ZIdnZ9S7dCReGBL9ER6NBiaNUuWVYT5JBZK3h6S/hsRvGCTwiFESiFZ4QmU9hktgdw+IAPUuYpaSEdLdJT4BB3XChQBgV46ZeGRrF8aTFiiKdqb+iAqP8mh/O3avEgD/VgEXkYhDXhSySyHXZxFR41OjHnE6/CNlKlK4iIenQGDlGoiEl0RAwhamvnZ53neYJGFO2CPE3hDu8yR5j4aALhPmjYWdtSij53ivLHZ0WResq4dmq3eL2HanaWbfAwiXjHKXMhYH/zORbRi4Z4LaqHZDWRZD7Sb5DnX3H4K7AYi9MYW1l4Fdw4FFJUVDOxJN1oMC+YjERRjiWmZOjYgNn2DuvIjv2EUubTKJ9iL2+xQxSWK6zohkbRjCY2KYr0f2vXdnclD/QwD5WIQAQZikyjY/U4EA3Zfg9pdvtYhc9FfSR2dBeJbC4mEQzXLeanLSmTczUIgar/N46KyIqiFk+xV5GsdpF183ch+VA3yXbfSBfGGIPg0Iaq5YqotpIsKZQdQkrBBj3swYLdcpTYlo9OGRlfqVrPyEw/yXYAOXku+Wu54pHp8xfBZkNyAZJF6ROpRhAo2RQNuHpTSZVq6RON5ZErV4DeQWyCJ5cUF5Zs0YZteI6Q+Hhsp1zXBW/qZhSqEXMqV3B00SI6MitaWZSIWRQSeINjmZd6aXtnKZl9OTyhqHJ0EYi/uBMDEYxzORf8lhN3+YplCZTXRZV0YZkqx5bCQZizCZZNCXnFuZgmxpiQOHL/uJtT9zBpkUsEMWsrB5xGEUwtaBBLSSb66F8jOYG36XtG/2eaZ4mWGTmURCkXVWadOYFTd7ISnPlQILGd7JF63ZkWo5aSePl4pRmU12VYE1E3p+FdFqN9fqlnBOITnamQKUGfwtGdn0kTE2lq0/SKand05WlY8nApAko+RjWdBUoX0fISwkRxs2Md66ePdUkUzMRGnvGT/XmW/1YupFGJFcEWDuR0mek+6pcSCEFmOtmM31kU+qlIcnih2QYO/jka9dCkFYEPaeFN3zachVkcCGEO7TCQZCeS+pgZUNmP/Nlv76CkzjkQlOikN+pdU2oUolEYheejY5alwlF2EKoZX7qfpBmL/gkPZoqRGgk4thh64FBlYpgW/NcRskmKCJMQ7v+QgZmBiHRam2TypU0olW0XlNsmVjYKpfCIPjrKFm95TCmxXjU3FxDIjJLqI3Zxp1bomP8IkNvGoQIaqASXUsOpXiSBH+syk0ThfpEaebnCqlEZo9O4bfRwng+zdKW6fYI6qDvzjmFHPQ/WJpwSGHUUd2lxqokXmqqKFFBJmhg6jQJhWOdpo/bAqQThjgnUrI81OptJP5TjaBnTKbu1KcUYgY0YoY3iijBKnnw6rhhJD2h6h1ShDwP3h1kRTgQJre0pPfEqYRoxcxFzr6s4pN4ClRS5duvQav82iX5qrspqsOnKLtLJQBejGayTqGh2GL5GE2lqGlhWLqZadvmaE6H/KiHf6qobe13/Rq4aCbInd7B/uHAnWKAM620SsTpjM3HGdRCMCmGZIhAvq3SpObPOJ5JmFqxHlJcY6mc9i5FNuqnoChjFoncmW6gT4kNcpbIEcxJjVhITm2WagiToGrb0AKBbehSJxGSrmk8SMn+tWpYY+rVnKrY0USwke7ZH256uQhOuIpyP4rY3dimylSlCgw9qqZEaibc9UoVG1IQ+0oQNGKb/2LGTKLBAWxOdYrZGSxmnQh0+CliBp1FM2xh24TvnGjHnarm6aw/1EFQbalju8K+NkkZi2S33KJJ5CpQdS64Du6wIu308kxmFoSicAVMfaDa2MRiYVjeYi7sP//O7I0ilJYmksOqxqPuk0DsTCBac85NDVoo0A6EQHqWh9mu/PyZG5JuYzHm+Hhu26usj7PkRA1NjiAEOu/laStpqkuenmAIVuxnB73B4E6Kv9WbBmdG/SBewA7t0aXgQWFUUaMm5eLs/uzlL+3vBeqpt5Jq+5zq2LEPAm3F6YYmWPmFY1zVJiYm1TGmx+LiVELjBHGyuVbsyMjwczhiDGDwTIGUayaqWOUycXNqUNnl0zTvEdgPDF+sShMcWteG3c/FvxwrA55qmw0u80TcTJXafdDW4XzvG9eDEBrMfy5I8ZWMSbKEXSdlvqjgQ5xuwAoG64zq8GpcTEDpyPsc0l/96xXCcrN7SgX6LJj10FkVBfU0Gmuy3ajSRwH3KudF3yKmac6zmtejrwkVMJh14UXDFt1qlmT6xZ5dcb0MRlAsckParxuwXpof8wwYzpjXhtRoKxwKhxbkyNvfkGJJsFjXRSEZaO2rMwzNhlpJHuBumwl3ajabbwk3aLd7kD23SItXxNBJBKt3RhYv3pTdIxQ35hPHgy2YqyFKLycaJzYwMz7lSslVhKWHmo1AFSRYFSxUKleHowwQRx3ThnfNcj/Vs0NwcFR4YK0bjRmlyZ/emFwEdcsdJ0AOBpqdsyBmt0Wl4vwy9lhJaGRREGyDIQZNUdqKbSHZGEG14rBta0ND/GY6GHMrXtnxIGXYe67wjTSZXNxgs0nXawREdRcEymGQ9qctPKIvyEKsC29EDDZFcmoqqiJM8nc2Gtc2N0s1ZVSBsMX3ISMWAK57g6MemSxNxbIkwTRPvx37jaYwOGlPxEMHm+dMSYqB6xhBuOhSBN33UJ3/7icgEMcrV5IPI5sFqnLwqvNM+gsa6YtfmCbXdIiTKXBNdbJuzN03JWZrGyMBKaneUBxhT/I2WatUovIR1zbMe29BHoUhbMRMIAapoAtMVORPu7Jz1QBX0yqumXZrDWayEG3BdDQ79ME5kOMkEkdmgqmQr2scLLHmTZ9C97dvtV4OGSNw1Qbhr6Q+Y/8eFiAJJsGEbLMHcZgaNz+3O4NCzcZyHvV2MwsHJknOs9D3TBkN+vSQypyLbNrJnZEJq232m4ODe+6AP6dmrc1149L3gx7oyZusshEFPAgHWtavAi9dGHwd9PrFkEuFn9QCl7m2w34t6yRe29bDgLENu/GAP6ADOzO2HNsvhEtF4yfiPG0qvBmvgxCwXXZmAJn7iDa4r1p0P6wDO37F4BHGzjrfhzzQTMt6U2LYO8aCWF6HjUo3LNNHjYffjdqvduXIVBnoPRf4iCMFKdrmAXgnSHbEQEsGSXj7MmGvQkP2AVh2SXP7jTENu0SVYFloUsVraMz5PehaNsvjTvhvPAv8x522I1VP15jVx5yZuMMVzFVy45mv0ihQM30xJEP1n1KNWffTQl39RDxrapDi8zhS9hEE+FHjOMgX5h+TUSCGIbeLq6OzB55+uDlNOE/hA6s6poUpddGie3bZe0K3eKEJLUvogD4c3kXSY6QKbK6MmLnYWD3g4E/eAuUGFXS0Z7BwH3C1Y7Bu9Msm+ffhAJwOR6RJx4uu+6nRRbf9nffSAh6/GTxdxh757t/AmD96e1OCewtLT6xKi3iwqauwQDx8uLASb7b77s/WQp4/HiAlI3xSnDwLPMhRt8PCQ8AJh3aKj43cY8pDHn44ddhQ/VVd26Jrx51SMyxnfb7uern//KLdCm+M5PvKWCt3J5+7HtA9afOx+vm3gqJfRtnoC6BxXga0CYfPvna7dyejq3uji/kUWTxNwzPOJyJwQiPCcmoczL3DVzWUS8fRYHfUPheIxZd3gsOBAvva0GdfvQIl3mK7VnezuzWVir8RKHdeMTldoP/EMzuAsz3wryWoCq8XV3SkHC515yGXsIhj8FntcafbHFPgXdLB6nRPH2rGbb8g6fanaFuroGndJb/OmL7UaufSrS7IKlI6eXYPqTvkXZPmxs+NGMaNp7dZ6OcpiXInXTvcFbuAbY/OoT3lQirhc5voVeZM6LBCH1/xfRPtss7veYpbA/OEiS7b0OuDZ/47tA3fuz1nurs+VdIbCn0VKxH3ybDP3uXKTfnb45T60ii/8Q9Hrpe6hCeT6bf6YyeVaAAFO4ECCBQ0eRJiwID2GDRU+hAgRX0F9+iJeBMdOo8Z37+LRw1fx4D6SFUUitDdx4L179ebNq2fP3j19+wSiw4lO3cCNPdetEwiU4E+iGI0eNUgP6dKL+u6pFFhPqtSL8eIJ7GhVHr16+O4pJAmu4teDMs16pakPn1mzLG3m3ImQXdCfCYsyxftQaV6+BCuuTbrXqNWPXU8iJLnPYtmXbGWiNWmSJkt9+cDhjMv3Hby+nRd67nzPXj2EVyFu9Mg1pGepbPG9Tps4IU7Q4P/e1cade+lovB2zgrS4uK/r114r2jTYT7ly3c07C3Y+2Khvwl3zrnWc8jFLmuDCCuwHfvny6AnhnUfPufxA6Os9U+easu9rx8XTmiw4Xj9z3bcVqgcnPQADPM80iOSJiCHP7DHqr6M4+ggksvp6qri2KBsIuf02DK8/z+CxiiAEwRnxKAU7YxCjv1KMCD7DamOpONjSAkc5fvjhcLkbb3SvrxA9a69HpwBrkTB6ZspNJO6OW4y5HPvhJ7HveuSLsL6C7HEt0iCyKj6vdDvpJChrtHHHfXaEUkrZqGQzwTa1fOg30ibMcEqF6LxIRzPV5DOyNv8E1CCWBOINoawKg6r/IJuQu5O7+0bybp/x9kSuppIk4y5QTQ/CErQKB9rSICO5AsvORrtDTFIb05RypYIqLG5TWdlzLlZQEaKnMIiOuyhTghiNNEo+SzJIuIFkmnXWTjujTyGu6mEoVIUiO4wgsvD8NaxhpbQsIRaTBVe3ibRcVp4tv91VUF9H2pbayPKpliBkw6UXN+ygpafEhaTNy1F2Lz1OsbF8neyrCgclVFp1Fq634YiqTVEeiQkybSt+8VpSoMUsTSyyjiecaFBHKSOLwZcGWjgzh1emCL+C5InnPHAIi/BihV5T0eNLlxxLRpzBGdnfgeYR6GSWj/ZLSmMHihlEmgn1LF6/apJM/yDKLEzpZxkPhoroeSYGR+X+/EMaqYBle+ogI3F7dGp3Qfb5MXB8thAcdIseUezcOlp52V05LinGu+PZyqifbx7IZaspG1Jes2JyLbtjCb27R7KV7StgKKMEGjuDCo+ORoJ8hog07WSiaqrJA72cTX0Fet1sS3W06V6/DUo00dIHgu0gGedFqDXUB5LY3FlbDxTB2A2yOXGS9FNMy3qWR9zWi6TVnfLHmwd1Kmhhl9jmyp3bbFbqG5x90n1Ek+r8h4A/KuvD7WaLqpdLfBbaiQkfcUvuo0NelfLivjtZRFXQU4v+ehSqx3gOLw0pXomkZbrxNSeAgFKeQLDEPbLgaP8//HCKPYhWHtJM0DEY8ZvEjsQWUJmFTResF6kiwiHFiJBpufmf90ATD8O8xnuQy17Z1iNDjPTDH/5QTg1H2Jz/GUVffjOMPkbTkJjMT4juISJGjphE9l1RVFjxjQazJpV8bUVuLyxbFi+yxX6sr4K4A02+aKZCDR4FHh1Zh0bA8SyGKE+NXhRIzPqyvE4trSBITJNoLtKs62gQZjTjnxMFcseO6HGPxTMQQdSBDkA6TEdSxIgP3dQe+RDPKk4j3FEQFKJ43KYuENlkJz3ZRmzdrIkJmUqhLvm020FkQLDkpCzrxUUq6ZA9+XNWLw3iG9+gxzSxFKZubokQYsoKZxPnsd9ClBlIPP6kmVYKWzBB8w6iCMWL0zyIjfIRxCyFZEUMgiCCGrLNgbxDI9502lLmEhGg3OWK6ExnIjX1GpMUB199JJxDpmNPZoLoJjkRZ0I2cpG6XPCXR5sQsAYyKUWu54lSodsUG3IVwhCQaa1kZjMHAlHaCERvGbEkQvyJEPTI0lTiUSc7o6OUH47moLkyzY+YclHa5GSlGVHHPvepEHPOtCAXxaghCTIptSRvnifqUUuDadS47GSpnYEqy1CVnw9W9YFtgiEK6aHVlaaMYRmBa19k5kVUaTQ8VNVpND83IqUwJCAAACH5BAUKAOAALAAAAADcAKsAAAj/AMEJHEgwnMGDBseVI3cunTt37SISBHfvHrh8+QTy27gvXTlxBRGCY0huYDiBJycKJDcOpMqXMGPKnEmzpk2C43IKHHez57mfPwWeo4kQoUKGDiFKJFgxY0ZwGze2+xjy4MhzJcEZRLmVIDmWLnuKtRl2rFmVOneelQkUaDpw6YbGLHpQobmGDyO2I2ivqcB9UKPeM8fTpEiSXFN2BceTZeG1kCNLRjsw7eShbd2mezuXbrijeJUKnCew772ngAPzy+cua+KtDIcWndiY5eTbuCHz3C3T9c3MmmV6Fjcu9mZ3A+cpB2caI8Go/OzZfn0yNjhxIlU6zs29e83Hj3ED/wcqnC5xpMcJLjdt8anGjfk8atVatFzc67Mr5wzvnWz//zX5NhBwcckFk2egbeaQSsrNU5FK/PTTDz/z2HYSQuLY9xZ2GOoHIFnihPhhZJbFJCBNmXVGl10NcTZRg/aYBqE/q51TDnUnNYRfUWWNqFJKPt62G38TfTXQiRPJldliVRVV3E/pMaicjCrRyM9eOxqEnTg6jsOjiBwCGeSYZK4VFH1iosnjk3AdJ1o7y83TV0wb3ZMOWAdtSU5cLeUZ4p9ahpimd4OWaRaRMLkmIJJJctUkhgsNpSBySyU350ztYMXhpiV5BChxLf0pqlX/FWqoWCVyd6ajhpkXaYvH6f+1F2nMPSiTnTaOKs6ed4oa4n6+CspkbheaGpmxJNI21leM/qgmgq9OmldEy9VqK0z7ZAqWqBpu+2dx5YQKqGchoWRWV8jelN9YPf5n5E1hIkjOXbAmpVeD4MhJEz+4ektcOpmKu99XH43r2cHrErVVujaRym673mWFpIEqxYthcfTCOi2ccMppT037zLOZt+MA7NF+CyHl76YIH6wuwwrPFxnE18mEaKJeHfkuTAbnCZpm9lJbLUEYYQRdP/5cNE87d+5XMtPkpOwW1MEK2zKPJhk20bCnEgQmzbkt2mw4Vvs8b1uTVqrSaUXvA50/cPcz2p1R7wkO1Jp13LS44/b/3LLMXZsl6neV4cbs1n5nGBvQEL3YV3Ntvw033Ku1qeNyCgJcrciEOf1p3xaT+xLXZYYFkq+Eq3WzWIcjbvV5ZwOtnscV1V600VEhPTnc+dxDWjum/T6QX77fGa5jOfkaqN8JJxZ4f6v31HpIxG1aXOxQujhljOzdng90Ue0++Wre9x5jU9+vdg/TwDk26vJXN/n8/CYyezCov76a/ewed1/+Pm4Ln/jGBz7yRW4jo2GarPZWNeZlx3ligVngoie9ryAMVDn5Ctrecq/++a98+QggPwY4wI1YaR+3g05p+lK0pWEleaIS198gWBMJ/ud0I5IYOVoGKv21SCAdZI/t/0BYNAGSsIQF3MiE+KGS3mnLaVCUIV1e0xMbegdsAOLhURZHMaGdr3ZDJGL6jEhC8I3RhFZi4uQEsj66sYRZP/kK3+JnrkfRj0wSu9rPVgUOpcAIjIAMZBhFqLs0wgeEBRTfQPJhj4hkjlrs8xcdy1XHO+LxaufRkYGmtT3ugVGIgkRfCKOCwqLV7nHoAx841vgc9TnIIgJx4gthiDBL2vJR8tLRQCCilI5xL0Ye61+DYES7UFYkRkCEEUUu4h4mysSZrGzjLEMlOq1V8pYkomCrMGQUivWxl0IbpjiXJitZDfOX9sDX3crpRTDibpVJG8g/5glPRbYxLnIs22KsYv9FbM4kivvhWQP/VA5dArGc42SnrB7CUIaWUyUNVWjH5MS2CLGySoq8SCMduS2RKA9mWPTnTgC6OpJuEUoTkehCI9JQd2Quc+tg6DdbStOIdrApbivkKidCwr/UTlugq1pNQipSxjjNqPVjFhd/eNCBKJSm64hq5tABNM5MCqI1dei9KjrCjA5kdxOSm2rWtzKheu06XxPR6Bw2v6MClC0bVBBN9NLSdbwUHVRti1Dagg65TmQdBKmpOVmY054OBHwX5RfdADq4gaQVddtsXtegaFSdHFUl9HJRT1j6ELtupq95PYc5wGGO0n6ltJnpK0GiGtOGzlSr1OIq0iSEtAj/IVA1aIwnVFwoR881Fq0NjOwU6RfFyg4pVeAox2hvkw68hpa05YiudKer3Iy9RUGsbW1WZXUpEVp0jWJNJCudODLkUVOtwaoZjqoZJJpR9p8DUe5B1fYSWU3ks6SFLnX3S1169XUz2WVoawWyMX1NRI1wewn4Cpng1SxtsbT8k0Ag+6wZ4kYxEwHTS4p7E/nOVyJ7aVw7psXQqf6ktPs1aU6ki9r/poO1WeUkCw8sE0PmdnfMjCQMv+U1EV1tuJJBF8NwaFzk9ma562Tn3WKsoLZMV8UAlS44JAXgqNL0XiwcpREFQk+CUG7BPc2HyKb5XlzGT8JnKdYDa2Y6l6hV/8UzQWmSH6qUrG4GKOZ4MhR/9S0MrnivL9ZuXv6IO8TCbZ5d7jI8OSI5f/xjjWLGp1J7q09MFlRB0xmLmrk20N+ONKBxRkdMKnVllhYIK1ELF7A6HcPC3CUp7pCHL9Hn3dztDtH/4LKirVToyc1zfIwkJ9NGJsUf7yodpDmNnW4UQba+hNVqPQteNUsQUrcUxC49capX3UC+gUog5uhrrM/JNtzRVkIkRLSucy0QyhXxu4hOMFQwckwdV9o8e6KVKeVTRWcLVKjotRmipg2TvAR2piopUNR2/L5dhetXAX21OzwoSi0r8dwMxjW7eWpALR/xsBh5sPtCV5c9YSmWRf9zB7Nr6O+KsRq4RIXJZmSSl4fIBEt3xsrDK62Qbx0FLhO3Bz6Gfg9QvnvBGde4old5SIwU1rDzLt4sSU6ccwBvIrebCstb7nJoUzg3G2PnMPVyXdGqOnQxjNSL4RQjfPwSRpA7Y6OVru5206h3OL0xjpOmPh1TM0/5vhbKMdKOZlERXp2GeczPwsmJjlM5pr5zPnXFolg9fh7y4GU7cQpAMDua7uq+uzvT93GNkHfq3yLH1V+S9ZX/aM1Dfbl6ATToy6dz7JE3e3QJxivHj1MemXdHVNmxjnfEWh4ewwfb9OH0p4Oenv7oxz6OmeUzMhjkvss28vItk6wjCsiI97r/jx5ie+7JSZwjRk7m+sj22z8++PCIqjrmT/x3wAP486iHJ4fotkM//9Hqs38HNECmx0jDZg4mRysw4T3uwB+SFX7QFiTHN05v93aXB3fANEzB9xDxlw7zhw7zpw7sUH/3h3zbQ3SjpDv/J3roVH3fhWOB0TvCtnoLeDt2Ehbg9zDiNyI2h3+Pl07oZHvCpBzAx1DwEH/rwA4hGIICoQ7gMILvEA/xIA/0QA/1oH99oQ/64HzPlzTB1kls83QXBRUoBEY12HwAdA/nABI5KBZet3i4gRyc9INBeIEaaITwQBDqIGoCAYLgsIRQKIVTaIX6p3xayIV0F0v5AnfK53Qv/6hb70ETIQRAlDh959CGbviGPGhzgeVH59RJGWiHmMeBUWUTgMgO7xCF8VCFVyh097CF+4Bu4AB64NAPX3hOhggOATSGNlGJvigdsKeDqJNe48eBApGHM+V7ovh+mYeEL8GHMEF/UJiKUliFM0GL/CIRwGeC53OIujMWgFGJk1ghpAOBaDYZcIhVLUVgD2GCy/h728iByKgSolZaMSGNqPgOBFGIsEQQ2Lg+nbUO8NCO+fcxWyghMDEh2OKLIZQPWgcZxBg4MWZzLeWOdriNGFlX8zgRojZdpWWPAyGC7DARq2iFrriFzjSLSleL94RXTkh8JUgRKClWX0U5rOeLpf9kJ9r0bxGpMDYUcxPJiQy1je2AkUZ5lA11hHmYXQIBWEKRZ/yFZBOBitVIiEN3iPKkcbHkDqH1E3hFfDGVbKnBU1+GdTgZcuSQjo7Vkw1Tjs9GEwI5kEF5bXpxlPHYUkoJD+9QiuDAWiPZhwLBX9H1EtMohVTIj/rgTInokKL1kS32le8gD30RixPxawpJNMxEiRiRDi3RE2zZbIMSbbMnFnMpfKWJl+6Ql3uZXdk1kk4YX/sllfgIhcU3hYXoHisZHekAlSx2Fy4ZU/aQmCrxaHGTkszUkPS2hg2zlmr5em55VsB1E0EJDkp5mqoJWKyZnUk4EbzJYnqIjx8oggL/iXynkZV1p5tQqRDRFW7rIA9WZg+U+UyLVD724HozUT1qSTrByB2nKXyClpQbORClqJ1MqYSvqV/r+Z1LiA4f+ZVh2Y8qeZ724BHRtWIFBQ/6gA/x5yDxORPew3zrs5M7IZptyR1hQVN5iYzTKY8pmpcD6pR/lV2rmZ0GOhBQORFLuIfdGW7qEJa16Gt1t1sU2hJ2kQ73sA/1AJwdGhOl5D1qCDgxkTxtCSTPmWE0EW0ompfsmJpHiJfUGaACmp192ZdOyZozylp7OYJ7SI84+oHdWV3iZhFAimsaMaE7t2LuoIUbeqQJ6UwAdJwVMQ83Uij4c44zMSxVCp33ORDx/9elXKqUX9qiR9iU2PkSL0qg2pmKmlp8qZiESkiPztWEbjpd5+BcDvExc0qnUDGheRYqBdUOvtOe9pAPNPlVUfEXgHoPDTgbfhYqZBJzcDipknqE+tiUMYqdmCqjmrqsneqXn0oQzsWHH4hXvqkOJagcFtFVzycQtthGCIgUkCcn31MlKoRyx3QOXgIkeyaa+3kbwNoTeTipkZqKY0qmyJqsmMqsy9qaakoQXilqC+qg8QAO+DAQ6OZ//8d0ZRhILESTG5dGgGFKvpOWn7ZjwpWoH+JmNVGs9gemq4Wv+Kqvm8qvSgiN/wqwgKgSOZV027p08AQTdVecTLSw9qByFf8bHpPUNRp7Ex1bEyBLoCJ7psOnpgdKVdEagiNIEAWri0p0awk7izABg1q5UwqZk3YiINixXpj4qz7CmvaaryJLo0T7mlRVWngFEycZQCzbshvnj7+WNFPbbnJDsxQ6YSS3tc/TnDEhpj8LtM0qtgZKtqIFjRPBjWHYtAi7rVDLZev2a4lIENKHdxVSGPfGdd3haVcqGdpprPfatyA7gkQLbqUaEybIRo54sP8XpIybuqprehXhKX5zKl8XE2EBo2bhubiLr6Abugx6tjWRZWqbuOKjbhuXa6yruiyIrtGWeDdkVv5xu7kbvUO7u9S7hODgu7+bd4+YbsTrtsfrj9L/tz42glYMx7zoqHiYS7skahPS277Uu7s56oTYSxDFujaHu73cm2jGy7qVeXfuYCO+lXjrKzin47zlQTYDLBPtm6wjC7jvG78yUb8T0Rydh7/Dq2js9r3+GH2sYSOqJjDBhY4ReMAITBw3sblfu8D7WnzT+8BjO39iATkVfLBHRE/GG6H8u8HZYjzSFcCGSsCyR8IXo3onfKmUusBRtcIt7MKBy4Q9QcG1dm4XbMONS4vDSSNjtm2rthZvmL5rhSEhYh/t4B4zwVoq0b5CS6DvC7/x68Q3URHMV8FJ9FVQe8M4PEAua6s1azwWm4k+58MJrCJDbHVkvLdiulopDLZB/+upYLnE1dvG1msTyheGtXarXlbH+/u2txYTNKKrfMw3VxosUYSfgSzIZjNxhazAXnusPxu0qbi7JLvGMAzJTpyK8CCF4CAPA9F2tFbJtfjLq2TDSkeAz+TJOudtzCnKJOXFWzfEAANLqqTKTHnGuKupa3zNtHygCiqSUHjLUwh8u4yCzRfNtSg3cFvFxAmDNxcXVLGWULauzNzMF/OqzjHH0mzGrOy517zP3Ay6btym/WzLhqnLBSmAk1iu3Cpv6OxVTMo+qjZSC5EyFQrIers1BzMO59A4ckfOMNG5fFmviayd+yzLItnGf3jSKoG0oCvQGEkPBe2K5VbBkPuNC/9tJbUKE1dyajvDLB/8mWl2Pxg9D05RyRwNE42MzyGNqSNN0k3sxNoM0LtLjd8MfC6Nhft3Gn8609c3zNFnnJxszKl2dgxnuaBpHsXBGZXIDyKEk2MZE0fttfq81I+czSphICpdmANNhYSITqLUSlCBujhMnBcniU9UbD/Wrs45HJdGGrdDNDboTjTx1tK71N6Bj5wqiNtIiFYN0073HAa7Rhr3ZYjraAomMh1lZocNe0DNfceZyqVBfcokE7Acve87Fs7FRxQzFFI5ECst1Zmt2Vf9ioWsRD8a2L92NAjLeoVHTT6Z2hf0JMjR2uXDRkXXdu6HfDMx27i7u7YdrV3/qVeAKdv5iNlUfYWt+EXCPRCdV852F9qGhG6q+hwWobxWpBip7aoZDSdhJEZ4Zw9WXQ+Yp8vZPYLR293ejVrjMRCEG8GqONWsaN68LHgqoYLu7XnxvWEYO6UJgRVW90u1o4X0tt/HpByteIWYF9lPKNkvaqxPWBO3PR4wDhwLzuDkXYWazRwwDaEaQVuJ+7ZLhLhxqxH92Jm3URSqBxEtmIXGdEzgAOCjEeDR3ROrLBZrer3OlTExHuMzzuDenNkmjuNLq2A8/nm4VpydV0grOYv+sA+N5FKMMRklZw7rIIqb7eFuV7iR8Zctzrm2G43RemJZfrJ4lVpbzuXfbI27/zw8+jARK+u0Pq7Wf03hqjpP/EJOL1TRiYHR6VCCdhkPSol/5j00RsmlEnwWek6mex4T303of36ypeqVvlnoKU2SA3srr6jeK4vm8dbVf/GCU0vpvvNgQLFwpfx6YXx8giiFeimytjkP9BBYkkqvRp3dAiHZSSsTDKrl3g0U3t3tsh6SSBsZMyzpxDkhlUjDQfprDrkXqEZaw97HB0I20eUQyz6joFt8ej6INi4P9TARj6qXLB7Za3zIM7Hq3u7dtBytNZGya+Fd6G6ZWS2GS4doFLIX7gNqk8ZtOJgh1+vI1wwO1KjX5809V7hL1PnRbr3PBI/tfIXwMPyH2Wy9T/+d0hB8FmsdIQxm5pSI87xI8W3EGK+DQUY1ads2EnAxtHcd1cxalec9dE4/dB9zjH2uEkvNmqeOoyHZ7ZEM8zHf9V2PijIR9YweQGdOwzpf9jSdlf4gg/iUJcNRsVITaB5Pvcua7A/edk8P9f1+jAM+0jQRyXvokjUP7l5f+DkKhWGPTASx82qd65MjIY2/3j8KiVy29o3Ex1rLTYEyZXLvrO+79Hb/4Ppn1W73MSYu4AK/xjIByVxv0qIKw/788ts8+LxNvTKhfyorx7mDcZG/8y8RT48mZv97dqi9JgUFgqeopkpf9+S9j1SoEv1e8tT+8atv0m189Smu+lMZ81P/Wdul3uR7PxGwGMVhtURs/fuVL007Z8p1kaA0n/T5yPy1DhOoD/7h79bZD7r3+JqAyIQAoU6gQHbgDIJjl1DhwoMNDS6EqNDhQ3bvLFqMN1EjOH37PO7jxw8kv34hRX5ECbLfRnD+7hk8R27cOHEsDYbDiVNcOZ7lzP3UOFBdQoQVL8ZD2pDe0qUT7dWr17Dgxog2BUplCE7dwakUIb4jalPsxIQXMY41qE9tSpMnU7Ld+A+cvXbg0sWkWdNmzpo9ff5EB87cuXMHhXIta9YhVKj2JuJzLLZg1o0DHUJ8SBZsxMTv0KI1e/QgPcb27OE7qFb1W9asSa5k6a6du7sy//Vu1NmQ50+ghRse5vpQNLilpU3je6n28meWQocWxTx2s8LQBz0zn2g2qcHijU8nV726tcd8Hdn2Q99yY7p0stmfK3fbIU5w5RyaOwjYoWXN7+IxZco7fJBbC5x9yMLut4E4kwi0iwyyCJzrEsSuu3qOu+ee8MLbx7x9ytvwrddgc4gfcGIajL125mnnrnJoaiic+nQTDD+xAtMIrP8A7O405F4yECsKDeOvqHUMWiesBCPUCJ4hxTJuwAw3pLJKDlFCL72D5DpIpi7taifM2sY5iKcZN7IxqKsaAuud7paSR54LI5vyycoWVOhIOzdyck+0BPzRyiozJFQ8j7Ik8f8fRV0Cx0twxIGUTLvYo/Scn+zDDigivSpoR6YWu1BDPxUkiLJRT2UuykAFDY/QQg0dcctF73GnPjL5glQcMsk5pz13klTHHEzRMpPIiDxDKqOD4pznO4NMpFAh54aSqCtUr7WJNEBfpdJVb7n18MCGFP3Hn3zqsi0ndcPR1Ux01nEnznXUQUdTsYbVKjr/lAUnHniYtecllYZMaMFSp2JHT2wX1shCH3/UsFtvf4QYvLgW5Weeux6F9Cad2u0JHHQqkoeeeN6ZF51607wvTWqVdMjfeORpVuAso2VHqJwns5ZhnyfStrEBA/3226GRQ04jj2SdtUVywMmL3UjH8cv/LxsTy5leS+3Nz6CDJzwIHrHjdEylmxPMeitOe/657YMYm9NHQo8e0CC6k24ouY9IAodcf8xtkTD88gKZt5+25o3TwwpTmWt0SvUMo4ySladss7XELuuuFlLYbZ+jsum4ox+jeyLwOiLJH78Bf8+3qgczR+XHZVd5TYSKUlvk2WU3jM2DkIozqnA90ifzgnVu0HPlx4pMo9Ifi9ij1FX/m597WryrMPZ0p712zYusNueDHhdK5Xwraggp0hwLVx9CEWQpuuRt6nN5+x0aXaOIzUPv7+rzuZ47aEMpAYoNHutIUsIQiMDj5Y4iFhGfQWJHvq28TEL7kpNBUuI+yIAO/zFo69z97AQVUJHQTvlryKoG1pJyWS9MAoShwpwUpzjdyXaGWchVAsO7fCFEcvXAx/A4GD8QihBVHnwbEimEwoYUz0DQasnf+rEPjfmqVus4IBb/ZZDIkLAe9ODKDfcjrfiV5T+oMZBaIoYPJS5PbNeSh5+iAje4nXBoYiGR/6x3F3Swp4AGbIhjBNnBL2ZmLC8TCI7IVxGZAVE1BxlaG5UHSCNqJG6mwWTzTMgcJqZFI/7zx4HuQkCnRAaTA2JMU7DjHN0R5D8XSo0TlSgPflUSVaqkUCZNM5FNskR0d/wMKA/kDnjUyiEPG5BpLhRJk5lMLA4kUuMexw56oCY8B/+xR8kYE6da2vJUYEyQLnXZEMZwcZfYPGUnbSJMctIRmZB5Ct2+6ExD/mYi3avdOkCHEnLKQ4A0rKHntuMzXDJHnAedSzkxWcqHMQeUU1xoO99JSFQ+BSrOnI5N8KkON6FRXE4Exz0gMw95iC1eAf1ZsgbqJ3COpqBoOWhMFXpOLs4lk2gcy0P5oQ94Ni+JQByaRS+ayqVkJDRg457sOFpNDZIopK5KZj3mUUflzcwhAI0jc1rKnZcyL6ZfBas4g+m/KfIUnpa8JNx4ZLLtVMdriZQdO+SB0yyJ6yBGe57nsLpXvm4EjPQoGTg/hZ2wFjasaOkHWcsq0qdshI5EZcr/dpSl0jA6Zx1zdQh6lua+JlppeXwFLVbBEVAABZarW4WpYVU7TsQqdh+MFWo5DULHtbK1mw6ZzkLiAUQN2nWzIVLa/fZqExqOloa15VEuV7tcxIIDUR0SKSHVaiHk2hap/Tqqf0gTxN7yMy0pKUlIvJkgvlZ3sOFcLkIzmaAs7XRusb3oWj0FIKRct75HkRN3g/SRknwkLeFC1EGcOt7PmPe8hE0va9fLnOdGN5K0ZQotV/qfZE1IcslaH5AO8pYp+jc1+0AU5pqzIAKPRim1HVKCFxzIz4S4H2YN6mMju1KWHMVTPm3qeDwMGY4cysVBEQsCKxkn5NIRvQn2U4g7/zSXn0KWrcuB0FHVB1SHgBjEbumIebTMRViaZ0Qi1gqODnY7ApeMOKB6koqHhFPn1tV9mYxvdW/bJu385zROtGuHN+i+Ka1lyfaYR6AjA+IQj692JC7xWCT5GTVjp24NaXBPLWrgfkk2NK/U74Y7rOePcBY13MImSWuW58QahHyPK0qiPddoRrPZQJE+jTK/SEsezfPJlaYcPe7c1A5/eYMatsk9AD1V5OTDIYfmD9tUjS0VR1QsOH61ZjmYzElLeL4FVel2ge3iunaaz2LJkEGEHTcN2XVayl72wpq94s/8WtKpzGqlB6vSmTmyyoTutn/VuBEMvU81GZJSud9apP9lH5jZhQ2kWBPUoWm/e57pk2y2da0cpbEmtUPr89K8XSCtACfdAPKZYRPOWuxAV7oQ1gi9de3qe6ckSHfVSL9ftbR019ymXzUnWEveIVSCbrqoxfV2M23X7r7FdODoqbj7rJyONASUDx2wzVet85vHdOE8fwpqQW6Qk/knvxXXMc31l0yIFc/DkE7s0/0n9ftZfeRuRwtKeNpYoJ2Z68Dj7cv1vmEPi72JTz1aoYhukBCrfe2qRqkIBSlIn8m9g2MJ0Gl6+3Ka89PoGiken1+VWW4/Pe3LTnzb2X2tDbIRiQNV33YbcvbKW57vg3cIlQ7EbdoXGvGhV7yzxwJMzO//+fG/m+yUW9761qwe9sFFe+0R1RYoJhqgtlw8J1k+fNX8PmbEIc1ELv/6s2/k+G1WvostDvrijhfaCboS8dRo0cUEaPg6Ljp7lc/8kPR3/M5/vvn9ZCiGq4WQ7c++94M/4vk+7QM/2nOL8diQmis/6Ds/9PMQNYou9nMKV7MS1rimdgs/TjuQpus/Pvu2dGvASqIpO/Gz6ouqQnqbiWAV/qO4duMvFxOJBIQ9zgop1Hg08os3EnxAcAMpjggPatskIkOiFnQfz4JB11DAjUANU+pBWxpBIypB5njB/5pA2eqX4mAzI5SSBRSLsNsz1QCRu3qJ6QM9g4jC3EuQIPrB/7tKwRPrJSQMwoB7HxYcHgX8N83bEG9hO43APZdymym0iS70rYTrJdP6OyAcFAe7G3EDKT97C0ORQG+RmHCbiECzuT88sVGRJEFkQgJpOg3iCMbapB0pQqYbFLqZQmsKEQycOc0DOFfZwzpsCExkwB3kjk2Uo5h7whQCxdbjoKwjJ0j6r0VURZrCwfSTu7VQI4z7t7uRxYm5RFzEv7oDxJDrRUiKnsELRhVkCSthRGprHhzcHyOUQIwLx8ArmmSaCGosMdzbKlWaB3XLRqQDQr9LC1JctFiCsbuhNibDsS40xwmcKH9URXHsQzR0R10MOSrExxQSRrsjHYMMqmwUSP9YdDCCzLmnKEgKRKd69CZNhJOuuhbds4kCnC3QWUiko8izajWAM8gr5LejocDGyLmEFEnAIklUMUk7/BM0HMTR4TEm+8m5MMjjYMlzAh1V8o5qIw5YIjnEW5aFhJNEAzaD8IejA8qgxEFPNKi7kSmgiSMwmi7uAJ2bCqk2DMmp9CvAUrU2zMrV46k2ykFIgieqOjJxNCVz2sckSq6NFJ2rNKI4QqmcXEkCi8s2EwkzfDScwiQsNChwaEo4S8leIi7AKplYEyd1esfDTEis9AfNcjWDhCRZs0x+4yV3miMj20dqdKS5uymAy8S++gzPdJuslKKdGk1/tJsUPM3F8MX/EgKaT/Giq4qy2WLDDsIkDRGp2Ryu2vQmz+O5iSRN+GIJ2QImrXOIvwKnsmSTCHlN0xMaxnJO0YJONGubp2uz13IeimyyRYMbZFoWlTIza0S57+Siu/yiZarLn3kj5gAtAE3Na1FLUCI8fsiH6WtJpHssxyqN/AEs+gS6rfo5h4AHzwiaWQsaN6oftAjQhDRQFvvEu/EivJTM9zyaOUKx1FzNQgK6q4ITRJykDvVQ2uzDw/uMO2JHD4LMTSon/jy/RcvQTXrRieAX2xyvDwXRxEQLHRWqdirRvOPROooKNuQpB61QpUiQvhyV/wRQG2W7z0NNe+zNGPvNn5otKBWaUznsoFqDrIZBrQeRKI2AGRFSUpuLOl5sTFXsUTWFzACBigEJQmVy0/jKRckkoZ2c01t8Tqk7G6fbqYUCphSFTBb9TUAdGhTMOuQ6VLKMM8i7kIAAACH5BAUKAOAALAAAAADcAKsAAAj/AMEJHEiwIDhx48idS+fOXbt58wwazAeOokB+/O6RE0cw4bmN4cIZFEdy3DiSJEOKlMiypUuCKmPGfEmzps2bOMGR28kz50Bx5cwtbPgQ4kuLAzHySzeOoDiFIFc6RSgQ5UyfWMHJnCkyZNavYHHy5HkOXFmcQIUydNjOJlJwSueV6zjuozivIzlaDckx7M2tXqXi9Uu4MDmdYw+fW3wTocJ0kNlG9Ikx39mqdcmdHPyz6t1wJAvTBKxSq9auolP7TSxw52WajheubdcWq9J2TTEv3sx5Kt++qg2SLh28uOGehw/bjB2Zbc23FzFq7Kjw5F2Xn6UaHwj4tOnt4H0m/x7buJzs2bUN3iOYL9++gkrTXQfn8WBK4ae1hyedX3/4/zYl1htLHkGWTkv2gLMeTbflhpBQG91XEH/bydSffwBm6JJyrNnkkWwu2XPPiAxmpFxsmkkIE2cDgqXdcN9pKGOAOcX2mjsDRWTPjgou6FJlZzmWzjm8TcjiSi36JBhXGM7opGhAKXQZjiyRWOJSJ5lEzpDWDbaVQMTl9xeSE5oWmHdPptnSTvhJZOONtIEzGU78wMWPPZppuRtK3vEFI5hhXmjhcGQ2qeahLjX5JkFUpkdnnfzkcyB9UtoHWHYWSnRVYINSiKShiIbKnX+OCVXWpODgSFtEc9oEKT+1Jf80ZISfaYUSpknaRCioooaqnJH6vXleqg7J+ZV055Tz2Ee8qYTQXpnyKhynmWra67XAUiflqZClumqrBUFHUJ1wSarYQnbdipBJKf05JrXYxjvmTx8yZqC3bYErkJUsYXTRPK4ZaI5JBCdETjnNepprmdXGKO/DgGK2LTgGHigZQQmy15K/+6ajEDi0eZwYuuXg2t2m0pYm7ZPAQTyqSFEutljF3uYIVqTtdBtRzjLPDFmy7e6KV8PTumz0tOEYLHPFRMmpr0Di/mjPQ+vdM0/I7kBWVDtEQrvry0eHrSto9TLdVlEZs/eWUhwb1E97cFeUj9UQGXXP1ERap27QhIr/7XeiHElZcTq05Zv2vnEnxXY//kjEtlJyz83vPO4ky+7eJnfn4t8s96XsebPVPY+IJMLt3j6L98O4P6yzbhC549b5Vj7zzKpsYl0KvTBLQ3Ou4a0FGijZ6DuOeI/p7T3Oz+qtN+96S8/DNRDtQ8oW8qx6//b1aL6nidI4nwv/7ejGI79PPsov7/z6rQ/EPkas+0t74SLOTTmzmKureUsrd68a8I/R2reKVz7T7eOAymMe+xbIQH+oTnYjskhlpuaxy62rYHwLVJn8ByC9fE9PAkSb8Y6HvPYgMIENTGHr+ME61fmjbeBo3EWoxyyCkQV/FOJd/ziYFeCBL2DDI10E/0towPTBT4XN60cCmadEBSYlHxRcjGuKcrUUeU1TuztaaLZDMGWphXADHCEJiWhA1D0OiS804hEZ6D7p2ONqVHPP3NphxSuCLSc75CGfBHK7mRUOIkIUo+RMN0YiKoV9DzSiGdXnwDSuz33gUGKkkkeujFTQgtkBVBbb5L8tvuSD4BsIQ1ZFQDGa0pRkdI8aK5PK1K2xeTjJB892gkFB5RFNHGxZS0piEi9ehpQ7CuQpjVfKU6YSeQUs4uMUyLp/ONOZBnGegnI2K57kjmhY1KAe91iQC34ORCCrWzB3RLxgllN040wn6dozzBEVc4hwW+T6nvkP17ERinBsCGRSJP8TXepQm2HzZDcFKhAtuQZEjhIdOt+oUIh8i4riFKY7zdnQYCYTfa/0xzOjJ5DGSVNyI8wZP9VVlZfcUlQk/eRAziUbKrWkoQ4tHG0awhaZjg+mOFWoRYd4yEey5JGT5Mf57iFSvXnSn9ja5FRuhZNuCcSlBDEKyBw1U5padR3rYJpVa2rTrt4UncQjIUaYKUOXwFJxGamdNXNDsM4Uhqkz2ht2WkYUR+VEn4ODDDrQUTGsrmOrNa2rV2Wq0AhC6qzuK2tZY4hYO1HvZ7/q5kGWihOl4S+umGNJy2wKFr0aCB09OwdfB/dXwJoWqgYh31sWy9gWHjGxja3M3a6mE/r/FMw6P0kpFkuyJTBerWve46ZLIOpQgzREIvcaSGiX6zPIYPW0NDUuYSESwfdEM37pg237OvrC882xmnk6yUCF+7LYOASQFNRMYZSKFZhWdSDwgEdBKgbay5jjvvi9b2j3aiC/wuO50SUWTeXBVeqKFXYDSWR2W9vYNFaEqOC9nGfguiLQCCkdYTWeSJGKlSWByWHtrdvWUgVfcGB1cHuVmTnKweK5gKPFMNbvYvibDr/69bgC3qpNVatKcqlOwQtm8Hbh810p5qmgmITJZx6kNfINEcIbWe/LOAWWweLYxCemb33vC+MW87HLLMavaEd7YxxBl6Z/rF97pBedVUIO/y7Ne+br5kjNniDZqIDi5VDakbFCWs1jHFbSp7oC0Jt4FbV+1WuKz8FlMMP4xY4Oiqmci1UTnxnNq4Kne9D6YzVGJ87QhM8+7jbTA1UvvHwC4CjJBzXkqTXQOCGOrNkrka5eWSAn3uuiVxzpXhYM0l2+70D4WuatMqqmTyuIC1eY3Z5qlJ6hLhdI5TTLgk64JAt5SPGmZ8Lz2cNj61XZVcJi01uLMh26Xgyvu3zbdt8W2KYiM4BvjVpuoxXB61Pee5wN7Whj5IAWmZpB9AY+cxDuad32tjuiHJbtkXum7XApatFdX0b32t3uDrZoKV3aY9e1bppe5GuFjN1/95iFz/+GNnxguNJ2P4ZqEjmgzKG4cFiPzV1Vfq9LKK5udiOMYOrKeIw3XuN1FATTER3iCZXiRO42TylrxijK+83aizw4iuF9zHn5NRCZo27Ur264w8HiDgITuN4E0WvPHW1UH16wly322dEdMjwnk1DkTG+mnJ2O3bhhdHVUd5xQ53fqbK9KQTH3OtjB/RXdnVQiAzZ3gCm25V5D61k+BF+LJ51jwaJX6Xh/pcr5bnKK9Jhx/a5nvx4ccQORcl+JR+Dic9NhxxPm0sitPLuvaeG9wX3zCyltxMdHQBMqz5Gt6zc4/kH6SUYOdWQd8pzxeTVAtlpcXhfqn23+z0EZB/cG4bn/xWFswZhgrotxRwex5LHQEcLtjGNVYOpDzWy/vx/l7OsodzXWIx+1RPGLx30VNm7hsVVnN3nht2vk13bn93tBURZlh17FZz5s00I/BmqpRxDxM1Q9YjoZJU2EkX2jxjUCqEmF9n3ykIIqWBOfpW7r9nP5402+pH5os1Mht0jLllHzt3eMJVv9p3SLA4KCJ1Q0IYLnU3OjkUMmxR1fUXYqmII2kVXpxmgviHE/tBNqIRB8pk7u123L1GnOs4M8GD+Sk06gN1aNVRAOxHIGAYBDhYSJ8iWxdkd35YRPKA82QXGLNn6OhoVLo4XaNlE2GE9L92MXiIE7qIGTNFvjBE9m/ySEauhgCFYQbjg3gNZ9tHYmS0KANNEQd/iEefhZoJVf5kAOYrY0k0JF6lRKhLg4jMRMYsiDMRQp68GFQMhIrMV8K3dAsTdzFFQy2URrJiganviJoMgSUChKU9gzNOZUhLWKxaRMTMc4ZBWL0TZDdyMntng8ZrRs0BMd1tV1APhdA9My2PQuj8cSxaiCOZVTeJh2qOJxRIFOgmiGhXQ6rrg8sGiN0eYPo2Y1TiOB9oAP66EPCMQ40LOGk+iGCmc5H3aO72Ic7NiOOJWMkCdYxEU+0ChEBnQ6eLdsesePuvhC9sMqClUPPHIP+mCQLsQS9eRalDiO36ZeguIX6XgTKf9Ike7IfhAhDxnZjuOkU9FYQksXfyHJjwlWknXziZ9nkMvjki+5huKoeO0xD0BTk6FCXnY4kTrZlV4JSKJzU4N4jzJXgUcZi21ENynYEP+FVfGFIxGBD04pEdCGXQy5kvdQOQcBkcFVUsaYk11JTjopmDoJhVzZiBclRyckf2g5LlYTcVmmDuCgDuzADusADzgykAuCkANRlwrphvrwZ4cBkTcZFqGBEn/Jk1+5UAwVUaOjk6ilmsFEkF2YcN2IiBnomO2QVeI3ZuhAme/AfgOhD5O4fPTkWuMYmlwzF7tTmj2UagKRmjr1lRS1UDClgmgXnbI5m12oDx6Jhsknhhr/CGEqxmtihg6XyZMigjqL5ZlKlJx5SZPcg1kCJZ0COZjVuZNraW4FEQ8TiZI7gg+0qZIruZIyB5KN2VGyhA4vqHHo6YTksw+cKRDHuYYAGJrf5mI14ZxYcZoDMQ72uZpfuZ9WRRCVyQ4G4Z/yQA/1AKADKaDGU6AGeUAgmXLK5z7Us26+pnnm8aAENg/4gD5VF5XvqXgjYpXAqEXYlpqqyZoiKjpPeFyoxQ7qUKX9qaL0wKIuKqAwKqMHyTyJ6D4jyKA/d1thdg6lBQ/yYA8sSZcWKFQzdzfuMDDWEi+ycg9M2qTllJ9eiZ0IOBBVaqWSeaUrqqUt+qIC6qXQB6a5/9l1j4k97cZiQ/FfZWcPEipDcvaSDzRz7ZGhuSGMYneCByEr89AeeSqUQTmiUcqfAhGormqlAvEO8TCrhWqoAZqoM5p3ZymLtAhhtlMw4eMO8YWZ80CcQxpDm+pd9pMOGioj+9NN5tEO97BIp/qk17mq2TmZryqoAyGrszqrWZqlLcqlcmmgt7mr/sZOb0RNjLYTZ7oWnjgP9/CUEoGc3jUiXEN7swaqJqWEBbUlpTqN/FCt1joPxliiLLGtrqp+3eqt3xqu48qlBLqYgNeoJnek1zM4YimkCfme6lo5TfElZPJJ5BWMnOgY0np6nUawXZmnWzWsEqGwr0oQ7+Cw4P8qrofapd75pTZ6o3Zyr+v6RwLJjZypiwTxknB6pOBmMrARg/0KULLSDlIXfz/GslCapyQKWPLlEjOra3tVEOxQs996sy16qJrJjT0lnvfGTu1kfBNqEM5kod81FxwBKkwVgwJIKghxDg9BSUCmFFibk4F7h9C1tS3Rteaga2BbszYbrrbapUuHrvSUYEqhrGR0my2xUf2gcCu2S3hLYXX6SdFKSUxnRIOLtVsJWAf4pwYRqJPptV9romHbuI4rrpqZq+rDj9EjSW7WDy5Rl5GiVkC3RZ+bF9DStObhDvZgfP9GlWumnYFrVYR7Zn5qVcNquAUhqCmmuLLLuGM7tin/yKK3e5A9m6CIVHUUSpeauw9qBYN4q1n6c4IoYR4Ydo9wczxPdjekM7iXNmAHOL3WC7MJKxD1xb3ggKICUZneO7YFUQ8EaaC5K5Ky2Fq/q74bdSci476B5rQ1wVv1S0TDBA4YerUuu7rGNhD9S1PXe70tAbsMm8AnqsCMyxIo+cDQF54i+buTa7QWXE8Y/BHyaR/vmxf2IcTf8xjyekymow8KIiL40JoG67Jld1ovIaydJ6wrLMAGAbuD2qoxrMCVScMOrJI3LLniycMU2qhwS0/9kJezYlvDC7rX5qFCTCmkKkQreb+gt2b6O0710JNSbMKABXnX+7JZfL3vsMWx/yuZg/rFJ9oS40rGuCjBk7vGany0bEyed1ZSbnJtRuwUW3IOymuDeWxK4PAe+vvHANqiBmuAAEzFVTyshnzIw2p0h6utVerICEzDDwye5ZvDBaG2wXycNMQmtmW8n0u84HNwezpOA9pnxoMPJExglCq9KazCNSHLKkzLw/oOtpywr/rFLsGiBEm+ZnzGwzx/UBm3d5I1tBTHyZxZ4mBw62CMUWx2kwGNgnt28eXN13xa2MsShczNWezNlQmrrtuqgjqzYmzDk0zJldyZl5zOzpQRs1SmDBjP87sW8hAP8OCfs9rNNaumZfvH1auC/ezNpRXAbznIBBFfLZHFWEzQ3f+8DjEMq62a0wwNyePLnucszJjssz3sD+R5MBit0cpcDuj5DvBQs+vAuE9ds7MrqytatvTQk9vszU1ds1pbyCcMXwH90is80zTd1Fh109sKqDYhvuWKQDgM0WgcputcT7JUTbeF1N+TuJa51zZt0zH8DifqrTjroi0KDiht1iu9zdyME2VN0CqN1q6q1gncEuDa0+DpmW8t1Gm8URr1EsRMOelQikcdzwUVFL+py44M2AscvmY7EAI6EPIQX4nNlgQtEVsL07Qc0o2N2JCtsCbKEvFAziOCu4y6QHIt0XErfT38D3dy0RiE1Kb9m5RJpa6qy2L7rVWNkgKRqCOCD3P/p9i73djfW9Yj/dgnKrM4DbaxCq4oObHdGH3zNNEVylGMRdFE7dyYlMzgM2PSLbNUKsPXTaviCw6zyaX20KL0ENtjHd4wK18EPba7bd7nLbMSkcjeKg81XK5O6csqpM7IHZUcRd/GSdf4ndExOA7xtlfoncsIvMDfSsM7UrbzwOC1DQ65Pd6N7dSOTOEGcd3ZrbOFiEa/HNTJTd/0TU91/WK0Z8R4W3Ayo2srXhALjIxXXdItSuMrbBAr/L0QTsuMy9Q6/sWR7RIOi7NALnJCrsaYXa/t+Uz9YA96Wabk5XsP6JtQztDpDQ4uHg8FkaXzQNgzjuVaDNZbzuUefchf/+7Ufr3LN1Hm4vuiBRrkjZRCHm6cPuXZz1TMBcXB9OFFpmIWLlwTq72iDXyrT2wPgj7oAoHb19vljY1rthzGLcHo8EW2GU6g30m1VFujImmBNkFPFu0xPzfHQQcO+WUWYyZaOZHIAjHYBDGgK5nqML3q0u7lKr3osi4Rgb3ag322d1eU6VOjv+yevksTdTk/NaRbk9Uaxn5fBQy7MSsRfD4QOEsQBDqj1Z7vhyzlM1wTU+3jVf3nAXqDq3SIP420F1HuMWTJcbsP6aXBQddlL5biieu1PO4S9SARE9sP+t7xWmzLzJ69O63nX47dOZmzFwXuKBSGOxg/BOG7yt1vFv9dOQdz1yUBZpAmZvnF32ktEeSc8QPxosPtlB6v7zfR8w3r4iqopQN/gypPtbjpmbCDiwwft4S3Ys+NEDgPbF52ik/e3/JuqPWQpQJxOPhe9IIe8i8x4WNOsyM9q4bN2gAKoyGX66mDoGL4QsrWPmWVes0Nqd+j9Y82EJEmaermm12MFWeP9t0cq0zd4N1qEys+3S+RgmY7iLapeLvOqPPnQHt/5DJPnlhvpoNP+IW/YvllwC6Rgir6jgIhoYyfxTbe1NOu9jZB3f6d7SxR5S56tkSUfdO4j6nn+ddF0W4uSzyD0VtPEIUPZvj1m5T9vTkpwqesOrQ8+x7vFwe94gr/PM5/fvkDerlFKe4tr/BqaPxWj3W3Y4qkeOxc3/ybl7g9vufBDfTV77uxv9VhTRPbP/kAoU6gQHYF2b17B07hQobg5tWDaE/iPYr5LF68uE8jP479PPoDCfLfSJL/QPbj11Chv4YlSfrjd4+hOXPnbJ5Dl1MnOprmwJX7WU7oUKJEzeVsiPAdvHjxwMmDqlDfPo8eEcJbqFTrVq3wvH5FqFLsWHADzZ5FS9Ag17EPI9rDR5GiPrn6LGrcyK9qSJEuTfpDmZLsQr8w781rly7dTnQDcwpkzBOcz6BFjdJEx1BpU6cMp+rtp/AqOK6lt34Fq5UsO7Gs074+a7Ag27Fv/+3JxT3XLt6OH/n6HQmY42DCLv3tO+xOMbiC65w/d25QLeScNSlPXngUs7qsCJsqpFcP31SPGjWb3kq6K2rVKtfJJgtbvtrZ6cnWAyfxdu66U3mD7ocvfwoTTrCxWAKnMOQQU+65rxbiDCGD3pNOncgYOueoxpJaqB579CGvH/PuwUc0pVCDRynRUDRNLAplg3Gh+dJih7612lMJv/z00w83qfYBh7eqfOvrJcBEHAwkhYxDrh133HluqXigkic8hZpK8SClZKMOKYU03HCsDzUScUSJ1DtxPazQRM89diicDsYaZ6TRxvpOJI7HHikC557d/hsywJBKOgklIM1rKP+kBAmNqR1H3YHnSXeohKjSpLaE0UIvFdKJO5XkGRMvIPvEByLoojzRK9HYPFWlTNHikk4a5ZQt1TXF1DOu/vzbhyMAiRwwuCP5wauh0JRctCR+8kGsHSqffUg/iOihpzP15OzSy8cEaqgeEPcBUR9wQCyVHnmcWwi6dNdxj93BXo2tQlnjpfXOpW4V00P9dJ1LVF8DHdTIwMwblSFk/Vr2sHncqrRSHqe1Fs1Y0VqoMU8XGg9cuvLDp+N6zD01ZIXcXZchkhfCFlZ55x2o3lrxnPK+t/j1k9defxVUJL48IvZQYwMsjqR+8qFIT3v0bbjSalVMiDnpGDJLrPAy1jj/P4g8ppY4rV2kddaCWKbXZTWfGoxHfr/199+cBSxQ1J9DAyfYlxKmiF98JEqa2mo5dLpG4jz1VlRwwSm1yobp2TrxvrtWGWyVxR47Zlwlonm3fPJSm+1he0Z0IY9Wkjs4EYnGrWO8p9U7noSabhrqqGWEMNRiSa1HnkmrHPlkcNBVXCGXv67TcbN+19JWcKaUp7Z9cQvXZl8BFJBnzlXSK+7QRd+H9I63P1pHCFVffUuxaJSHalHFrdueeahEOcbe2/+9ceFbJp6reG5NXix94To73LTVDhTPOhekvByrSC8BF4m2NxbEHe87WYFPWVzHjnjU4x5UKU+4FMInhdij/4MSqdf7fBe/eM2Pfr+zH1MUkrwGqoRy/UPbf3qjl+dxpGCC6xWRCsMPuiyQLNTizFi+ppCLvYMeVKtK1foklXDlhlYihF/KTAgb4hVvMypEXpXoMY+GeJBwu7IZ5gLzPLcpBIcYFNQON0Y4LzKwWqpTXDyOaLMkNiSMGgGRnKAYReC9Zk5TrOKdODNI5GVtIR70oq6ad8a8MJIhZwTNAf8iInHlSG8MGWRYGAKjd8hxPHcsmBn/9zw97rE1X4vVH73Wx8fVzzuEbApUqMXFDuZnIbpZJCMdKcozgiNnhEIJ0VSiNyB+L0Kt08qUxBPDjYRSIQGEpvtMeUqXDW94qf+sUCC3AstYyrKFtVSIInOpSxwuRGNh3IvchJPAYaZukA6EpXemxkwyVUUl9YSmR6Q5zU0G0p//tFcyOzlIKhlSLOIcJ9ryAcqFjBNI6dwZHmVCFkKqpCnU8hASyyM4uKkkRPncJz8bAlCSosc04PNKN7XovYZ0DJcxbJ7/mucZ/xULooXSWImgKEfxfBKfG3WmGSvpxY8GSoSBHOEISVpFk9rPOwMlKEZZ2tKXxtSqMaVpDJ950zLpo2OJi9g8RQVNYpGlkg6ZhxfR+BEoEo936ApZyOTUVLpuk5uc8aaVBlPVq1q1obicHVcl+tWtOYWncfFPPsvDxIaM6m4LS+v/RBeCrPfBRzates7uWkWWuibzgfC8Kyy9CRGt8TWmuRmXVF5qniGFJINebSM4psoQvS0TL4pd7LgUyMG/4gOytxGpUpmTu92JtLNQjVhoP/sULepVa4jtK13k0hAwHupXOKUL3hRC2mFeDW24/Vxv7+ZSmpKoHtG64GRNyRqTtUt3UDxNSt+JyXcud4Ur7R1/ciNdyfZpVwRr7UkSeLfuoe6b4vHTT/Pp0fS9sL8bJPBEzhrcdLmndabE1/1gSRyDLuSS79teiGnmI4YAloAAM1R2C/yxS3pSo7htLIgUGGH+NfSv+w1qWS5GnMxSmKLKnS88PdxhcHxTcS8UMc3i/0JdEyt4o7DFj4GLLNa1KvaRMq6b6UIsWbQJBo/fGt+OUebjnRq2IfYFTws/PE2zJTku23uwTGpWSScP9mgerlTH6LjgoDYxyyrh8m3tuRADrSakZDZl/trZQCObss1uJiyT50zAKneVRN3y6W0rHZrwXhnL/X3wuMa6NsqKJTOLMwiiVb3qLu4L0pEuMS4JiDNKKjC2Lw7U7MTyZRAtscT0rLLmSi0j7qijlKxG9qpdnWSyyFrQSZTx3bw3JhgTZ1S9viWfaubkmw67IY15YrLFrWwRE6cuvPwVD3tYYLgkFpqm9HNqud1tb4OjU6ked74dfSaxwGVrumroszNIIv+86dndAXxm785n1Xn70jeD/vZj8K1vivdOP7j6NwdjOMMBUw7YQzIlORv+N01ta8wVR3nZyAzwcfGqhsghcKZ7yWmH53gsZwTvWASokWxxy3cpH/fFVZ4nxbGcmb4Cl5bxQc5p3nDTICeLoUTVczEDXdz8ZjNxRKxxUOZ0226z+a7DLkrwdnTWNDwjY3xu9ffNNspaEzqrty6umopccEFC9NPNzsszxlTtVWe71twuW7hjndzb63Xd7b5qAC+Y0HhZ6FVxk46zBF6Ebudu2fSk6mVXUvFMH8yEFcfaQe8dHJxLYF3kwj17VN7ybc9R5jUfdx8vu6HA3qVYRE+WUHL/+5GM/DRu9FSP172+d5if7eQMz+ZcRRr35cS77jV488Y+FOJ8P+dpc2O05Btf35sPLo1rHPDFE+fTGxP93beKJEpnn79WLR3eaO/9aXY/T8uHor+ZfXuRm3PsXnUpDgI7Z1qsXPKz/hiLe5CIaIkt+jMl+5s9fkKymNOpluu6ayu6JZuoUUGUAbo26fKPA5yussGPhXFAVbMUuHM0wlmgELu9O8I2EVoysVM/z9it5iGR3Qo141M0iktBoss//vEh58O9GNw9kRogC8wyxFpCH1KJCvSiBjxBkfpBMbElEUKk/XtBUPI8swquvio3zdOXLiIzNBOL/OlBMsO8biG8/0OSwqITwgosEYYrJyCJQVWbKQgjsP15oXAqFRbTkQpkweAyw09ZIVZLPtKKsuR7w3/Twj6Jqdw7wt7ZOjvqIYYwnaRxGO75GMPxni2jsIghizRENNnrENlaxH7bI0jbwgsMPzebMAVqqdNhMak6HWIiLcrxQwrDl1EkRQqrQv0xRXACMTfLKnryHywkizBsKRfSxNo6HKk6pHAiHF58kFFEtmCMPR1hqUbUOmNsRV7Lw8RBpMEYLydkQUHcLkupRYzCxbFQx2m6RnBAEYb4RR8zxR9sGCtMnFebqKsSx+nbGh7BmGrERIJkCH/jMGJ6luQJF3X0k+C6RhTBl3ssxf89wr+DErE4jMi+OicLHEjww0TysprM8xBUnJwpMxd5+A6HJBdLlMhbociUg0DNc8QQ40i6iy4jhEcPsg3a08KkYQhtzCgvohaoSJFOWqazqkl+mklEyxp5oKU0a0MsRMiDSsckqxkm6ivPuKWEREWjaak59KoOIabw2Md++yodMRc46sW0jEeRmseGsEjFMSQuigois8qM9ENIE0i8wKrUYixS0R+xpMaGirSjbLTaSMUz66TtOkttlEtVYbWoxEsWWkyL48u+1Eq04bvAvDFZ3C6whMcSGQ9YEzzuSstvwpJCKigtmkJT0st1TMt+88asDMCv65XT6xmBtMQdnKr/ODRIjEHNvhxKlDzOIlMaxFEuWUK0Xqy4zETF2izGznS5rSKWSxQL3mLDkWxB2/SgT5qxSONGPBtKS2HJprgKvHKu2HyfzNREyTRHrdSNjVi/7MxBrTvMJ3RBg/SejPokGQNAwkrE8/yYImPJpBwo2HRPKGo0bozP6oQz3TSQIxGR3ZrPuBxLQfxB/okpnGzK6TQw9XwlBm3Q98wR2pTPDN0y3ZwsnIIzc3xAkzQ4csnEt/shtFQaYxLFEwXGqQpRF9q6rxOMnVkWdCSLBqTO2kjIcpM28FjIfVwz2pJOH025R1MkXbMe4RjQJ2TDaZu/1MzHxGG0Ikuzs6wtK6W/ekerz918US41TXWMy5OcxvesxbHgjDXrsAclrQZaUTWluAnM0psxmJPgIQ1VHsPUn4ZA0ym9kiDTGqnSxNEEVLYT1K0UC9fiIWXsQ8ZcNDSlL0jNUUkVykq1vDPZMs9UCUMty/0cjIYpzvisQL1prg4TVenExUldiIAAACH5BAUKAOAALAAAAADcAKsAAAj/AMEJHEhQoLhxCMuZS5fOXbuCBe0JvHePYL584C6CuzdvXrtz5MCJC0cSosiB4kaaXMmypcuXMGPKNJjS4MybBEOC09nyYMJz5xq6lLixYsaMGC/mu2fP47lyIkmGEzgVp9WbVa9qjVlz601yIXmy9FmuHFChAzuyvKcRKdKlTdulCzmyJLisXvMOtKu3L0RxKAH7XRn2JVly51bOW0lRqWOkFD3OHVcX70nBg2fyzcwZs8txXsEKFGsyZULEMBdPLMrW8UWK9uSSoyzV8knOMm3j7osZsOe8YkmvND0OrLnENykqd62xqbtztKVSNal7917r2LNz9QkWqOKWylsz/4/8vFzl6nrRr9ysvb17muPKIT5L0F1ExsuZw/0YsrZ29e8F2BJCnREnH1BBpSPQOu7IA848EtlDlEARhqcfRrHNdRdJv8EE4HqWTcWeddIJ2JdwgR104DnoMMTQOuDY145aE1IooYX6cSTbhuF0WNBmWZX4UogijoibkbzFBJpWwqXE3XwupsOgQPIsBqFJN+LoGlPzpJOYkz5ChCROJdX2YV9j5tWVe775VByULq7DoENWSmiPcgXllyNH7kzmpJjTmdjemTiFWaCTCCHUXYIvuuNoOzN2lCVFEFH6llJHZThbojb9KOh/VhHqF4GlgZnoolE29GikEN4ZXkVGmf+U447lgJYoZVQJ+emuBKU5qkyInsaoi442yOqk+rXk2oPPgRWWs0uayeu011HX01VLgpMtQcQJG2WxkHYkqauNXSgrc+BkKBByzkJlpqjUZubrbtuWduub37bj0LFZXrjsufsodY9cCgrkIkhR+RevoHjpOhZKnCVUVncNQWpxpHbqqdQ+HHPMDz8d71MQx+Dwo5FkA1nMkLbSLvxeVTArzKuzziZ4sbitapzPPh/37PPPBfk8kUdpdQTpTinJ7PLSJi56VjrhSgqhlkr9bLXQEAm9FKysxQYOSEmvyfTY2C05znFPVzwusq5d/XE//sQtd9ws8SOQyAJhNFFF/FH/RupeLZMtuFYEpg11uOTqzPPPcM/tON0rffxSlyBNTNq7g2euFaMWi0vuhYtb/fjcLQltNUGUI8iutufNq/nrBLl4c87i6Rc646P7w1I/bksu+UYEuwjOyrMlHbjrsC+cLUOzT1076Ka/PXrdvfc80FI4W7nYXMUHzqPSyQu+qke0l+tvW0GD0zjkJvFevfUfb40pRpKBLZXYCYOP1V3hcztY555L3Gs0NhPdQaQf7nuf3QYSP54JZIEc8RI5wHQQgkRHf5rpX2AMY6iCALB8r8LTUW4iN4Io8HfgMKAJF/jApcjmVqLxzgUxV62WwEuDf4IJq9Zmpx4WBT+xgskJ/yFSQurpSIKIgZpA2tG9dzlMTHZ5ogZLlcOWZC+APaxR0bLIlCC6BGT+Mgk/4PYSk2FPX4iTEBMp0zrv/ciJU5xJm1hyxToW7UF1vCJMxhOeyLHwi/HTWT7WyEYnShFzIuLRhvoHptuIBH8FwVm4OveQJe7QIx/EGUxC2EeT3E59pCNi3K72GgmysY2HVFiZQvSpG1IQYsNJ2cVmKUtwQWpfs7wYTCSExXQNxHwXuV0oY9KzQZqykHDsFRzduKsibUcwc+yU/8Axy2INpFjYzKY2HSITO1bqecIs4kz4MTCGgGRTqPyeIWkYRw7672LWLNY6UkVPek4pkqqxyueq1v+zx7lEhQ8spzlBghBUrtOQ7bQKYPRln2vWMx3oaFFEH1qwguASJyAMZj8dh5MzQspLBDXoQZmpGeRRq0PzjFJEI6q6liJopdd0x5waJA+LzWRc+VkcAjl6k601pX5NHKlQY3JQEgHLUIJxlJxctFLVmeOpUI0q2pBjMCnJaZsNTU2rXHURn62PbioEqBjNuJ8X1mUkIvUPO1kyVDSp80wdXNBSGdJUoEj1qWXJa1meGrsoyQke8NCmDtWSM41uVKwtYV/JinnE4lHwsecBnBQlO9LBCPWGA0kpRCGKILzq9bOgVci6WLTZdcBjpsWCh0UbKo/W4hGnbLmd9Va4kmH/PhCMQIUsmIS0ViheFrNsjWKQAjUcHzGVpefwbGiXC5WBvHSip9UmYAXbWgfhLGOxdRsDXwI5gMYPk9xDJwXbWq3fYvAqk12kHMUBUZZClbnwhchUW2TawLoDsPgVLJVae12uyna2D+QuTxd7RnNuqqC77VEjh/tW81qWwblK5EzQ0Vn45lViF9aWfJ96lr/K9K/T1aaD+BvAxvwXwCz0mCh1J874efSYp9StSvjXYAf7hS8NMylBKJxcC5flXrXiFEHKAo69skhOSAaxfbM5YhLj1LAADtrHFkeygUxPIO57DVDFC9nbrNK8JMVKw6ylFQqbg7n3SvOtCgLa41g1/8mm1W/KrPtkKGONgVarskDk9o8+h9UfZmSKXAiKYBmrBMwI3cqHdAwRM8P3XsFK80DaTFo4xzmbEOmv+U4s5ZB52spx8zNAAQ3GchI6xpBF9Dq9AqD0wgSiZ/6smikoacyEtsNwXrI1UVdijf1RymDkWDBVDMpQ/6O7o4xfhriX5seqOtEkYnRBzBnrC0P6sc0WTGiPQ9/62jfErK0SbAlYumIKe2M7Exk/Qh1KufEuYEdE4oHH++wwMy2lPbZ2omQMaVstl9tSyq+IxT1uTBGzZ54O2GNKduW5lTo2BDvnvp1U79p0Odq+1d9c0VHtIMeYQ6ZCsEDis+1K11fEmv/W00wS6LNzP2bdV17ha+Ji4ImnVahPolmtIOmhVGZcikiGtaxP+S43dYXkYNErlFDrqOpiUUs4YTnC0cXwmGN5yj79KKEp/mzuGA6kjr3xE5PJFyQ7Wt/Gs7hPfCIQ+dCMHEaWEjadvjbzDQRvBfQHyxW+tdYsls+iBigCXRyZQXMZ0Sp6Gi5VZkqx68o21TktXZW78zaapls7cZZUSYtNfu1zZ+mOMkzc7bMBluuB6+uz6ofp4gJv/eYgPwicLJY48IItVDSmrL1Nct/2JjfWhdbtmp12lgSNr8Qb2RjPPIbC2oLjHwRxXDFN3xhwLM7Yqx8w1o/4+rSqyM0Va0f/4sLTlMaTyUjJrOFKPszZfGc7zUT+Wj3n5HlXvYX5p6ut7voMarlNv+/Vt1iNo3qBp1glA2/1E3xOpCJJBDVqEUKmRzkThHvqASQxoVQpdXb6dit5ZRzGZzHg8nRUg39AwxKqF33SR3ghlBHSA3jHZlsExifMhmqmQg5uRicSAUyOwSVeYh5acUOEIk9MRXmWQzNoMzy5RD51RzUbYzUI9ITR93wniIL+p4KTUhFdBXO5I07qYzID0yfd5yYN6BD2dz5bQzm4gl59kU8WFXTuZQ7EhyDCM0v9hV062IRO+IRf5Q8EyH979jhW2ENYmIVPuIXHlkJd6EKGx4E1czjz/+B3ZqhlXlIvJbWG4gIRprVxPEZaqTI8lrRDWSRAjsF3/1WIo9OHfviHpOeFTMFFybczPbNTjiNqVuaFXcI9bqd4MyJCl8J3WzIP7mAOcaWGN6VJ9YFNkkdRqpJVBJFFrPE8oMdPXiWLs4iK0Nd/VehToVgUeKiF1WhAeueFwcMoj+I86DOKF8InwngkN6FHEIFVWLVJgtQx3TiNe8iH1piKqrh9TeGM++Qx98hRBmSLtxQ1V2gpykeP9EgeE8gZN2Qn2QMRRyOROPEqtgOLbkON1ZiP17iP8MZLoWiRsKiR/rRngfZT4/cqeZNuCSdsgpYOPuiQNxGKzsgZEGg71f9jinPDkVP4h4HESzyEXYZFkraFdaZHfZaCFC25kPaQDusYLzTpQ5yRktDTO0TJkz3pf3DxU3UkIfhgYjr1OH52jclGVgKjkkq5lC7ZJZRoIjUhiCs4lVfoLycWiwGJlSj4k3m0hPegDxxDkgTYaVuClvrAkiGDcPvAEecwjO9hJ1/JSXI5l6BzYjq5k1jZkaMEF3pUh/jwlX7JM1/Vh9FnlEgpEPpQmC05dQPTkFBph5yUlF7BQ4LkGiQ4RmO0h5fZkSnkhVwpD/FEcPVQDzfil2PEZ/ioj4vliwBomqfpaXoIMkzhDjH5YIwGl68Jm1pxRWxDlx3zNre5kTwZff3/kJg/5ZvYFCPVVV3CSRF+mXqimULJ5ouweZrN2TF6OJ4R1Ja7YocpyYt6kXJ3iJNvg5u5OZr5EBcYmGTg8FemVSX24Jn7MIDvORDvtoNBRJ+fCZDuk5jt8JTpgRMVZSM0yUlS6RUEZ4eRmA92CZ54aZIHylAZuFIrtQ7s8FcO2pcRapm6uZtglA+nGUR9WZ+HWWrS+aE3cQ6VFBFReZB2ohdN12sBSpuxyKItCmj5IBnt93tn9lQwtaANcicqKqH6GDcVug8/+ktBmqGeBhfp0EHnpV4yEaIQsaR0qkVa0SB82RgBGjr3mJtT2A8H2idm1nF5hTYTZVoTkaPYVxBk/woyZqoPsZKmasqUGvJG0KZ7nnIVdRqVapEXNJWnraGD+EeUxxmeKXSlg9ZxiVKoAFej8FAP+FAyYkpEg2emfWkUktqSkOoOEygdRVVjvpoXm5pFxugVgUViXvmYN9kafHqXl7lnL9qDHgdkCsEi6KAONVolsVqc+Ph8KPhukAqpRYGhZhoykDoP0AGsldVbWzGsQNmpK6FaC/oO9EqvljYQ8EB3PaSsnBR6AyqWBeoP0Qp3QUYcZAFw18oO+WoP+mBl16ibjfqopzmuGNqcP2oPvKpO6kpZu7GXHsuGBWFpSMYONUqy7EAQgMVfwSmcD8qv4YGazHeVzwpoA/MUBf8LWfFhrQnboPigD2M0EDsasRXLnhVLn5GRDuNQJJUFONQBXCbxsXnEEqcFZyZbtVWLsq1FDys7og/Knix5m32Kl/7AoXNxszjLbS1So+8gD3cSoUDLqLUqsT9atJB6D/iAseagruyqTOLQXHkRkQKxly+RZFWrDtiKrVZ7sgIRD4zbWls7okTbnaRaqqgYUF1CsGZrKtUKUa7qDvPwlT9rEuFornRrtHZbfu6yrs40InnrF8UauO4oE+xguLRbu4ZrsgTBuI2rtSsbnI75mEL6nadojSpEtnAIFsFnGpvbIgHHtvegqLQ6ZRxDn+AwtMrhHOl6WTQmHTpBVYMBskX/A7gyUbsRZbu3q7gFsbv0sL69m6w9G7yV6YKVqz4uJG82lxCG+iIM8rmgiVh6927TO7HWe7fzIA8wqUjb66sO473JMTlPm0fVRSXMWBCGK6MWTLskaxK6u74czLvC2ZmdSZ8xG5A62pEEmapwx4hwclUO2p7+O7oKN7Eh1JnOYQ6ggWghGyARiTPpeU0soQ4WfMHnuxIb3MHs67sgLMLNuoXHWYszh6V21YjE4hA19bk7Q0YCgZl6d24/OsNNYcCpC2bawsDuscPikp4OAg5pbBIWrLPmUL5DDBG6O8eMy8ErC8JBOqokzIU8yptYSk+4VGJhClCYWaE+Kq6vwkvP/3HD2psTMPIpEZwWaJzGEywQQCyjUwUUcJzBJvEOdFzER4zHzbmiTExEU3cRXNmVAgSaEFHIZIXIFHG3X6whNvYS6GsikywQlQwOFSyjLbVSiIu+6Euvn1zHRwyrnYmjGrrHiAWfLAeA19mEWMwSgBbDdvuVNFwPvlkwtTwQ6sDL3vzNV7HGWzHJjrISlxxRmazJ5Yu74HDL4FCvnkzHdvzB7zvCTLx/iWWW3Ama/QATvDNAIAyR8rAOedvIjYYOu0HON2HOKzG76Yw2UWWt5+vOBSHP9HzEXVufwmuIO2rKLTekjEMQH21lFUopBN0n5kFe9UJhXeoyDG0SJNvLPP8WVRzXzorLyQTxDuwgz8RszLwLvP6cz4E5oaD2nC1oWyVt0qyYLl8sU8L4ZeknWgPh0i9NNvYhrwQxu768pVAFx8Fs0QNBryZbr0XMshCa1MPLfxxJhaWcxaNXaulSwI4yF7A3EPHBxjIq0/C8K1qdWVytzgqxV1x6rRg80+K801tt1vHAvl75mdzq0QUqSvDJxwDNis7RJ637qyMHFfHnXHtNEIlNxNqRTX8N2EAMFKxa2LUL0bTLElc7z/KgtTeCkczsp8jJqIjIqM1soJSyzV/CTpvRXIS9Y1bNy6MtEH3dHubpm6e9IBAt2IT9xmBtu1ut094sEJ7MX7UdOrP/WMKTHYX/9E/jiT3bTBUzlnsS1nZ61boEobPJ7RKRzBnNfV8rQaOXjFcTXd3ILc7xTcQqC6bebYiUa6oxMYvUXN4yaMN/4hnVEVpVHcTfbLgDQbLvMBAM7buZMd+w3ctaWtjVbb6jrdAAPg/rmV3eKJby26ICBnjeasoHCoyvNxPLFeEyOuFhfeEDQQ8EEZy7MtPI9cshXrsFcdXvTCW0DaYqqtZM7Kf692eW+eK+LePzlqksAeE23qUVjd08nrXTQrIrtc7Ubdj+Hd8c18nxMNssa2JMLtnh3X/YyIUQa4tOmcJ/w3MQ8W989dWbXLU6zuM9zitAHuTPBcctcdMQ/3Hhal7bts3MK87iKBjnKtSTuzmwdq6fMcFcHEbRFX3hdcy48BAPXz7odcUiFO0SRh7PaY7EzDql+Yx9zyq6kj7pjGoyVH5g9cKYJlFyb9zaJ9vT4KC77xDq/PUegFXhpL6JFmzJRG7cK5HkXwlljg7eBm4SBcg+H23rzfJjIpcXnt3e1H3Yfl6vS9PL1K2zQ/7fEKFatJ3M/jq5uYPbJviCPJXtxlQ507obRgbWVkuvV/HcfkHTL8Xp1g0Tq+6VbN7mRO3kkb5n197bAnuLlQN/7P3ZWrHvZC7O2C0Q9UAtNM3nEXUV2/3BXqtT8B7v4T1MWyjlJlQ/cBhk8qEQrf8bVXl+E3sFzBQ+uyer4+AA6PF67MYqEEC/1TSNXKkeE2mutcnM0bwz7QAb65WNbPEuRgJ1TnBng/PFYytxZkVm8bveXDg/7knvEgC/FUOv3Cebzqpz9C4xz+3+vrYd2a9O7dYo6apodVaGqgO16eAQxIYuEIP6Xj5GZASPuP4ODh0PEfpwzoOBXz/cVBzG9iwh2+0epKEXv3Nf4HV/9/989yXJqNF6XDcOzO9ssjR9yVrqY2+cXBlv4fRgp0Zx9j8fE7KPzoQe8jOx3Yu+0ZA9oE5P95ufQno465DD1qcaG32SKiulv8M+7PHs2uQb5oT6WVClyUNMD160EfjqF0D/X/ZFLuQxobi6D+15rMeNc5+Ty/DhGLqez2JZPIXk5BGaJSXpUKMF0VqM+/wiXlfTX6gAcU7gOXTo1KljRw8fOIYN79mr11DiRIoVJcLD2DCjRYYF0Q0syFEiO3bvTMaTJ49ePXv28N3Tp2/fTH41+fXDmdNmTn89ffb8F1ToUKEN+9k0+tMnOH/ggkr0l8/ePHfr1qWzCo9iSnnxvL5jd1AdOLEezZ0zV07t2rVnz6I1qE6rw5b4Fk7EOJdh3ovgNuYFrBfju5ETPX4kiE5kw5Im36FUydIlTJkz9+3UaVMzP3/9lBIF/RQcTs1JlQJ9+o+hv30P5bnL624iPdr0/7x+DctQrDqPA82lBf5buDl0xNGxAxdRor3FFecK3suXL0XC4Ega7p24eeOTkFfWpVz58mbym3F+Dj2UIWl+l9d7Pu2vqOh++R7OmydvnvKGtel1xS2s3XQ7bLjhBPqtIHWqm8ie/ygKLEIJJ9SLo+skOizDxbiDxyuV9nPpJcryoak8E2uC76f0ihrNJsvWi08+olbjR6qWbryxnnpquy1AiQ4ii7ePwDHwNyI9Uiee5vCisMmNGNyQowwVs9AxjFCiTce6RNSHRMtONDFFn1ZUrcX2XhwtPqdmXK81HHPUMaUefdytrN6KFC6ueO5aMiWGrHyOQkCXXDKxkKo0qf9D77QE75578oH0SzDJExO10Jpi6MyZYFSKITZp1MclOHW0bc4/dQtSLAILQjBB4hCSBx99COUIMFpvFekjjxaz0kOVVmJUREi9LHHSnU5bsaeGzpQIPjFBa9Y+uyDScUdwbnvMqz8FbGgsOxEj0rgF+eNoIebyo2cev5zcCFdcdT2Uo169A1YyER8d1jJ9jUU2vaUquomnMT9lah997sGn2v9K/coxx3IjayIhNTxOIY7uAYfPhloCxx52p3OXVng3nJerLCWbzNFh852J2HzJ62zgS5W1KKdKCe7s4ITBoU3Ohh0Gi9uIFxu3OYwnignje5yMLuRbR+Y1UV9TAhb/x3tXxhprSTE7T8aZ++GoaxXVa9bghEmdM56HTSKp7YrqJEke5paMKSaD9dUnI3adFnnXqN+5kqvIGG0U36y13vqmgC0FrSewa66U8TIbMhui/9Jmu6S2N0eOIpLeoWdujmYNGWiH+e47XnkTVdTkem+81/DDtaY0RX87o2ifTAWWWTTK9cHH8rTVDppz4/98TJ56NBbpaFxNdwz15iZWUFWLWG+d6qpxdFTl2RE3r+vbH5dI9/ciT2+5HYfPfPOJHPNqedKl/xtop9sei6L8ycrQ+sWuhMzgCGeP7nnvey8LH3qE4jh+lM98+7DZsy41G/YVz20SqRrzLIKmW0Hv/3Qhu9CA6nSQKVVvf4uZ2q+qxb0Cym5249EM77wWFAa+yHzguEwEmTLDoWCqPwxrGOes86d4KCQmtzrixvjjvPcBzSpWQV1uRlinEprwhIsRXEr2M0ACdu+AkYIhisTGwxrqa19ilCBR/NHAhlTQbQwq4vJwdTSYiEQmE3liHtdBv1RN8VuH4c1uOkcrrlSLiy084NYiqMAy2lCR4rsUGxmiJEpei3iTVFJyZIU6DTZofgzR4x6jiD8//hGQcTnIIAn5qy2+KWUGzFribMbIzmhqU2YcT5okR8N+fFJbmVQbHy0iuovdMJSiBOHmSrmbKQlJkBdapX7U5cpXehFxYf+c5dj+0Ujd4dI9YktPP/ZxF3pYcjao++Ri0kmRUIIjj7haph+bGUixGE+VtNIRQ96EyJWdkWu0PIq+KCdQTvFQKPXpZEPIhcQl2aUiNypfO5cETd3Ec4rzhJvxoCQSeTQEP+rqGEQZYk0wJi5g6NtmQDmIw02ZxqDb5EeoQtZSiqyzXDUFRwG5JNENkcSi8SzhFO0ZPb5xTCLdiwnLHonSWhKUIfmoSO8WyI+HLFQkuERa0h4KO+ZobFaXuaXBYqLH7SjzpxelHpJGOFSihsyoDkFql0paojEOrKk0XcwuYQq8/iSUcgOVSNKYmDFiwjWndXNPRfrxzrKedZlm6d//WjVqEiZJr4ByJdaX6oqau94wry9dI8IYIj+GeHaDDySd8xYSPJyCA7ErlZ5jH5uhBKFSsm1zWIQy6ac5IrWfZjwpejpLKKnu1aik8+ZEcFk3RzHEoVeFLR+bqVYSVtG6xrFtRjeHvbz4SiJ+6qjRHJXULuESjfHBSXQ5sss18pUh4jFjRWZSN/p+crB8wisf0wpIElbXugMRSBXjubl1cLdCFeloeBcTnvKaN5s/IU1+3xvVl4rTgVjFoUXqG9iJ2MV5ppXuKanr3yoWScDLJPCgmsMV8dI3s/6MoM2cKpLipjR36h1d8xgMYr6pSp7VK7GBAGyoyJaSwAUmzIER/8ziFtN3Hy8u1kld1NL52dR2aiRf7jI835A5ecaxBdJPg5wn6/JXqAhJMeDaxdHwgtQi43Wyy4ArxpoQtMqKlarjWstH+PJ4NMsaTZaJ5ljalrjMIxZqmtVMqDaXK66vbRmU64xLSN2ZIs+CsKCFCdiwafpWJKYeiUEyZFKX2jdWRPHnWNdGcCiYI/i5GIPt5k1ai7VuixljD3NivlnZdNO/DhKSDm1qYhMb1UZW9aqvtezFwPrNcIZ0rfHmWvqKZHHoTW9FfK3hdEr418ycbobQQpBilxvRqWbHExcNwGa7mSKPjra065tEkcjQJznRsLuO6O1vo9IgZlYQqwrylv9ygySojk3zYACTSYs4W59HlXWf8WaZedO73pvNNqEsHthZA/tt/Z0YyMF9mIID+MRn5RySAdWhrUjE3Q3xMLTnbcaKV9u+kHOcDnOMNOh6vFsWPTaJD40Yg/cmuyhvm1Vyy/Jbzc2hEa951G8N8cHuTuc35pufv/1YoA+9zPK0aMoBxfAlzc0lI5V62qs9kbhSZDNa97lE7tLJquuP67IVszPxLkg0J7u7zCYUx7ik9rRPOKctdGBpcbzBuNfdInuHfCmDvl8j9507ao6Homi1pZfM+7KupfYR115lOCc+7qe3ex8jP8Kjo/XH566n5S+PebIvBnYLgUkLmwv195L/7pMHG+zibxVf1H9c9atnJvJB7Ud7Xp7dvBWJ4HEP/O45JKd2zCpHBKq7bde0+4QyF+z4NnTllz/Rk+1OAFUyTH0WVvdLUtqSHngTuFvEr7S6f+Cx4/XJm1+2YUE/wEkhjjA79zOsX9uX+oO5jGFA6bGLB3wuirCq5aAI/kM1xvAp/xswtpKaa2Gyh2q/4lMu4luMB2xA+oFA1to067IQAamn5svAyIPB7WqMCvnAYSqs4sOwElytX4NAo+qkCZSSoGrB65hB43nBI1TCZFs6hrjBrWqO/LO+xdhB+3OuCDwqp1mt4IGIjhHChxs0ULOIC7KOJZzBVDJD3PIghoO+/9OjO+3Dm7WDP9BzraNhnjvUIC40pOSIiLPLlVHqnDQUxCX0IMARQYrYQj5proaYH5qTQ0ScO56ruufikxRcDmohlQWkw4qgkvsZpEEERQ6kLK1YNGCTQkvktm5yxI2Tu05KooQywZvCxNrgmblZp+9LJlBsiPZpvkIcxXU5REi8woSyG5aiOMHqJErMqlnhwrIjJj5RmA5zL0b0uCeaiOMpDORhQg8CB8Kwn2AslxTEQka8ozhMmljssAZkHtJpiXzaGAkEwtGajY4qpxwcRz6yxmt0H3dyJwahrG5souihrIHcKGDzQ/sTR3QkR4ljLoQxQXE8QbarCAhUKI7IJ/9Doo2KBEeRoKgmcpo1+642dCv2S0iF5Djfo6/uSUi5y5hIvMIrnB+TDKm5ccfZKCda5JnTQyanMbCCtAim2wqRxJUc3JiSlMneE736ckhUXEAs5BOivMLCEp09lAhS8Y+NDBmtiBBC0ZagdEOjPMqaq8OlZMqX9KuzZI4JpEqF2pHacLWcxMr/kRCurD0RfMA3gUhtqzmyXMmXRB0hrBaRwMm4zEqQ4Yi6DEawpEjvqzhHUcyy1MhwTEvC3EjBMEzKxEHOK0m228vNHEbITI7QTEd9+kKLxMxbOTDLBEmsXKgCxEvNZB5oozbHbEmFNMqm48PSnIiIqMnTbI7U9E13CWyQ9nvNEKHIu5A5nbHE43QosOwYkbhI3SSXwAzO3xRB3VyMhepDarpN5JS1vBRGiKRI7AyZlajO4OxNd1EOQ6Im2FxM5wq9mFhJjVnMWLREajlPWlEyvtlPYUpPXFnPFWrP2zyq+urLVnxPs1yt/7yVcnKagAAAIfkEBQoA4AAsAAAAANwAqwAACP8AwQkUKG5cOXIIzZ1Dly7dOncQBcobaM/evYv5MmocOI/cOHHhwhUkd84jyHDgxqlc+XHgwJYuB6KMSbOmzZs4c+qsGTIkuJkzc4oTR5Ao0Zosx6VcqRMhzYIHzUld2PBhxHYTKV68p3GjwHvpyg0dOo5kyZMFVR5EqHTnT7dw48qF21MgUKHghsY8ajMp06Z7oZo9d66hQ4ju2il2afEiuI35BuZrZ5IsuYYm8xosR5iwWLdB54oeLbfu25+hderl29dvW5vkwMV2KbgzYYaHISqeN0+r466RB4L1uPJyunPlBBokZ85wOo+gfZKeTt1m3Z4opds0mncs99auVbr/TTu4c1Wridv1FlhxK1fI+8DFb1eyXFnj5wRGLZy+3XOlrOGUWnUEjiadT9kNSNtTAdIU3l81zUbQfbZRlVt6vGUIjnuPAbfPPvwI5B9CJKXjjkBmNaSYPbyN2NZRDWInY4E0GpgdTTMS1N1AY930oHKqLVchbibqpl6G9oDT2FYegshPiPf4d1w6izm325L2uOhXjVwWqCBPDHonJlLK/SiUkIQ5l9tuvFXUnntNPinnhoodqWSGbVqk0T1ZPkciifZ1KeigdqH2VHdj+rhlSkEiZJtzRuLp5pIYdZiPnJiGGNOe7r0H4j75zONfYc6VBBOhqKJqlJh64RTemfuR/2oYYmzOMymcwOXzYaa8PglqRkxmJGc+94haq2L/sdpgqsy6hN1Oyrbq4EtJUftadxTKemGtt3aakUBdOdkrprmGyw+oF+mpkajPiRVtj83Ga5pQ736HFIRLKfWaSuU15I6JdSL5pmM1vbfRuL8S26nBw2okbj59mvoRSyR+JG28g86rXWA9jrmstddWm5Kjafrbn6STxuRmTufG59JWA2Ok0bn86PqkP/48CfGoHh1UssTwYlzdl3bNux1frN4rnkvhOQqpkbVq6BKeeCpJKcFfOUa1rW/mKifO/vSjM4tW7qYY0BcLPdfGMjlLdFFIe+fqgyv5rCZi/akXU5189/+N8qRuVh0wyrheyk8/YOOsM5+2GlwsfWxZ/LHaOhkt07NvX5wokEyLJ7KQdxtJU2JQ991O3kdubWyd4ORNddeG85O44nLuSu48/5ZEXNqUi4YggjF9mXTQ4LE0EInanlgT3sw377zpdTbfuut5qmv47LOLLbvi+zx+nO4qTd47aDf9XtPw4pfpWoqQuuS8O+vEr+b8T78fv/zp1JR648LejH3iT0JczrpnLMMgJH3jsw5PLMejBiaKeIpiSckMI5Ai4c0h+GsIOjbIQQ4uhEiGySD9MLgOeMADMeCQhzx4gxFxfQ2A4yJWRQp4jmslkDqmeRuiWMO74o0DUvmr4Aj/DbPBChmxMxsc4gjvhx6IrJB/sRuXFGu2J3aRA4E3jM6z6EWbaLkKHCZTHhiH6EHCSOWMaFTIVG4DQiWSkHlPVJcLpzjFjIiqhg3CYhbdhjm2tSqPSXPVv2IywiKiozNSIUc5FsnIRpbDHJxBYjpw00aHkNCEJXRimxhGx9rNkVz2aNd35LZH8smIaAF6F5mWEsQx0u+QFZKKI2c5S4WYh35MzCViVqgkmWXkk5kCFc0ylTOdzeM4u1NWKctXtFOeLy875JEydfJKhsDyHGekpTZraUttnaeEJTShE+PYGHN1clxge1KUkJlMjy1zJwyU5ua8uEo1JbGI2ITkNhnp/5dZMkeSuGGiOMeZp3tsyEOZEmAx6Ui7nTWkPivxoh7lhSO27WWH9YIgo1ypwTLqc5Z0S4oj1yir+8GRnFvpUEzkpFAYYgpUThLg4kTlDsIoMnz1emczTwOUAXWMlBwLkBsP+VFHsoQsZHHNSG9zIXeoUGBL+lZwaNLS2b30Vy8spsLYJTHJTVOnb+kpaoSHtGcSb6iHpGVE6zUxtSzyn1XZ5RO5hqsP2fVDMfmfSxEqQO1RkavE8QtQwZog4F2UXvBiFUSYaMlSFXWROPVOSJTl1sEUCStbg52ucuUkl/jjH6D9B/Z8hVCXgqpP7PxTZSZ6w+voMJXSGtP7FqtBbP8a1asnEQmr1FIikynmqQILFrgQSpPQitaqOlPYLw8Hw4ywSEqGsankwFqo4CVINcuK1mxpO0l0PBanMkpqZRWiIr6pECtzXZJLOKupmIQWe9rL2nuyqjhgFatFPLNYgVhbmrvARXMPPEpE3LfYdUwyn438CHaS+laS+ct08mBe6pK0oQ0Fa7ntdQlowTG7mMgspnvlFGBPNRry2Ie/OTlQUHRYFGh2cVUIPJGB8flRnPLWsrOCGvNMqhuoLowrnZWLwoIVQNOeC1gRw+lcLGObzHhJgf8F8Kps0o6aEJGoCGGkg8M42/uRMJOahGpUlwuX5G6oayDqh5rX7FcqrhP/bf8tC3mpdLr/eMmipwlelKEZIKqh93Q1ueYtGxITMSJGhOpI9P3EqcK50tWXc6pJaDksEHRZrT0YDiDi1EzaN7Olh3spC6kw9FzkoBhjcrNX1DKkwh3HLyesE8iAwWHg7nYw0exgR/wG2ujgctItyTUoOOia6cP1dVhR+tdNNTohp7FpSce8IkVZfLS8VFlE+6NahLdbuiqLkbEdPWQH0YHr+73DhPGQBz3oUQ+ulXNXkt7wQI7MJwr30lMsTZz2iGXFdnZR1Cp6tHuec+oU42inclkNOPimOjyd93S0Yrioth0TA7NDHeMm6rhxret3nBse6U5vOW3mXuMeFxw1/2Nc1SCdb5zt23td/aM4OFPexhkMWO6QtrzYlhqfesdvDfcz9OTBN4jAYx0DaUiiMd5BNhpygxxnh8dBHvJNGsxlGja5P1Auw8wGy4UwPC3P7GMxfhUmYCMf8j1yXvAuYS6ofsu26qBXp23D734CgXqix23EjUf93PEIeT3qEVWUP2kgn33v1s+l8tc1Rh82M7ZCX95vLZPqSAPj1EXc8ZnWFjaHXTRdw+nO7VyCY+lMb3os0Uhujnv8HYFXIeEfL5AMcxhsoF08xPCLWd7cW1dprupMc3fLxAj8x3zifNsJ1EdnFjrix4Ietw99P3aAA+oZJyoaFyIVDi4911KHff+62W0PfFxEH/LB+u2x95j7QhwxSGJSmkebcnbNCvNX+3Eok1OjeCowh843EM1Dd4oxffFzd+8QP+B3ehtkDhknS2mkEN73d+LHboSHD+anD3glEHq1dQT0fnBkdbqiZvTHb6tTPeXXKfqwgitYLGHBJXiWYtqRIwQmYX0zfdQnP9V3cdeXfUW0SLL0SGekd98XfoFngRd4DyuIV1WVOBtCU152gJoEDua3K00YbCzibhZhfirIgvpQLDVUSqdEgwKIg84TTrmUS+DHg+PWfUTFSEVlS+TWeq5XgRaYgisoECT4P4+RJf9iayF0QvJQD+CggfvQhAOkMPn3YywILPP/EIZCExquNYZjaIauloZpuIa5pg4MmHG2BYSNNIREGHW5Jn6DmIJKqIeI2A8ERHxDsmu8pIHMhVzosjBc2IWQx2/nsHzM93kzckqW+BCYOIzroIkXx4mpx0FxCIcSeGuoZ4zr8A6DmIToZ2zs14rHkUZM9RCDWIjzh1z25R4YuDCNSCztYA68OB2FNVaU+CxmSIzEaIy5lndL14BBmE1y6Heot49SFw/kp4TxMYsAZGFjp2UkwRCwRw/lp4FNqD2/Io7j6B7laA85t0ftOIbVtV3wuJHyOI906EFoBITNmHH7mIzq0I8rpCeqOFp96B/moEhv9UgLUUIpKR8CCTZi/5MwF4GBEbkVE5kONoSRqRKAfGQazbORSKmAHdmDewdLaqSNH0SSqZdPDogOUucOjaOBesiSLZkOL5llBuGA4TSI+CAfq3hkCsOTt+iFkOeCr3GR/kcX1kGGl7NF0+MOmJSUHCmPyTiHD7h9QxKVNBaVuoaVeuIy/3N4MsQzxOEz4QQPg2hQ2wNfbnYPaumTXggxNdUWupVb7SgoRAkm8DAQSAl+xdiRqLmJPah3nnhGR4RNUWlGj8RBhck/iJmYmuJQEGUQ58CNTmQP6HeW9nWZ5+eFLhgbnTkUcEltvgOA8fRqAqGGqQmNTNSRnIh9ftl0anREfwmEUKdrKckV7f/VgZrCJ8hSHySxDq0GEfMgnldYmeO4ll5IkfkjJssZlxlDE0xEmrW2hs84nalJj3vXlMoImLbBd/e4QVIHmY0RZORZnoyTOw+GFU41D/iAfuuHk/S2k7i4gqGUEvZ5n8yJKqbnEtZ5mgA6j9YnEANKoG2YRj5oj0B4DicJe+HZPxz4oOByESeoOsAZIpRZi5ZJjl9YLOjgLp4pontUojGhDulwjKSYoqZ5jHSIcVP5mliqTxKIkhVhfjiao//jVzuqf25yDyACpukkpET6hfjwiBYjonTZLPMyjPMoROlwklGaogrYXaiXnVj6p3KIkkk4M4eXoR2YM8OVKx/mWQD/9JDIt5NJgo5JCqfjExSZuIYx0XoACg6oyXR9Wo9/+preF43+OHssN56H6oTz5it3lWaedVw5mQ9FinxlGRaTqqS9ox2Xuokc1KTyyKmc2qkT2KJXGqpRiWvnNo23mGmIl6p8WHsJ1Q80oaGgYpzimEKmBqdxunP8qZT+mXE3IaWp96nJaKzHiqzjl4QfFkDN2oG596wuIa3TSq1sySHzsA7oqK3bOpRz6q3fmn0nKaWaOK5N6aKh6ndGqG6zx4WZJq/gsIf/Y1zs5xbUKquzyh7ycKTKqa8xyK83soMDm3F36qQYJLAm6aKqh6XDWopUN41denUspYprplcmV7M7/0GvwsYRm3mruKo2pwSy/7px5PakJquP9ZiyolqlJxmNIKewL+spMTUQa3aTiVOzJqcT+rYPGFphZGMOCsaxIwqD1wG04NeXQ7uyAGq2+8h3gFqluca0kIlSMBtpCRWxVpt7O3FcYeMS+FAR7nCkX6uvCfSz/rqJauuMRSisRtt0gsad/KhrTFt1ZYpvmAKtLVe1dws2eStaDkuFLAIPpiZZlDq4QEG2R+t9dzqHJbmJhot6tjaKbPuno2iaTAtcsPNJhocpEIszmau5OoG3A9G38rAOoSu6y5lFMmKdKBtuMdq8o9inZSS7/0m7Tcsbpkq5czIuLWW1Hfa7oOWwxf/yL17LKj1LuiLBl7zaQYZhts5rtNCLT9KbuG8LeOpWUFfnQrlLTLhXsxPbrCUnWsGLO7ZKvvdpvrpFDqnZl1fWvjFakgZ7sNM7v00rtzcHU/FhO7qLuRLbv7dXXAD8FfdavMYLl7namWWRDvPQqQpsTwwslSVpj8bqtmsYubY7ZuXyGJ+kwYrXve2KMwMhb0oyIkg6wp/psz0xc+fQDmYarP5puCLrHC3swmvrXd2kshHccSbUa8d3w8U2mYm3wf3bv8BLkaaiLAW8c5M1Dme3xAKhvE8MxVGMuNAbm0lLhJoIt4Jov4UjVZF3uV/8rjiJOIyqqngbKsiEWxt7kYT/sjHYURZKDHwmap1vvMBxzJpIK7vDGrCQO3VZTE5X0xUd8knbu8Oatrdo6sMCAcCG/JKIzLN2mTELpsZUcg+218boW8nty6flaq6CqbSm+XqdjIKUojCWMkdVtcN+tWYy68NbBw4bNhle2U6JrMhPZl2TdRntGRm1bMvGiKe43MDjGr3m6r5rCMxxK2aLaE5+jMy6K7V7SGnO/A904ieRNc2UCJqx3BxcURPtFRkJ/M0+iLINyMsHqrSaHH6M5miA4y3qbI161WaFCrHw/MxCLDmTRcJiKxL8gsI5SxPChqH2oMIATYQD4YMEXdCrK8GdDFxixiEN7dBhyiso987N/4y3Lnli9nzP/TdZnKEe9kYTLGI1Z8bNA8u+7ZuMLlFGl8zLmXzHH9doLA046hUuoqxXvSK1vhvP8nxMyGHRZ9yc4XXCSow1O1GWRO2fRj3S3oVE8EvQ4mbHMxxOTgXV6DzVDmPMVt0y8Oa/P5x7UVLGIVrEzTkWYr0ebkEsNXHFad3CadSDbN245lqVvky9JzTXLC3MKUXVGRzTd5VhqJzKNu2VOO3K+CmD4kAiKLwTBJOWEuESj0ulDHy6RlQTQ1LFsivZqht18fNx43TZs/e0BnXXmx2kdlWo69fXACzAy3a8YB0OPzRrOLEyWWMT8uDApyvFAxq7N2FGrunW+v9Iu7xt2b7dLavdxzCtb3q91xmK3PMMUaQdtpczcyQhRjdh2Crz001q3Wk9xcpIxeaQE1TpgCftwm+Lx+I93jGzz8A33OjdqljXzPAcz1sXMcuW0x1rzUd8GS6RgNA5EP0oGlE8xb1sj/8N4N190k4nw4tmQhN82eQtMwMhLgr1rrEKyVsJ4VknIg9FdmMRmpXD0/lhE4nm4R8uaywenUgXE+wQ4g+cfVOhEwY64IgL3iweclqshcPsMLkLsbmXkzQB08U14WNXz7lFF2mcHOhwE0NehICXQhHWavDA4Zl61NctaC9KGDuB4gXd1PP7cSDX4i19YTZ+3i5ne7Yjr1n/ncoiomw8bp/wVDQzV+IblHfXNxAOHH70+1SD1xtZUdLOy99tDb9rlOd6nuIyXOCcjG5X7m4XVtzunD2JCnzBd9wa9hhW1OiDxUyoMXOBNm4sOr3AnK6Dh99517wvvNTc3U0x0RnLXurkDN5+HreOJnB3jcGDXGlUHXzS+tnr1SesjFulwes2AbCv/XqChxOfzt8n3ex4PhCl/tiTDe1VfuWTm+2H3rk1/kvFPbM4Pm/r9O2bIyBFMw4lbhO4nduJ+3o6kbHGDupuXfCzLRDvjk2ZfNCb7OdWTg/VI+j6frmcprW5KOuH87AC9OWeRuYymB16cUbjbkind+ma6BIs/65CEpHudf7w7l4hOV/quP3afY7xKqTxWuil7KVpm8aKIB/yGDyzil57J+9VC1JRZz4Q/Bdo4PBBnPjr8ovpcT7zE8Hw5D7H3t1BxU72nt7Wf+ruFX/Hu/1xIXeH3cJZS//xFpuZc9/vKPf0GwtPk0UTQEjbvWylESx+gRcPnUwPYC+VnqiybejrZd+rmYricmzxTOT2QT94v70kSt/ZwZT0jcj5akZVeu9a7MhHBVETjNTrQvufHlf4UH359QDOiz8kbx2jTQr5WV/SsPmaV89G15fStLvbql6/wz65vrRZxc2q1cqW+m6FNeEP0OzermwoR0wUVR8TQkgTAf19rf/v+gr72/gQ9mab7Ni9j5a+dJX+8tovzkG+mlr/nwdtboCO5Qxt73YFLLPaJK7a7/vA1QBBrty4ceLEhUOYECE4heHEEQQXUeLEchXNlTM38Rw6jhzVffzI7t27eBLlyaMHzh4+lvc6vgSp7uVMmuhi3gQZEefNiRw3njNnDt25cxHRTdR5kx07dUuXroP6Dl68k/LmzbOXNes9rlzzfQW7T+zYffn0ne3q9etYfv2QRuQ3Lx1RgQQNHmyo0CDEt2/LgatYsWdHcDFFxisJDjHVelpX1ozZUSbknZUlVs55uebRj28xO2UXVSrVk1cba8WXFuxqsl/P6kvL9TVbt/7/kPKzN/dc3XESDSZkmPAh377FAf+VOHRiyHdI401NqfIxx3Q2MV/HnjnpzuWdZRY+Wlid58pO140cObWq6dMrVa9eO9Y17Niy9dHu2+9eu90ViUcUJzjhCPrPuL4EA2ej5SJiJyJ6UkoPnJROgym77Ji67jKckBrPuM443Mkp9NBTr7R6TkTtPfhWe62+rs7KZyy33vJnv/4I7Auvuwjs7a0eDYwIufCKQwycd86DZ715KrTupiYnexIz8WLajkogryzvKRKnIo0e9lBL7cXXxkTLxbRmE4ufvmpsJx2BBvpxoh3jvLI45AAzyrjmjDxSqtLsYXInjywMyakOQbSs/86+lsLJvC0RO8nLeVAEU8wxzTQTzX3a6ms/N+H8b6//kENQUaQQHPJDkUQiMR566sFHn0BxGlQpDEFzCkhblzIVKUN3FQ0eLiP90rEw7yETU0zPwu+tfNokhxweeyyIoMCuxfbOvuKMEyMOJWpwRD8bu0+yj56cKcRbcwWHV159xRW0XieKN96ohB0WpWJTtE/Zlo6NjdlN+5lxon3avIhAUYezKKigEnT4olJNnfitpdCjip6VjKoV3QoNi7fdBuult9535zUZ1/SEhZTYSSldCWB/WaLZRYHbKlgifqAFddqGNSJqI44o0vZKVC2+mCSN74HLXJki+xgkXEueGv9ek0VOWV6s6xVXKpZJ07eel42VuSuaWQLz7DPvE4tgif6BS66EfcbInKCTI2zeAxEUquSRGMMHnLHShdppqdkF192Trc4665Ei6jryv/FtGaUHvYQ5q7PPdqzzzluyr+387pnrzXKiJSeoosAxd+QG69woo73vTNUpwAUXS9Z0N9uV8deBbNw8qEI7r7nH+ZRc3K+rilTSzGP2PHrp7Vl70zU9RT3aoIkSyjqR4KkzM59kP1VbzkJyNfCxzsJnM8qqlmid0BCPHyqoIpI/ZfvtH/Gt5JVfHvMsN7bPTc+AWgnYwGj0LN3YjSiEG01fEkOe8fikKA8LkkXwxpyU3Of/LOBgST3cR7imvEtr+FscOO63PxXuz4UvLN7xJvI/r7EsXwJEyYnao7kDHhBg9+GURGzjj3zIJR3VCZpkQpMkIk0QURIJmlCKEhigDSoesdqHPt4CE/fl5HUnBNdb1oE/+6lwJDDcX9eKQ0MuLQZsVaFHDnV4QB3WsY6fAx3b3BYRf/SxiO5YR3WOeMTvRcpAJflddzo0lLtFhHzg6J511mEPcKAFHCfC2wiVGDJFjbGFK0SjC9XYF3yVspSLkccbcfgg9jwvK3aE5fPymKaC9bEfRWyHO9whLHcYUm99+dCVOCIUkbxKcLAJXCozqUmbcLKTnwQlDP9XHFNWE5U4/1ylpB50R3vE0puem6Xo+OiPW9pjHnCsh3HS+cvCAEloxKRHrCKCFnNGBHysY6ZHnFmnF9Kwa6WkZjW/VjlsYnMel/NmQueIx9DtQ4i2zMc9rnKVV63zLRZdlIcOtUWgdIQdV5SIFiOCj3UeCZ/53KjeYuhPf5KScm5UZUFlykpJvUyhdjSWffQIDlv2gx/30MqJKopRiRBVVxpKaUS4Z5N3xLM4gZPILt+RT4+wc4wrZenK4LEllw6UoDIFK0pKM9FW3rRSyGLbPgi2Vn7s4x746CYs2anRnpwUHeyQBz4cKjikwBVtETmJJo9YVZWKJqsjEug93/LSr4o1rKscK/9Zb5q5MAlsYGx1K1zjWseURMdUDRpPUjk2FI/m9T4S2SsIUwRCzfKuM2Ds5GH/mVjFShCscXxsQS/nPLPyS4tkWSvBsgjUze62s05UVDDbORiPrMOpxWGaZpkWEa7g067NhF+vsIpYUwKQtkC6bW51e7myfpNfEZEROII73FfWw7iXmytSQ2uYeNhDpH0hU34/2JNCJZKdyaNtgPF1pfGKF5u7LW8sczpdvk5EuFx55XsfhFy9vZZRtoMV24ojMNyRRSwgol98JSdgARfJQALcrYGzyUqbJjSn90UKwfiBzLga143sdB1o/qYxeRYniyPla2qNw5QQ/xI9M9QqiQX/2rLirPhyKoYjeVts3pghqzjC1Ydm3RtHmJoYZSI6jKsyLOQNTwStH1bka+PrvyNzV8m1jYgqjXMSCUkYypZDaG+rbKDhwnXLXXaj8fZUpx0D7rSmgg0lR4qs1PYDSqKd6xjZSGJSYtNA771z8xCa4IXGrMdvaetbu3k5QBcJPazyFYOSRhJYseTQSHHoj0OK3ixLBCs9bgtM1oyU7c6W0rVNEvPqlOJM41nKnCYbg2GdaKFOuNRGMpJIZigijIkZiz6ONYypK9Jag+NPh4aSf38pyklTui90rlOxnUxesU15hywxkKi3TI9SLwZyF4OcuBCzzWsbZ33abslEoPqn/3uI5VyQ1i65//dmYa1Z3czDdE1haaxKbvit7o1UoPU9knfp29pYJDOss/0WrYBQ2eA4p1Wotw8rxbef5S6xAH+JbnVjWl/upriPs9zNk8D0f7wa0b5X8mps92rPIIzIRKm36/qlceEMZyyF5zVTYkOc2JLFKWpQixQa/xkxp9Yx2Ku9NKLHNysS8bSVpTOpsxfHkwYKpWFHDHWvopud430yiq8+0Ylr3WAORSZJ3buYEamsa/ses6JkDSRKNr5mlzKbcd7u9rj32s10v+bU5WGSA1c9m81LcM47vFegCpXwhTf8Yvhd9rkqWiXSYW1lPTyWvnhy8hOpPP+kMne6C/8rlXY/90SELXy9573zoD/oUNsDb/TS/uIY/zrqU/8qV2t7zTGLPegaGtyc8VqFYsy97rcaud6/FPjgrQpS1k31OL6Xm9hvPunj2vOurUpEQocqO09ecs0dK78y6r7auz0yCr9g4b3eYzLNI747k7Btyjrmwx20G7VUiof60zfqYzoGQxtF678zIwv1CkCLuZ+mK0CnezqGe44S2bx58SzAUrEGzLMHzD+BGzV6iz7JwT9E26+3CByuoBm0Cyc1QZkRJMAS1L0TVDKYGr65gjIYdMD3g0AabD+fCzrEi5UdrBPrmye0gg2JUBtmiTQWMsIjhDnaQgxTkrOp4zxNc8L/BqSyKPTCCaRAjSOJfXO1eZoXLZwnGOPC2XA5MRxDy/O1ADvDqbih80u3zbO6NoRBBQMTHnylqiC8STQ0PcxC49A2TQm5eQlEaWKpJDzDa5K5mTM2RnTDvutAGjyR37tBN3qVoQspS1QUGBOp2dtEq+pEhQOwNztDXeolHIovU3Q/F0sbcFC2GlwMLlGaSGm1/OK6X9Kv2bsSWeS1XDTBXQRFePDFgporYTQuheocpJuIGpvDNhIzFLlC2BiTWdOb16gkDmM68LNGMjzAEnuObeTGX/LG3SLGYhxHjCtHN2qMs2kRMpkIaoxFdmQ9UEMvTpzHNNLFJCsxXtIlsAKs/4sctn1Uvqzzx4iYv0J8DoHcnHXkNuo6OR1Es3j0lYeMu0F8M3w0sIx8kDprQyrrvxn0My5LQZgayM1JjYrTIm2bLksyRq67r5RUSaphSf6Ru8tjuIpUsSsxLpqUMD3THJKDPiW0HE/zybQwxrfqq+xbm627RVOZwUV5iqW8Rqd8yUyTyZrsx/7DSp10oxziSp+smbc6y5FSm3eEtU5BCg1Eup9kLQMRHrVsyi2hu18UxceSkEubSSeMS7lEilHrslfES7z0QgiEqrzkNkvUooDri7brlJPcGtBATJfkRa3MrZkEks4aRheTDspEiqx0lW3amMz0yc3ky7PEwiuBw/9xNI7pcj1Vsxe1VE1QrEvxcs1Lo8oYjKXZvMrRtM2K0k3dpEH428PfNDvoCs7TPMyl9C7M6zLmlEqqrDNvksDi5MFVdMVWu07NHMeSy74oREiVCJyzzL+9HDeWHM/yG6jcekvXTCjhNI4ISyWWwUyfPKC+0CHpQMdYQavNhEOjuiTXg6uISCcLNZWH/E8AbSxLa8HieC8NrSMTNRAYm78EFTMe6iH6LKpLuiShuqO8FLjCLCodikyLylAX3DwO5adQIsGIBFA0jClLG9DoAFKPPEgvNFG6bNGVoKMTzdHYpJSzkUAHbbaUsBwmXUN5WNIwBER6LNJTOlJgNJXd0tD/4mBPv/TI4ppDMC0g6XnQidhSfjzRu8zPtsOoO62zt1BE4GvTpCwjrCpT82tNRVFTGSU5L93ONwXI36uoF6WkOn3SitpITKLQ/OPQeYOv5pQQAdrQpCQ0tizSMx3FjLwS0nzH9fHISK2KHZqe6BzGGe00DWXV11tTB5EITPNRdMpRUjUQycm3InVMRc2z4iAqy/qxnOw5ZnxRHZVMTKpR15OrB/XUEtXJOIOUFnzQIRFWJBMXpDDWJUy/NEUoZTXKtBIygOxWWe20zbKoqjTRhdpVBzGmZnsLNe2sFRQ0xqikwBGqk2KdcM23IzOQAbOnAEtVRHzNmdTU2tRVRkuT/7bSohVFJ3Bsrzt1P1uN0MB5kBXcV8/CrUUFrAo82HhIp25zL45JDoNFHnZqOPVbQnZ6wtE8SLLgh7bKBxNFMT2TVhj02EvqzDqbw26FLx/tLAniOHxTLXyF2agFVG8TWZulViCxrJ3d2b1axZ7L1Mlqw/Tc0LPUyXz5Ul5FChuswOZwCjiT2oR9W6utE4qtWJ/iWtxixsniLGG82hj1tlDEs1CdQ1DFSMV4nKeI28RV3A3TWZzphx+D1a9NKFM80b6dUbzNIZoMVJTYV3QLxSORthlaXEVx29GdRrbR2uCasUvCXMn1Jrik1lHtVeV7JQ2NTG8bUcGlCrSNWcQy3f/fJdW0Sl22Eim8dV1YYsSIJVEH5M+JyF3cUozdRQqwExGpXSHSVVjgTVHUlTHVFSmI01uOdUPIxM2E7Ka+yF1UMgle0zFh+sN5yV7txS/u5T4Z+94oC1++xaRPhc2KCqnmLdwvrVrkeYfs6ouhwUW9iV/5NTPUdVzu44eevSQ2vKnnNEX0zJjcXV5vazKqnYjTyx8ZKo68SVyBYuBtA6KdrV8Z41rHwtPX1Ug74+Be6bK0bcEiuUGSiFoixN5qOmFjZBYZe2DMYpp6cGHo3NsYljASPaS1FeH15dZ6++GJSKwfRhOtHWK7LeKQ/cZYEkYLtjMKs7fpfRyPk4gJqkss+HLY5ArXKo7bJc1aLIZgt7qk5Oti5FXiBvSyMx5j5ImXv0kML2uZ5oyjgAAAIfkEBQoA4AAsAAAAANwAqwAACP8AyZEzd64gunTp1rlbyLBdu3kQ59mbeO9evnzgMmrUeG8euIr59uVrl+4cOXDnHJYkdw7hQ4v57tlrZxLcuJs3xenUubGnz59AffIMSrSo0aNIkyo1x7TguYMJGTZ8CBGcxIoWj4bkxzXfTHcu55FE6O7lxbMzTQpcm1Op27dw48qdC1QgQYMIFUpdGBEiRZDgMGIEmo+rP3/9+MX8K1Ps1Yv7uuYTizDdWIE46RIVp7nzW86eidq9W1nv1L4T7WG9l3Fwz337wHE1jJgr7LOLVZ+NLHlmO9UdV5bDOS40uKHGkyt3a9dpaakOqfpVDdx10dn8+tXGfjsmzIvcdyv/jkmSHPGeO9MjX86+Pd3meNNNjR4xtb2MrH2uxtqaN/bZZ/EXGGT/FThZOmwRp2BOOx0FmnsQRjjQXeeAQ1ZZ0T3UjlX3BZVaR/ap1tpWkgUok0+4FXiYP1zdA9ZKaxVUkknnIbVehDgaV045FFooX4YOeeThRH0VWd99IF3EWkUdWoXaR9+Bx8+Khykm01iWUeWQWuYV5+CDORIVTjhhHgVfhWQB+RNEWvbVJpCOSWRfREDCCQ5wSdK2YmL8rAaekiQVhJmXGt1Ypk9kInpoUWemk9FCGfZU56RAzpehWBnutZdDTnZokZ5Usghqi5QJat5xGRm6KFKJrrpRUwVZ//joQpI6pClD8r1Y2a653oorrxdiGCRErEUW6rGhduUbQjSCWaizrgI1ZrQaycgrUL6uAyywUG1b2jrgbgsuuNA9JGJhUyKLbFeNbUkOtNBSCw6Zrcqr0ba0SqopsE71669T6HTr7cDumOaQbrJhp526VZYY3DmEPmvvRvXOW/Gqvv60V7iVoeMUUyATFDKFeAns7bgF63UwYAljhxhi/cS8HXbkQbyRehNnVPG08kYnlU/ugPPrrh47Rc6OSCeNdMgAp4OOOgmJSy50j22VEVcyJ3sYn9nZdg+C46gn9sQ8z/vTmBe3V2lRuiJU9DnmHK303ErDGvDJBmNIbJSRaf/E8NajHmie2OnlrFHa9JZZadA9DVw0U3LTPRzdR9vtaF56/VQdgbBx5fdh//wDDpVcU9knTV2GHXaDhrcu9M+M+4iQ7JV9fHTkkw9HnOQ8EhSwT0IythFsnc+mUejIh77nfyueDvaCqrruKuyxB+VoQebQveD249T9lEbuyFOk8MMTn/DxySvfvMIN3xPojsQhh7P0hzIEfvVFZa899woiPVCF8HCHkeShESHhJ0rWGZ0/0qe+mekpMR1xh1pwwhPC0S9HEdtI0Hy1EG05KiP7o+BOFrQjlqBDaNKZhzzw9zoB+gUru8nIihj4jxVphDem8wrqdDfC+MXrgjhiHHT/buVBj/1EhD28SQkJMivprHAjCFGHOtjBDnAFUHxX+c7naHiYnmQnh+4Tjv8G9UMgBtFSPpNKuIy4ESSKYxwC0Zit2pEvjbBDHQELmBSnWMUrTgeGMgRd+vwBDpEMJnAdwRKzTDKcMprRPZuilK0Yoi249SQzLPlRGvfSODzm8ZN7nKIV5SE++1gkNjNMHiHHI5gvrk9JdAJLlxz5SKCwDi6aGpaRICI+OoIFHUn7n0t0Ock6ZuSOeYTbUwCmRz6y4x3xwKKc7qGP2CxMlYQ0ZCvTtT5WhrFZtLTlLWuZlEgaiUh+iWVJCFIZXdLJl7HrWMBG5rtPPs2Z0CSl+Oph/w986GMwglSebJSEEf+QjmYzWUkGjSIOgVTmXRECTfRQRRdfpVBOIWKSPcSyqV36ElwZkWfA4LYjet6lmXx8BzSjyU98nDKQyOuidyoSmNkcNDExmYdwFmrLcqRkHlhJB089I1HOhDNVb8lXLi+aUY2ic45GshVIZadHj+kvaU2hEEqpqNJo0qOl1LRmQLOpUZoWUmExY1egMDPRN55DgN/52lDn0qDCHdU4kHInRkOUmnfSh00fBQc73GZPks7NpChNaTzi8VXgwAYc1xRobvB0Vqwlhk85RQgZneVWuCYpJjYzzvyQijG97fK0mCpmGtcRUsLakym8Wxo6zJHYZ/96lZ9hzUhkEZObabKGRFnDaSJ3ihw4piOLUbLHOe7KUAsWJW1ImSvQhIXaIhXzVhlZRxU9ac+Rwja2TKmtbb9aD5fqQx+ySSUhK3Ikmm5lYc1bjEpopDqfvmQ/AVqu2eTi3DAplVb4y6sk4SkVeFjRfuOqotO6y93ZgjePnpQiV2/bz/xE9h/9yGl78xMZ+FZJJFeCEUs86yfc3GO5aCubUkZ7FOi+ZWrG7MlUOLgXA49LIwneY3fvKcV5XrVuDJbwM/P5VZdiZEox7dM5XZqf7MCXZsMNS3VgaGKhpljFzS0cq/armYSsAx5GoTF2szuuMmtrxxAOZR6/i9WiJbb/x6KEhzxwm94F1rAfH2ETahAWMw9jNpFB2o+f/hkTm1zZxehhcVLQppkqgjSA9oudmM1MZu2amYrIBMqbPfnjkro5sbP13TMFKCIPs+hOHGWI+MwLWVOLyjsfEnRFzpvZcRwa0cfRMqsSZxwzf/nL8IA0C7ObMtZmN7uzQwgVnSZFo/C4x6EGcpA91uYvX2Uf8K0hP+5Ex7wEcB6szprpQCzrQf+TNSg+dFAUTS1fmznY8AYHmIGyrQZ/0icnBEooe8xm2n7yKfd0cJvRYW3IHmvb81gHhL+86mq6OjHkxm9MzktrdIvj1uIc56LZg2lHu/vjZq6MvXes6XzrW8cj/yusv/FoWKQBXD734KbphDYj2kZFIuh9OCtNdBGK0zqkF1d3oif6XC4nx+MgTzrHFtxdcPzuJzreiMl7ouPZvg3g/l7zVeuZkHbE3NR3Bsf7RE1q9CrQdPzQ5sR97nOxp/vKz9J465RO92W7tulTz8i+P3m5oNjbX/VkuUHUoRB5VKfOVFLfgZrytCoa/h6oDBWfDDlrtv9TaO8S+tjKxFxwKL3joKeidgd796b7ZN/QPsi9qd5gwAOcu4QnNUxic/bEx3QfOsXLOgiP820fa/JKoibbMzKPtzOa3RDStVFAHvrmg770eYR6Ojq+d6dDZYoaSf2/Ar9HdkSzwgSqff8qlZcY2QG1YPAAauQln3YlWR699nCHOYI+ps0fyqhE38jHnc9/CTvt7lKXEVABemqWR+kgYRsxcmv2eilVSrrROeIXUOqzbWCxIeAgD+tgeNgWgRAXfG13J+mQPeqxOvmXfCVYaaNnaeDCf9Q3RdBnPdOHad03WKiHb//SL830THJWD7g1e74XKgxUJa9zD/6QD3wRc4G0PCD2ERSnEcqlOz40MXK3fCzofAeogM6Wb6gHZ6HUE8mkTL7zFPgkZ42lG+CBeOPXQKcTNP0Qf+qHZ7XXgUExD9mjIFPYHjhTV3AxelXYcTxGckmRZjq2bz7RLyADMM7EcKQ0TWdhU0D/WEPJghH2oGSqsYFx2H5zWIckyGjJl2vKNxd82HyC1XEhhWZ5VxSCGGFdKHWGSFvKdE+iBw/R5IAwFBuu9Dekg2ci0WGfUxu0hy3mQIL0h2v8RTifKBd9+BNMZ3pORxSO8mbP1mwaMVs3+IoSNkXvIGdY9BcXkTCudiwNZEM9AYmI8VgZcV5OmA6NNIzECBf9pRxU1BPxaD2mOI3OKIB7t4VSN1KxohHmAA4zCGyLyIiHJG7qEoSENI7Lk3YigY7Edw7loBNCR1TGyHGglxTL6FpKAWrRKI3TyEZQl4ja+EcwIRsGiSw0VEM/cVDtZ3bxF5HsiGXFiHyhwQ7HNI8b//l0cKEOAOlMW+iRSCFkffRtf0Qgt3iQKSk6PpGLDfmQYXNricOJX/KO7WGTcxF9c/GT+hgU/ah3QrYO2Rg+RRkS3rg135iUSpkRonNw+2B28hCMMTktUllGOuFGh3KRnaGTSaGVq/gTTpGAARmW0rQ5tDcbfQZ2aIk+62J27jA4UNkqRvUTSUSCq2KVoxgtfLlHQNEv0xhKXJWNI0mQj7VtWIM1tpeYaqk85Jh22dVI9cc6NyGZdWmHnbccqGeZynGK2ZeZzcaTPcGZgxeY2TiQHwIZV9MyjiiBDDSOqhlfFjJLbxSbmRF30HOCOOKbeodpxxQmvKmbTlchGcGAX/+pUn6EUZ/1i8gpc0nJnIPUD7GBIEejIM+CE4PCINKDnfKij0BJFMskXmAZbOGzjdxolBrhMsqJPD6RkoghNIKSNLsDP0gERPgZFDjZHng0oUhBWyLzbKIHmqFpnkniH0t5oECRkniWe1yyFgKxjrVJTtrZOiTFeBw6ZPA2kCD6WQXSi+lTojSUYfMAFv1yEmFDTjVJinShl0kBMiVVTzz2maCpT0eCJ7NXPMbDnETBRbgnQfVJpGYEkm7xXXaTg06qjcQZayHqH1hjFAm5EYO0bSQRN4PDpYaDn12pFB+joSfVpJhGngE6mGaKG2i6MEQBh+ypbTQXN64ppznzb+D/aafVaBBb1aGQZqOmRGUkYlldBBTlt6apiWG5t4ntqKjGsXpS1yNu8aiQmmaY9p+zOD6MAaj+IahquRFpJTNsGjr8IEE8FHSieigek3cA06hJgaqpqqqf2ap7VmHnGaicmpbboUDoU0PFx1Yx2asRAqkbAXgjcxTEWqyeqYPIGqVM9h1Uqh23KkOHyanggKCoszoY12JS2KKn+pfhuX11UxTd6i+gxFUACqXTwRhTaphWqluWlaA19DWO+a5GEap4aFwQUqcoYRC+02lGka/MZKxP6q//aqm8ETMDC1mGqa7sCjESOZFA1FCWAXkPK6wRu0xPwRSOarGGCIv/SabS/3Sj4pEdtxo6BGuas7quoYNnYBOXZjQOLTEP6LJt7sGyLesv8yqzzBSQ/TqQ/DQRTJazHtupPMs1PFqE4UkxUuk63XMOSIsd11qIN/i0UAtwTfqffYpFVYsnkNFhWQu0W9syP4E8SjZfagGF8rocbmUWnqO0i5K2agu1oMRHbqtP+1Spc1uwMoSgyJm3yrMP7SJiLGEqs7Qo4lAOxxV+BWqOEfKPTUsXa3uxnrm4i8iDsfZPdMsnfrOuhARxhLuz/2AllHEq8wlHa1EO8Tmk7WFcMGE8t9EdYXJCnKkZpri8K/eVVwSlcasarnuYnrMRXUS7hLqzRbhR5TFXPaSiK//qQ3/bueSQsmcBJVgRa02yssnbmZmpdwCJb6kIe6mnpzU7i+RltdT0Xn1Wu+IoG5BFudo2XLr7Jf3zoFAovj5hXECVJOjLV/10J8vBsk6bgD3Jm30JmBh8m46WjYslD+RVtbPWOf1LqxuRdjprsLg6XMEoXVPJP90DoUr0VnKbQJpzvEVzehtcgyG5w0LpaMGGv6xbw2hKuHVbPAFsQ6o0Gd1LSwwrFLN5E+VrLqvxE4IRIFZRDzhyQqfIkz7Mw6z3xULJqqSUv0SMpkBBPHRLJXa7ve/jwp2xopZBWRuRviLyEwQEIX0pxnxJFGK8qh5cxvMgwlRGPNWbvYFhyE7/dppF+E0F3B4tMcf3YbUToRH4YB9AQUrh0x4dycdaWRRV+MOALIuCHLdY4bpIbMUhUTziBrQsEmL0ZZ1J8UaeWxW8BMKkNIv1IBFRulEaFGwWup9euW+hx5ehR6F92HFgGcggPMhmSmiKjCIDosaLTEjKg7uYQlx/e0ktscnuEGwqpVJ8uA7RxEvfTElflo3Hxh7NdkeE2Ida6XzInMw6GMT++sy7YT49AaskbKvXnEjCUjvxuc0ZYQ60Ag/vsIItuKezuEI25msvmpszKJTORM/0HBTh/A7PFHrhHMQN7cyMQWurLLoawc8dK6gYFkYzwhLsJNCx6RZv9I8gRUW+/0mIQgZN1PI0o2jRPA16Gf0OQPHTQk2eH6xPZqysU3obP0FxatxhmXq7KBFHQirFkezSwFsUnSuG7tybNS2N+AQ8PMiD9EBK85YcM9jTyfzTexrOQT3UHb1YDQ3CQzyu0LzKl8cRwgfNJPzU/dAO+sNTcFTVD7U6QdE9pAuQT+dJ8LsRa70RIUzJPLgcsIjWae3WbB3UGpHRcF3URj3XlVdN2qQP5TZrj2uufoOwImQxPEPL5evSZXTYv8PFSMrYmV3WTgjZyaGn9Oxrlt3bP30UHg3XjEsPR81k50U8ZyHaNCVotNbPbOp2Aw2VN9M9mSsoL20TPoWK3tkTHhwP4P8w1nkMDpHtGdG42x/n2+h92USx2cNN3CCND8Z93D2n3PnB3KjsZGzqD/khrHBndKlCy928EsYxZF0lD/FQo6ERqRaddOn90+C82ZtdFLg83INctXTNdlV8QKtx3GtsvTrELLobtoU9YvAED7ipaaC81uCM0HJ2pOWdzHS3zA3uofAG4RFOFIxLtVYb3xS3H/gADvAd5JVHPH1mvbiHJYwExxQDQucAbOBMgF6MoVB3mT1BynShZhXtfDEOljKe3vAW3BCe4xeIxzkeERb+2bL240EO39QkfERu2utqhBbSEkbTFvsFXeEAGrRFeCpVhW9B3CCsEVoclFXXkVq+5V3/3ttfvuhgzt45Ht49QdyALk1gVW5rbsnjmtdE/tT7IOAq2qBeQi9yiYqi3HwVjRRzZuF7iXozGnq87eUI7daMvuhh/uiMCxSSXub2kenwnRprvuanzNQpLLseEadUTVyHI5M+EV7YqNFRXtHhXKEeEuSrno9nvaplZtng3NHwpu2zvliyyNm2Xsb08BO5nuNlSMkQzFcXzuGmXUMjkRFPeRyBrVAPUi9KDpDaiZ03rd4ZUe4Z8cFyYU8XjH3KLOPg0OCzvvCMXuvoLumSjuvgbesVvu4Wz+aavoEJySIbUhO8+kaZS0Y9UQ4ZGo0/YZNADRTBlurjnZXxe0wqmNGx/67oDM/wNm7rEJ/zAB/pk27rYR0i0cvu7Y5tmcrx4Um6xxfYSf4gJL8UtPXyUB8UAH/gcjbIBhQaZibzNF/zNu/oD6/zkj7oPD/ucBvWZj/EISLkmj4lfsMPJKERcZRi2A2+kQMXh92Tba0RAJ+xkD4XOJntHe3tXN/10RTXRg32xB3WPnHuj+7eRXL2Qh/fsIFnhERINryiqk0mIK+ikHOkGGqTn7kR5KlPysHbg3/6XU/2iB/2it8T9dDzjW8kPy/0nz35y9NGDxL3nKj0d3r3SEHyPJLiKR8hgJ/w5In6yB/uhn/4jl/hkL++gg77zM/6Zo/JETxrumWuW/M1Jf9hE/RHvqnCaDyirb7fRkAB/OUvj8OPI+CS0caf/Kfv9e3d/M5f/ZXs+hAPwoh/9kGfEQCBD9y9e+AMHgTnzx+/eefIkRs3Tlw4ihTBPZQoDiE4c+fQfTwX0py5jSVNljOIzuRKli1dmnxXEt5MmjVt3sTpzp08d/Hk/QQqj95QevOMzquXVGk9e01NJiUalejSpU3tgbv6Ely/fA3LiQM7saLFcQ8PjiTp8eNatmhJojwIN265kVrt3m35LqZegzj9/q2pM+jgoEWPUmVqdaVSelSHImaqtd9GfvfaOZQ4VvNFtWvPpUSnjt06dqXVqQu9ti7LcnQ94oUd+x08g3r/Ad/OSVi30KNIqVrNWhLy8HoGg7Ps10/hQX72LjssN05zOI0GX4NTl/Kg6HXdSbM7Hd7z6o1wzalkae/evtjtwdF8j1s+zZ27CQ/1/VvxYuJL8SZfzqB95knnHHPIOWii6jb6CBx2wOnunXUg7G60d0wLTzx0DDSwPXz0YQ8cffRx76WY4psPMJ1WnKk++4b6Cb+qgHPqOIT6Kw6vfQBEyDLoykHQLI5WYgcen2D8KR54LjyoNAxRA0kkkgyaErTsELIHRIPuwUegEvPqK0UVV3QHHsF+Auc+ooRqbEYa9xMOstj22VE5fwzq554Co4sIpZA+M2kdeGKEChx65Ikn/54HDXISuyvB+ei8PzmqksqSSNzSnqS+1KqmjWZCUcXBzHQxTTWlcvNNG+PMcc46FbpzH3vSMSc6cSJCEJx0EBLtnSPpQSgqRBdl1EHwEELvT2VhksekQzm1C9T3EKItVL/I1AmcM5t9MapU39SqVdhABPBOrgg0sLXWphTUzBjb3IgogxAlErxHD/pzQ5Pi+RBTEQ8qE1qW4KNN2r4GDgzbFdGcVzdvvwVOYJdevbOyedxZBx20AHU3Kasiu3FTouI5sSQn78UXvY3YqYfOEAfCJ6tqJabWpvioPWhmTzcCakWeu0VM1VVpPohicGSVB5510mE6nQnd8c2ppxgzdP8okk120jSViYzHng9f3rJLok26aVqcS8p2pSQZbrjb/JQSeuyS9uEnucn0mWdpQdneSNxg402U5JIZzVrrldR5px4Q6dzyoKa6lFrusiVGlG/dTG0WnLdx9JvoOiezuMxBNxUOWK3iOUgvYjfK8DQG11Hc5a0G2kg9grwcezZwZjPYLp/nxRwohIJyiXPE5P786HvsMeoxpJzFS3C+Ds+Q13eyZJxxk9Qb0V+iddd9Zt/dGf7yg4gv3nhwSPfcbhGXb4qxeZw13SBgTUd9oxNXZ73609ihx9cQ4rLu3aN73QMb0ZY0OLyQjyXCK1/m0me8zkGrbpMRUcyAU0H7QY//HokiEksyVBpfKQ5TIfLeiFy2wgSWBGXRWpLc2uYeqhikP3Jz3z64FD+QraR++wKhyVjyIHb4ih5eG5FWFrcV90FKhu6RoNr4xqkb4nAyOowZ3L4UxLv4Kh71+Jr2WAK/jdiNLVsziGj498S7QFBgVRwb6PQBP48N7XsxCdwRF9cP7YFtHyQKkQabUhA8nZFBanRP74gWRSoSB3kC0ocG/cNGcCQqMWGkEwYF9K+NsGeHRmGKAfdhSGSVxj0l25lWGElJOI7tj3ScJBu/aMDFibEkXOKSQAhpEHzUYx7yMMqHtqYStiSyYGeLDWFkeDw2vjKLsZRbPBoTRj6+BFwi//JXPYACxmEWs0Ti+5L5lqkUgXkpiQeZ4zOpRrNENQaJe2yhSSSZmKvggyBzXB9Q5ser0FAymcEryRRpyL4SdemeSzRIJDVVj8YMhZ3SBGMtk6MVQl7FTeAwKEHWdxQG+bM9uynfGwnqIYMiECEKhYq8BPbFfrlsoi5JZ3CyUseslLQgmtpnGl3nUSi6kWjkLKg9Dyq7hGYRSfnjVNcwGSKmjtGO66PnQWiZxF06iqdXjQ1QtXIVqXmNIFPNJAZRajUulkiPRGWhGM8ZGy+JcoVr2SlW2fhDiUHscV2yJwLDehCjkhWpeHlMlrR0NKaCqHtjA9EF+/GRuMrVsV+yK/9ehapXoo6VrLFhaUvZE0/vDaSqLikILTv5ucU26LGcWiUr4fYmvB60lpXtJUM/WFa7RBShRbtUZ1sSuYQaNoF2Ky0aTzvcuwjNKhk9IFqxGdvZ0lYrAiRsAjG11uIeZ48XLIkmiVsigbLRuF5DLmV7xCWoOLckgUNdDztZoq+6BLia1O52UdvdsdGUtRmdqgpfxiWsaOqDdoFovxB7wDnqdiXxXcmE5PsSn0I2Pd9tbYGT6z28buqvLQngYeVGYAK3BMEJXrAq6Uuz74I3r/k1LJawwtC72HZcJDIwS/64wg9HN8SL9GeJI8xhTAlEUwtlSf0e86GEFhnGMN2IRg3/DEhwKHZudNLwjeebWhJDuKQc5iUPOXgQGDGlS9PFJieTGOWWfPbAL+1kh8Ms5Z7mGDiQk2xesdxfqGzZhkqxZ0J3OWb3ENLMsxMQP0zyxzl+tb1s/iiViUajOF/5gI5LKV2FA16WUDi/6Cz0n6GVS0PjDtGwGbHEGB1nvZ4TclBRNELw2pIkSnaqnMyojmy8klzW6KmfdgmaMpfq9ox6xytsNQ+fJbFcxqy1tW5tew6oUU3jGlq65hav8fJmyVIWyiTqEqpTbefQEtJLGoQzuIVqF+p+ddXOvqq0q3vXK9OJH/yAcpZRzZKkeDrJtMMdXlVlb5hmukeQi1iPMn1r/3S3scrszmtY+RhIoyray3axtwaxQm5Oho3SWGK0wAtdcDb72q2Khbdx4kffh8MGdz++C5kxCifHTRyj470dx6VMbTnTDUD9CPnKk4IocK6P3yw5d8vVy0szH5l2jtOUivnK15/L/MbsvqfN7eQPnHty5Bd2j8T7e2caeSyvUs1lSRaaGONsvW92dvpw7xp1isGqmmVPmsA+FrKleMvEja7d2OVkdm02OO3bXbsKLwgrhVT9fEqSu38ijaSpeFkgkuWtDddUGL8dKnDq/nuOMVpzxRK+8C+Lu0gZI2R5PcbrrIrX5C/fmGAhKlGDyjx3ifbxcnke55FMUwwbqdX01f9TbC7PUeeahV6hBDRRoY59SzBPUX3kQ+pTJ/ztmz5QFsOGt7xvSeCkKI+REk3ByWf1Hu3m+cLzA/eidyheoAlVu7heSajD+ti+b5DvMxD8vXV37aPPx+UhxP7F4zKVarGHKQ6pwAu9QMCSOT+PUqT7q6XBIz+cy4dmIxpJixegkAqHKj36Qp0ERMAMizHJ6bkwSbuPg0Db44d8IDiascDWuzxdO6WsaZbfY8ARtBnKkSG2ezf9c7sUXEGtSL+SCMKSwJ3hUxIjgTb34zKXyJp3WD6BUaTJuZkwGUHly0H92kHo60EV9KcWlLecWaD8YSTzShODQKqsMZL8ES4RrEL/nQGMgMIq/aIbxdLC5NAhtPuSHwIWrSoUZKIWPDKUlUCv3XESQSFDGbpBEjyYRUSItDGVMvQoOcxCHkwOH5yrv1kn+4kKlgCh4hNEzKkND3ysKnw2SrqHfHA+dxO0ckkIqrPDe8C+J5KtIGwT8HKK7gMi1EnC2tid6Sm4J3wigkBFlxE0JgoQV+QjfQCyqxLA9XmnzUu6IDuIILqfYZOQRrk/uTpFVETFkrgTgyi821tGnkq/KOqXSIoZnpkhhCirKTqWbLwqA+LGfHAJZDS/aGTBxwhEh6KXPHKn3nIWemHHafwZF4LHeGy+bqxHuzG/XpKbDISR/PFHLfKhSpLIs78CxoNkI1rixpdAxj/Cx4c8r2lsp2bsIBCCP+3TCl/5P438kqGRR1tiiY9cQBnyQvTCSZw0Qw9MwEraiAvTvvhzSeuzo210t5cALpDEwyfKyZQMRV+sjSLSC6AcyicKOLBLyKNEylcMSblKFJ7kCwQ0JYQgoam8yKq0SpbzrGHMv62Et/5zrFYBy73oxbyYykrylU9EyxK5yi0xyjlEszNLQbiUK7lEQP1ZyekhGaxTyYAAACH5BAUKAOAALAAAAADcAKsAAAj/AM8JBEfwHMF0BMHNW5iwocOHDfft40eRor+LFytWzMfx3r18E/n123jP3seO7c6RIzeu5ThxDWHCBCeu5syYM29C3MmzJ8SbOn32HAeOKMSVSMEhJSc04UCn4NAhJLhwXkN79iDm67m1Icav/kby28eRY0KNaCvea5eOpUujL9+2tKmzZsKgNJvq7Ql0r1CjR5cu3SvQoMOp4Nox9PvwXkKQ/Ah+FUuxI8S0X/nlu9cW6dulcl/etUswKF7GqFM/BAx4p+CkPg0W9rlYqGNwHnOX1F12H0GKDm+bzG0Wc+a17diuFJguHVuVK13eVU29ut+3RXm+FuwTnXfvPK36/8yKFWvV8wux8i672aN59MPNNuwHduzmeckV637uufTpvNYFGGBLPm03WE/NJdiTeOEtlBx++OX3oGLnqfeegxI+OI96xHUFVkaa5ZNWPvilAx2BOcUEoIAspiadawYSxBRPCdZIG0QZ5ujOju7kiF6GPPKYH3weiQjOh0hipFmJJkb3E2ktRvlXaK0lZOCBNCboTnPuhNdQhPn1GOSO6ZCZzjrrjKnmmGemKeSQC30E3JFJfqiZPUyq9OR/UvaZEHY9XdkUl2NCxCBB7SQUZJlb1ujoo2gyiuY6DU2K5pgPmiRiZHTWqaRm7iV3jmijQennqQ0Bql2MQr0p4UOHNv/U5TqPolPYredI5Z2jlvJ06ZsbfjSRXp9WtlZbdZnqF58sKsuTqlU2tF2rPeaIWjre3WrOttxye6tUNu7VpX4naSRUsRStxZJdzvrnE7OoDkUgQdJFu9eMOb6aHEFdClWYOeSUI/DAAndbmK6IKbqjhlUN91FDFTn0z8RehZUZiemU85JN/rW7E7zxQgQtgfbqtVJi+b4KTr9NARwwwTAPvO1sDi3csMPCSjQnRBP3/E/F9d3jzqgbG0UXsx6HPJ28f8rForWMAVzOyzFXXc7MClN4s8MchRRxPxX73PNDk+VjT1tUcuzQ0Ukr3dSLRalq8owPpZwogjI+61LM5Jj/Y1iPDacHX3xd7+SP2GOTnRHG5mjs9Iodq+32x1OmKrdQJ++UIUP7rswjOAnaao7eThesqDzoLSRPT1ndthPiE1/0m2SLz9Ok4/NGzvbk1oUWd8mu+SThj2HuSGtztqJ2ToIMV5WoO/DQaqmbinHYdcQJiS37b5EpaXaTAaNI18aS887X0pY7nbt1iQ6fuvOLYmtYQgNbuTyh1T4ojzz9Rr8OO+pQBzoCqA52TModqAtWkSCzPXD4rIGc8p49+EMvKm3MfHz5D2t+x5r1peZu7ttQefDkoDHR6hwCI8jAluMO9OTvc+CwFAAF+B0CsuOG64DH/kQYn4nQhyAP9MdZ/yK4uGOpZGqC8SAGn1Qah7TmcexDVOdQVqERXkh17dgSCmXGJR6SED87ggc8Yng8Gn4nVwO04Q3focOt3UMfIvqhA2MnRIKEpFNh4cc9mFQjlShxiWs7mhOr9EcnCsVad1NIFa14xYVoUSCA8yIJsyhGgvwvgGc8x8zQmMYArlGH8qCHCPHxRgYCMXYNgQztMkKW3ExwaHQDJE92x7F6Ac+Qh8yQobbGSCuC0WaSLKE7KIUmAH7HVpqc2cxq6El2sDEe+6tHPexBSsjIkY6PUSUeNdIR2+lJlrPUHcgCtLD8NAhP5dENzhrpRdXtiIz/myEmtyWzTQrEO818hz6hSf+PepDyjT6sY+wisxVhETEzxlIOS1JTvmaxrW0sKmdiEhOrhPAyna78IoTO45BJsSMhAGwIwbrFLXyq8R3QnCYp9aEzsM3xH/4gaJHu+KGR3Kc56xpnUchxv3TcEjXj6xhqfvoQHu1PHhRqSi9HCD/VqIN+VtuWSW2I0n5S840s5YdAY+ebDt1xm3fizwX5Qg5y7TGW1rHJWBv6NqIW9Z2rS2SQzLnL1D1vYSsTyg1vGECoxswcU81nPOhh1ZXu44c9iylBrPfVTtnUiOEba0zIkY55nIQj8yCHOMJRnYdCtHI7+SPLIDJXOHE0IVNck0/2ylpMgqNqgAUHAdPoTJT/pnSabxTJKWG6FYxeD2igKtER1yoOyrbjsmXJ7GZV81DIUcetqkFg/rQmoXcqrFAPuSE4WMtd1752pMwkYAFxyEZ54HYiQkysZhRJON8kJDOtFK5bxDEO43ZIPpkNB2cZKsiE6Jez+62OB6FY1J3wb7rFw+6YogeRvRaTu3yloQpTGBV0JES8mAzgO1BnksOml6u3EeFJFCeW+/Bnaucw68O+RA79ArUm5GvIf10sILhxEDX7Q3AW1zTa6fkqngZ88Ay9M7rXNsTCFxZg466GjjRtiKWIBTFVNoQbfZB4JK3MIvM0ZRmH5DfATWkuQWb837U9t4I2Zgx2+cUj/6Gp/1KUsmRCekUQHHp0r/NM5pEbMk+ZocOA7rCHPlw6x7BsZspXdS/QYnonMHENHF35kjmWG+bdjZnMYG6R7+hF2pr1pEtiHOOkfPUQOn9Uhq0VoCbnBxElE4yTgdbqbmN66HYk0LCE3mZHdOMRSO9kHpPO9JPmoiwy94mQJBPtaB1SyZ78Ty/Ti7Ml74xnTILHIbGVLTroyeTvrGMe+9jqQB0zzByal5SKPhJMWbnrsjgk0uqi9CxhXD5MH9vGtlw2v9wW7X4/GMjWRnJDcuUQCz81Ierh1G5h2g/HmOhMOuxwQ9bNbva4m7TloPFPXFJsYwNVRXprWnbGoW9FgYPBfv+Sdq/ePGoDpvraPdFwPIIFGYVn74FbMZFU0iRxh1ykxO6OdN0yLmwYc9whHuedEq3rE2lb583TjvacoQ5keQq81WucuUmyKpIGvjSxGPMOOyJ+j3Q78FMSSbfQEdViMBud2DKeMTirQ0ynl3rq/Yanv6HukFQLMOY31CFuuY4RiYmtHyQCHTygJ4+en/LnFSELT85G9NFwPChJX9bc97L3lXeezn2P8N95kvXCGlSrdZz4A0dijx1ZJeJmp2MeJcITzlSevpdHepmpQxfG6FRA/iZj1D1P52dnV7xXD/0++6nScsmaZ4n1xz7wIyJ8oM51N4e8zR/S+nLI5PI3yTz/c9n6MfL3pNmo2bvepQ7PBh+fgFhfI0pDKWJIm/0hQdyHPcLdDzxZp/UoJBdQYm9pxTFJUxfm03nrB3o98VEgJVvi9RAFtF37FEoJsUDgsH2GR0cW8Q9rlxrusGS4QxoEGCD9tXk/JnV5t1oO2GoR6BAHBw769CWMpYE+dzixQx9hgRXUcQ/rsGTEBhMl2FmWhoKk5mN4Z3dOBX98FoMNkUAKxBEUkWvQJ3u0hl4g2DjrM4TjJ2ZGOGdJOGrDx3d74YQQ+IIE0VcPAU3pYRK+pls9ATsUJzs/wxNW9iUZQz5c+GL05YX89VnpF3wd1YIBgmFOqIbMtjrgoB52RBBU/4h/chg7FAMRvrEP+nCHrWcOG4NpGvcQbaNWcyEUZSZsOAGIfvF5paZdTgWDyNdJZggrWeETXvd1cuhAFdMPWJYPd2g73rdZ4leKKeJZ5MMnAPaLgWSKjKF+O8FajIGIhmhwTMg6qhGJFFOHqzR7l7gymuiLcneMnjU+QcgTnGiMwGh+qqGMMdQQH8WMdSYUhjhbSfaKk5cQ9xeHtTiJhfZzipYx3NiJuvMWbweQzMKJXfh70CaI6Rh6qrhd2SWBfQWPMIgaWzEsjCE2kEhxCpeH3dgxFpQ2STOOpOh7Btl06Jhd3OUXEYiIfOYXw2F/5uIXiTOJsudS8xCAQBGQHf8Jdz5BkFEiEyO5E2KoFy1IiO6IhhLIkl7VWHsxNnKYESvjJG8xNQLTkeYIDiCpND9Zau+ghKRHlEQZc9F4lEjZITsDk0D0Uo8nfTVpEK8BMwLYE1f5hdRBhn13fE1hUlKyHvW4lHVojYUWGVq0Ei7jGWkGESAZkl9Yd9XxlWl4lwPUJ7w2kdbhlxMHNokiEEvhOKVBioeJmJNDl3IGEVwZMt+hF/LYFB2CKv9gmaADHTPSj3F3mInZUXHmdAwYL8dEM+7YgxiIKonHav3YmbsnlwlJapWCmxUmG6zWFKepF8Tha34yfTLCccI5nMQZmncXmkHZJ1JVHSpJHfLhJ/z/EIsq9BKyeZ2ByHJgGCWlqRrX1py8g4s+MX2wpDE1sZHoOZfsx54CAnPfiUG4+IhnwRbbeJ/WmZ/6iZAoeEzQ+Ir/GSB9OR/z2SRzsYcImowqOJqokXyFGJZp+KCTmTgSmj3vRaDrgp8Xeo4KiCoeyhOHCKITyCJ9iY+vY435AEuXNmYpSnd5h4S7+RCPGY/v2KIYdoay5ZCnQqOQiIeGuaPzloKfB5qsKI9hOaRFOqVXinUUOEaKWB0/Q5kT1xhD46SVVl9AGXwliaUvaqVs+qFsapQQSF46BKE+oaT8IF+Oc4IXSl88dVyiGaX76ZBGyaby9I5n+KZZeoYG9A7V/yGgr/MQJmYirhlZMUacNUFZ8yAiqdcQ+qR+KwgRrviQhghhooeopmqG45VDfiGfjviIm0qiDhFcKXEl0RGOc1df6SAnUwgRMxilRXmq40WqwQqso7qQdWZAjMGq4BCgDfSqXLFHykFsn/EaAoiMvdOnm2KDcuarzImofEWq4Bqu4TqsjOkXIuGqhWeu0Io2noiTAkOp4Ncn9JVip+eo27qi3WqlrSWu/Nqv4BolLvUVjqgX9wEOoxKcnQiKLeGWVOlZQiEO5ZAO9pCtZUl7pcatLOivGrux4KpP78COUvJzGZgQ9uoQ0YqwXAiOObmybNMSlFV22JNKXXaxnyqUHP8rrh6bszq7szy7s8bKIpRBsk0hXOWge8JZfg/VsC7rHJZ1cbvmSthHs2m6jDfbrz17tVibs+K5MyWbgY7BFqJYneR4NHKRYlwWniBhcfDmbFPbYFUbZFkbt7YVD3QbD1ibGml3GWOhM03xiPMFL2Irm/SFYsfFHg6hM2knEXeIDyR5mz0xQA5WdeFqKXLrsXVLt5Z7uZp7uTMYJQpXj7MofQ0hqZFlrVZZnXaxPJa1QB+YTdAJDtLEttNTrg75eUG2Dp1KuZU7t5vbu72buasTStLEg35hsRBBaKmnWAqRHM0hEFooWdVBYyhUWbnRFK0rFFL6s1Nad2iis9Ozs2L/5LviO77kW7dHRVjDuxd72RTKizJaZiIuk6emuxrnsCVUdhW4EbXzCA5derFuq1e32705q7uhFr7le8AIDE1HFUrMhxX/NJ/gsL49gXhGBDp9NKk6CVTjYA6VJR7zsMDwkFLkqUhVcVRWQQ/Ya5I+Eaz95rG4m7MFHMIJPMOau8D7Q1g4PE0O7BGXCBL3J3kEEZ5xGMF4mkJ9gysYbK3jQCgEcWBitJWf1KUHpibod6ZSCpaROylYG8MyTMO9a8NgbMM4zHw6jA//dImJ+26Rlo3XO0cEwRnO6xbYIRiTGj7jJA7127+MEcacp6GCyloCvMWhRrdd7MV0G8ZgTFg3/zzG6FseZszDLJW376YPuXGHhjOJZ4OZ8guKr7UUuCLHp0FfHJyOtMsToiRNw4vK9LA/1oFkzWRnL9yzMey7R0W+iHzD4DDGi8zIOCy8o7RSaCzJCXGJd5iNhnMRPZMPbHE79umwncxTnzxggPVUnpRkQjFGBDG81GTGZowVqKiQfPWhgLyojHpyXDzICnzLNnzI6rzLvNxPY1wP6IvC2ezAVWbMEIHP+DwfdCgZW/EcpciJM1Ffy4GZlMpk8LkXwruI23wP3fzN6thdwRq5OnvOXdzOGB3G74zKqszRqvwQjEsQlrwTI328OmiLR6J/zwEdGnNpIAkT47BCt9Icxf8klH5RD7SZpsI60berTxaNzhkd1Oe70R5Nxh4dL7g4i5FhO6RbujNxmN8HzYwiRvEEZEaqF3SbEPJwyP20gD7Gr68cwDJo0Zcr1EL9zujL0bns0ai8FyVdHXpkwc4bv6EYmwK9wU32xIGsTxBWZ+XsEH8NDvEg2IQdhlJ3s1pMED+dzmaN0WjN1rELu2yNmtUrIP0H0EqRmUf3EONoFAYEDz79xDrLXYHdE4qsiPXwzQ7Ir8Ing4pt0Y1t1mkN2ZA9QpHdE9xMSmbcEI6hv7J4NuAjI9R6S/8FsVdDcD27VzmrvQRhW/GMyt6Mr8fa1wzJbD8NSrF9y89d2/bg0SP/tFg47RDCq8Mj1M0OEdLnkkrggxRFO9zwEtMFkysHV86jvbMPMX+ElcuFxc2d5688wUYWvSPZrd05TNu2Dd3lAd47Qc9L5RAj3BOHQ4+z+jJznJl56omAQVIElxAe29yMqrOuXVWKTM+LmNvRdpJ7Nd0pvhMF/NrxsHgDPtSMTH/zQNvkTd4OTLwP/iUMzUgOTrw8QR+TyA+zSjBO05ZBCNMJ4Tfg0DibxKHNzam25dzyLLsqDrIMuY7Mbc5V/IQxLsaEVRXcXR44vs3kuePcl+B4K+RnYTsB8130olaZzd64s7BFpmdOAVgwx9w1/NEJEd5uq+WlTIjS1uXizb+K//jlOCzmbL1UDmzei9Xd2QzoLBJQFBNTZxM+RaGZQWXh71q0RUZSE+Y37RmspV3YsJvqEEHpEb2QlBLAPsaooeYQg93EUozIto7IYR7mC2Hgjp7bIU3mk40avWZHh6WDdRRTbm5Lm4x7Fi6YfuMt3CJSV3M12abcM/jhD0HiTQGy3BttMNziJ5friR7b78Po3o0VZf7ouR3p3Q3ZxH4bEsGsyJyBGJNTdrGwSU4UguE3//Iv20I/E2btaahdWuvhqUGqn3fwBvblUHju3O3u5Q3sCKfu8O4XkOxDOnjpkGWe+oWTNBEOMCbcJBXw3bIT9ZR8p/4QwktKDwhSJ4mK4v8OEQ5/7r1u4IvY4xNP8Tpv8W0t8WrO21g17xgxNnrUGfaJabgnHWpVtAVR8qLOEwVzdSvvEP20UlTLjHsX2uiHzeId4zZf477e844M7LtN9u+uzQ2eEMAMZRs/NvqH9B5PZkvPcfDt9AWRTCZ/8lJP6ntxXl278Fzv9SbH8uZ+HvWAHhd/5oxk9meP9o7+3QTxwGic1Mg8MQ2XEkeU9P718ZteP03+EP9CEMoE9QHfENnGE3R79YMW+J03+LP+9cHb2GGP7kf94xPfENx8FT6O9rvP28bedTj4M3fKzCXj+dZ+TzBHEBZGZNGOTAcz10UW+lFB61kt2Fbl9o0L7tf/XUkOv0O1L/bDzvs8uOO/X/FBTx49Pp+WbvS2IzWfD70iTxRolA7iVcoVli3fIjrTXv0AAU4guHfg4gmkV+/evn4NBz6E+HDdxInv4F3EmPGiPHDyPH4EGVLkx3klTZ6cB25ePZYtWUYEZ09mzIj4bMKc+VDmTpgQ9+3j18/f0H//wO2bl44cuXLjwJVbOm6cuIHiykFkx67iOnYRs3YFpw4cOnTnyJ5DmzbtQHQPCxqsp4/hPn11e8KkWFEjRnAXOwocGTgkSsImVbps2TMnTJv47j6GfBSo0KEC++Vrd46pVKdLN48rF9qcOYFiwa2DF89jvHjwIL6Dfbds2tkP/9s+jBf35z5w9/DZizyQIuy9rgdu5AhYcODChQ8jrncXeM/Gwa0/lBt0qD+B/O6509x0qjiq5NKaWyu8b8KW9OQZfwj27nm0tnHTw/dT4D17L60PJ46vh/xSraPlRipJHnoWZLBBekpSKSWXwImunp14os6xm6677ifKuDvKHvDIkYo8ccKh6px0VkRHnRbVYecd1RISqL3kvrruHPR6eocee/LjDRx9fpsnueCGywiiJAsMycDlSnIwygdTgpBC/2q8cDrGHAOHSw6Dk+tDcPq5J6lzxAOHPNDIAScddzSa8coa24vnnawGAosddUwLTp137JFrN4H0sU6+iU6zyP+vATM6SLkDB5vHQYgWhLDKxKy08MLHuPTyy8gYquyoedbREc3Q2FRxHXnmyZKnCQeqZ0E774xPT7Fue4wdevRpSL+HfoPM0HUQNS7JgVpz7VHmIm1w0ikjnDM6WLMMrlNP7wpTKHC8cwcdc0ILDRyz0ElnHXdY/bExLvu7FNNY6ywNHLBm5bMndeBhKdAMtYTsUIIEMhbgvoxTViQom32IUipXgvWhTDF8DOJrYcq2MqTW8VY0FeFxp2N5Mu2Uy1fBoSfhOuWT96E973pHN4b66Q2fe+556B67ItNKr4D7Eqi1h5R1clVmJUVoypKgQ0wg4PhVTNOJa64LVBDvkSf/nYzLOQecc1tiGiZpByoZN3m7QnmgPXEVSFd8Am0I5i6tjfpInTUauK83jQyaOZAAkzJsBpFG2tNWn7bJ5jCH6mcfEbkaNqKX+P264QURimhWO+3lE0aXfT0qorr07ZeigQX0i2OP/8obwZH6LjlswKGLqWvIBve0cLYttkcedzwaeSDZHY7Vb5LpaXTsPGlVGcbcAg3yIbp2g57zu/IavTjTdzcwdYNFAnvysEmO9nWuJbaO9uvWrpi7fX573KbfHws+yte+oh/lGHNbW3rPGeLnZYcey8tblJSRjmHPI9obDPeGNzmvic8l1ArOdFpFPuoYzkMOoQuwIvI+xw1v/4HEO4gA02a8rMAGf1HTX08u2LaeiG44j7lIATlSsFVxj3Xfc+ADIVi+CXJwIDJDIQv34RsfRqZ13QMhawoSI7eYMCH5g17nBgI9QhVuICwEIGxiExGNeGyGNFwd62CVNMDtUGkc7CEFfwhE5gWJLvxZzNMMcqyeKfFfPfsbFNuWuLvshlAXWlt8TpOXQ2lRhADLCBhFsqCPdOSGY6yQtMqYRjRScmleKpzhmDdFIvZHjpDZokFYgx+bsG2PbnvMT4i4knrkL22EFE5sDolIRynSI4wEySPDd6VJ9jBiPfyNTG6Syc/tpldC0gcc5fS0g7CmeLiZEaCM+b+I8IZmM//DTjIFYhJAfcVfsUxUZHbXJASGBJcfueHkAhe+Gp3RfDhRVzyFqa6Zfc6UfEwm+z4ZEWfy84nMS1zzKBbMHw2KUHXxTYRYRb/GxXJnPRFMOW/pnr2lE3C7hIgvpRNPjjZmZpq8p9s6Gbl9ilIgMopHQn4UUsjMjIOf4w+F7JEzF4rOesUZZ3JoyCBzMigiDMRowxqWxg3upKMc/ag9p/m/IcURbBx6Jmvq+M8VovIuvtkQZBB6E5oSsnF7qR4B97bTc6LzewkDXmJIOi1L6sSoR6VnPVFY1f1osKTHaqaPgHRKrWI1q5CJ3j68+s3ihJU1XrQlT3t6xKcKNWkQqVD/W92ZLrjKLKlznQwWh9STs4IPqif0nwr9mE+7Wsd/DnHhaY4D1uodFrG2FExnISvJ3rlLsrGbJ1w/Ktc28jVmspNqZN4SVR+1ESajJZSQ/goRy/I2O3vkjlcXRTdEpiYeMoTtcohWtIs6jiW3BWRlL1tM6FFTucD9LMlYAsUUSsa9+9FmBUEa0rZFd1jfrO7OLuLanGY3jM5aUHczKi1K+i63unVuGxkiELoI6S7PNGIr0RdFDtEsOOU95Slh6a/C5ve6b8IIYmuZXdat82tfs2SrKgvEBPeWwYRK6HUgDKsJC+quv2Jwhn07SH/ZlLqj68uH4SNiiRZsu+p115zG/5hiFYs3mfPdpEGv+aV+gq2VCi4pQvenYywKRHQ8HtZNS5eajmmtgDkdMWyPfJd2PYzJB+6ozeSKTP3lM8YyduYoV2rjfdrzoHahLwutWtPGFcR6A/qw1hRYZGWtWcnthOSbw3vUejqXzw5+m7WCM8p/blKgnjroT+Si4NBaFS+D/RdrF/Um7DYyzYlFGEIey8vvShrO8ay04YR06Sq6T9P8vA9+MLvPwEYvKDuOCCpRTRBVD5CAZYbISBht1li7q11WkqmtKZtpK8I3uRSjmWP648OUNjOlV760HAnlq+ad1h87LrZgqbeoyIwZPjBZNKOrXbSUwK+tTbYWNr0Nuv+a3YRdawWwgjp940Ed5WaS4bLzRI1ZWCqp3q4R0F2y+8GJVQi3Ka5OzSzcm2H/KpgsoRH86vGxdD2c4RI/bZe3xWC6PNme0vVUse4N0QP+TNoG2rd1ECPpkNfM2x6isO8o5MGfIoR9V3b5yyWOwYH0z40C3e3McD4xRT3G1QMJjHKCfh2ufTyNRR/IyFEYlHT/FG9FIyXatdqTb1uHj5Jxo0GZq66tX6vrkHn7z4Hu06ehGORyP/pkrP5pfs4YLmxs+FVLWXchfdRzNDf1FB3uZ8pDZNnW+bHP387znv9s7A5TCQ/P7mvPBerY/WMuTHwGz85f9VcfXS7M28Z4gz7/ebedT+7ngxN6sJee9I2cId+ASnjU9zsylmxMQbtk0J8c27wPDm73rkw4ynrp4YKysc1FHs+B+BmZXv4yhx6qaOPju0muVvj3mP+QKkVw9b/plM2qX9/MW4c9ky8p/Wsv7PArm4m934Ep4cCvL9m5EQO8seq5+JM6Soo+Lrmm59qOUPkSlUKf2gM148KWfBImXYuMrOOSBWRAmOivaFOk+eu4opKgt8K//RDAD8lAHHuMAGuMqLuWz4kMe8ooxGsaBWyokvILNCs9MOI4qYsdswOko9OODOSOfuCH4NDBm/BAJpyZ5oKsbVOMoWPCGGK/Lyo+CAwMwnNBNkO4jLot/8M5Nincjru7i//jlGvxJO+yEJmRskx7m9mCndlyjwALQ44Zw+xxQIlCQ6AqKQq0wKiprxsEh3fjvYSRsOm7lpeQpIT4GwmzLHVxKliREpJaub3hsRuLIY75iHEqwwiMLfn5kjWcLBmsjhpsCEi0jCqMjNzzlFiBO0UUCJkJOQL7KUZiDQWBHXlQjeRAQTk6xZxSxUPULlfkEFh0wu4jpsmQwuOKifa7seAZwl9SGq+7JZSTLfRjuGZMxSQMGkSUklfEtqL6OI4KIhsEEa95DyZks9zCQZ3gkFsyPgs5Na+apYs7swJaRWUpknyLjD9UOtqxHderRVucouRKDgHKQ/+pSwx18R1dZDPCy7PigbqIGCyKaEAYup4zO8hHSUiQcD6hu7ZYNKou0aT9o4xIPC7+WLlJSRd81BDgUbrrYL46eYuC0I3aG0nUGEguCrGCdIeUPJCVJIlprC0Dk0GaaaM3rEeI6B/+cA9K1Eip+8oGWaaXdKxjMSTYiIu6+DUwC6C70LmlLEinfBKDkcqpdKe4Yh5+OLbH4Id8+I3Oukh85MOlU7407KD2+B7YKKHRE8nBSkqesTeDNMhXU6SWDA7okCCqpKe50svrqyb+aMnvEszIKMZylC2Pu4sYkcCAHI51SEq+6CJog7Zpe0pu7InHukNhOrDeuId8yIfq28v/lvKu0dxHRHNHiMg+gihGZWRGe4uh2RS9L8ouy2wghoydYPKoj/JN4PTMhQRI4gRPJ2kNlJKqZbwORYnNpowIUqRNnfII6vRD69TNTNJO3/zNSbzM7zS5tXxB4NmJ76qQcpzDBgku1nCN1PqkZ1PPB3RPIyEnkoDPXXospSG/+rRP/IQJftAH4Ci7mhBCOeJFCunA6CMpX5yUD0LGgXiH+/qmIsw5RVlQ95PO42PPCLW2CY2J7Nwt+9zOLyGU8dkSjtyU3JOTPau5m5AWEz1RuEPG4imbfUqNI4zR9WxQQ6wl5YgI+BSfcEyXrLMZHi28WmM4ToQJoDJStXw6yslB/yQLUUEyz5wLjvcjp8joN8Pot9ehyrfyUn3gUf3ARYHgDhDJyg0aTV9UkB/6sw1ZJs96KtcJHSMsSSpFvuVIHYUiDEia0Cbz0gsFis50CG0ZCA0kVHxsHaBKjq/hTxZMmCP6mmZq0oN4U/WLVAalIUtFCQlFuKrc0e3s1FPKxkB1Hn58OUVU0jn5RDrirAdrllg9z1ml1adsDsN4NOnIrazj1cyKSDgEVs0LRyYUUACTlLApniqbw6laVhc1QsmMU5WM1m0yCVjMEvqsp/vUS6zU1srIym8rorsSnmOJEmc6y5N6TH86PYl4mslcV2iN1pO4FGrR1R3lTnq8V5ssv/LwHE7krKM806J/ecxnSiIHqTiJQFeME6fkiwy9YUnCYAlp1SGA09F5pcl71VaI0CZqnMYIs9kmsg7HQ6utY9GGCpBIzbjrQFkIRYmVtZTxcdnmSqrf9FSZzUbnia+SWlSvIUxmGlAAG6RS9LKw+qq/O45jwR7rKNr3VNl6YFkxXdqsW7tHlFmIcJshukOL/SwQQs7kLBqma8yuVQ/WGtqSKluhOVq0TdrvXNvfg8hsndiHgJm+jCmhIk7UlL05CtcFwdu8BaDGaSiSFLOXC9zCQNo7FU0njCu2pUmJhcOHAJEhgqy7okbJ5ax0crxiHYiAAAAh+QQFCgDgACwAAAAA3ACrAAAI/wDRoUtH0J3BdvMSzgNnr+G9h/fyScwHriI4fhgzarRocZ89hArnPbQ3r106d+3sPczHT+K9dufIyRxXbpxNmxwrjgMnjifPnhx7ihtakSjQnEiTKl0a1KJRoUWZJt0ptarUcwIJnkQJMmFDhxAnUqy476LGsxktTgzr8mO7lA857ss3L925mDLzkqNqNejQo0aR/j3a1+rfn1B9KlaKs7BjpefAZS3INeRXiCsngqO4D+1Zf6BDV8zYuezmewuVzjWptXXMm3zBjRNnc7BTwj8X3ybqeDDuor5tK+b9uLjVyOdab0VpGSxmzRXzdfbcr1/o66LNZhQr8WzFl2/Dh/9/Dbt8+ds5DwtWb1xpcNvvmfKN3R7yXY5aD3a9jDkz9+loWYfdgNf1o9E+APJjIEbg3KNSRG3BtJd5FDZG32/AsVdfeu8B9RRxU224oUFc7eccW9xNhCBaBLZ4HXWhGTjWaBjl8xJeFVKoU1NJ+Sbiej6i91uQsslG349S6feWQvytBGGKYiWYkYAuvugZP1ZiZJ1FLb1k11176SUmbEbW5t5hINYXHHB9/XYTkhWR41h4TJ6IIpRRelYlaAd2pxFoC1LJUZfhpUNOcumYZBKOb75pUTjh7CZcbsatKVWauu0Ip5xzmvhgf6D2B2WCBC64XYqkEpgTP3OhtiRJD5X/ZFdeOznaY4eAYZghrsQllp5VRxrH6WMhzfOVc5+GGiqqV7IqFoT+aURldhz5E92Tz87jDphyTrhUruBiyGt8RKJXVa0/ymRRXlIVe+y78JIUkrL/IWgvd8o+ySJ2SHnHUT72uPMlODMFC2S5HI6LpoYJS2XrpsMyZSy8xVZccbyipohZvGCpyM9FFlErlbWbuZUOOIxWFZ9fHXLoV6a8McwYkhGza1VC4FQs3s47W+yVnSM1pBBSEzfIXUXX/aN0Uv+AQ/JoNpLE2msVRcryUyor3HBigGUKZ1ViDtsO0ThbxLN+JKbN85LNCR2SUm2zhbTIToM2d3Y1VmSynOxZ/2oYYpO6d+mvXyfF6eHqPtZO2ow37niJPqc2tng5VRxXyNTyW/d1o0VnI0xOXS0ufLzC2TemEMcJp0HKtU7QOoyLl9Bb4FA+du1wM9RgtU+rirTT/XZpaE5knqmwUKi36eFwhRvebV9vOa5VTukIZP31rTteUdpmr01napuxhKXImttt96AtLWrRwwcfL3NhyTevlM1JMu46OndFhnL+/GMlkFKM44h4lPS9hOirfJrb3NO4xA8vKc9Hx/ta/BzWHnZRLif2Uw7+8meODpoDHB40xzlEeB+stAYc7ljHOiziju2hjURss0xmtMQ5BZ6PX73zR/pOViZH1aZluIqKBP9/1BirHK52t0MK6zTIQXOUo4PliGI5chLC/E1mhRxpXHiUFLeIpCo7NRxQTvh0jzhNKIpUuYn73ie/9lQIbPVr3V2gKMU62tGOHrxLVrbnwoOUSHY/e9BEpCVGa51vcwJCig5rN6s66mQ2tPlhENvYvPMYbF1WUc4cyXHHTnqyg3pERx9h6L06dUw6n0na0up2N38kcoybqQteOAmOmpgngpIy3YZyJJWIAVCTI5SJJ4eJRxLyUG0FdNenPJbK0Chtlbxb0CEHRZdt4aUitrzlytaXl9foipJFKl4PxSmVJLJwiQTZpCcr9Ek9njOZylymdKSkIGc+s2lj5BMNrYX/T6h9hCAWMYdeYDOucRwqUeMhxzetYrWFcoSXbzQOOqsXTE7aMUc36aQIRbm9GPrMORJZ0b5Ac09oYi6Vz+SSjXA2NW6pEYK0OSjbVAKTS1YFUg5lzHnGSU6zMaWF4HBNRS9K0EiWB4/3QaFHLQbSkNKzniQtaT/ndhbr3JNkeWNISQTWyJciL6aJWohKJmKPdNhUKZBKa+hyytNLFlGAPMMdH4PqGhFaFI1eNapNinmfykSOSf6ZZ1XHF9WSgmOqOmTVdOz5j2l+R2omoRVOYFOO5CDEHhozK1vBkdbO8mg9Ol1fiB42uZ0pkasEwR/+nIhXSWb0jiTU30H++jP//9hrsKqUaj6dJT7GLlAtrhJYTKZ4VMumJrOz6UtnrfZZOL31od4LTxZTqJWB2EWgrZ3NXmFLwiwulamCdCo9DSQgqaYUfWLBiCode6232GWcMgUfchnqWcHoxlcUlE9OelaxLFpkHdUdIWvrSBNydLCb9+EhOGDXlb+e0qnNYqx5c/Ifwjb2d6sCGO2G283L/gtfZpXKcpmrptCKFik3gWd/kwLg1Ar4rjKJLf8U3NEGR+5EKnqqegt7z4pMNXzpfWVSrNUSe6DwS3cJK1KQq6sRw2+zD31uiGxMWyUumK4b5F9W8Dc9FCKTtoF8jnjpKeEeD8pz+tqxUhZZEVkRBP8hStGYOxSKlBGTmCkxG5J8pHzinNHWbSteCkAB+Md2yEMeYJ5Yk7BlrwSVV7fVakmDngOgpbBZq2WTC1ka3ap20Jkjdh6ifm8GEj+DV9FCQ4g5T8s4eYDk0OE5NKJ9NmtFZ2zMACozPvvprElTmkFLAbZVbjuXsn6as8stzgQptaHvXixeFZM1iWStkO/u7NA6Sxu2UZ2semWEx5DWoY2ClpnpWFqf4DANUhqNkbnUhc5OFhHyvOZGmySa2xSrNiDBfG1XD1CF56R2ILvNTF2btEsO4k9IFXRuV5KGM4JdUWkAlo4pxltNHiIMfgtTnntz7Cs6c7bFzhY9g2CRIyr/XAc8BG5rUS3W4PgUd8IZEt7OVKQfimysw9vNbrS0as7iqC/G1RMzNj2m44n+OKDvHRJ/l4h7KZRMUtihcnjEA9v1qMex8BGWb4PbzF36Cs0FWRaGI0VpMSKNjt1tqKDfuVJ+iwrDctpxKrdN6UyP9uKmLQ+DwKMiWPyf1C1C9XdYXR70SIjWFS4+qPpjwk7bR6waMvYG6YMiHzu7zgHVLE7P4xxTNF3chYgYPBPvJiVxsNJBnveEHPpxJge4RdChDqSwgx3veMfVEZ31rUNoOtV5PKQvAjBj4cwru9PHPnDOkZKm/SycRtA9Ko6kluFZQx/S1CNFbkq8t34e0nYc/zxSnhPBc+T2ud89PejR+4Zw3YvAF76ZwdGPqM0OJdi2iD70YXYfX5XzDBJ9UeNpPzJ638JsuxI4ssF93DZwS3dvqrZ34ucY6oB+8aB+65d1Wjdpl1d2T3NeTtMlW9VqDMF1ncF8h+V8AKhY94IaBFEOUGY8bER68JEwCph635eDsQZ7JDJ+sscRHGU94FCBFniBu3do4LCB+IAUKHhwraItrQE78rB4EdF/UrWCjSYR9oAOaLRsl+KFi4EwCUg0dpeD+pZtPNg45JcU1yNK6Id7RmiEFUEPSKEPTBNpkvdPyrFyimZzKaiCO8dp+QATNTGDvXErtzIpCpgTLGeGrv8na9sGfn2XhoyTcuvADmyIDubwP7eHe7mnexeYE+xnEfdghzlhUjokeVBoRbADWMvnf/+3cyzobqAHSe0BLpJCdAuzVtgXHI2Yd5AYjMI4iZTYgymHiUihiRtVEZ3oiaAoinRYgqWobj6WgipFEtclQumwDrWmEq/4h88UGg+XD/qAGuYASTFoX6JDOuQCOLjhi9tWa4n2eijhDq83jMRYjO4ADz54ckAoEFjBjOCAfu+AexwBilfHfviAD6bYfPNXZO2gjEkmj5iVebC4eaYiEfjwbugYg6ezRqWziICDj78YbcQojK1WjMTIj7mnQsg4e/lTEepQe51YkDnxibr/N4XgwJB2qG6QJiP/lD8nAWj3QI3guIJauC2FSBiRIhwrA5IhOUk0SJIl2XT5aI9XqY8GsZLw8IlrCJP6Q3iYeHs3+YkXSA/2sJCaZ1j0B5EtNpT3sJHG8o0WEY761BJ0YSg18SjhgEvuCJV+mYhUKYwKEYwpyYODSY/82JUt+YMVwVEyOZMDOZnn54zxMIqD8nWrBJRbdWgP8hX5gIKw+HwrVXE78Rd9OUmA6Ssg2SNBkZiD2Tj0SI/aBpt+t5jvYIlLMZO1R5M5QZC6h5lkQSWQF4KSl3ArsX8P0RnThHYAuFKi9EOpSSRBFJWrGT9AAZtUKZtZWZuJeZu42ZJk/1l+Q9iblCmWZsl+RgYOyldP5nVeiTUX83QvqORYzplY0KkTQzGdeXadXzWDT7mI2kmSspmG2tmDi8mYBXl7vEl7vFl7A/mSYgmHo7iE7WlV79lPDidSB6JeTBMjT8hRHWmD/imGJNqfvSIOA4qP3KmVlJigLLmg7PCgNMqMEmqjcBgP9VAR+3eC8lecdRN8MVIdwVeXS2OXrPIS6GBRofOXJSqS7cOafrGiw9iiLsqDMBqjzUijkgmhU0ehOeGjGQqC7LUURxqO/SB5JoFdefWkBnh91ncbVGqYrQaJVyp+WfqJncilQziEnYgUZikPYQpVY2pSpygVV7hDw1VUbv/6pt9iffA4p7R5p/qYp3rKoFzam396k3Hmoz/6nkoxfKd4VQYSMIbCSYzaqOk4hh/iIdsZm5SqlVmqoHvKp346nlYhWBhaqGt5pqFql/3gJXiRTT8kSdcJd73oG5I6qXwXflppmLOKk804ow9anhFaGFX4aIX6Y6DKNM7HD6soTBi1mn8jhmgCOOOAlXN6p3SKpZZ6qVvKmwJ5o0uxEsunmRlajeAIgkYqVcG6KMKUXeUBlQ/EjjA1FAZ1Eu26lQQaq4zDj40zqwqae9NKrV5ak+DwjPXKEsS5rdbosf3qfHkZTARGIQSbNduUgGDVDvmgrgPqsGkThzJ7gdHakrn/6ZK1WpmWGYocQXkrsU+fKqoXCaTvqUOmOkvEmiO4NHelIzoJOw/jY6BVqpLMSiIzK7M1m5s3e4ljKa84apZyCA7st3hch0rTgq+9CqT7Go4jO6xJa7JaU3pwCiQGlRxVGBpW6rJ2SrXOarVXa4RZuw5bu6l9Oq9ge5YZSLZeBLTYIbRry69DG478EJSShVEdqaqYgrDnwLKE5A9Si5LgKbELaxB/C7gwqrUqNLj0aqM4aYTrl7hpWbao5HiN60xpO38h63zCWrnjirmBo7npMA8cS6REupiPw6KhO6ug67elm6fHyLW4ans7i7iwu5ClKFi06zuj6riRi3Z0sabi/2q5vtshlcWywEekGjGrFgEP3Bl+MBqHg1m6NBujXpm6x8gUwOm6r9t+7zefjFtIh8q9j9tYGjYrFtW7Tyq3f0ETwdt40tJum6G+FcG+deq+izmzVGm6VheH4dmYX1kV0/u6Y+t+D9GBAHK2hpTCDqm2ueu9/2QRexllbVqiwJGw7VCF46gZrXIPEgyxFfx67yuzyDu/Eku/79AeIby/i5eW14u9QioaJCMy3Xq7BPxP6qIjifikBuUOmCUdGtMf5eggWQoOfzfBPhyxRXx4kIi1aWzEG3K4IqyBJFyKyidSRHpDaznA3up8apoObIpil9uL6xgc47C52BJSR3MadP8cl2NcxmRMwXiaxkcYD20crYWjv0r8Fe9nwlUlpFRsWL/1uA0EsEk7yOOyFDaxuV0cJRInFwDDxIw8xut7xg/bxhxcxJ+IJF6aFNQLu3OcYzASyrzKSi38Dy0hSxMysOUCmCAUvIGVItFxLQ7SfvaQpbWcoA+LoJWcoDiZsd1cGAxqsTMZvRZxgYjny+/HaOOFOfhqZlJcUsccWUobp71UDuTQwP5xeeM2aUjxFfVAD7IGo2hsvNmcvJUsIi8Zr7xJuBxhzvuryXdyW2mBOU4Dsu98VQWMqnAbQcIxDgWRLHHJxBWxkPhAwiWteFkHidacNivdg9p80AgtmeJMowz/3dCHhs7pnGMcqiDMl8LDbJ9SNcoSMs+AWcggcSwaeGjUXA+up7eHVsQDTct+99KyjCTijKmZWtOM+NBzjCISDUswZ6grfE/xPCuWG8jkmxzuUCyyZoTph5ZM/Yi1FtBQzdICzdJUzY8/Mpa1Os5YzaXNyBTnzL/pTMfiNdE2FLR2uccY7SoGLL4FtRyvZ7o4mZMaeNmavJ4WIQ/b3NJtTMZIrNCZOtpE6IlMkbhaR9KYoc8LB2woPKahPMAQuS0y/FKpOhiFjKC5uWCD+4mHN4pLvIQ8GtJJ2NnGHaOOUbGiTdpZXZNHfNr8C8ul6DmzS39P3M4X9sn+oIomgU3z/1GsxorbyWG/K6Tc47nBiJeEFgHL+6cPJV0Px23cuQfO5v3XzE3TzdjNq1sRS0x5TJF5193Ov8VP5rXdDuJeGt0oPBHef3FQ5u3XuPrcYhuNcqzJJJ118b3N803f9c3c9g3hwFnZEt7PffExdxzWYEQyGdpAjl1LytyqCFu32/jXyo0U8SCK/L2jOa6BGV7JI46/9d3Xo/3hFSviYLshJxjgRZviA2zMsaI+L+6UYEUQf0qE58mphmfjNw4OkKg31ezDPV7VSxHk03rfpU3mRn7kG8LTA1Lgh4TiK8Uae/FIQUQT2qjVSfHcuXzaGXhOdh3mjiy9ZF6xpD3oRW7klP8ctjmu2VVx4jD35gIe58KVTbdh2wa1UbuMv5T542IrFWVExgYd35w+oYa+p9SK1aWe34i+wVdnEdRcFTx9tkvOzgOsQwcOsMnsQxmlLv6T6QmNjGSp5wiZhFnHEZu8f0gB6KNO6qlu6hbb7CFe2ayOhIvO6EqhJa8dizlkSAUOkYsyrLwEQihjPZL5mzq75xI+tjpegunckLMs6svO7NDe182e5r5thNS+3tZ+7WzeuHYJKDeXW1dFKN+uF29r5yI07gKRqdKrFFPYEBqYhCT9fsme4Rs+5vOe8beHs/Z+uDfdF3boxCjsTAUS8AKPdmVtwHdlHk+0UQG58Pd9kzL/q5D2UOx6s5CxmxQZXhHP7Y/yrvGGfqkdb3jwm+9MsX8ivyc1tDmPa+vupfI0kV32TELkLhkOytwHmX43fpkR3x6dfcSO+ZtAH/RDb+Ssbs5G7+WaXcLYG+uuFOBvz3yebF4EPzAuTmD2bGBUb35tePW26s3DDjep4e4Vv80fjBQ4G+THqNz1u/hlL+JXK2uu3rPfwfa3RbyYn/lEat1bErR1H5bYZEeHomVtOHubWPVee5DgsOVSgSCFz5IWcfGxv7VMkfiML63T+vi6f7hFL6g5sZ5GBhE9aseaX/w45+if6g/f++19FkV6b0WCZ36P2ffSLxV93iDLh4J6nee5/3zEEq6bhbH4grv75H+4CInBH1/tjE7HEh3rxr/5nK9ryr9VX+JLBBNjMhaW1f+YVn89AKEO3ECCBOPRo1ewHr59+/r1excxIsF3FCWuw5gRXMZ1BT1+3LixIziJJU2ahAfPZDyWLV2+hNlS3kx5CMHVqzfQ3k5893zq09dwHz+i/B4eRZp0IFJw/vz9gwrVX7577dylS3fuHDlyHsmZ06oVXdhzBMmWLYhOrVqBH1mCS0hwoT6kJycS1DgS5N69GC3aHXjyZUp4MQ0fPkjT5kd8jX8GFVq0H9GkTAcWNdr0adR//vhVbYc1LNeCYM+NRQcutcezp9UOTO26LV+d+P/oHt1ntyJev3pp0y4Z+GRKloIRH49JsybCmQjjenR8D6jQhpitG31I0Ho/cP2ccvacb17orK3Prga5Vr1arWnRGxwYT25Q3A11/8b/2+RAePGR/3dppoGUI9A5A+nJibGepJuOOgcdJIg6yR76jjN+xLuqPLKw4hArdT5cL8RzzFnLtfcKekc+hejrZx+g7iFpouA88i0//CRKyS3DwDmOQAETYk65Aw9MEKSegILsQSUHUnKf7rzbLKrPrOJQLHSw4ggjdrZk50MuPwQxRPX22m0geu5xqEV98BkIn/totDE/wnLkC6aC5OHxLR+FhGtIP23CibbHkmzSSSabfNL/qSj/6eeeeTJM50oOU3KnUndmYgmejN7h8sswxfxwr3jsSXLNm3bSLaIa48SvP1Y/wvNOHwck6M8hcwpUUCQLFSrCJrFTlLN+xLPKUmMvnQknZRGKRyVVL9oSTGmnnc1Me2yjztR55qkn1XdWfTVcccHZM9aC/uwToVz5uhYcBhvMFsmCEAU22M6GtWe8dopFlh555tkpYHtwkqfZOYvjNFpqpx1oHXpYbNFFfcAZeFtvwR0343AFBElZuD7ymN3GwDmyQSTlnZigk6kDxyhFn4IZ321n/ndbgRvDJ2CCm4UpYYWn7TJUduJh6KFsSc4Zp4s50rhppxXCFeQiC7Kn/zacB3pXYnk/WrlXCl92ajKq8gVY4GtxbmwnnAYuGKaUfF5YnS7fkWehbCV21yecl9boab//VogvtAd/9+SUPTLcwa/BbpGqewL2Se/B1Va2HnpiehtuoOnGNk0XI3cXKHCQ5NsvwE9HXcHBFxxUdK67djLNCsNuPPJ7Sn4Rbagtd4lHlZzVHMx3SG0oKbylO9S+pe9K/empm7da99H1+cl212Fv+Wup/JlMYsltQ/LqqqG+fDDiJOpUbqIJRQpvX4eCyFscoXf+eYpPX72gF21/bCDY4YfS9iKWO7TdbnAdy1NLCkOceESkU++gR+eWVBDuJMVbMdqNq+g3rnXZ7/9VIzMSCJF2JP71b3oNAkeaAki7hhAQgb/ZUQMj0pJ6EOpB01tKZeJ3n3fQSYMblFrIPNLBnIwvXFfbC5tIhjS9RQ6Eoktc8RbHwv1pbEcJrIkEhTIZo31Eh/Lroat+iB+OOa1yHhxIoOpRNSMeUYSqW90B3TU9BsUOKYxTE4xAFq4ZwgRB2KqPZfiiQn+AkU6sUkx+nkMbIdpoJ/ejzRtHGEdKxpEgkYPXUcDGPTVJMlxvqUhL/ogmFRqNZXsxogo3ZZdDInJbi1QkLKH2KrMJDokFqWQu38i/iUkRSi8b4BIVqSMe+Yce14JMZU75ESflTCcE6UeWhlOQMdIGTzX/OR2u0PiR8fEkhHLEpS4teUnrpZCQwOwkJDMmyj8mSYcNwVr/DDW6nG2rHnqUJkqoGadYyVKRHbyJGrcZSTiOM5zivCUvzalJYDbkdm30iIoK0hKDHAQhyPSlMg1lQMcczknUq6c9pJPPGRGEMPEomLlgZSZxrSugZxwoQQlSSaTZUpcFUagv0fm5Nsa0mBNFkN1KqdF45ownoEMc9X5CUpN6hDgpTelKMzbQRn4QoZ6cqTjJWU6d0o4fn1NinFJ0rrkMVZlFxRlPFpQyyMxrH9Kc0xgJYymVeqSugKvqTfIjR5w58ZZJpCROS9jLc9YHpL9xTkTbmVEdcgesk+sr/4NGl9GGdQRccoWHpYC4FyEmyKeADexvlPjXvJXQnIU1Wu4QG59albWxuNHf9wroE4901Smmo+YhxZjZSsWqjEDM62e/aVD8hDWrpj2tJg27Jny4tE43AeRrs+MR2xVQZR5h6MucOieQ0HVWsPKn8zr2SII8krwFBadVZ0vb5BpPYmnL60cQ1KDX7mV/ffWfO5OySX94JIytJIh3vwuS8KJujR6p5XDz50bCgU6/R/kqSOFrucXIt6wZVWFtT0hHA2Jtsnfkr6I+8sNq5ue3TYNpGqsqsPuZ16akZVUlkXfaUraQowOjcIXhskYtTpCZhnOd/pI5xRDTBsDgcIeJ/f+mTY9VDsEUC5hOIApa48ZYxoSljinBqrMcnwujxbvhXgxluPxGsTKcxONeCNPdzQbOyW9+XpTLW1ys7jWXenxQ9x5LuS6bCXxZVgozD8VMoTxYuZWBE3/A0Z81f+RSbVYxTHPlXBbHCcaWpiR7eQVSPucYSMTbog7FrGEahxrEnBTkZVbFXUefuM1OZpfZpgzajGVasoXKHY4tt6zF+jLDr1LSHSnkHcs4iShCGYkYf4Osu0LvjPiRdTdnndUq77VNcWRvqQvNaV07h8c9hmfGYled/aJ6uuaEl4vUXGKasErHQDTveYHY174GWYrbZu6ycjwXG85T3Kaub/KAHGT/RfMFWQSpa7vPVWAOhqyN5JXzvKODSf8tNGJ7lvRC/twrjeVZutxJntaQlO2N2XUv7zbjGaNdXnlDj3VYcx2gbYyztSnrbBsP978B7V6OO2jgt1OzNRVOK/miHMUqZzmUW+7ytcL8fZ5zUVp5vDbw7crfEztcnBgbaJW10JxfN5weR7yXAfMlsXjNK8SXDr3qETrULZT64KIIkqzjZ+fZAXmEBp6k044cJEcm157MfiACTzW+lZ62jarNKiyDGe5Jwwnulok42tZdzIz1t2P3h0nCck3sBV/0QIxVLqKTy1ZFNzpfUqziaK/9dCTvOq6Nqiyc5/wjHOU8SBSX6kMp/zU6J6P750PPH0ajtFy+RbitGM7I3WW89WxUJ+CUWvd+x2v2PO53CoPfYMvz6trv+h7nLd+qkx5fQBxbzukHZKC9bCuIzl85/aQzqNoqKXw3mx7LbH9dXmbd9vD0N3eJLNmqHslhlfIzP4VLP3RZv7P7CPcbooxbm+ejGsCxniBrvHjhqKuZDr6LE3v7ut8woJtbHT1KGxdrlfiYCQH7rgU8vQUEiZl5P0l7vnhLvHC5wKyrvpORHODLL0wjuP0TLOS5MbO5JcizOSObk9EjELsSkoTAiSF5wkWqh5lxLgkMlBqUNacRPx2El7CbPyDbML7ItjqjuwbbQF1bG6qJwv+gusG4YkLlcELFeA4pTKQhAod5CKjdkYtnYyMtdL04yUEhM5kXUarCQZmtuT3FAwnZuiU+U5dc6TYeQ5pWiitKYcGhCzw6rJUD4RM8VDE+jLQkVDpAzJj+o74O9D3WEcMfFBw7Ez5qeyMui0KYUheI0q1L5K3eIj0fgSVP5MTACcU+xEJA3EJxYZ3WIcSRIxwyU7zFgw78IqcRajlarBznaI6cOBwf0sVdZLZZ8cVFIryGK0YthDIoC6t2oTNUPBwgG0Ge8EFMu8GsEixTocaIOy8DaZuDqCHXyZFuPCleTEA5rBUzST3Oaj74M8aAAaF5PK4czLlte8drkazRsbb/kamzwwktKTMiD8qxtkmRhLBHgIwrlvjG49vEOzFIWVq+YXwpGpQzU4yxHCSUlik0vRmYo8I61NmaNVqjsykvWFM950AY+QAhkjyYeDjJXvytfnq3g5ylUYSphay0Z5y/rBkKfliKFpKwm4GRnaSNQBwtnAGKkZE0YrzC2VtJf2mgEUNKOFzKJnS1lfQIqOyYcqylGrSyMJwO7IAm7zlBtVJE1Yuvq0GbslQxA5k0baIagXEu0OuTt4TLBAy8k3vKloxAvIwyvbRKQwyKzCAI7gFMo7q5GcOPqsqlsmQTTwuqPkSlqnnMiMoUyZyruJTDuUwXcjmXcMHCCdzMZ1I6/0xbq13RyoLgnq+ayAIiOOZDL7JUCATRqyCSi06TyolSIFb7OwYyvmNpQrLDzVfpTZubsj+ERhEqwcdwCI9wigg7z7xhjDhRR2Gqs1gECV0DGfusqNlsNL44KZOMw+/URMMLz4h7JgKFDlnsiZIZio9Yz6gjHA8zLjM0kklavI1DzFh7HkmLi328xN/oT+78zgEJ0TgJzwnkpuCkswGEjOIMzQZdRQkVphRFm45MkC97L2hMo7pksjYMvLcwqf10y9qsFCRrtjmsnwEdTwOlst8TQs0QzRfFUSuzDel5qZkymQ4Dz2u0CfbbpxLLLW9EstJDOIQbURsp0Z90yEiarf++BAlFySOOks+wgtGDSisdzQmyDJ85vcs2PEggzc5dHFOQQL8yJdHeDESrZMUANM6w+ZwNHMv0+g0SrMsKy6Us1dJIfEyS/FFjCVRYKbsiLVQsRKVnTMagoA03bVSMpKmnebepFC6DFEpMzVRNXTQwJVLv7E4R1UMznZreZBfgtCXx44uoUBR+WEUKlVPO8iz8iAvnOjub8FHWKsjWsjCh/FJdJL5joStBHUiCgMA8/FaXlEprPdEUlazxIwhiPU7fQ9YoLUXKYc5JHZLe8Q/5qDAgic7WItcfxdZa1dbeItNNFLzSm5mC3VXplMCwtLOmQ9d0dVNj1Zt2jVSzmbT/OPkTe3WLPtnNRgoqCvvTfsVEbVVJgW1Bc9nVgo3KFDvLWBMtKm3YFl3XiL0pbkqwIvGg5rJO9ZPX3ZQLfXXA7aLN2tRNks1VMR0Qg0VabtnDHI1NZCxV7fuNzugOiGWTmeWmtDlBZwKsdfGjAsNXnkW9n73WoE0yoh3YTo2Tg5VOp/k9q/O3/ioIqc2jqm1XrCLBrJ02jcuVmOBSjcHMoF1CER3IorURtY3Av+G8fMiHyMi7gYBbuQWrOF2wxlwdb6rLNHojvv1ZNbJYD61VwG20sm23wf2b+HoV/skHoFhcKVLPgYDclCEv4kojtZpRksnba4nC/JQosnq2vwHd/8AV02tKQMOFtL2wntRNEr80TtdlVNhF0Gr7yThCwfHSWNogkmskpt2Fj3Vbs7fk1CRTqcH9l9Q5VDJ8jNSNDNBcXnDojCdVuqql0sak3ev7m1tZFpCIVtnUXkZrtA7lX2YbUpPbk3kg3Iwp3/w4XsWtDuX1iO0JDxgxQtFiSJrLV2aNpYslpokiv+H73O1iNlz1EQImSKc5YPxIYMZt3NBs3+Okind11wlGIpt9VctcDPbL34rSYDlxy02liSQrWzId4AIel2rEwchR3NXNysYNMbGBYJuL0m+rXdeMqbiwKJZAuXH8KRzWXhupplwE4B8G4ibUwxFuGnkrYeoyYkIFXmAl5q/GOUe9ukEorlMpzg+XsEsY2mLfzawADWMCGWM+HuKHS1M09okjTt8U1q7+cuNBxtzKzUz8oNemueGPCAgAIfkEBQoA4AAsAAAAANwAqwAACP8A162D565du3nzwClcyLChwn38IjoElw+hvXv5MuZrl65junPkziFMR66kyXMo0x1st3DcOHAvwYmbOVPmxInibi7MqbOnz59AW7p0qXDoTZNBdaJcONBdQYMJk4KDyA9c1Yb77s27uG/hPYMGP6ab9/XjOXPnOj69aE8huaFwY9KUSreuXbpwixI9Su5uw3MKBToFGzVp16s382FErHgrQqj3yppViZBsxoVv4+61ydmv589SicZsuBn0QsBMCcqDWrjtT6oSJ/LLiDiixsiRM9pr567jQdz5uiqcR7LcuJJ5HebkyZC56ed2SxeF/nPd4IOVFd4Dtx1obNnfFUb/nK1R427IijE25GiyvfSdOKnLDz19/kTUCq9jt3iRe76g4/HTTz/+ABigbVrl9lB44HCEUkgogdQTTRQ6d1M4CoWDoX0cdtjQdeBUZs9FwBk4nkL+pFjgT/2Ip9B/P9nTm0dhfZTZS3FVSKFCNS2koYbg/IghkKb96Nl7HjL0FGsj9ofbQv9d1tCBAapopXwVQUXiPAaBpNmXO85E5IZACmlkkUTStRxMo01klHxLikgibtuVV94+ePIDG5X8WJkiOP8AupCfVh4om2IaIUgccl/mWCGZZwZp5oafCQkajjcll1RJQfFHZ252hhpcRlTtGRGBVv6jKqGEUglOiwwF/7iQbcR52aijYmaYZpA+7grUpJPWZeGbbiL5nKe5YSTqsqKa2qeKq7KaIp/jobqiTvnsBhKj7THqkpiWTlRmpD8Ba2ZSzFkIU30MEQsUp5j1ZNGTkXEHHJ3MLptnRNKqGKCoAVqromxlPVhShBEiB66l5OpKqU/nMuSrT+r2KFSmm8Ib1Iifduzxx5/eaeq0B+LJ7J7WTjStYmGlRRiX7I3zaK8OlxlUxM/t2C50ffmEUIhNBs3xPU1GJvScIAOnkbP72Plxogdey9DAERH9W3lWkySzzpICS1e4wi7HU4/q8gxvzw1VltBWI7LdpNpy8meP20cjzWzSIdN2IoB6//9bka3f1iSOuVLhLJXgZJd9sWka6wR3iMOtDffklFNedNIjQg730KECFSg4Use60bZG0eS1Qw83ZHhQXPOouOKeNb7Q5CzNrhBYuOeu+8uV0x20Y5Fbjq+UPan6+UKqxrqbjTfKRHi5p6uJOI8TJglOX4/XPhFvTnXv/ff65d5778H/DDSdUzJ0vEPGJ29VtjXCu/CPFov7/OE6Vmg9nOB/b507/wMf7n5GOYPcpTsOCZ1PZqOVGu1kcPSrn/2C1ZmfiC1/+4OO9wIoEI940IMCCaD35EFChaxGe3XhnHD8Qp7GaG9rGtLfhVanpgzWBW1BWYdCPpgOdPjwh+f4ITr/PhjC74GjhPKQiuUuEhzE9ORaUhtPRrTSEv3BLnqHS1KbnuMUJTmkI0BEmBgR9kMPGtEuJNyPiJSVDwYNTGVTkqJCzmEcmhirZhCbmExgpxwb+sQdC5nRTRBmjkKaAxyGTCRaUFLGdAgEHpDsIlAKQkJ59E5ZVEERq0A3KJ3Mxh4fKcdMNOW6nICtJubC0JqE5UeddPGD4EiHVMpBy1omkpFD7Mgju9cT77WjkjCbHKio0q/Q/amT4qmI1hqlPz2aay6tnE/3eAgOdCylJ7XMpjYRGSEf6hKQgDThEZ1CwhFW8oRq3Aomx0Mo0B1Tk+8UXTtIp5lmTlBIOoqmfQD5/8EIGbKWDtGmQAFaSEZ2pCHyAGf/vodO1qgTavyS1qsUMqB4xqpg5DAOrsoGLB3pUZ+f4acHUWKOgTZEmy4RqEPww5CEJnShvhTfvEiFMmnByh8pI9g8zZFRjQ4FmjsxE4XCkU+QwmmHHjlLT1W6RTZh85DVPCg53VFOmJLTIKtRGxODU9NNoqgfz1Lg+0C5LZ8GLnFiyp84XAIhOvLRqOtKilNGytOBmrVYcclmQb051b7CNI2T22oTq9XOY5JMQDfhR8FAYtaf7lGtdjzHfubZ1J6kjnpw9V5SGYvSjVLorGsdh15Tkg6qmvalL2VoQtNJIlJFbZN/Oiy/JpIVjv/YaCg+XetnA0fU46TDNVNMR2UvBFefcG9GPTxLZ3+aP+aOMqW2TAkvq0pd1DqUbaCaFTsLy0nQUUmsLnQQT72128D5th0IDK4oy1VcoBzXI9akYy2dm9YYkqOkFcJtdIdYkED2r5Jq5FwcBeQnlfmDTyla3/usNqOy3kq0kq0XlBRDkre2NykGmSYYlZvb+dnXrbsVKFr469/uoRaw2EWgTq50E9meClrXIo/VHNStxpJDJf1hSHBxeGHTcG8dSS0pLXkrVNA+V7TZvG9awpmfEpMwO+BhkDvFCs/xEDPB7rOKjJc30p4ebCwqnvA9hNtj6mR4rmCsq0Y9TFQIlhf/ybVUcmmTAqrXshhFxSMZ1LCcZS1PcW5c+sh4XUaWML8oI+5Yb5mhc9wZWVPNW2Nzm0Or3zijRZYhWmJrl/ZiiQblHwduYRufZbyGhPo2gZZuOzbtEJO1gxwWXrRUGg3kjii1jmx+s0AhJEt10olzdwpYv5ICats0TW9YLlDoItK0rwwQVMRbiKthLWsznxmAQc6okXWtzRH3eqvKUtrS9lRMi67YNnYicIEdwkBAz8lOrc6KO8wR62pjGCzdq7Wgh/xgWrZnkQddNRuxpq+ACYxVpZ7IqkSdqIODJz33gveU9mEPt9qbOjDzn63PMt5dnyRCBx2OYAmeN5rCZkAo/werwPqcQD1Nsc7qtmiKwJovGE18HueQmWcaproLXzvfHozvGNMCy8ghDW/i3he1IuqPhCvc5RBfp4ByOqhQM/vYiWX2V6h9Fxpetrgw+3kIeWjGtMkJZHV7t2uXHvP2KRhQB3550rerQKtfPcqfxHm97wmpIV3cIQt1SNzoRjR74ONogVU7V9mOKre/vdj2GprUSW1qnIJVyloez5g/snfUjQts9imMT1xzl81xLO1p713QoM1VPCk9rI5vCKi1czlob1dlA6qKE8UToH3Mk+t2SSXEPNOkm7imLXUDB/IzFzmGpPjXqP8d3M5pSbmJO91V4jPLG1L7YXZaUFPzZP/Jxgz8pDyP59CBskOiz/66eaxucpsc9efPH3xcv/XZb3r7wK/g7q/TWm8nflIUGXonMWcyJKlkJDSUflERNMpXfEGDDxJ4eEiHdtI3PvNQSaYFSZAUD8BUD/UgeQOHf23ndArxOYrxgLXnWqiSFOP3FOfAEwlYMwmIfvIhJ9FHJ/ZXgZ8iNI8jfxroDhw4hPAQDx74ZCE4Ijt4D/qwNIsHgNv3EETzgG4TGfqgDxBBIElxeS6Hc+PlI11Tg2L4dfOBg+23hBWIeJOzEPPnFEP4DnAYh/HQgR5IDyC4gkpDFVCYWNkiOW6DDwqBhYgFFFyoJ/fgDnSkcwY4hmKYQXL/036QmHpqcxPn1BDrEIeYGIcdSEJ2eIcTSCdNqIfmJjpzAxbcpx36sIVW1jTpQEszxIjCZ0NmGIm0uIZ1wQ64iIuXmIlGKA/00In1MIFLeIV5ooU9QXG8UUTkREIh+BCwwj6rkntQNw/moIiq43deM4MLGHqPSIvtN4m3yBC5OI5yGA+/2IlNIoG4QYwr1BP8ICPw5RH/Y0nBeA/78IwGlntZoS3WSIOweC4fxSFadYFmiIEiAo5SgYvqoA7iiIuZ+A5GaIS/CIJ3aHj2d4WpCBT+sBG2VlBBlA7sMBCWxBU3ES04ZYgcUY0S44//iEXoghOwM5BvY5A0qX5BwQ4L/7mQDZGLmQgOEWmOwFiRgOgQLSgbNOZv5vBD6sAO7wAP8mAP+hBW7KMiYHWIXrKSYdiSFGQXY7MmEiR4Nfk4mWaQCYmT6qCUOwmHDlmOQDmRdxhv6qYyXyFfKTViSxmS8EAW99hdlTctVplRWKmVsQga0wMUCAGCNOl8iQkU64CTQvRDDYmLC/GTvniOndgQ7FhRiQVK2oZkSbmUIfSU9khlcBd3v/eKgmmDXNl55VOTs7OYP2GWPzRiPrQQ7KAQtzmZEVmZN4EPGIknmplAHFlS0JWUAwEP1rEV+YCPfTkbtQIfvZKafmEhY0MXUYGQY7mG5uOasXmWQhREtakTEP8ZDz8hgewYl0RJNPMGF+WwZPOAnO6gl6T5Kk0TaA/UlakZkDApQa3DLtYplmmTnZWTFArpnf70mOjQEHDYE/WgEOp4nsbIbhRGnKJlnBmYnPawlwkEVtyxG71RSo8imNMpQzIhGr4lekq0NraTaT6DnT6hkD5EUgiaoAuxoD4Rgg+Khfc4it41l29RDiFRWi+1FTu6oXoiI7GEaZEmabBoQTfxOkMREu1QEaIHoBPhokeURPIiOVp6k2dZSELHYeWQlDrxk+foib4piBHacsoEcqU1GMq5pl81G7/XmUsKQf8oKZ9BomxyY4thPgKKotdppWwYFCWEUF06EQsJRD7/VEjZhA4MWaM1+pNASZEWqaNyOjX9kBVht0ZckaknOTr8dlZaCR2CQxoRhhhhuZ0r6hCJ2hOH2lKvqqi1SVLdFqngwJPgAJHjGZFnanhMmIU+sTIlFxyZ6l0Ulw6QBkOlij97dJ+rBGHo9SyvyZ2Qw6ITMatSUUk+sagJKqa0ZA64mqtryZa+2onmqaElOSiF6HovhnvO2RuMRap5Gh17cUFrRQ4HASNvFKiE2qo6oa1JUYkKYYQOcZbVhA5CZku4Oo7lqpa5KJF2aJ67lzwmaCWXh3LzGXcO8RKm06R1ERc2MUohMQ97A5bk43wD6xkEW0kGOxHWdKu46bBqCbHe/7mUEDmx9qg+sdeX67ZiBaJY+8mk2+gTpHRe29EnjlMZ1Zey+4NE1Gew5DkRjjqmkDqzDpu1ChtES+mBONqOjheFd9EPNtccQzWDQPEmOYEjPOFb9uhEzKl7svpkTCtOGZRE80dCEQkP76BDDKGwhaQQkZq1DruoVtu16KoPsBK2YmsX/rAP8/Ch98kj94NXmtEuPNGe6NWO2sW5ZcuGWiqw8xGreJu3P8m3DSFEgruQhDuOhvuZ7GCOOJqRgBJ7jSsVqkK2RwmteEqGpPElv3tj89BGPSElU5itWYq3dmsfedu88rC3kHQTuMq6rVuggAupEImjO3uCjOs5P7FwPv8aV81BMaV0ue1yY+j1uRMhYSqIvNz6tM47f5QKDwR6l1nrrZAau/RgeFc4KIwbgOzjOaDWpoBJH0EhWmCmvhORHtyhEKTnqu+bJPFrupQqvTl5wdR7vzebsxdBu9rXszoRKLdbuwdWFkJ2wKS0M8eRFpahE+2oGPbQoBNYXBM8wacLSXHYEBick63Lw9mbYxT1wfvnEyJ8u8ZDtrXScUYrsh1bDrGEXobmEMZ7eA3aY1RVw847v3xrowuxwzyswUxpjhK4EBUlxCZYkkOMxqCGjMyDNsMlsswxDiBhDlBsaLTbHU+ifC2VWcuIxab7vEbYgTncxV5MvfbrkLLLEBr/a8ZnDI0jXLv/oLtmwVgtkSlblFJqQSITkY46AYIgZVVX7MdRG8hGOMiE7MVZC4ey+8BTx8hprHCN7MiPG7mTLDs/cRw3Fp8o6hB2+MAfAg5CGL3WA8omJsouC8h0aMqrW8jkCJG+WMXSVsb/+8qy53bFYzyKZVsGgxdqEasB68k3UQ8ZWEk47Lf7lLzG7MeBXISYyBCFnMFMOZ6XyRD3WFHTHMvIQ82O7JwOsi0FPFwtsWR0QQ/zAM2+rBAgmFBcLE3xW8zpjMyCrMzvbL+qLJGJJc33fM34nM//wM9mURKu+BPt6UgOkZs3WsXAipEOmtCSJE2hnLeqpc7rHNEL/w0OzLyWC/GLDZEbWdh406zRI4zNWfLRIP0TN9aYdEGer8rJT4KYHeLQMN3H8avFRBgP7ezOO2ybNf3APN1pGa3GG408cZdqSCG+TdwRJi0VHtgQSXh8MTzMUv3QejvTRMiBVl3TNp3VDDG1DMF8UHJl+te9YA3AsjfWCqHEZi0U5DBEdvEOPlmHDUEP4pSEHvJX6UzXRPiQeO3FN5oYJRi2QP3IqiK0mMFjRxGeNg0Ut2nSR8gQVeyLD9gh5xROVWVOzYvZb7jFeC29qW0X25GF0ALCIXyx5jba3cFS2DSmQRSOju2TnKjTB/0hTPYZtU3b1d0/pzuHdb3Fut3cHf/SFhjR08Hdr6FtatC4kXNk2hOh3PgBnlLRlEcEDvMMDp8IeCPkGWcEutfthttd15ptH9CsfF0dcz872CynQKtic+SlLuxNo+CASzkJFM093/S9g9HcD+DjF97TZPq9UP2d2f/NISjtfQRO3rDsdvMJyaR9PWyST+GK3ICB2qvbE7ILzg46w8Q4IBl+FxsOzEwWhODz4Ryo2d4N4JezdgfHoxzdPimOzQ30EUUBVOAwpiuFSw6eFJRdD5JtkUOJqXlbF10UvfQrzD4ezELe30TuIW19kfuS5PP5v0Sc4E+OH6WBFn+BHzIeFCEIzvLQ1ikNES89f0EhSUPYENp95h//Hk0VqR2LF1Z35shhuyLFvSr7qM2mvUgcYoeSzX3BKiCBTrCTxN9kPpmILuSekdZY/oA72OhunkCu/DliZTxxN+fI3Rd5HhRXTombvhD8C5w6/tL2HU593EVhzoEMUep1Db1+oZCSSReUTeIl/kZ+8tPDPdouZGtuURK0uT8y/LYDkh+SZFVlnt/gUOgL0YENQYQ3od13kYuHLBUB7h+sXm7BzbhQVM1yzmVnweKYbkP1oKbMWWLjTsznTuZDyNfl3iFg3OxSYXiMfhmwAU/SMs2kyeQwXCMkxUhJAVW8DRT4UM8tgie0K92BHuTCPOYFX+70mySEe8E8WeQeb3/c/9GEN+Hmq/K/PMrkDAQzG7fcQLGwthQUQCngID8V+nC8wU59O77yIPUO1YvB5SoV6hjFDXFwsh7YjjeKOh9etuUR46oTQJ9NQAGUUIlyD6EPh7fL4E7wCX/sdsH0PaHZT+/yL9/cCN+bFr5AZZxsFD8119I+m8r1+WbOSlG1emWo/17P4ICRRCPOgaQkxDzdcF8XOKzMDOH0IdmY1WuWUP+w41me6OOOVo/1We/3K7L1RMO00/0TjapIQk8PWLipiz/GCL3rJA/KpjHkIR6Hm+/unN/58cyWP/Ep4rfI9R7plce9lA5xbUMX3hlfav3xeDL7fn2truQ9de0Z203kff/b+wU60c1c0S/bE6BY/HtP+ihu3spfbC/X/Ag1hzBPyDBbpvuruF1x9DEc7z6x3Z+x/QDxTuDAgewMHkSYkJ06hg0dMkRI8F08ihTBgat3UaPGexc7bgTJj18/kv5M/kOZUqU/kBtV9tuX7949ezVb0pMXD57AluAO9gQqD9++fSTB7dOHz948ehmBtoQXVSq8p08lXpW4zqBAhV0XPgQLMSHBihTl0aNXFdzHniJHljR5UmVKlhr71QVHl18+mTZb1qNHcSdPkO8MqtUIb6hRjUntAW7qVO1UqYhbYs26TqvXhOoMhgXt2fNYshXRSgZ6T19Lom7hxp1L124/jSv/+cXUxxYkYIoFuz60Ss8e0X0tZ4J7XE856p6UqVq++C46Vs3VN3P+Glp7Q4VXTTeFDrK1SJJ348pdOfviXH+3+fZ0Gjge199gL9fTR5Q2OH2rgeLDJzyqogoPHMIMlAg7hbZjkDuvSjsLvAIvGq+889CTDZzy1rMtpnw0CjA51OhDyCfQNqIHn/wYQ6q/xiaE6jnoNDPQuuuw0w4dHdFRh8ewFOxOoO8kvAjAnlTTiLi3LmTyH5Mu2jCvuWDKp7iNHtMIp/kM88q+LPMrar+L+vMPxuZktIzG6hZs0KEddWQQSNKGBCnAI9mq0DwmL5xtP3/Yu83F3TTKaT4cHdII/z/inhITSgETQxOxdTS68aA2H3qzQTkjEpKi08xs7bU94+qTw5Wo7E+3nrjkDJyGLrIHzEbFM2pWy2SMtKpJL9Kss0sx3fHSTQ8a6DvmWrJzzCr3eUvPUesqb7/Y/IEJqZlU3UgeeUhMSCPpwFGRKKDI1DBaMyec1DqEQvNxOx7hFHZYdor1FKMCwSTPWSY3MhecP08lKrd7jDwXxBURO04/uApOs9LsfgWt3Tg3HW1eeiNczh618G32vNdme+uif+mqNjcAk+0JLY3iMfCieuwJ11aQaMutpgBXXJjhntT9DGKftZOX004xzvgpjqOlNlrGyg3Z35GdhClVpWBdLv8jyNICJy2L6gm3qAJpemyetZi1EC+dweG555/XBi3o0uI5rWqjlVS6bn7NhY3kFgfWOFHlsr4IrcheDreqFikkrji+52H8qCXN1nlNS9mmHKxhsTIr7r/HTbzZ8prucySn0aPWWgD7RlHlqmGWdePVOiJTXBAZ11hhyKHj6VteHa68d7HkxDweojdOnGySRJJdI7fcGv1fk6I+XeP4AHeZcJyhQ5ncOm3mTz8Y37Ex7XXblNPnr+T1TniMEQNzPOQXTbJ4KJmMemCllksdI65xljnJVI8sE0jIpL3whC9dQPpRz4L2m8mNxkHAk4hZ1leV/hTPgrK7oIbodxv71QT/f7uJ2dLGlZvweC9+yZtR+Cj2kAW2cIHB0xaRKHjBxG2kgvDTV+lMFj38NQVAYILO/wqUs4IZ0EYuVEivkAgkglgMM5n7lGVoWBwrxQ6HF4paf05WEw+yzoRSFKIUjfIkhhnwIL1SIhJ9w0QIYsaNExGe4I7Vk/ZZ8ChjsmJxRFUyLUYPZl2LkloOF0A83hEotzOTERUpOQW90ZGYCdIjyzJJwclwhHWEX2OsCCU99eM2eztZKGUlwp4cbiOqWo3CztawRR4RO4+EZSzdOMlJRigy7MujoASIFCuFKS5ZnMnJBqhKQbaIkBz5CP/ussqeIKSVKiSNLKX5xPnQ0ppl/7Gl3C45QO0REoicPE+g7IcP1Sisf6yxEn+8yZqyMbMlznzmOqY5z4lEcEv0uiYtBRdDzc1Rk9wc0yUp9Jr6KYWc/KvKOc+FyFVqxaE2QhA9BSIViVA0nxfFqDUrKccPnoubgvLP43SoFC/2y512GSLiEskOI0Z0ms5xTkZlSsmN1rSSHWXYRwMo0pLNJD+ga0mtTsqosz0Uoi5F6kWmMpDKKDWmM82oTaV601WuRqdJWlJ5AsaxcolpaaR8ChXDw4+N3KaMiqwKgZwKUzTBFKoXxclUpbq5ntgJZRT8KFYtdDw7cjKQJoUOWEtpysiFrzAHciqkKpOrlrwVrnKtqf82/1Mky/gUoEcxXrSKNyuwKjRJM5MiYU9KI28BRa3gmEp4HKtPyG4Up1Wxa11BYtkBIs5zJOkrhdTj2c8OlWCJrM5GdLeRphbMIuDQqLbkgVwJwk1wWXtuTWFk17sSLEAnU01t8aW0T6JwI2Hi7VD98zqSwsiwkzktM5W7XELZ0qbQraQ77wou6wKItlYljtK8a8jvljA8x4Tt1ICyK5CEbydPcc5Q1wsS6VJPZb7dSCivK+Hsjje/Wk2nbtGZ4cEKVrdU1GX3OIxMAQ94d+Gb6LdwxVbGFiy+gZPrUCNc31DSN5SWHZM5cSseDfMHjwBGnFfF5J8wjQlbI/YISVH/tzO0GZAgSlUsW2UsXanay58F+62EtYxdEopYaawxWiG/+8WWlCmTBVLyU1pJkAE9h8XFHWp0Gyxj+s54yxQu0yh33N8g8ve7MDnSj+ncZBthJbWofXOL3TnXK+ssWVr+o5Z1o+f9InlC8julnbpsQxAtuUC7qg5TpTPR4ib6uHR2Lf4ababf2niLd2ZL+zA8Yku7KMQYBIrs5lskchYpObA62afl+a0nm5ZAUWHZoJ8LY83R2S+ujt6d76pn/u6Xjt6s4ZiJA2ReJ+uDf8RWgYpNXJ0UN9mDZnDWVq2zZ0M60jXucLXG7OMJ3fDaBOwJ9/QnmWerWS1sBgk8yn3a/3OjezfrxjJyQCRhm0k4rMz6pDtDvBYb4hs6f6RvvylFYG/pjs2nbXPBDT7yqqDO3Q4vs23FZfEJ3YzbDLNHdq/r6Y3/m6kgRzTJda4WkzP83SjL7gm3bRmg+5SyqzzW/g7HxZ1x3NiU2XnUC/TzVwebI+Sy4MSJrk5vCky++UlKeRm22PRK3ewoI+mdIx3hCt9xqy9HljBZfq1dm2l/p1ulWstu9qjPt+GQtnqRKlwcq8I97tfVHt6hTfS6awRmHkQ43yXf8jpJG968jl1AXx54Xv9zNfdzPMrNJJ/q0XXypy8YzEDUbcsbx4osr3zjuf75X4de9sjRmKedInLU9/8e5nW1fKt/vCjYR5j1AtQ6jGhur8Bpy/fP923w65715NfJxt0uPsO0iRP2Ihf63+f5f6S/a0yS6fauBlf6C5msxAv/6Fm6Euq4bxHeg9/+Cge+9MtM/aSoRfQzrjhA4w/hUz2gcAr505KKuL8FxD3xG7/9S5wBkr3/M76F0w/Ccz86OzYGlDyNYz3926UIrD7b47yn+KEzc7yNuLLIUywOnDwPHL/LG76tCg8K/I/LQg6r0Z+qeC0EazNFc8FB07i/i8GKq6DsgxUu4iItCzAbtIw5Mr3EWKsglDq/UMIlLELPqy2ik56fQ7OqiKJ1e5m0Qi0q1Llnu0IiDD4jxEH/2cq3EswS1Ii8W9ocHTy4tNo7M5SxfkvDGGS/vAqw//C06zqbv4lC5sCSGDk0PRRCT+tD6TuOf8Ke+TKS6iIYrIE/6LDD0gMMFWyOtcpDRmQm1ElDNZQ0owsoNDu/D6QeA/wLTPwLA4RFKEM0OBPFs7nCJCxFg4I1ArKqSVRFO5lF+KIrq4lC+LgJqABFILzF8Mi9UoRGy6MtjqgzxFi+JnSZlWE2uTHEjEiLYQTDgEssZmxGyyhFXbxCSNQu6uK5a3w/FSxA1Ei2KHKZwHuwpwBHKaxFcizHdsxF3HvELbsvFxmY64Mtu/NA7xsU5Vg7+GrFlLnHgFvEflQ+aIxGsFgbyI5AO/9LPYT7FK7JwLyjSHBoHLWoQ4vcRYzMrm3TyBpcRfhgwcCpntFDDH5cJZ2QsZLkQUNEyYDUsmEijoKMrZILScR4mUb7RmTUwFA8qYmkM7E5uIzpSSUUyDxCnoJcOKJ8yb9IxCzJRxQZNKfUwJxzJ6jUCJ30G6mcSlMcvFAhCqyss7prSBh5ra/UOVsMS7JkJrRES058mbVkyxsKldugMcUDCYxLFFQzuIAAACH5BAUKAOAALAAAAADcAKsAAAj/AM8JRIcuXbp16+C5W7iwncN5EOfZs3ev4r18GPPtwzjPITiH7SiCu9dO4Dlw4Nx9RInynMF07TqCS0dunE2W4MSJw5kTZbifQIMKBSe0aDifP3kqXcp06VGkRJ8y1UkVZdWeOG2OY6mVq9atTMmRQ0nOJEGDCBUydAcyokSKFjPKvQcRHMSQF/Pdm5kOZTulMB/es/eR5k2WOnvujGq08dCgjIs2nUwZKGOilHNS3bx46WGUX0ODbSoWnNmCBxOuZfvQrcWKcuVSJGxPYj5+4PJ9/KtSaUyJsMHZa0dz7NLNmh1Ltgy5ueXMOIcqVZ45cWeciTOL/qx0rNiyZtGu/1vN+jdEuHEz5o6NEjbu9k1jWsy9LzdJgd6Nl+Zc9Sh1qc8lhZSA0BX4H0vPWXXdTtdBt91o3ZVm2kBnIUReaxGhB1ts9YGzz3sZvUdZXhjlBuI97hg0k0MGnaQZfwwqB2B0CEJWoIFGIVijVFb12CBiP3q1XVg4mXTOWQet1Q5rbgH32nocaqQRPx+KCI6VOPHDz5Q8bUnXeRZ1ZNg41mF1HXP+JUjggDfimBSPPK05lWbYZafUgwUaSVBB4zXU1lsTzfbahrHJVWU/WWqpKEtYXrkoShgpqhdZNbVplY1wWqppVJllSqeCVyF3J57Q6Ylan/L8CWiggw3qanqRav+5lKxKlViflVr6o6usxIkFIY463ijnpsQCid2LyHo2JGiTnXZqQ02uOtFbr1abV5Ui9qOolhm9ph5O/egqrj8oycSSceCgy9SblnrqlGSVtcmgj9ZdxdOy4Hz264RHpoMaQ+a5Na3AgRZsMKuEbsstRq/VNo+3KD3KFEkvfVeWWOdICBVm7frk8Y6dppmgUzyF+iKDdir762j7hoeWn9E2aV7AMTc56FwWORztRLCGyA+ijG45XEkGgURcOhlPNmxTT2W6dJwiu+tujyfDWCx3fL2UJMARGe3112CHfZ6GFbkldoatbkgrSrvqZZteDItpoLCcPr2up282VjLKyPX/HSRoWHeFktYvA/zQ12wpaXjYXtfcEeNf25xXruSCI67C205Ksn8bF7ujjTXGKx1iSoXK2WQQbhVa1ulcaDR5sMcuu9ey195WTDzf1ui4vPuz5UwuRjey0lNDXfy7eq+Zqaj8NfVVvmBpVXviS8JO+PVa9zn9Qhaqtb2fuF9UpeVK9a5ruSkm/fne00U29fCViTxggEClbO/pqKsePUrfr7YO9gAMIEL+J57UpCYh3mMIAuHBQK4BR3dYqhxT+EEX4KVrfuxDHuiM5yYANQcqS2ueqJynv9HALiUMCeD1CGKkFlJoTyt8yQBnSMMFeq8tFIkV5rblqIhNSkxIy0mC/0b4ObtFRlh5CxCNQggje2lHdShkSEqiqKLBxdBfRjKHFs0hEC5q0Vln2VOFakjGd7wjgQ7JIQR3yMbfle0v+RKHgJw4P/gJz4h3dMwRl0c6/OGPMiaUIv/cQcAqzgRJe+qiFsvByEY6shxf1JO/xCgeMtawgeV52OTaqDBH4WZLmquJHJmmN6ZxCjpRG51zjgWkJhKRKftbDUsKaUV/TRKL5zDHI3f5yEhS6HqWtKRacAgbbLUxYmvDSa/I9LdSTgeP60Ll6BRUJ7/RkYTkmWLWMnMOXnqzl1wcCOGCScZh/kaNa/xZ5dgYMZzchxyJgZAc4RXNjiFRb1WpVz6bp/8dWRJLl498kE3A6bJ0sIOcNmyIO/diIh4qZYc8ycc8kFYTec7TmfEi5T3dVzxXvtIzg+xNUxCyQnQEj5GiEcd2CIok8cBjhiLlCc8YmqhGIbOdEtvSRDP2GZ3Uj54eMyK7NEWdqVjtj5lZSFMIGUXukfQluRSSK7XSyxemBh5NmamhPpQlnvwjUcjMKcXIUQ6L9kd5bLobNE3J0am5smo3iilOuEfXPiXQICY1h1c8qtJxOPKLSFoHTjI0UxLtw5hM+Ydiv3pTzLXtnWNhprHkBNQiHo+tnDslZfj5x5ShRLBL6Z//8JpL49iEM+HgjF8bGU5DEvZg6Tns+BKr2If/6jBc3JpH+sxRUVCNkmqgG8d3xjFNunEQTsNqolGdaCFBhlS03IMqb6X6k82sthzk4CI6QCutabGEWoSizGIZy5KNxIptVKLLkvrCFcV0JjHPEa7RxpIjzwV1Y25djGfpZSeV+LOptmPNWgppUo3FUSdUZSQXq0itgc1jKQirlVcXm6iMcBW9XjJXdeaZL3KkYx5xOwlG50ajtMYJOvP62wmfSz15uLgdLo7x6xTYooxZDCWNzK5AWjdYtyhFqZMhUaRY8lXy+jBEXaKSbgqDNPyQ9VhH8bAmL0IXcuixTU7j0VqpRrpqJmbFIYUxjGMsj5qNWR4DxmuNTWIQ55ar/y48ueRCXAyRekwEH7CyKWNBGRyckItWg3kccdQ3r3GcAy+EevCV7cuxjxXITvulU+zmSuYyO87M1ZtdtMAhD6YghB3sUIeo1XFQBMZ4HnbWkEZmWyu9XKQpuJHNoO8lZW9lZB5WXjSjCXRZUFUHwGvBSaUvTWxL3+XSg2QgVsExwHSM+tmgPugZ43FqhGHkQ+Hys5Lj4ueHZpgl5cCxS8gml3RdtLK7dtpkPsrl2vHEgTE7WG10NrZVuQXIyn4ps9cR7Wf7O9pmjIfAy5xqPIuvH9nOEsP6zBQJDk59h54yoUp0jnNvkNFK2+w13y1FMKOQZq+VN73r3SQF7nuG/f8etRjR8W92BDwe9KBHPeyMD3zoQx/YPh+jXK023Pgj4TyR226cNPH2pKMcIy4WNHsNaY5PjycgJ7bU78KQl9YQ1CpfOUH8TWqXv0PgMZ+5PWqO85zr3EMV0eoagXal9sB5JK4qN11oYnE7ei5NjdbUfkWrzKhP/U9jzrTVBxjtUKtjT+Yw6ZG23nKvgz3s9cDzzc2+88Gw6trYavvCaGotlqCIrHXfsjQ7Z1/O5FstCfwvp41NbIe4eHqD33fhDy9GU61c1AD/+uNpfo+yq7Ny/dCLw3J37WRqS8mQWnhe3Hl04iZ9U9IR/bo3A7vUq/7UL2Zc/2Yoe6xrPZfhPNL/4hkPajPqHuYyH3vvcY5wh+dDZ9ZmteUe1a0lK2WiSH9+u9DtOc5A182Vln0wBl0MhBCf9Wneh3josEXit0VatHWF53VfF3ZkV3bh4nBfQljFpCgI14EiUiIT4xDwpH9Yxn/9RxWnx3ehVTvaQx76dnL8Nnu0RxCLBEk1yFqJh3uFF3AyR3OTtw9ANxI7ExfY4oE3cg8UFXq9FjJrNTIbtCDikILQxRTkQUN05VQwiHKzJ0aJt0g36EiMp4Mut3uR13uHFYQZODZwsWo/Ay42BSnf1U1KiHF5l3GUhSZwEoWnJ4X+o3rQgW+DZ0kR+Gxc+IVgyHWkZn67R3ZAeIEs/+EwAaNG2OZnCFde9qd87TCC9UWH0jRUoXNxe8iHA7Y9OCFYA7SHCIWAKZd1NOhNYThqEah76WeGjvhdDsEQZTZ2k4coEvRzljgXE7UQ5jCHnMhW7nNEx8gToZhvsNOCLFhOgZiKoBaDoWZ4oraAALVLLEeIXYd1iQhzPsgP4gIO2uIXhGQhuWiG5KhtimJeDOMONqaJJmhfdiMjxTNA5pePZ4RJLnh6CZGKAHl1EeiNtJeNYLiNLXd4OcgOYGcP7Fc5bZMSzqYOBwEPuagRlWg5l6Ml5jUYNFFWSog3S7hfmJI802QU+KiPZqRsseOPAfmShDeQBHmNX5h4e4KI6v+gSzY5hvRgc+IIkb6jG4REe0kiDxTxMwmnK8enZHrhDqIUkqWnQW3FLqrEUSmpkizZjDC5laook/0WaojHWrfnb+jAWueQiPAQeUB4Pv8gLhJFSNnjDhKhD23IEhu5EYPRDubATDJSjFNpj0sTFFepkitZgFwpiBFIQ4nZlQM5g9hYDlqHkNfoSGepDusQD2pZi5fzQ7cILffQITr3cxypF8sUkgLCdJ34H3rUNAgymPl4mAHplTFZeAgIDuzAE96IeA84lioHUDn4dWX4k+czLtqClwwVETR1dse3EfYAj6K0mnYHfYBpgiLjmuYHm4jpldoJatCRm5F5k4Sok+j/AGqYSXbCSS7mU5zssY4aGVYbsVMgaZIXp3SWVVQn1prYuZXbuZ/cSRlk+Z2SmVfj2ZA29yHjwja60pYb6VjDuSvb1ivPuYnHgXHTOZ/Bkp/6yZ/7iZtLcY0AKpnP9g7y4INneKAa6Q+L1TsdeIGhqZ72QFFkomulc3fRWV/FlYUYilAauqH+yYqRyXU8qYs493tnh6LjNV7mU6TFOVYxmiNLSCzHY5J5lKMvuaPaCR3/+Z3Q9nXyQA8U4XssGppHeqRJ2otLukxNym6c2IROyjmCSaUAaaUyyRIRqBRZ+qO4F3AjChe+Z6IIOi5kmqRsM38UVBJkxUxI5ZcliId1/wMUcCqNcjqQdCqpODFq4OCYY1l+XJpqGyic7QmoY6qgvWOXSilRSMNbX/E3FPqkHBU6kfGoOhqpdYoSjakOTIGpYqSDXJp+6ic+6oSgbBOqSGo+fuYP+zAcFFVWglOM0UlK0acjPwGr5CSrKXebtimDotahANp1esqra3go43iioDqmo0qq/UAxNqasWEOHTwqYdSStWkitMmmrLIGTz8YSXJirmjpwM8d7vvqTpMo7wkqsn1qo6cBbKLWsFHpPztQY8Dqb8jqI2VqvXHepEwsOCkh+jhcPKCF26uchlNOg6JmgoUqwoWmq6aoVqqqodWhZ9RkOD8uY8tp1/kax9v9qqzQIntz6dYPlefRBpLyjkcIqquHKOxSUPmRVVlhxd44mnaCDkjEbsbM3rzaLkyixgDqrKecZtOJSskErrleCrupCjxs0LMVFlUaxGTFLjVLbjdiKErZqtRhrkwi5KWH6c+1XOV7rp+PoD28ZRPmSbln2TH+JGUIBI2srtV9Zq/SarYh4teNnqUzxYMIBh8iEWxyYt+QSqEV7oMaqWxRVUZLFrMgFnY2hWuSQuIpbjXV6r3DLdegAueC5FANnacQXVku5LeE6rMXqucc6aL5yWpGmdFqWPH9ZXeLgYSGhuorrtqtIr69bsyyUg5dKu9Rmu9/qSbnLgeEKDkb2p+j/OX8SBbzqqqZElUSLlrapJVwfdm3M27bV2I2uW6keCg7hxHhMUbu8Knm6wUmKcnZ22YGjGpS6xVPCa76LKp/2qFIu8WqzFLWrS5DPC73Ri3gUcrE4oXsu5q29pxuH5b/de6Ihq5woW1FWQ6NFtcB+BRM05UnvO7NAao0YDLdXu4AXzBQa3KWAEhwWxkYsyhMOep52SUHJiqj8dL4V6hjJCxO54UkfzA9wiqNsK6c3+7g4QRA1rHg2ScEskcP0gGoTgRNy4cN5W6zc63CWU8LlS0QNcpqplMRFoVK1hhLYIlsfsrZTvKNVzI3XiKuJlEuxi8P6ex6eJ2TGpCUCDMBB/wyw2oYioXvAI7QTcDzJctwODuwhq+aOGAGvJyere+yhH1p7Ahq7XAwOetqlM/eIBhdbmau5veg7/4vGvkMxMArJ9jLJFSrHh+bA9jcSSzGQAnlQwExDByizMymGMnynofx9prGAk3HK9IASBRN3U4LIrkyqCiPLhYq0tmyauGwU7GvJPGF539UetUGrixmvMllDxeyVOJnMoLzMH+osTRFw35VqhQUrh+LKQJnN4RsxJAG8wvvNlEwO7iASUDLOaScc3nWt2pnHtEnMB8i4nyzPiudCGH0kiVcgqIzPr1J81vy1Sqm7/5zGHYEfB0zQKlwWfSFkhaJ8+EC5brGfEP8dbew80dha0cvsSxndQlgMHRuMz+q3ytdShGGKzbFcpO9HvgOt0nGMYBE3ccr3Kg1tF/MgD1J7092X07D7nTytSOHX04u3eJkxbS7msWN3Z7b2xIjcvYssxOI7UbVsxPXjzUpMVmORz7ChD4PxiPMxGTQdg6moFBOMiJEp1ojtQlrHE3GrqdPWg2idz5hXhG4Ny/9bPksdusraRN88DioiESQHKE2Bfe7wgoEdkIR9zF190Ynd2ranePQLi+VHhv06zUQoW21dpJYtMXa5D+r1yCp7woCpUuVwEkvyevkmbNHMP97jkvzmvMBs01q9FNRo2Ift2tg9fuDHm7o6geD/ANlCjR6TDa6hudvJxCh52WSHmqrC22Ulg7weBg5qcau2aco4YZhPhXvQtp3USEYjVd04ed3Z3drTS7c6290W2aU9iGoeXdQfnMgIur1LEXzIWsShYb7WxUjB0xSW6nI8UWlOhYDQzd8STd0Avtq1N+Cu/cfcLYbrsKtfTDDinclIqZlvPah2SZrcHNz5tFzErWM8QcpcnKc8G3TgYGflkhI1TeID5GmqqMx/bBYq3tMGjqf7PYYbHOOEZXCTXeN3a95LMctiYsDKZVQDBViMbacXa0ZMcWcsIQ8vFanTjdPwjKtTfucvdOBimMN0tuUbgtvHx8+YQ2RfJeYCjai5/+xXDhjIgXy1gJ2PHLvcPFEPr5fVcYatCPl9GW3RLJTYVa51+62IZOYWBefgP5O54zLoRDZ/v23AfDmd4qBgQW5SsVvrjSvb9q2IKFFp9PB6WB2xoDWpM5npmq7YnH7suarnOytw16vDHmtwZYdt1ryi22slhU5BY54xm70ZMqLoSsFCKxe995p7+5hv8ZDgLhbB0WYQAf6dm854xH6TP5qr9vqKsu118FC7BIfPkud7meu/WNIPvg1E8RjcxlM/q6UUJqFdyo7OAIcQ03buFjnT6g6WfYzixX7BVSzusPvJiGjTKxljkK3WN1fNAO9Q6OU2RxOPorsvqvVXeoWv2//68WOY79cbc2edahVf0X4M6h7/80Av2ytJbZAXKNCO2wpjx0hvfCqfPk7WSOsKOArmgFqErxirpUDq3Z121qpccxGrg0HPcvYe9LdO9h4vbfke1M/e70rf9naM8m3p2+t1qt/hSJXSFQkW85RBIfdr79Y6GTXXe19Ps2ZP9hYb9BYLt4V95Rub5Wu/fm5/WOON2zxxriyi3mLxSOoyUIykKY2u56NdcJK3odHm0HVe+J98+IiPE/1Z2DL5cmov+usX7ZL/0m8PxOPbIrxV99jVSIGbLmKh95YS8z+NeygRcyghcPneg2ptpaaP+lYruRwP9P35y3LKgwqO1oF/c9z/3/3erw+Yh8irLve6bzFlpa6r9R2cuN9KAQ9n1NE845Wm786gjPp/f62Jj8zbSWqUEakA8e5dvHj05NGrl9DeQnz47t3TF1HixIcPI+bbt48fP3AdO/K7N89dunPmyJErV27cOJUrWaY8ac7jTJrgztWsqU6nR3Yz48ETCC+ePHnz7N1jl1TpUqZLdT6FGlVqVHZPe/Js2jMrU5xdwQkEGzZpWIEED9JDWI9hQ4sTI1aECzEfRo00++UTSbIkypQuXaYELNMrOHSF0Z1DjK7rTnXgxpINKk8tOH1bLVedmlnqUseXPXMe7BXy6LJD0aJVaK+hQ4hu48a9WHdmv5Dp/9IdNnmy71/AvXsL9ljSnGHDMxsfx6oULDx4kvHpy/iZqWbqVkFLX/ouNE6lOAV+JT2Q4GnUatc6dP0arsSM/WbXvr33pG7f9e2bA44f8bnCoat2Zme5g+oBJ6N9sEuquswsA7A7j9ZZ57HtaBotNMgIwrAg8lJTjS2I1LtnNdbY28e9mWo77Jz5UFqRPvteBCy0xjxqLDvxhiLQwAMRVJCqBi8TTbsJwQsvtAyPHG9D8zr0MEQRn/Qwoow4OnGe2/DjC6YV8TMHRi9/w8+/x0zrSMfKtupouh6h+pEzpdYZsqbvOgqPrHi8QhJDJRUyD0o/n6wIOtk8uqcdkrqsb/++/RYVjssvf7NpuJqYGkgyygTdRx98gKxKqR6TatPBOL2rs1TxBiMKHIPIKy8hDplcbSFZAbVoSo/6AclQFRONaVF0biMON0Qf5RI/xdKktCDKDIwIH3uA1AmzT5sadTtT68yToK7QUhW1tFxdEkpZx2Uy0PZm2seekXYFjBwu+bOtMNvSUcdTdQrjz9FHi2tqIHqey0jThpBFM8Fps6q2I+aACmphh5mD7GGJkSRKHpy4xRhcDp0lt+NZ2zoXnH72wevQLMsxh79fIVzHNpYh7Mow/L5Uud5k7aGsK2gVRDPNON+BWGKhF842Q+aOrDhpi2niFpyEvnV1Vo+nHhH/un5M5EcfdQ9tN+WVIXQnbLHDDs2wc7w0Fh2oAowHZ4/smQdqBsE5GNTO4hw6b6GLzlZppWtCqKN6oI56aqpbg46fq0Xe5x539jNJv8TSWQced5L2aOnFOiqs2PrSNkydggjs6B576km66UmdWhO0IYHWO/aJ+fbb75oSElxjjQ3v+DkpS+yoH32sZHQ/eS0nap55EvYInWKHRTlYdeTBh6YQUXf4Tu5Yr3vCdZaTPfufiOYb6dpZvZ1A3Ulf3/CG2FP8o+Gd97qwpCovSnnlXWXeo5RLCgxxRFe9juiDMiE6nTyAArPtfYYqrusKhMAXPvIZTXxF8xurToM7p6lP/2MeWd+rxsUWKS2uQMNbR+jYUbnLFSUh+mOaR7Q3mBmZrVH2i0c9CKgPizjJWYNTIDwQ1CCCcUVUHhkNBfk2u74pTYOtIh0IwZW7EBZuVuhpj4kyZQ95jC1sFdPf4JqmOnDc6R09mRGNCvOUYIUuHgArEDjg4qfT1cMzd3NMHkOlla6QRokWzBvFakeUJ37QK1UM4RV/hy6t1UN/8zhIJB15GqIQqGJHOiNm6MbGzg1HeuyoR0RwAqW2PAQ7yQESqSL2RwyxcpCE1GAIaYLIKipSUIyso6vmIcazGKRivkSSQOxlMJ20UW0DNGBNJOIRt0gpKzY74h1rIkE/UtCaF/883xOhaMiZ0FJ3V4RIRtBlOnB5y28YkkcrIeMU7t1rjep4Rz0g4pXfibNAOmoTNK9SRITh5HvhuWZAhWKWDGqTcNykojdf5bt90KRxuRQjWlKXzgyRxl7WIWa93vGvZCrzIcvCJzg2spE2YWUm0qTJP6sp0EAShGivjGX7yDVLhVpRNaKkCQ9zKVFKmoYe8VjnWNq5tse8QzKt8Yg9Z6Kae2bRI1Q6KU9o4iCtHPFBqwQKS4d2pJdmk1WJ7JgUa2rF5+BEUzuFpUGSBFSxbGVB4kEIHMuko4ZmChyzAilJtxdVvg7pexBrWFYD2sqHcfVoXt3mN8Oa0JqOsKMn+iH/L89C0YqCZZiYuahy4iqluQZsIifsCNz0R8CQ8dOq/vTKwyYIu9iVj7Dke2Uv9yTThXRzrAt9bAGv98TKjsZTloGrDqGTVGbljFA4hRsYj5Jbuk3Vbv1z2Gqt6drCDgWmMQWrrMQ61hHOpqFn7Wkww3NRm5UmrnJtanEHcz1I5i+cDZ0RUfm4z2rBboLXpK74rotd2p5uu42dVUcbCo4foiVbdWpKtILLUKWaaanjIjBrENjeo86zI5vhSv/AwTDWxs4jRyvfw2Ir29kqdiHsu+3GRllHtRKkNKbq10CEe0ucDPhtuzvPQ5z1yIXcwzjyhWDC7js0mrjWpdmLrTYR/wlRxgKYgDXBx9NajMlSKSdJZVVqaE4M0XCNyIcQpg61NCy0DQ8mWwMdqAwJWlAle9O2utugTAdGkwJLlG/rtNNmR8UxLi8UPVKaSD4MGOYMa/jDht7wnWY4E8QW0s1vLmdiFRJhH8+kwEQpn1jOaN6b1sTGUOZzHd2HuBJdzYSbvHC0eoZoVg8pdQaV9BRpmmKckdDST6Osi681HobOFacFPKCOG+IxUoLs0zrL41bg1GpmTyitBkVk+m57xZqQE5gYMpVZEuK74X73UjjloQ9jRa6qTcRANTH1Jmu0xxU2291eeTY9umLIKP73oNmdM00SmE4OtzVAYBnd+8xd1/9lijLc4h42uVtD12PfSmTqxiM/lx1BRC/M3YSMU73/S2tC0TnKqON3UK28WXMT91I5Fba4RgiwLAcveOmGqnPFHEEGvtvmCUvxZEJbvUp3JLIttmyAhDqWHFYP0AI+98mth/Bxr4WzLzd11DfScqoWeiYsu3nWcZ5z7fpc3xFNp7+LKuOe2xOnDWfmPEEkIlLPZnGKuxo/Qpoc0/pz4lrHe2hynpq7duV01xY72wpSVmUa8LPGBXYBm9nMIWlE7hkRNLKJaPdROSzv25H3dvauc7cx04B/jyRbhUn0gHclUx09fLW/7RZ7plukJjL9W7xylTfRvPIWZ16qGK37apH/p4O/37x5Cv95IGJa9AAvfeLpucxqB8otbjf11JUa7iHR/kHNZo7CEobp3VesJrzvCLRx9+gOcmj5xFcrRW+UJB36mLlmNatEnP90dNEV5XBZ6lQvPxPLO5v7/TOo8is/Wfu93Lmr2uqKz4qyKVurAekQcFO+7WimtkimY2O4X4uw1RiMfaKv/UOVjrgks/i+CYG19XkzKTrAzsupwwOiDJGMwVEIbsutEKk0DFS8xfusujo/j6stnIEhd7u70HiYrhgKnxgKdPI+ECTBEuQmWWOfrou/bjIwdEoNtohAOYqwBJy/b3OouUsY0VoeIMSb/quJIlQzyqqdIcm8NnNC/wJUHwQcvqUSI3SiB1j5MxsUEUL5qNVAqsNLOi+ckBARHOXRsCAEBwkakiEsQzPsCLNwwb/ZlvBTHTbkHycMLShkJr+bw3RyjjzEwtLxuCxMOCZROnSJPx7yior4RI8gxAZ6rkM0xJf5J5yQHf4LHwzJHM2hCScKQKcZQP65HTgcEslKp/PKQDnqOUt7MtUQxkxMwHxDvK5okrcBh1ZcHaZ4GbszRFskMpqAhw1rrTXTvaUZJFgTnF8cv3N0mmYcDBbrpRj8KCwcmCfzOXZUvCFxllFhEhXUn1esKmzEuqtDosHQG3A8NL15xDQEh3LsRQ9qwvGzR5wAF1hSiyfZjv/qichq4RivyMjVkaqSgsVtBI+v6KOw6MYyC6QRU0lz9EUT/CDhG4xIWxWEsENP5EgOihN6tC111LeZiDPcOR27EcqsCMiUksWRRCKTJLMPS0mVTDJ5KyR0rMQpgsl5k7K06hMoGSUCEyvBkRVwUcGtZBrf88XuI6R6A5WqexNZ3MbvUSkhoROyOElw3CraWckAjDbFCg2J4sQNqkkN1LfaYp/ZahVojMlro8hd7Eu0/Ay2rLmJe5k5iUusGiy7HDFzlCVZWsFkZMDy+BMCIpcQ+iopA8ZDUkw0BD8QTJ0wZLelcMxlYyCsm8WkpEz8sszL1CapdMjdmYnUAzkX05D/GKS2JksoRyvNajE+pFnIMgLBwJG5y3jN6AzIsHjLwNKq6rKuu3wi3ZQpz/PNnwLO8lisPvtFStS4eQMhSVSVPCkjuORKKZIO6YzOb1SlIbvOgcpO3DRON0NAc/s11HEpf6lCCBvAPTmNbvnJ4zykKBojeaMswHLPh4Co+JTPo4SZyKQmpbzPCnLKV+sW7myf0qknuxIcihIKKGKyAo0zJuQgD+qm8sMYj8g8VXlQYZqTDvEvhLA6o6zQbCQSuOw369xQ5ujQX1pDhHik/fmm3sSUgAEhihoQE8slwclN7GIqKoXKn9xOqOwWixE9oROS49zRaerR2IxODR1SIi3S/7NAUEdK0t3RuUu5QBD6qShVLEPa0gONs7t6Ml5KElYhpIPwSVVpRIZ5E7icUZD0ih7tiB61zw1dUzbtFjd9JLCEQkwZKRLtoLMAq0qUxANF0Ji6mLATChIL1EQl1ORkqwj5HjF5Recq01jtsCGN1ERF0jflOyY1ELjTVCm7N/MoTfQJVVGdJbXqKkqCpe8zvkJdoFkEGskcUx5ly5CM1b9KUzUtUkKVxCTdpVxVvF01NRJlsSWjSmGFNeccyynTIF3ECYvhvQB9hwydE1XbCamir7V0VLKQxVnd0Bbq0E+lB27t1jgtIHAN147KufD7UBntRcD5VYBFVSMMwZ8YPf/leAfN6BTXwVf5HI3I5Nf7/KKVbM7TEFgClFONiLqRSaY+oyV1ZEKeTFfSeT8jUbTMgdcI6RSBqA4xU7bXBIt/8thrXZiQvcyRRYuS1bjf2YiUJVFX+dXx4yDyIDGFjUQy4rb3DA2KGsH2DLp/I4xjwrDrIEqf/VmWiVchHVKiTTKjDVhuxclvdbyljbtk2p+n1Zh11SCv0FM6k4iGeFsjZM+lUTSKNck7eaewVUuAJFvI+CeBUpihUVuYYlukrTdBWVq5xRW6fUdE0iYNIcu8ZcClEpF6m6GiYc6FzDWXyhDOAdsHEtuxvVCzpU63RNtapEuJidxyNNLRBEvPm5L/kRopXGmo5JKtKnqiYgzALJ1CETzBItOeimrEMrIu6cVF6W0e6VE1BLkfMzXbfa3dcDSsoY1UEkONDuq8hftd4I274W2vEnNa0D1Xn1xeMsEJ7cEW612002VX1hWg7NVexV3c8LndRgQk5vDXIt3OAvTd9A1e4b0rCkvQ9z3X3JTf01hdwP3RClnEmvWKNsKojP3fFTrT7y1I6j0y8VVJ1WRTsqy2egJeuZW7B97d9clTllRYVqleAta1roUMPMlfmvDg7PVf6UiT2PVe1uLGugxfA8YcFU7CXwJYBRZRTG3g9ZVhrIQzC55gFtZWAgFPsCDJawG4+iVg5yWIINan/yGeG9cMYDJESCR5mAPORcn9VCmWIxdWXysm3s2FwadZT8+NX3nTFhn9YzDO4F37YQxmzuz72tCxitakFgA+4g7TvtvNntg54H9l2Ii9wV3NY1wJLQrjY2DU0wk24RlaXu0A4zkRvR0Oi0QmwhkyJrCtO07Z2Em2PEbeKtz1ovEdElJj4BeWoz3+qgreYm3Ftu/glmTO4CIj4EwKCxkiwpkQiFm2DmgyrcTtCZ+lk6Xc5Tj2ItRN4dRMRRKJW/XlCNMRZWGFWJbMPFcuo1QmGJKE5R9FSrIYSHvuj/69LEiGXbZ0T4l53Inh5bGxnUFC3V825xceqdLZ42er4GFFCIouTmaAA09do5SyIMK2Sko6CWMhAYv+IAz5UmNbBhVuFhKBtmSiKWiygUSEJueuAOZzXlpCeei0MmYDBVVBdmV/qWgbcc8YAqpook3SEOnDZR0iLiJqjUySXOmBLqyWdgcndmLMiWmcmGmGTip1zqachkrc4eKLjuZntizJFJJB9olMor3n6lqmCAgAIfkEBQoA4AAsAAAAANwAqwAACP8A0aVLt64guIMIEya0d69hvnwKEzac6JCfxYcTH2K893Cfx30YD7pz167kQHLjIqpcybKly5cwFYaLSbNmTXQCC66LyZAjOIgrNQrNZ7GfxaNIiSJdCs6eU4rz0pEjp3DcOHE2s2rNOvNg161gaeY0CLMnzKH7LILzx9bf0rdwQS7NZ6+dVJTgrFoFJ65v36xYsYYdjPAr4cMRBRJcBy/mvZZAIyo92Naf0aRo4fJrazTfvHbnUOodzTfv35qCEYMNx1q1a3A4F7sb/Jhixsjg+FF2qxZh5IYKl1bm5xn0VNHHp+r1m7pl89cvv840DH0wuoPrZm+1zf12vrS9D27/vOe0fE+NP5Vubkv8s93Q5Aaem6/c6t/n1WtOT9haJfX8NWU3UkzzgDPPPOUdqOCCCPbE0VD5TGSPgiW181mDtkVWmVsRfpaOhQu+V19KAML0Hzj9lfhaOuAIqF1EFTJoIIPu0ahgeRQ5RWGFPJZEI0MPIbQhcQ/NVVc6oZGookvSndiSk0tGNBA4Iw2oUo9YZqlljDRuWVKVPSLYUFq7bWimW0cmGVaKKNpkWIpQsgZllAkNNJCL7ahU5Z4jZcnnn3y2A+if6Qzq4zzAHbXWmRvSZZdUpg3GJoBy7kcnS3a6+GJCexZa6KDu2ClqQXcuppNOoo6qEzyrgnngg0iV/3kmcfd4SNWak7pWaVeVXuoSn3p2muqwdgqkGLGjinqsqac2SxKICYUn63D7NCSikgcxd1pEcq40J5P++RrTn8FaCc6wy8o337o4tWtsOrG5++6dzbZK0krSLrqhb7XahRdC2m7LX3Ra7cdrruKWu1KVKimLzrrrmlOOORRDDPG7xsY2kEBlARdtvirpdtE9/iYUMLe8PllwwgBuutLDFp9Tzsw0U2yzxe3CeyzHCslzo4Md6XaQbv7AxFuEoGXLF3MDx9Qty1DDxDBL80lM89VX33zxsQj5/LN5t5F5UD8J/dMSW8TZwyKJV/n1JMIofpswtr4Oeuqw4Eg8GtZYm/9zMYsiNWjehHnOeF5Ebf2juOJFJ8QeUHgtx9LT3Ebd0mgpsZ3fi31WCOpI68ALTjmYzzwO1uT4fQ7PXiO4oDxaVbY4W46jDY6/5eR1lUJY9Wp5VpjT/dqeVHau5bOeh4qOOXnxnfU5CI0kz/Svy/OiOu8WBI87Pp+HG1uzD10mOCSHBo5o2aYGd5uW4xeRXgfBn1VjC/8ZJoOHHvhlqOkwf9Dz0Cuej+QhKOIlBHvyYgc7GBMPeTzlQY5jXG4U4hYDhQp6pNuL+iYnNwC57XfF29P9bERCQSFLQPmznssQgkCcXEwdMFwgPORBj3rYAx/4uIc+0tIPf0gQHPuYIEL/+gU4cuROJUzzylfcpyJtRQlwK/ESiEgouATNQ4UkaZ2C6nFFd9BPIS1sV8VWhw4YqoMd72hgDW2Yw+8IbS0HCaJkHiMiIwbvg1UhR5J8VyInLmlKevISCSc0OBzpiIoHsh5ZNlbGdp3DZjNTHRnPiEY11vCGOxRb0Ygjx8YJkYgQq89KxkEOC9XlVr5iYnVSFT3jaclGhQQbeSZExZGwaiewwV4LH9k3czysXTF8RxppWA8cZpJsCAGJkBqnmwj160tS2QvvypEORD1kHufo3ZJOIzAAuQuQIbzdlhAZSyvSaHpeJMtBzChGvtnsZmWkpDDlwUZ97PCN4lmmJ/kB/xKM2EppCBnHOdrhvXmgMkqqzM8376SQLSUEkTbC0vRUyCoFrhOGjVxeL/uGkxhWsobG3CEy41g7ylzmIkc66EHiY80H0QWVu1KN27q5pJxlKoqFu9IVEUnAz3nxHaFjkRnDuDyrOS+S8TRjGkGKD3vuY6SIS0gPOUREI/5voIhy6UPswbxdrQ8wCV3SAhOizqyUxGfJ82k6SXUQebn1kZB0Z0fN+NF67hAhUFXJ40A5lQ95Tyj3yKZXvwoTwYQ1YbgkCzwas0JgRUStttTJuXTm1ng6kpfOm6tH0xgPetADk500SnB6gzYiuYckYnLIUO7hDnIMdjBJBOFKGAOOxf9qj3ODopJCfIoQUjHSrWfEqAuNejVg0lWBaIRHZ+1x10W9MWhv5A2RNEIRCNVKKuLwKlgCI1uWfLG2tmXMYrf3uVO5A5cqqRc7iiUvjCoEZjLLmnHpitEzvuOzd2VLPyCSEfAIjT0X2QiEkCax7MYUrIftLkLC6yxA1evBEC4IO4iaMzOqBCcUq1l7h1pUnLAjHsydagWb8iCxLTM3/BwwetqBEgMfmCZ4VLB3vxjhPUX4wchVoISFW1l1vARmFOsxRo3qS3XAwx5B9CGHSMwR8PRjpNLt54CbwmIX89ElsZUxWXtrEGFi58ZgzvGEh8rjysZTJWP2cVvhS8b5Yo//yOhghzz2UbTHMdmNY9vNSaUslNu54xzjeC2W/ahllpBFsi0Cs07ELGZ1pEOXjpaXnWC4EkpaGCF+6/CGefxRfNC5TP2Q49kscxmPDIVKexR0RAhdaJc0K9FfvnGOY8hhCkv60ZX26KXbyi7gevTD9MjhPRvXqIM4RK+ktogyIRIk7A72P6xuNUxOhR0uS5jRjeawmb95roiQGblDTch8eozcpTJEH4hTMluCeCCGrCTZEdGRYLVrsiwjpoPQeXWimzVrSirw17aubLEO+O1/kxkh495wXfV6kMX9Q78Qafe7VaI2OwWa3tHWFcuobe11MPrXaQ7utm+NE4WE3ODa/0YIuT/KkqI5nHFLpmBlVIJNc0zFyt2yN3TwraKd8BvbIdelu9jZLtjE6zomDzqZiX6QhBe9Ji9/eGnJJOK2RASbGcR5a2gq7Xx7HOhLD3vAS55rsbNzPk13V1Z8ODtGiTgitIoK6QI2064v6drYpjQ4KK30sJPdJWbHHtrB0eaI0NOG9viJSh4+u7abCe7FiWbbMMddu+fHIF/Pe9+zHfaYiN2Raf/7QWa4xsOlW+pR35fZkslaJBkxg8ErjQdjHDXMnwroE0Z5wft+8L23hMzugp7TFfIO0iO+yfjUF/iiznzK8INkSIKPaJYTmATbROfiwr1FE6L9vYNc9533Pf/gie7Cpq9LIYyZXj1s6BAT63P5zF9ctKAvfepbHzXc9NX2k457/uc4IuyAEOBHaWq2TmIhLwFkfiY3TOv3FHiWbvAXf/IXR/RXH27Dc4OGfSWiewEIDtqHXCsBggDobQXofWGhdgqRgB5YScTEfh3RcmwngYqjEJ7hellnYIRBdyzDXmX0fwcBdCyBbWERfi3xMC6BRsNETxgSJOCQV/oigzM4g7mhNvBhHzjIOxpId/enUO3lgyu4giIYhAHYgVkReEv3dDGBhMrlNQ80NPzwZKcHhatnNvlwLW2TGlqYhycDQmHnhSxjhuSHhjAhTMbXIMnkX3BIQcy3fOAwgaz/FRqwV3166Bf2p2V++Idm530E6GNhlHBpWHxqVCDG5lJOtnip50lmM4M1aHMzEz/BI01YaHmyBYgE6HsIuDo0gYQNhBAPVGJORja0gxAvF4zC+HDkIyKjA3uxZzKyqGBqFnjykmmXJXotgUYKgSGq5UZFMVURMYEtMQ8XdD52VIlbKC6EFTWbeHAtZHQRM43USCDYSIq/2EOLtxKrN4XvAT0jIhMHo2UY6CvpWGbTqDq+5EKFZxPx0G5AoxEesY0UFBNpU0ewOB0xdY5LIh1dB3zBJ0kxw5FtpoIvEQ8JOQ9sVF0dgYhwlJIv8XyhMo5X8Wz09jtPY5GXcoYGGTM4/4kz5bcSRRZMxdc9N5RD3tGQReFJMeEP+eB6VgiTMSmTFPmPKhKIOTmVOmmEPDlXCvST9HAQvSiPR+GEepZ8ZsMPxrGUTNmUTsmHBOcuHnkxqwNX79RrVnlhwKRj7zA9vCiUYaMUYLkoT5Z84gEaWXeWaPkackM5aslCREWVvvRON0N4l0WXBRlPCmR8XMkdDKkbYAlgTrhfuPOShAmVXFGYiPk7BSiQbIaTGDZGkgR6ETFuQYaVi0VMTdGVJQYyZaIowhiYNgiaZ6kiMIkyolkdJWhmVHl+x0l4KQgxsQlD6/CTJDk4QnmSgLlMRjFSUngPUlEO46h1V7Yy7CMT/P9Ymq12msZ5nGhHlcqJcB2JlcnlM4hXHtPpEaNGag03g0jZP3fYF8G5Gv0xnF5RnkSnOsGHnui5nuzJnJr1nt1TRe33EvpVjDO4D1EBiZHonf/Yny/WjCrxjDdZoAZKeDjZdOIGM7+kWfLUQK1zfDokajCITPCXG0RkJ+eij1RBIuT5NoL2nU0DE6SEjmvWmsujmpcVoonha8fFQNSjkMKGblnhcEjpIY90HCuVHPvoNKoGoCZTDgP1GAnDTp3YZmPUZrcoiD+GokvHgtQTnw3hpC5BjDE4luXTnTGmF1Zqgc3Rn5OjFTkFNfWFgBgmL2DxjKd5UWKXXCp6eE4hbC7/KnPEuBYOlxuOkiRtw5QJoRfceRzKCD9cVxg8p1LoqG0jN6hLV40ol5WJWnqM2qjvZxm7AaUd8mcyU6mhyRKveEeT2KkGoiJk+BLYY3RrVlmDUaohiG2gOD2qOiasOjZP1kMwGoNDw1dWiKHPpkQBumq52hf2kZHklxBmqhX+VnCmSlfC9JMtGJQtuqzN2qzLJIUR2Zt3GDd6ihgZBzW9qpjClRg2wYm7139iWG6EqEYNeENeGjJv0a6rt1/9EiqseESeWpgqwl8Fy6v3Kn4+9o42kXuH2n8Vy30AK5ICi3j4wBKagbCU0SGPgiQrBXsgNLH5IXZgJKpI9xJg528f/8hoXtYS5QqyNFR64DCy+FKyizKB1eIh0Sei8DF35agiHqMavIea3wqANzu1OVau5XoQ74C1Wau1POtZa9QSH8FPYRsejBhqz+R6VHEc9GFHtDcY/pMVE/IaQbdtBzmCVKt974CzVru3IIsQ8QAOIGtJ6+cSH1G4Yyskq/d84Ch9U1GlU7EuU6G0YCE8WwE7iOF3ZXqiaHa3X5e3xrq3oBu4IskSneW1gwu2hWtP+hA0J9YeJjR98DMzVlp/baMf1NRtCuEULkEeByGKIrFCNcGvUDt8Uqt9zwm6yJu8oSu6oqsSW0kTHqG60kufTUg7zwcadpIkfkRKaru2oqGrJv9DDsALDhPlEr7rGsI1vHUrgECnE8r7vu/LvPIbE/YERAqxD9I7vXI0VXRYoRHzvYSGqXoEuS3mLefDrXMVqMH3jsZbEPD7wDsrvxI8uuDwvCqhQ82VEPmrv9XrQzJqEq/Xnc+2Ldx5DnaCF02CFS+CXmimJ78LHROWwNu2ucj1YBD8wOM1wSI5UTy8EjiEwZmkwRusuvTJv//gmdkrGtxJq5baPAM8H0orDtTkc4hhuSyhdzBRXzLbSDSsY/WSvPBww8IUDzksujx8xj3rWbmLQ03lVC46xETcSWw3hdF3ElZBM3wRmnKCFVyavQPxXYWWvjDbxREGxmH8vovFWcr/xbxoPFFe61mnm5dNmsHgkL9AHMRPiI9/ZkRVk0Hng6N63BriqyDykLMdqxJb2xL4kHiDqolavGvelmNfrLzjBb+LpcM8/MiPvH68HG+TrMHdAcTf0cFjGRUnfDr0cURLbH2sgRXooKQiqVye64yZmGuyfLzHS4iHXK7j1c21XMbyi8a6bLq83MsLEZRuSj4Nwca2QcTE/A9kOaXrkkFp64oFzCTUoQ6gGA/CVLX9TIZjmBC7SJzEesU268B7680KvdALzcjiPM7lXM4WrMpsXNFC6c7ETJbTx6Whoa3iGD/L/CRYAZL2ZbUBuLeyaLNerM3Fx9Bl7NKLHM5nrMsR/13T9TDRFFfRi8rOGIxX4GMg5eBiUqwcHm1VCEE63pJQm1WuSJiz0ta+3BzGLi26DB3NMp3L5GzT9hDRLVFOQXnRGWx1gXVxcsK95JBd4sC9edw8/NHMB6E6lebPJn3K3SVmVgvT3azDEtzIaZzVvFxOkRwR8Vke8fnD9Ts2P12HZ70raX2jbt24aP0/6UM3IJmAv8bUYXgQf1vXNXzXeA3Oer3DM42sNF3O8rnK5lEPK2HTA0uwOuTTVleDvrnHR4TWWHEre6wQb5vFJZ23nru1FAxCjJbNUQ3Tob3DiTrTEG3aO23RW63ags3a8vnazFoZ1fIeZL0rKdFirLHdef/c3eez2zWRlVcrtyyUi7jnvp5t3ImKy438yAci3c2t04F9EKzd2jgUR082czWolCN8wAaW1vGjrRMzqNa4JCV4hMPdLNycteOVEODM1xKO1Ut602v01/NN39Et3/mt31VXhwxLMSgBk2q9x0qSHA4rW3RNs/u3b8StzRDeGIsFXoE74RJOD8ga38w93xPBxs+tEPctn8m035yhnRbKnUENk7dNFWUNmXlDXCmuIqxMGB94KqA74wu20ICroqJt447sWTSk46391RSBQ+ahEjV92nH0VPxrGfaADldzFaZDreIA2QKOECwC5TWjFam8EpbrsmBxzYXsZZ+d113e5V7/7rVhTpIY3txlbua6u+GNDrRA9FSJ4+ZwTjOTN3dNrBIFyTxHhccU89beFhPF5LSC/mDgQIijV+gxPVGIbuPjfOGDzdP6sM6oPeUJkeaR7uFDMg+ZPhqUyOn/PeoJMZmgHupZE3o14W6HIWYOjGha29Lg1c0xbu3kC+tejtWlPebsbE89jtpoHtHlkRBsvi/A7pL2EQ5pnTsYOtJVo9sYFhHKPjFRS3GAHuiyLEwsvBPaLOMPrhD0U8Y8nNyJvtz4/cNAjOu9vuvkrutAROQR+memQ3nNnDk41+5vHe+YBlcu4U49KX4RsZX5ToIsbtdAtRJYju0C7dDb/tCzjuG2/666Pd7wDm/OGuwREt8PalNg2rKUd35x7e6Ya6bbHs8SHHXvB0HpQJTOpa7grlHj8hDrL//lMT+wM3/rDL8VTiXx+9Dzs83u9icYpOOwY2SA8i5G4v0/V2N0wJQQS8X0lVzybSUurz71jXwQVT/rkIz1Co/B9+Dj5W4TLUrkZCN3Yc/uaX2HP7oV2rb2R507J3odwSQPQIu/S+8SM7sktxzcMIHG2U7a41zBjU7m4T6yZ24TItWsX0/xiX/xSgL5P9hbZYdRHJ8QRySNHaVAIFbJ5LPKMLH5ABLwWvHefe21Ny+deunjTQEWqy9aUeHz//0aHHb0R41wdbnqug7xBv89/MSvGsevy/a946bf4bXJ/S9R+HBoD+vAS9555/o6rMJl7MfurfocD6q9rMHKY5z//QABTuBAggULygMnTyFBeg0dFqwXsZ49ivgsXsRHUSBFjgY9DtSnb18/kuDaoTNXrpy4cC1diitn7uM6j/Q+3lSXs6BMlTIFolMnz2JBe/UKokOaFOlNpk0JwoPqVCpTeQ4fGozIseLFjfbAafU6FZxIkiXdoSw3jmVLceLGxRQb16O6geZ4wgUHFB4+fVKT5kwqV+o7wlEFS12Y0OpVrBM5YuwYVqPYe2RJ7gN3NqXatm5jnhvo7vBogT3zspNXDx9p1kwNtxa7uCFTrUP/vxqcPLXyvpH99tlLd45cWs8xgdKEzRppvNXJB9KF/dq5QYUIBTKW2nHjbY9hb1oMyfuyPXQqx70tdw4du3XurDc1ejMezpzQj643KhLk9NHwCvOnrrrqrrMJNu+2Y8qiysLr7bdz0nrLHHTWgScxAD1ixz6C1GEuJIEwI6ivC6WCZ8QABXyvQBO1AwejBXnjLSR9yEtJwvbce8/EptRhhx6+ChLRoyB/ckpDsaTTEUULVbwQrI0UlBHGvuZRyB142pNnHi3nYZK1+eLiMZ567mnNSHDqYw1JHde8CSyv7LkoSvEwg4cdHBWaJyuj6MmRzYHoUS25+tBEUyB2BFPT/09Fv3ITTigZHGkffeipUMssJYoooT4XlWofMj/qR6BBoRsUHHYOnYqwdxLldM2tMMLnngVFEs+3vujhsiFMM21VsCHpM3OgU09NddVeW3X0ontinRXGBvuKSDaJjgWxIMx+HWsg7+ax59MzdVJHKWGHLZbVY5uEddlmnb0M2mit4vVcg6oVyzu6dDLoUFTjgqpEeV11UZ9Zaa3VVoHehfdfgiQdzd5g0+zXX7nMVfirgGWElJ+yGC6qHtnkpde5Upvad+KJ4/my4u4ultNZjRn+ymOr1sQ2ZIXJZZNiggbkVFmMCXZWyq5knm1EbFUGsF9E/Y3HOoSU3BTdR1sOWv9SESlCuEvYjvaTH36QjkvJgVDUmr9kBwY6Rg8Hssjj6lAGOy6b4x5tU4WwGy0+olhOOyRZBbqoKHpQJjzluAxvdW66+Su6IEAxZSrevX3G2FmBm2MU68ELf2fxmxQP1fPkGLOp7MNeRVtKgbvq+F3COxd9IMUJCl1R2BW9e2apZZVz7Y129TLQxKeq/dwSlb7Q9OQoZ9Dv33fVW7ADxeJ6KpuLH8jr5JCbOGKJYydoK957v7p13cGvHhySvrZ29ri4v72g+AXy/vuC/NV50bMHtlpbiT6Wl7c8Qq/alaR9BMnH9taxwHXMTyAOrN9NvKcwjThqfFFy3sGIdr5FCZD/NIrbRz48iCFica8gDFzgkY7nlAnWLWpyYVHl1MY2cGQNbqxJH2vmBiLFrc4pJZuJQFJ4oYixhmes0ci6VAcRqxDuQjnkDxQ/AkSPIGeIg1FVET1yPPvJ5WkJIU1FwLGboPnudw4pnImk2JRqBWlIa2yNCZsyP1Zp8TBiO11GYkUw38QIKw2RR+Fu6JS+wPEjhhTMCLcnFjp2kX7II42AwKG8j4iPQRqz1QhlJshBwkaRIfqctcwIJBF5i0zTU5gdB6LKO77nhW3iCh/bRZQabo6TyQkL5grySXC4T5GmHGP4/GRFFubPi6+MSy5347Wy+OaPfOIkYZrknVEC6FMj/yQWgFDoGi06koItqkw+9oHJjSWQIQ3hZDwcKBVd3uZNSEQlaepDxTgy0DWPpN/imrPMsvhjY0Fymy05dxjbHOyQ+xGSXFbDFaYU6jByHMg2i5nPY82jkquRlTj76Q+O9oMfnvpTIKOJOHZ6JHoJNUg7s5ObhqJjRBJtijGTg0zcYFQkmORoTv0Js0neEhwkzU4NHUdJ53BEch9x6YVgGlOZcsqC4cGpTv350U8VSJ3geAdQ5XJU6SFILFxd1FLBBw6LpnSMl+yHVDv6URF1aZ1jXZw94SqQsobvUbzRmFqnarO3VhI2JzWRhdh0xbl+h1m0YmZaperRgdSDpkSJJ/9sVMoUogqkaYDVEQobKM3CEmSPl4xqTtcX0mTGZkSVpd98MKtNIXYWlp+FUWJF68/iBfJcXlmt4wxS2c6lBnCYdShp5LhZ11qSYIkliWhr57GrMg5p/rpItAoS3NFA1LVPmhpekSva8AXSm4dhUpeil1sAGSW3D6NnFa17XfGty2vkVK4zJykP/8CmcR+ZyLlQe10APUZW7t2uTj06JYV8dypVictknYLMTvKXghbk3zgD7A+B+DNIj22KYEekYQfHrr0Rfm9yOTqQnQoVwx1GMbIgfEFxSnij4BCw+5zDVa1F9nApfrCC/iujFk84xhsuXWP/REi5NBjHvfpwRlv/rF0Rq1W+yVMRYK1DVPIeGWmPYZaSY+vjEU+VO4zT2n5bhA+wRsdE6wUflv97jyVzebH80EdGdCTm8FXZslP5khOtLBAOT6U2/81HoJncZLWqz1YZsXNrMEznn0pFq3sOY7IOK2gJw1evAvGopBC9JtsCiDAp0+qjrdxn2nREx+HcsqULrb5exrkoG3blhbJKEFF7jpVhOzHrlLnjVKtaqphuNZkTXbc/MXqOfe0sJI85FaNoRSBrzhhym9nkXXYseY0u9k2QDekLkRoiWckNoCkd4mmXe2G/Wxxnuf0vLZmXReLuMbnNjT3/Obc1t+ucusfaVEXVI09ZYdQY4R1vXWk3k9XdqSubtm0qrH6k1irjt5/87WyNZJnNlK60R9+LaQPiJuHrbhUX6QbuCnrF4oFu83s3PpDihapaHwf5oopo4FY5JjImXzPKe71yYAuEfebs1baz2XBsTycgAAAh+QQFCgDgACwAAAAA3ACrAAAI/wDBCRzoDlxBcO3azVsIbp69ewMH5ssXsaJFgf748Zs4cN/AeyApXgSXLt05gSfHjVzJ0qK4lwLFtZzpUiY4mDRzqgS3Myc4cgLJAW157mRFd0gHKmzY8GFEihx9DvR3kZ9FqgJFCrQ3r91AlT2ltpT5sqzYs2hHjgs7U6jboENHnjyZ7ijSgwoXLnSadWJUtFinYvVHuLBUtmlr2kzMmPFamm6F/oxrsahldBaTImQqcB44kOD8am0MjjA4jagLm068mDXp1z7Bio0ceaXRk5jBrYt4sKHngfYe3hM5WuLfkYMFol6u0aPVftBX61z7GLb16xERC6x+kXZtuQPRYf9et9tgwrwXQUJ8Glq06JWmqaLe51406tNWS6/0CvftTJwDtXYTdgRSFxZ3FnlHWUvioZNOeQLxN9BvH332mXoXqqdhSBbx0w9zE224oXv5rXSPZ+ekc147Jo21mFkxAUggbAbuZGN3k9GWk3h1QbiZRQ4JF5w9H4lo5HqfTbTPPhvloyFXejEEjlMYRhQYRp0N59d/Ad70IowzXgfWY9StJFmOAy1YkYMC+ShlRFE6FOSQUM45pJx2Glnnmxc5xNI//4i1E0xfBihjmP8datGYPSEYkXdpxqXmSnz6FmdecWaq6aZ6rejVeT4Z5lpEMiqKqIstMWqjdpEuKGlOlV7/2pWntNZqa0J39ZZrWlRdeRVLrb146lllCZhdjYwmdiZvPyK01IRR0npXO9Pimuu11xqErWav+VpRccPOCKZayJbp6KPL9qeUUitSuFBCDK2IVF285VrSveTlCw958Liz7zp1PRiufiW6dFY44Qxc0bgrlclTjSMBJXFQOQolIagRwRvhp87Oe+/HIGPmoIP36kaeyfTOpNmzMwVakbcLK8yYWcYu6jCyZkKaYzvy1JrxxrV6HPK9RaFUVINsSpUrvMHRBCigabE6EMIyk1rslzIdyB3EOUs81FA89+ypRe2+Oyu294pXlDkDmWOOZUfnZhG9BSU00nEXBQo1WlIj/5xwl1UTGqOXF507W7q0Opu4pZd6KnRJ6LDdtttuF03SQCXphhSFWwWnXlQe5SSdTwL+PZLp4QZrlsM8XXcmqJ7N+qndFXEqO7V3pWNOOQLxHpHkmJe0Drfq3Rll0xf1I9Dego2eE+pVo9oa66ySKfWjFsnDuKadjRQnu3lRm86kP+EmfG90BreQPNi21I8/zJem2sHR00TzVwhSf31LlGG6aUtDgtNe7kQtuYGDcikSGLTiJI8G+os87IhgqAYSqF7B7CsWMZ2p6uelmrWucNaTTU7IkTKE2K57K6FT5zxHQB8ZJCLGW18DwQGPGu6LHeJRR2L+QRXlWVAqxkqYOP/GUY79YYdhG7TZjRqTKUv5piWgEciG1JdC9S1EMzXMFzvUYUCxWAVQ8pHfRXozEN817BwJSUc5qDYshg2IJqwLE+fQYqStTCmGXUHKv7S4xQY1hocZ4Ud8WJKysPxNHORoh5baMQ6/nepqgotNYvI1k0qlZUP4uCOd9MK+B+6mJFxskFEa00OrOG8k4xsHTKhGwnloySCNZCOiAJREQc0kXycjG4GKR6TOZOouuYRcgyTnO/HwKiNYshLZUvnGcSRSSxxJhzhkSSBIkuo1WrOIDfcllih1U061i5YecQmwdIiHmLyjHPAuQg/k6Oc0WHFZRe7BonOYkYSK3FKEpgn/vddcTWFcE8i14FFJ7tGkiQLsFFLImS9zqm2dESmH28RCGKsU7J0/M0orQzIaRlLTn4TyYIEehiBuEeh7zgKf40zGUAhuMZTngGg5JJoT6MjvQwJR3lRY4g5Xcihj5HAkSMHUT/vB8YOwIaOlJMQus51He9K6FkPb5NIIquOqkavITLu4kn34EJlW6pVF7uE5jgLpHPwkzT+FyiWdVIQtAU2M/94VoZ/xVKALnSo4JOjSdVg1csCbqU/0kR8eFkyQyblgaObZjnPEsqikM0vCIDsSkRYuO+S6DicdaFKa5BWXullJBF96TnDMFKIDkeBA6oEPwi7PH8SB5ykr6djH/xLLmh8VE0lnYsSBdLKzEZHHPBrIPvadRa8XGa1ARovVk6B2uVuMyDvogY/QgYOHfmHS++g4Pn5StrJDXItM2NoYY5nLcIkh7l1Gsi2pkDO0IxntaHfzUi6yxKps4x062BEPfOgUjE3S7vxywhV3rDG3KwmvKseL4FEdy3oEytZKgBuR3bT0whahZGrZsder2je+OJzoAXVjj8ICeCIaeZ9YacKi8ZE3weFdpd++S6PehkupA7GwhpGbyxz3OLTKteqHk7vciuijIgBWDjhUrNi5kePANL5JmWbMwSpf5GQXzvJI3utj+TJXh6QBo0dQzGSMUkqNL17YlNNsZcbYkP8luXShj7OM3IrU2a97le9VX6O3jJD1Hl41jctgJrugNljBAmFzed9IOEafZX/bJCizClJDltp5zlq+tJ1/XFU975nPpelHPh4S6PiZuZ4/STOi2ygsy1pnmxeJ9Dvgu2Wx+AhCt1atfMHh4evw8EOIhZ88MXoPd5zjyaqk5qpZXShXhyvSkoazhvNME04DWbXQ1aGHwSyWYS8PjIXhobeVQ8/dLZhq4SWHKgdmExtHL9LWkbNusC1BbGdb273+49O+/TRTj5pFRcQJEWeqksmGCSboJV0HCVTpgXnZ3hERMq/z3W0kR6Tf/R7IRlqs7p2UQzJliXJaXvKYWorF5G3/9smuLaIOiW97hy4b977jl496HvsnOL9JONJ6RPEeKspkcWPKpcKOH1tEuRG5qpC3ze2KnyVQG5ljEWM03qH6nMF/y7r0/jl0RHF4uUwPe1rG7TTl5GMeJkH2oGjsbC8ZyCZa77rcW1JvsQvk01UL1D7sYWy1J9Ga4H17oqnMbptMe+4qV7ri8d70gblM1Cwyh7pDvrBiBT6gMxb5WGLiopeUh8uIn4mnKY4dsrPk7Gn3eZcs75JyDZ7w17FJLcWRablDPOJWnTjpS+8TqNNzfFPH37oL55bqZL7BqetgS20f8ZGEHd+NL73pR8IPe6TdjGoRykyLWPDjI14c7wj//6zb/PU8l58lz8f3WXrZ+z8trzSoHyVSdQaO48M+9F3/+q5vn3S7572m9CQQJnFs3+Fd3jc1+Id453d76ed/OfEO8YAo3nZ2NvMS9sdGmpeA0XN+e1URL6V7+RZ9Xcc8/PB7fneBGKiBKnh79ZV+KkhBe1NzqXRumVd/L3iDK+GCOIhkj4d23GeByLeDVhZt6OeApCGCErhv/NBY6qZzGSiEMkOELGeEsIF3pxIYg0YRaQeFXfcO8OCFRDh+EUeF1rF7q1UPLXFRLAE/1wVGxUaA2MeFVTZrYigQdWh+LxcmeXgWTBIqeuMy9lBbCSeHbeZCS2eF10GGM9GH29USbP/4NP4wD/a0YEJHiApzhwt4iEg4Ew24Zzp4Fo34flfxh/CHag9jiVaGiRvWcnvofNzWiZ4Ii5vIEjpFQRchbPJUgvYgPh9DgB3XdnPnTKcyfpjoZUxXhLLYgCCodPyXhjtlixe3bzn1bwIheRVDDkVRfMOHf2vRSsNIhx54b2Z4d8rIdA93jg+HFs8hKnmTcaVRgo31g5AEEx8XGT84dEOERvaQD2p4HeEHDqqYZ8eYdMuYfuiYjgcpFUcWOgOmTG1Igv92bD6HgjuXNd5RI6wXJs6kIvzIjgrjVw9HcehgkC/lZeZ3kF4mfir5Ds24EkwWGL4ijfB3InVhFK1BkX7/sxgGsn08WS7IMo9AmY/5FGxN5nWj94kg5oEoGUHEuJIrKRUq1hLD5g/7QJMlNDgXgZMzdig+2ZXl8nElMQ8eAh0vWWXn+HwghnSp5ZRsCQ4RGA/xwJZ3aBH6YF3JBB/y5GddoTtPth0LJhVaGZhUxkZDVA5oNBzaZVPRUZSnEl28xlwrh3uj9Y/SRYdyCYFwmZmauZkRCEMCoQ91SVF7kxGjxn5vRYnWIZhUJg7lkA7zwI8pNpYR0Y8D03hqeXQPd5mXyZm8uZkN1E521Fp1aZczIWwa92+ZQzRqt3DhQmUb+ZoaAYUceJLypZts2ZvYSQ/auZ3aWQ/1EBz4cA+g/0mcayg/eekk89B3kpFAwHd1qfOcr4R4s4ibTGmd4Yed+Elcv8md9CAP3Pmd4CmeR1ZTGHElGwEl/HFsggUOKZKNKkEWYdKarsQRxbEeZGUhsHF4NIGIyyV+66Cb+BmimUlc/Fmi9UAP3gme4QkOw0mctOlDs3ki9aQgZwI3vwiMvOVMhwkVozFm7xFOpGF0LdF0RUce9gkPIiqi+umfJbqd3vmkKsqiw1mLNEEYgdIPv3cvk0dyAzcZQdGgyIaj18QT+LSP4NISaPgbyNMY5WGSFZGHRfqhT6mSNpSkItqk/PmkejokmSQQS+JVNlWcVnoab/g2NUmJFbkW9TgUNv/6lz4hMekgHGeaEzOUoSdjjE1HcUVHmWIYfpFmp3DJnZq5n3mqp6YKoOAppUtCllRaFYsJNXtXT9Z4JltZFqzTqNvYMHXhDlGUQuDQpxWBhtehY/T1ZUb4oRUBbREBqvGgn3Cpn016qilqRx8xnoBKliOxJB4Sbr5XEAXxZLzTl/Vnf7a6E+y5pRfBmufgDixzUL+hPWFCSZg6kNAlZ0gaDzXUmW6Zn866pND6n9KKqk1DJPggnFPKqtkqYFZaQahHEnWhbvXYfThZmAxaEkVRDtNzDsMDr/jXaca6hxG0G2C4TZw5EM9KXKPar/7KpN0ZsAI7sAUroAcbqCxaEdr/ymR7E6u6k0AdZ1rBVxEUOUTYaLEQu64XMZdeyLFPRFwsJaSThI70uldGeofYCQ4re7Iry7SkGrDp07UFu6Id0lWJyY41dxD2ZJgzOBm5mkHHJ7QqkhAzZJkjMZcCkaKoWg/DxT7cFHHythKXGpI6tID54oUWwZtZqz3Nqp9Wy7QCwbIoaqpe+7X4MLAzMaA26xGvGij5MIA8S0TZ2DpCsbank5O8I1wn2p+ZKX4VobrBCg5oGLP6ABL4UA/GxRh/u3IcWKSeKoUCkbj+6luHqz2MC7CQy6eS+7XIY5pjhSQR8aceoh+Bcg9qRB0kVFuGeXMq8XGiyyDqQLjaCZfi/5e6rOtbKOq6UzIQoDmgw5UWbcphLSm1K9lwveu7jQuvHBu8Suu40po+xyu59iCsYyUQYEuX4DC2bJgPaGWB+XhsL7Go6xa6RiQObwMOOTSdmbmdJRuB/kmtwToPAIwWeLZhEBeydCq/+1qpwWW/FeGveLq/xnu8sju5ylsRBbsSwzmWg7oP7pBsOYmNQEFybmGrYboShik3FbysmbmvIyoPSYym3mm7ujadUju1u0uETLwS9xu80erC9tC/mDS5wjrDa0qXzqtiVxqIj4UwQzQZ0yS0P7xzAye6njtiBLmsVLuZLaE9T9qYIUvFYLjCI0GieDrILXuqdALDXxwcH//smTZ8sIMKj44VEWrsTJO3c2rbxjxBcMUiUfIXHhehrwOBmfh6r7/pnSg8LHFqh1UshUrLToRsolx8yDELEukbu7IbQGixqgsbGnuZlZZ8c2rspY5ERANHDiJ2ERx6tBD4m0yaosbbq69BZ1WcFq+8x8EKpV3bxbMss7Z8DwWrQjQhoLpspf6ApeKTEkCLMJTcfTLRhM6JjeeANMiczPtqh24pEMBpR9xsuSBcYRcmfvAmFSwLDi1sqmf4srIcnrWcvk+Cyy2h0De7y2enntgYh+MqExLpN+vMT+3MoAORzOMIyhFYvjQ8rG1iMu9ATpQZ0IG8wtqJzyVat2j4xDL/jdAJvc8MHcNdzH4z/KviHGi4uA8zSnDOhLFsu84XPRlGjYwhyBLPStKn0lIpvRJvZrI0kc8r8cSxnD6/OsvWug+1rB5fCxw9LbNA3W/84A67s32qFMdsK7RGHcyf+xOoZUzq99EWgZkEXbdRzVArLb8EhaTzu7jAi8IbjM8j4bKoKsMq6tVfDdagKdY13DkXIZzjjNZq3ZNmEXBvbcy8I9foYDk8iVqzyA7hG4HWHK8qLYawJhD3Ws/1W6n2O9AEvZ3XzLXZnEl9atZ/GtYxTNaVLZ6Aiot6Z2zc93YyQXBsGw5FvRg0VRIyJVHPdXSUec/me6JK28Wgabsa6tpV/63EiVvYrVzbLw3TxOuy2dxLmUTLjx3WFwKsLVGX0ZFx+WBsu3OKPNHGziS6wQyuZcQ2gHURow1RSBiqJvoQ8s3dTtvaJgvKLOG4AwHLip3eAqzQ6dvbRfLe8G0iBWzGUCO9a10mmkw12puVMnHMpgXgoc0SC0oTWOuf39lagKrgPkFQwjvejRsR3Fm3parYNq3e7P3V6SG7PqHLUMMPkhimlldycPxkNaMSa1NGNJVVUqF00mWHzeqkMi6baNHHLdHazWq1K6y42hPT5v24Pk7hPs3NSzISYp0TU2qc+zAP6BBwbUsdm/2zUuazDBpTUs6g020RbjOSIvjUKGoPCf/OGF4+EoEd2GKe4+L9r/wZ4S/t4z/+q2tey22+vFVCE0aeFe1Q5zyceYg2ycE3cBB1TvnFOzE13WY06ITegdPJWomu6EWXrBHR6Ceb41pLqk0aEZZuyOndxezNouQpRRqy4SMxnlFZgsY96gcoXpa8fZbR57hxd5ghYsPUEuaQQ1Ze2asKG7cOkCPb6HXKuIsr6eXNEsFuzRQenvvs5smu7GS8mLysO3YOPc75oDqaQPLMayeJVUnHVRFhOYp3ftQVmtZh2nJa7gGNv46L1Reh2K5r0JrUtZgunjlB5JU73FSJdjGV78tdmB8H4Okw7kj4oblXEZYhYpWz4tvGYeH/Jw/VdeyJ0cdyCm2jHNuH+8o9Lq0Vn9rprdvhHBH0TpfybRr1HTlh2mAJI90enetXS2QX0eoHFM+jhG+mHQ/2sOnne0c5MZ19DNAMTlC+u7KU7vNoDvSnukJeu/EZcvRGNs6f4Q51LvLp6jvdnhtyIw+nKvHo9ztvE9ry13LxQA+I7vXirru7691jrrhiru78GSftvshDP9nyjiTeLPdSJN9RiQ/uoEYBN02Fw8m4AWZimNrC6uBvehGwbjnLRQ/WqjyxO7mvwfglLGlvefayzcJNSvmVT9bZ3NVQxLxdPdbzNPumAfKa/ORJtw411EDfaflE4p30wPrOJxBI8zZG/8EO8tCiBdy6pCGXbwaXbrmkkS7IJQr87S78GI/5HG70fdq/EO3xDXG2qpcdNCW17gDjAGHPHj6C+MAdRAiuXj168eIlhBgRHLqJ6MyhQ8cuXj18+/ZJvHcPH0N58iSejPhO5UqV8FwmjGey5MGSNW3Sw5kz5zyePBf+BBoUokCiRe2hjIjvHriQTMEVhHpPnz6P/ayC4zfvXDlxXbsiHFfuXMZ18OT5rHf0oECDJ3E+RJpQnbqDGNXFw0fVI8qQBAXGjbvS5buXLh0epmlTcUmdjXuiDRq53lCjRQlKNNj26VKmIUVGlarXaj+m+OCZ4+pVHLhy5saWPRs5olq3D//fQWSXW+JcdevqiT5IOuJUqsQBoyQMTzA8cMzhHYa7WHpjnY/nSZ4sW2Flo1AR0j6YWannzp5De9w3uh8+dOe2lhvn9eC5dOvcxV6LcvJxlQdzswMHQHDoQig3eTraC6LiiNMLvY+OS4kllyZszqGEpFOMOsceww677bgDkaiECPpsPPNCIg499fq5h51yXoRvnIMuMgtChfazMaHcbhuQQI3soeqqhPZy0CN+VswxIZaSc86whzCcTsOdOOwwqKPSCjHEEZUq6MTQpkLvyH788Ye0dWB8sS53erKRoSRxU+m/d+KhB8j0hEPoowdX5PNNcJickLnmDEsMypukxMn/uiqt/DBL7rbs8ksGG+STNHkwQmeddcC5D0IcD8LJT4RUckgejqRSsR9+EOLnwYiuEjJHQAMVlFBwYjL0UEQVXfQnexZytDLMSJSUwVStIrNMfeZxBxyT/MzuJ3pE5ZHO3xqsajR+xFwVIc4QwlPWl5obtDBbc81wV157TQvLYIs6idhJi7wT2av0sedZUadVCJxQkySVzryyFa7bIcEJdzJ7pAIXN8AEhShQiNCtCVEp2XX33e+Q6jLFIislTZ+RRIWI31shZGdOnDgKEsmTXN1HZITmAa8fAVFaZ6WTDKOwUIot1hDjd4XleDyPHaz0IH1EIjkiuCB0iGWCSQvX/1WJYhYZvOACLBChTQ8SbGdaL6RYHqCpEzpjjYtm6uhjR8vz26ZhehowO+vdOlzAiLvn0665hijnQcWmtUafDT27MYx9HVpriCI11kExYwVnqrllLTWtltXb2s+p8BFRRwE11VRCiBMqfEJ9D1fM2cR1WhzYxouWF8yPhcTa8uM+rRuph6Cjh6OpEQ5O7xzRm6op/3IjfcmWeja3cOmcxZD613OKXfZg44LcbSMRmtRTk208LPiB69X7QVcvQ0izq+9sFXlwSM951tRrTR3Xsq2/HvuFblzUURxFO6MprUgJSR55LoeSlZ1PSMIhDXpQApWCdAYi6kkWmebXPPtJ7P9+tIISQqKUOH+FKlq9WouWJggafUAkQeArEfuOMz7AbGRgnGuYjZSyNM/MazQZTNYGwdZBCn0QYmVLFwkh4iGhpBBEK2ShC19YGr9sbIEIMV+2tma1N33pdmNCSAaV9Kdyje0gTZIYQkqFRLP1b2UAbCIAv6PCxz0FNJI6oLdA9xe/Had3WExLXkQDK3DAjGRvg5s/wKHIhJCOXB9ECP56dpA1ItGNK+vQQX6SEK3BK4Xto2APDeggGO5Rk2/6o7/ONzXc5ek4cktIpcrESA16TXCEQV0ayRXJcVFSJjUR4fQqdr0qIWSTChugZShoovPksXKc+YtbUGIhmNDjhi7/29ukJmWeFoKLasIJIn9u059cTvI5qQQm2RhITO0sUXvvWiYzbefMuPzvJNCBi0OChyr0JWlBtotcmCgnLh6RMWJFjMjqUALMdEoEaIuCY8bA4ah4oqiZR9oWF/2ET30GD0zePMgUAUOvL3JuoPxRznGcQ7KGrhNR2YumE4lmR8jxs14GIxl05mQtQWq0H0Q6XoKqgr5kYRNgVxQhyRpTQp3IsZgS8eTjIuXFfUwOp6KiU0P0qbluvqxpw0tImS5X0CTFRCIKzdFSaXjMJd7oJPD6y0BoWjswrUijbwqe/+rBMKRG5E4IM15fc3S6vi71JHE8zqMqaqwjkemkeB0J/7BIRJXj6Cmo36SaYDV7uZxgEakiElFFvYgsx3prRI5zKEf2KEi9oKSrhZQgUvSUns7F5a6bfZNNEoOUf4GKhrubDXcoeBAvNjacpSEZVIzzptfmiV7fBKxw7vpCHlbuKahtGmGRotCZuKW3JWwTYkG0zLbVdUzHnRtBGJSk24Y0tnCLpUeaa0ClhQ90gtXuQieGVix+97tu1c8m51gZ8p7HuGT6h1gXuN7juO8pSpPinvCkO/BJpJuWMw4scWsj3Uaks/11J1LsyUnhLlMq+ajqeZOV4J/O13NNAxNlXQghDSvIulbccI5a6jopebiPIaZMNI/CQiOR9h9HTrA/Wv/lYodqUr1dZXJczlNIV+aogjaK6YYneZIOJwRRHv4tkEks5LmGBMV3WjGSWcyPKEOVtU17c1zaDEpQOhhSOT5jL7eLVg15978JGfGA1TJkeRVZxUj2R5J/OsPwMBjPosrMox/WS/52WYSGdeiHJRJoQU+UphclbaKPDK5W1bi/gbSzpBNiav3EK9X4pTRaLc0/TYP5z8b8MVxrJ9BDH+QfEGG1k9VbYVVD6NbFloieW7qYiRWqyQvhyaYBPGZCT3aeYkJvkmSIbG5vNtYMnd5Zu3tpelynHmwCNGInypaoHG1bpJVIqU/patyaUqmeCp2kv50rLo+bJomCdrRPKRn/QVPQbe8G48s4Qw/+2jE8r86RWrwDrYUc28l98TR2c8zG/R6qjeZGdzGVaRAUzbOqCGekiFEykEgvkOVXJhmnI3Ktz2kcvx2nGE1Y55iAz0OTHeoOXYu0LTEBd9PbhtZQhtu07PjrsHHu9q04Tr0RAvzcAq8SvLqHLSMdSSIpF85+yKpah088PH66DMSxLC1nxeN0co2LpjTbrOqx0SQaMndEIxP0zZTc5F3P7CJTXloCxlPt87ZRmKc9G3uWhJpijojcF+gkd5hFmBxPVHWEpsy+U1VyCCfNig+SLDYnFVKGPzyg69hXHOHE8X9s+PyuOCGHVN7uIQT4TjZPlKl6/z5Mkzv0qAV/Y1Cdnn0wR3tfr+RlhssjlXimfTzccZ/bTy/3Vg/gyHvobqJPDojCB9eDJmOyeD5cM1r7MWbcyfDg9QswgdaJ87sd/elX3/rlZgj2gR50bk7lzCf3PiDSoF+rJYNRmDq7sgqqovRbPP1YJqKwJ5mTpqb5mrjIrwqRPuqzP12BqaAzEQb5P9ATwFo6slrqB5npo6WTIZubqILIsqSYFPYZsRNiIJp4vg2SO0eqQLLKrx7UrQ3UleBZHA/sv3z4v5NTsREEB/AjNk8zvvY5O/cbFuSbjVV6MGPirWlpP4XIiRukHxyUvEg6ozHMs4OiOiBMIiFkFyLcPv8j/LxQy6AEY0IEagsWdLiJAoq2csIrnKCkwMO4qDXeuRW3ew6ToJ9DFJw/waUy4qWDsjxDOcOfuQ7rMDeg+JXxkid9cMOuO7A4TDCkyBoIgQp1EywJLJmFaiPGmBZEnJ/nSaOx2bJyQRfWgURwoMRKfKcSK8Iz674kFMCISLlPAgwXJEUGLKwZ6jNE1BTlKJw8Sx1HBDdms7uDoMS9IzB2Gw8j1EZeRDklhJCZ2pJf+TlTjDoPG0chVMacMaJ1bJZIRMNb9Ime2A/G8cBI2cZN7EVv/Dqoyre2IMZoacAfw5H/oSHF46zIU8Z1NKLp00A0nInHoEaQg4wQMTEzu0f/TuzEYMQyT0o7gTimp2qrhYgsvzFIidAn5vutgjxEV1TI1Kk/h7QJ64jIn/AJmbIM8yCWe7hIjAw1URGgaIIKj+yXEwJH1WO5XylJ3/md8bG4RmqelmTHdoRJs4FHXLwOm2Q3L+khbfw9jOpJP6nHy/gV7DAKEVOtkUhKmDBJpkxLHGTJhay81JnKm4DHvcPK3jsRTdxEAFSVr0QJRTKejHlAvXunGXS6TUtKfBpEwGjLg6ifwmHIyIzMmIAOh9Q5W6xLyfhJ/tPK0NhLACw6jfw6wCSuccQS8nKqwmyymcu/53uIhmgMxKDA0rGfg5DMZnnJqYw2gatKXKRHAsvJ+V08wl4EJ6QIIuHgDCuBu4ezRojLP8RsCEBkqi6cm0Cxn9uUzLk8C4jEzMxUzhJjJr/jyq7cFsBQpGwzzdMkMeW8Lz9bq+fMkYq7QaeRiP5gRlqRTE6JTEuijsWQye58jO30CXgKTvE8QtBEioQTPEXih3xIN3p8UGNiOSlMN+rEtcYsPmnJpxt8vsK4TuxkyLKREv/kznkQUBO9ugENFrz8ks9E0JPoS3CqJXfylUDLQ/Oj0KHMP626UH55vPd7C/pUox/lpQ8C0RBFF0QhUXTrTRWlqAJt0QPtPpSI0QUlngdtJzmisxztrw+Di9b0kyAd0qdRTIgICAAh+QQFCgDgACwAAAAA3ACrAAAI/wDlCZxHsCBBe/PsgQN3r2G+h/v4SZwoEVw+gwbbaUznrt28ewvvzdNIUmPBdunOqVy5EBy5l+TGyRzXEpy4mzhz6rSpE2fNn0CB5gz68+ZCcS13Em05E1zTpUHJ1XwJleVCgfIwGrTHleG9hxApivXasGzZkRrtfbV4j2tCrnARtnOXrq7duipdSnVKc6HMnoB3+oRKmCdSqIONKj1MdObTwkupQgZ3DqvWhG8VOgQbUazEfvyWPmyr9mFLsKjzNZRbsiTevUD7JjUsWLHRyUcB5+65e+jgo1AdyywMm2jxwpYxIoyrdnO+zmL7gQZXkXp1i5xDQ903+nJDtCkXwv+UPLymbsa/J9s23/s2bdvoedfsKxu3/YXnfp5zN/ByV7OoQUeRdKBF148/CLakHTj+/NMgghAiGBpYzlFoj0bugBPeOTARppRN9/XGk2HvBQbfYSfG5hRTIeKWX038ZaUcXGZ9lZ1nOEaoY4IMgvPPjw7u6M91P0k0mkg1hcfUY+y512JSKIr422LmocgYiH4FVd+Kkx1H1H79bUVjWQHi6NmBQqbZ4I9qtrmQRNyp1hJKHL4k3JYjYlmUeiMG1l5iV7LXYnlPfhmjVlzVaGNYZg7Y5o5ABvmokECFtiCddQrH16ZYWolUOOEUxpuJutkXaIvFSYbboTMqWmajYk3/GiGQskYaqT8+BsVPPhemBNM4VP36V267gQMqYlAiReqV7ikbIp5+QVtoS6waBE5zAN4Ia46P0iorhLba6uM/CqpGJ0wcUiZsegsdiyyJpSI2VFHo/USoitMSVS1B12Jb4T4Ab9tom95+C264CL9pbkoqpaPhazGNc6p6y05ML3zEBreUtPm2A848H1vrb2rPdRYRwCgLyG23kn5LK8KRKnwhSeCQBPG9SwEaL71/5llis4w5xiWquCE6ZoUkx5lanEoPbPDKkMIM5GlykiUSSunYWV+UzvZZ4sV+Knuib7PNZ3aXLc6YaLYkt+22tlAL6dlDsUYtrrg1ibUwh+X5//nzh8UGNbbfZR9VH8c/HeclUQUx5+rbkLcdsJnSyW1k2xTtWBO5LcGMIJtD8nquxPMmW3GywPn8p3xC2UsT4vkuxJy/j0eOGtsBqjyRjnBSSGY+k+G6kNThSriwneL0PWrFU3b9t9geRjscoU0JnfbHcbWl6Pbcd4/00rrrfSRIP5Gv64KdE3/rkPeMPhPzp4tq4rN4vg77eFLBdpC/zdHu/f+1W9TScGSampRFIV4B3lJ4NC710WpX7fNVxO5Eup6U4yXlAJy8SJU6e80HdhzLn6oWchAArqZfs/vJRxTlv+2p5m01cUvjElIjXUFoeA58ID/a5z4KVjB55/AISv/IoUGiiG1ZWsLXxnDWkvyJRypv+Z9CmAMyqCAQKLNbmwlJc5nGZc98edtcDkEHwXNp7U43GUc6ViiSc/yQTyCaX2yYaD0PQmYvUdxeV2RXxaUQxCMq5BcJsxiXlqyGNAjpYhe1CJUxgo59WMvUnRayxtKoxh1EDJHOivjB6dmPSdObzNFqdMUrLqU1gqyZSQTZRytiRpEZ8c8eieLIR+5wJHWZ4PTIkQ6POKcdRIQexf4GmXtpSnpMMs4ozcKckBGlNST5IzQ9UkWQ/bGVIYOlNjFiwDelz5EP2hUuM8UXXvoyNcB0EutQx7OcXUlomvJkMolCyCzy8ZnTzGdrVBn/TRVGc5vbHNOb+sGgNdUydOOUygV56Y6PQAQs6YzPhzzVondmyYefhJ1L6slRbM5Jnxhyh0jhIdKSmrQjNQFpSQAqyEQBD30GHaPxerWSc9TFY5wByzzOccR4WamihMloeapHGI52lDDTLOk60rFUpp7UpDA6KTRZKqaGgCMi1FlITMmlvpli7abtUEhOuXOPdGSQg8RyUk3cJT9kHlOjgcyMUU0JFY9ppGbgKOld9rqOvpY0KBl6qkaSA9DmWASr2qklGYGHyoWA5XIXciNa+2QxyNRLekuKln0UOdeCFIYkIm0qOkaLjr3Wpa/6eqpI24GV1sJSLZUi6FZz6I9+/yiwhFTrzEPm4Y5znJVwEwNVqCyr1iUxMYlBea1RsekxwsBjqaStC2mjW5efwAMeeVVtjForj3+26iv7AArxGmirIWlHgQqCzm57GxM5BkW4moRS7OIqS45+LLkptWtLpDtddNRUJaN12EJQK9KFXNek3HUtosjUmZbgSmo4LK95r6M71YyEb4T7iXCHC9TiFua4JKSqURmHFqCkY7r//S86NASOvq7DwNfNrkgJK6PvgnciBI0wzMjrrQLBardD/GHp2rVhtg5TdfMNMUuX25JtzoWSJ2ZYil8ElBcP+MD72t9y1gaRiFROjDtGGO8a9ZBetTdeReZwRS+rxLMpUf+bc80iVZ9ck9FOeb8rJgpJZWRUfGymMwTSqo7x9iPy6sjH4ougb/2W5kKdysPQAnFfqCrXOC93JAWG8ontnOI8s3jA4IBHfzj6u+d85ss94vHUBl0wBBUI0evF8G+KnK9ApaeyH2TR67JZWEv7uiB//YmUV0JaoFx3II7j3o0CLbxv4s3ZLRszZNn7xg2bKmfAGfJ9mEjpSvu6owURiFIf1t9iW1fUWYELPvys7OxIR6vNZnWhwby+CE1kNJE986eMDEcjJtl1M+k2c9aNj2/X0yDdzXRLSmsXT8NYIPXgCsHZXTtT14SB0J5351Q9ZnxvpL08UTOS/20fOjZF4HL/XbfEVW7w2YV7pC12h5VbbGxk24Pg3UPNVWEq3oT1XMIT5hV4YjJyy3bQiLgOqpYc020tf7t7/XM5WlirXexiOd0S/1+AaiLbVNObcz+vd+iu5iuSm72YAW/6XLfIvYLDBZbdxUpJbX5zretcQbKNd6pX7XV527stZoRrkpOuzuTRx5jjaLq3Z8d2KRLyIBhxrbobX6TPaG5cF2eg5yTEHd5mbVhVYleIQOVhodi69HxRfJwbz3pEytBoN6e494Bi6lOjiUdgd/WBMu6gIPFjHyLx1ft+VihrE9d5xDput+sxj4gbtfXQR6TRJl4Wt6dwIX7GDspsjyag1PYzvCcj//B7mOHJ0JpipS/i8pu/9ujXSB/wh39Z9MHM16c89quh4hXzuKiASYcf3QcUPjYrYhY6NDVBO0MYjdY6FpMYm7VN9cB8zSeBi0cjX1R37uc9BqcVLRGBEbhy8bd9lYNxDDIgDNJ7EmYk41QOfyFRULGA8nUe87NOgAFQHuiBXuRrspeB9yB/9ddZ4YYVLYEV9PCB6xaCKDOCAugon1M830d2WtNOGnZ+UgI/ZDNRtKFksHSDEZiDlraD7hd/imJ9ckYQCTaE8ZCG8SAPRVgPBBd/+uBlAehgcFIRnzNbxgOFLOiARAaDpmOFi9FThAGBOFgQHxgXXphFPOh4UheE8v+gcKEGD2qohvRQhDgXgiOIcRNmh7PFJqCxNxEzG+Lgh/cBP5SVVhnDa130gRQ4gS2HgYtISo+HcI/oDjG2EO+Qi7qYi2lYiRE4cfC3DwRyQ3S4O03ohBDkeXzTgjfBb08CiEikJ9rEihToga+oRSyUdWxHhogYhCV1Xe/QEu/ADuTIDrvYi20Ye/gQjACohBf3ewB4jOuTjHTCFxVkergBjYAojVvIhdY4V1x4jSs3cQRJRZchd7YIjgtBjupQjuSoi+iYjkeYhLc3PAvxagWFjOJUjytihUf3h/oYjUYxjf54iJdmiAL5bV3UWgn5XAuhDjAZkw1ZjrwYD774i+v/GIfC2H0xc5GyJWaf2CvCJ2Ta5k4heZQk6Y+WBnspOYtwJ3fX5ZLgAJPoIJMxSZMRiZMhGI8R5n0FuCsHyIJE6RMadJT6+B5JGZBxxllNaZDaxJJRGY7gwA5WWZfm+A5Z6YbsFoe710AWeYKe84nz4CtiOYNhY5bQSBtpeYOWxoVM6XKNuD+Uxl3gKJd0WZcy+ZCU6IvqGIf8IDx8x1XEIyERRA6FiZioyTyK2Y9KeXCGWJL/WIaK54jJQZnwYJmXGZOkdZV4GZESuY472ZWqJjWQlDWm+T6BmJrKeROL2ZrOpxWwGZvdOJu0SGNweZstkZvqMF0w+ZC9aZM3qZd8//lgGidvxXNLhImcy7mettGc0dmKBPGezOcWiUSdkcddZshd8aCQC6mb3DmT5riZbTiROXY3wylm45cS5nCcY8meqJl4NiifEmqf3VaJ9LCSrZWG2DmXlzla5mAOVdmdAQqeAwqc7zY1YOdItnWAusSMDnqUMnEOTVeS8fmeFHqfNYYRFqpICbafcjmO/jlaItqbFqqVwYmi5uk5O4QpZ+QYL6qPMdoOFzGbN1ijNHqjOBomjsijPZqGuJibuzmkWZmTR1poKQpO+8CiYklBT1oxwBJE+fCZNyqfWHqQCralGJpgAhEPX6qbmTmiRepn4/mXZ+pI6KkSGIRRbdpTaf/ES/OwDxEypzZap1mao/NAWFqhp1jhpRyKmQ0poG7Yg8GJeT9xUGlqRuWwphjVoPGzLOMQRPYQpzqCpZNKqflpqXiap13Kp+PIkH+6mb8oqlwJdl/XVbdEFxySqquqnvu4Oo2aDvdge5EqqfDZhbZqhk+JqwhHD3pqk16ai74qosAaqjrZl0GhWP4gOkriVj5kij4DKOUAq3GKJpnoD7Rqra95rdjKpdoabtzKhv8qDzYpsAsRD+DqkOwwrkfIlxsXdg5UnIiKTI3hon4DaeQApxJxaDmmhddKp013p5eqqURooRcKsAGrpwVrsL2KleCplYNKqsVKnAiFrIkaacz/Gj9sBSxrNK8EQhFXxTT6+prRqXiYGrIia7KViLQnq5/iuLIQSaIRR6bvhkO5kqRiBpZ0sqAt6kOmp5pB9BXwCI9HcjtqEbRWCpuzqaVGK7Ik27Zt26M1Aa7niI5Rq5Pog6QHqqQLQ5iquqqAqLOx+hwlAxZU8xX0x0Vma6tuS7JHKxCLu7iEoYZz27I3F4ylWp4H9XsRpKCm2bftyjzA4g42kjLQURNkVX0Fl7iK+7hLq6esy62FwaeS+7SUK6jhBW+rxjngBBpkh6idu6ysehMX20uxSrooQxSItG73gA+qS52v+7aNq7SViBuTmIaTy5m262AxVbW7e0uRVCee/4tGOuEYa+QQxrsP+mC6AAM85MN89dBkzQtQz/u6rvu691G91luTtSuqF3kwuStT7INLDINB4eukOlEO6WAO0KoaDRGMx1sTJXO7LWEPsMux8dtF88u69cu61Iu/+fud2Mu/4HB7hAbAWIsX4Au8QkYOIsVG3Fh3IYFCzfQxWAEPF7xNGfy40eu2HezBtBvC6du/8pi3m3fCTcSgy2p4w+t0Efiv/JEQBFefA5FgCXnD2pTDi+u4JAsU0zsZHly9P1yEdRfEI0zCZnpQBog1T1QO9qioCExNzfe2+3mb8CDGE2wPH2iGNRGVVgxLWGyhC0EPJLenX/zBICzG2Yd3aP/yv+BURiisF8fJrjNBDtREyNc1u7koau+7FMtrfdXUx4r0x4JsdoRcyB8MrDC8EHKYIIUqU/SIwuYgHmvaxjHaS0JYmbsol+BgkzVBfcEof6nbr6A8Dzl8duCQoaZ8ynSbyjvnjuFXxBb2Vb4rFZP0puswY/KwywaWi3uMXT+hjpcYfwWHr8Oso89rzLuczPgbxr9ouu1orhZpwtFsF9OsrGw8yekQld68x+H4nXzaEoLsfCunbiyHx+WsSB7YtuAwyoOszoV8yFHbEv6nhKJJxOX1ygM8Hqm60ReUzzG2zy3xxekMyPglO9N50BiR0JCRzT/B0oSxqQ7tw6i8bqr/LIckHLNfaWF0kdEY1LkwgQ7rQMe3yc1AUb0F28UFe8zHDHERh0IoDUtEIYTTIrAx/dDjCg74INE2TYwWPY97y9MEPB7s0FdEvYuRq4ZF1RXK+9SKtNCjPL1SHSJVXdV4eZNXZLftCC5We57qisL4k6ovAaLkuA5mrcv2wdCyk9ULAYf6wNaX4dZbvNRPMtd0TaJFCMETDc/glMb0nKwwsdHmYFMO2VflOJf3kY43N8YODDCOfRmQKxByTdmy3bItsdp5jdNA6ch+rdGpGtrogLClzQ4hItBxIagO3A+tzS8FodCFos65TNnfyYabzBAO3I6XS1v9QFbSXCct0dsN/5MOwF3aZw3Qeul210JxOrkPyW1NBAG5XkzXuay/c82GvdyD5eqwo/l7F7Hd+OMS50Ba2tmdMBm7Xoq9BbcUcbjeBuHeRGHUPzGJ8R3htFvViG1VV0VLrjzPuz0evi2kLTHgMgkZdNvUHnjH+6fg7c3cDS7SKauyEh7hs83Qiv0TqNaJV+u9sPxEF/vfmzaVNRGT713gHTjdDO2Zbxm9RWufkI3U482p6WzILz65c43YP7HKBNhVCMXfUkFs0zWVQC7XRLHJm8yX0kGpCcZSqpjikd3kaiiJUB7lvOjPMU3f563VO3l78kicybjTKrGgecFf1WWVCwcOo7UUTg4U//9oogdy5EiupwB1X9lUEyRN4NXr5i4O5xAp5+rsuIlt3JmtIw9Lj3xeU4W+aUIq6FAxk+F46Mc8ykZI5mWerY2On9oU6fDr1ksB2zUxiZds6ZgO4/NN59hn3yJYrzYufvstUtJlFy4mYCFalw734QNu2k9O5YkN66BBsu57g7Pe7S7tWUOYFXHd0m2uz/q8nxD+688d09zK5NSd3u+ciTI7dn+kVC527+zgMAG+nf0F5EA+opMIFIr+bvvwvN7e6BwrhNwV1VRt7uaO7umu7vL9xTwMFKt95/UKdK6WjC93UtcV1C4Wrp5al3PZzw4ODm4IMARCUMBn8AcfvUq91Gf/qOtBYckOH5VfLPGajr+TThQXH17vfOVB8n/6XZ+3ipD8kZC5LPIjT+1JjY7ruPKLrQ/44PIvL7JXIfM0n/VQIbA3j/M5L+HKbMoq7vPpDTDWMYxCAmvf8RY4muJUXem9mpl2SY7gYPI2aQ8qn93g4INVf/Uwz9LZPPiw3VqxbXU3P9vsXvGEcfYDgueeqN9HshwJUYjxWaOsa73hnZvcvOppKA/1oA/SgfYFCfiBDxSFXygN//WKr8483IaFkd4/e2qz4mqne0DMQdxxkdCZf+nAXdigH/Wjj9XFjQ+mf7S5vvUt4vWJ3/o8/7rTjbxTb7y0Dy62n3/1RJAs18S9/3/pEd4S8IAPGB9e8IcPjHn8WB/uZycPrO/gaqifn6+prBuBsT/94bV9lrcj2a0ahIRzAHFP4EB8+OzVo5dQXkKG8uI9fBdR4sR37NjFw7ev38aN4DzqM4hQHjh5JU2eRJlSJUqPJEe2hBlT5syWDh/exImzZkmGPX3+7FlPqFCaM/Ud3Qdu39J9/Phx9BdVar99+e7Zw4oVn8CCWwcSLHgQKD2b8ShOXPdOnr2MVJnG1Bdz5Vy6K0kWxZu3ZM6H4HCW9Lhw7GCGQw3Xywvu3kekSpk6hSo1aj9+VrV+xZy5q1igOM9aZAevnj6NG/cd/fhx6dGjdV2/BpxY9s6yOf9NxiQ8+HBLokW3tmRNmunSpxslT60aPLhAfV+bh8WKkKzPmxHZSQQd715pjv0Yqx6+FPZ4wLFnn6ddt+VgcGOHeuxNs2vBxcBZh2/a/bg/08pZ0wepII/wgU+6hhTyDJzrJKKHtO44imm4B8kb7y70LpRrrvXGas8nw2BCDEP/woOsn/0mO80/mAIkEBx7YBqrtoosimct7kzjiB9wHuSxHwpfC8xCITFMzCeecEvosIQ8SnI3IldUjsQST6SKtXtYpCnEDRXiScaK4qGnrQdhWqrHCX907Uk15ZqJHnDiIyo+mV5UkzVwghtuyuP6O2q+rlrCR8s3NyxLsNrkqUf/zO4iJK04445DU72X1lTTTZkExZDO8+Ly777HHH2Uo9Pu8XM+jw5SskN6/kKQnnquLNPMHWUqbb9INZzUPEp3XVPT2YRjakTieJysyj5LDekwoX66qTB62Lpx0R3HVIxUgVqS7Fa7eOW22wuBfSvKYc3kJ0VkuzJssIcKS9TBHvHyDpyQ2NoOW21VgklXb/fdF7+kxM3PzBRJPRdVA1d1E2F28TnKzI6UQo3MpBRD1Z76wPHn3tjM05dfj3f1N6nhgAU1x9UIDgvEoXrCKSEwXWU42kUfHtExpq6qByvSAot0yEld+jho387z16ORH+vx5M1QHXRllptNMmaHjcLs/06bl1oMK1j30fhnloTutkV5WyTQVNmKvjpPHssd1SCDEUuXupeflfpdo2Ba7GKjg+WUNY2RXBJsfv0c8M+zw1MqbaYeZPsoUt9WFqFlF66bR7yuzYu7p3RMCjaeU5KpJ8H3LXVsAa3GC/HERQ5vo6dGfg7yyA1MNGaZH2a0ubwTiwzSND8/qU1VRw/7XLETG66lidMWFfYAZVcySbbctbwoxzFXESnujvune/Xy/Tp0VQOnyVLi8zJeb+SXj1BCf4+FPvowhat+pqXujGvFYFt/VLLuvf8dz4I0G/Nd6nyJSZ/6MMS6WLnlNKvZzOyUVTkIxSReKwKOR5gDrged6P9//8CXbH6mJkzJBistOaFsjjeTc2EOLvkrCuLGJargRHByHmpXAyuIHivZZ3snikpMcgK29/DmQinMymwMgpcWKpAx97Ofv0pmLCw57SdbuZ0F15eiiN2pVkCcCTxqJEZKHek8JSxKVtSYwpj4amxujImfvnI37dEkZEl7TrIm55GX5bB+WmxfyDwVqxPNZCPwQCQ8/AIORc4kHosc4V0Wgh400kSNKISji9iYMt/M51pOhGHq8OOwfTzuYD9JVBa1CKGJhWyU+pFMYhK5yEY6EpIjHMkk2yMbOeHlkqfK5CZTRjhAnY45NOlbDP1FSpBwZkmFoSDuVtkRBjqsd8f/gckFPeIdHc2ykYmsJR9vybEOwYeXTgrRi9bIRjYCM4kDclEcV7hCNd1RYM1ESF/elMMbFaUj0lydDomFTVo9hUwyCWcj/5IhwYxvnzGRoFDWOVGKVvSd8qQnt+yJx5CYD2bUA2hLtOkYOy6ug/uh1VvsA5NwMtIvC60J0BhSzgKFKKI5s2hOK8pCs61JOIFcJo9O47bJ5Ww7MkMPA2Win5HasY4a1FtCxagTNgEmYeTbp00jqlOurlE+PX3SfYD6ygcNtSASZYvtDtfKg+5NpBBqqlOXQzCWCpGqwLtNwnADp6121a8yQZZPPSWxjXaHiwYpyFOVt0q3sg+KAg2p//LY90KYHK+lQ3RJSkS3Vy3d1K9/pdOLAlsnsRLWla/j27G051iaeMct9rNmFIOV0jjShIx/oUtuiujZz3bVeIYjkopM60rn4UmliVss0W4XV/voTrL4KUoi+1Ij1xBmN7ztrU5/ezp5tcSJL1TOc13ZKYCxFrmpuZvyYvtAmVxPYmlrThgRidu6WPemh8mudreb0faGEn/BEa8g/eMcYBntvEkV6DaVp7udESlvCpzvTV6jm/viN79cLSYxE6M38gYYP50ayGpFduDUdDFCsqLalUw8m/q4sCURpm513VNhw1z4nRQVEOH4KxMOd5i4q2GRV1bbVqP414smlZZkY/8yEBNm5TeKMTKMHSJjoNC4xjYO7URzXLpvkbfB4z1WVwb5WCMvmTGNySYU7VdME6J1pTGZ74SrbGUJYhnHp0srcMdWFAILS3HO22BpSTpoyp45f9zNi4lbFB1AqSw+Kn6xIqdKHhzSOXJ21jKeNbxnmvTZuPd7n+M6BZyJJTN//i1bZdmyqe5CtJJFhDM4I0zpoFj60pheo+HyjOhW89jTY/6zlRgG4Dcjs7L83fFMvmtOiDYaqrKe9Xgqbesr49rJmt40n38NLgamlmBeLnMGj53sbmHKHuH1CLQnTSF2Ubva1s7zqbh8ucyUV3FWIlV47YQXx4mtVCwCybI72U7/V0lnQMKJb7qh/RBaN8ndaIX3tcm2af7W+9OP9TbKvIw6wJbtXP7hdV60Mp92Au3cq2HpwmNc32lTO+LrbCNYAZuZQJNoWg68Hn3qk71T+3u7nSJ3rwvnp4PMpF3+VffKWV7rh7/cqxhlolcszkHXmoaLKIO0nfYd5NP9VriZKhXTIh0PNC684e1+OMSxrOfa5oXmKvZUcbZp9euFGDXg1vHPT91sJYb9PYEDE6wZCU6lUxntacc12y9Ec4BdcCrlymOg/6tv+O3aeHc3cSV9pRXThSVVLy14yqXL7pY3HdOKR8/bP/0wyVSpK3D/OoD366eIcSroHaenstxEXfJJ/5fh0p5z2oeCaUq9/krHx5PcW/KPqJSLK1vZ99A6TzjLJ7aLnsckJ4fi8RVGbkl70WecfzRj4as9u8X35Abh3kCYMN8fzicYpNE39NnnOMPDDvPSRk5y3uA0OggZoLFDE90qvwvbFTmyO08xDo/4B49ovlKyFvmDEjabPmThutqyHY3IOeiovv5boz1aJAEcv9xgOkszQPQzPtgTDuVbvgfkCrjrL2eTl+oTs/xjIeoZFRYZPo+jk+FLq+hoiJqgB98jPRJ0OBM8PxQ0PmHZIQZkPqp4QWIrNn+bvv0LMp4CF2Jboix5EbVbFitylWgbQCN0uSRck/RTwRUMKfeDwv8l9K+IOR7EIrrbQ71e6yVHe4/7Er9IMcKCo7MTVBM0TMNxab8GRBFSmT64CDkXOZc56Tj6uxDBc7QfPIg9HEMStDVAxBBkScDVKg5/kIknLCXusz4mQ7ZGpCStYJoCMjojsqms2jWsGL2uobA/7K1A5MRAM64mbEHXm71OmjeVYYsu7D/B0yeji5OmgZvh+xBwCqH0yC3yszIzvJAE0kXtiazu4Y/TqMDRwj1TISqJw74tMZBdEicYaY9kzCrJsa1E2ha8mgtpnMZb3ERrhD0J0aYPEkVEHDewQrSC6Y3amY9KMsc28QlljBMAvMPBY6SbgEaWuI0MyYvZ6b94mpP/idKkarTG8sIdfXS/URk3ToMJOpm4PxlH+Ng1AnK4ShuUmmK2MHKplvqYCounzYM5XGwhYVmcQvygbXyODIOnths4gsyLgjs8AGSSl9ytA5rImzqVi7woYNLInLy4/OBJbfRJlDGdR6zDN1pIdESSOgPAAoITVhScjsGLepiHeZBEqLzIqczFizOomPgf5MijVBNKBAoLAiFKl2mJufHDnEEXg1sPJGFKDFnL2cikjESPXOzEPIEJUASHukSRuxQ6GUQf+yNI0VmXmfJDkjsY8WESrHITRDrMLFlGi1TMekzBxyQOHcEWf+ieyXQ//uCHuww57sLLflSnNzFLwBke5LJUxUD5TV5xB3eQiUjiFq0aHQT8inyAznx4jJiQTX20S5TxuUU0SaITlJkqoavarKR0NKwKnZnakNNMjK8kndYciOiUzgOTismkzdqsEieSucKBRNUskCQBHA7JEvL8S7MEzHQTIeJRT2/ZCp1LwKKQzKhoQMrMyqDMz60kG9NJK0HZIy0hwaJ8JCESz5caTUuRSfQsEP1czDNUvRWjzlhyQKmoDBe7v5CEp6VpSRghT/YoTpg4Rtz4S6jJURJ9qNGZOhV1QIyJzxZ1UasIOlLsk6HjPEwB0PHxzIN0pA7NCx8NCAAh+QQFCgDgACwAAAAA3ACrAAAI/wDBCRxIkKC9ewUTFuTHsKFDhv38SZxIseK/fxUZ7uO3L9+9jx/ziXzo0V67dunOnSPHkuW4lwoJhotJU2C4mTUH4szJE9y4nkBrtgTHMijCoOAeKo1YsenEixeb9mvYMd9DilNF2puHMuXKljBp7kR6E6nZs2hzkiO6FujRnvwGKk3KsCk4pxKhRm2qlB9ehiLvce2q0uXPmGODlk3LGOhhxi2LNlbIkCe/fkz7CfQ3sKlejHhDZwTscbBXci8fgxNnc7Lr17CJymbb821Okfn26d4nUPfDhHE5c07o7zNG0KJFayx5MiXq1KlZoy2bOLb1s2vbxrSXFrf37977Jv+dOpz48Yp3k+eFSnG54HRgoY+TbhZndfrX8wPVbpA7UPAABijSRktN5hdexoGWVT7znGZYdGctVtNOEupnIX8D+WebQgJ2GCCBfcUF11ybeZagRBzd4046Dsan2E3VWTiZarBpWBOAIXkI4G4g/kaTPySFmN5TCYLGj0knrcjiV8+Jg59YMco40JNS0sTdRzd+B1JIW+aoo29CUkYagFdRVGRUgW1lmkorvURlQTBWqZCTcvJkY0wedannnlx6uFuYco0ZGHi/mVkkiqTds1Vzbc63GpVx1lnQm1XOA46lBtHE50H2dOrppwfxec+XczmEG5/egQgOU+udOVGiKK3/VA6NNDlJZ5WUuhaWa12C2uk886gJbLCfitqlgAsFZqyXVlXGanFnsocig7E2KdCb8+UqqYyYGrUlqMOGKy6xnn4UaqiK6vkdQd6ZK2ywxB5rFYElQhste/wIVm1qMWW7bU63wgasWd96Ou7B4fr6K7C+7ilQrwgnvOV3Dg10L775IOkcrfzKFKWF2rpGbE2dKqTowhEjDG7ECpfsa8rDFstsQxEJdDFG/JSG0oOIzVShnCGLnFPJ270L89Ew/+rpQOK2M6zTXDGsdKcTD3igxfcC2dE9+/60Kzgwhv2vpN2mhfBJaKON9NrhCsS21FTnuJFEBGUNGNfVzgrTfGKD/z02UkMlRCvT5GZItED+8TRY2u407k7akEeutriXFmTp23Cja3XNWLsKpM7OkVOOT3xH+rF1Aa8WFIaKk7s0ySAlPhDkjtdue+OMSy45OLpDjnS5IW3Euc3RIupRtaSLE/bp19mqupTjvp4QqO4qlKTt67CYzjrr3O69472Hn/bRW4Wa22XlEX/otFw7N6vyMAZ9bWy2Uun8ZBFvh/iW4PxKUDu34572Bsi9dcCjgAWEx/e8Bw7byeOBEHxgyoB3PqYUpHif4xo4zPG+cDjpJ6iRH+rslzq0pKxoMjuZ9AjiuOyxCB0wHKAMWcS9xilwgQuMYAQneJCRoC994PDc5/8s1aYPngMc7XNUTKRTwsZoS4QJGVj+opg5dxlsYDF5IQxjqMUtchGBCcRh7R7ojh3ycFTNmsgF15cicMDnJeVIxzwC0w5yBK2JCvlZTaDIk59ginKVU0jm0IWPTzUNbe4YiPa2mI4tsomR2kMgPCY5STGW0YwsyxFE6FY3NuaDd1+RIzhywzXWTepR1+Lj39w2LisZDiSFXNnB2kGQRqKjkSoxhy51qRIvqmN7knRcJR2ow6SB5HzoWyMbeae9diAkN/moY62aqEqAVfMsZUPhnl6GMmABMJFutOU5OFiOcvKyl18EIyXX6ThwYFJl5gMRJzt3Is3oax5HgaY0l3j/zVW+Bnh6atnL5iEPd6wjnOj4SjkXukt0/lKd67yh4yCYtHjSDIhBXN/D0NibjrTjiEskSD/9eZYUbkqgVyyoQd04zoW61JzmOMcW2SHJiBJTHmccFYgsqMy9sEchVbnHGwWiGjzqhKT6AehJUZrSdqJDly91aUxlSsOaDrNxFM0pMkWE0c88ZZ4DgWbOTPKcXY1URmd1y7IKhtJhFfSgGyRnVKe6RXXQdB3vyCslsSpBlpmvWT+MiV4MBcSGBKZBentMWp0Y0iqtdVkKG5Y7DgiOhEL1pTFNaF0L+A529tVo5JLbJsHayYsMqThgNay+3mhWf95vlY8VlUCBVVDK/wpknLyMaWYdyo67GhAeWW0ZPuRGIFbRxLSdgZZENGMqrqyorEhNpVElFdvHXtGbjSuII3P5VF/a9R2XjJeocAMm4wbFXnQDUkMUtTO9LdY10xWpnLCExOpuE2VknKxAbJlQNsnUi+x4hwSVqo8P0cy8gk3IXhA1pnk0SonRjbDJ7HvfhV1PkelQx3ZhKFN2AJdYwx1IgQ0svAORNieDZXBQ4ZNYVEqYn+/1FoUrHC6VCoR7vdWwZWHo4Xocjl0CAlNdTlyTFCMqqB8t62tfPKn4SkleOspT7PArD4HY8IDsUIeW1SFg2RWERzvq0dV4Mhwjqzdn7WsUE2PMWCZzKP/KWmKrmpimUkri1MsJ0U2HeoSZ9PREWu3JGVdSMivVObk+R53MkiMM53ZtsyD1GJaPexLnqv0JIgLRjELmiZyMpBk18xubHm+1ZDa7BjejbHSc80Rp8IRVyic7Jnl1o+lVbaYg8zTTqzK2L9gwLyF6tKabX93oquAoS+sapZzjBhJ96GM3A+mzUwjiFMCYhNCDI4t+Dj3sD33H2MgqSEj0wb+HIdGQDAPxcJ39bB5dZlV4KVGnOcJrbL/m18M+9Sd5MqDc7EZH9eXT9Loprk7hY93OhjZmFj7t076qI9du1POgBOxT5ju6/tZzlCvcP0jPox71oIfIIShykPv44Pj/YHe7F+7w4fwF4l1xCR6rQ51IKebiUlK1stiKuGzOY+Q6fKDI6QFye6A85e2GyLPK06pXjTVWaqYTze0TJ3zjfGyNDmjJAOnOCMbj62AHe8lPfvCE05rhapS3tHJGLfdB2GMeW97V8w3nXoEWggORR9j3Hvahm7zsCV/40uuVYjTPY0USTzRjKGTzueuPV3s6ldbHpUOBfB0e8cir5jf/db8XHeH7EDyCiYScFOUt29NhfOMdXxA8p6W61yVo0KsMDnhs/vac77zfjY70s/O0XvYy0vE2xm2Z5LHqfWO9lBqm9W5G0HHxGMg71tHb6ls/wO/oe8kBv3K0E77wMB9q/3306DOrK986TJWlDt1xeXgIxPpavn5vNd93kKO83aHHDCdJv5e7DRrU42c6ind+kpJ+6LZ+EfUO77dlDGhX1Ud/Ymd/gLcb+udyrYIzbLdaAPgiyUeAsYEPSAEqiNMytPV8CbiADbhl8geBRFcP3Nd96XUcGAM64seBHeiBrwGCjNEyICd7EBQPEQVXWaZhOpaC8Td/2Td23Od7dCODUWF41bKBARhsOOhPPEhQ9BB0l6eA4DCEXgRDRhh/eaV7J8duTFhmg5Uv/yc6qLd6YLM8VFiFY3OF8pCFWjhJXMiA3uVL6HCE2RcP2zeBwsM5xgEk7cNigyN3NgGHNyiHZv/hemfhY5/Sg1g4e0Boe3Clh1+4iX04f2Togki3cpxUiE/HWsCmeozYiI0xDiBFUiKIQq8RaTU2ew8EhHmViVv2hebAid+lfaDYe/pHTxjTIGxII+WXinD4GuNADufQDvtmha+oOPhzKZiCdzp0iZo3EFrGid21i2DYW75Yhs82PK7CIKFTaHCCjIrIGMuYDvZgFRj1L77SHzGRTbFRZde4hVyYY9u4RbtUDrrUh9/1h4DYgoD3e4eSL7FiDqJzfOpofoJTDuSQDvdgYtH1KQP3N/jodWHHhV04hDq2SyLZiQQpdkRXdskkjFBRirIyOqeIjEhBHy9xDu9YF8OGZz//ti0bmY/RJxDvUH069lQiuYsDWZJKOI7pk5Cf1pBTwhowOU00UQ7n4I6BxXo5+S+0CHbSx48wNJRE6YABhn0F6YJIWVrG0Q8MgniSkUoPCWOCw4rOOGQEeJVYqYV6J30/CZJduUsC+YBGSZahB0RnopChI1Lw85SpJF1T0o5zJJcEUTEXR5d1yZE9CQ6Zl1c55o8BeYRIGIEpF5g95VXm6D7pqIqJ+Sgf1I41KSJJURX/Rl+OKCO0505Dp3eAOBBgl5f9+JWcGWCdB4plqZKfQZhf0ZTKYxbi8BIT6UwZp3HKsm8nE5tVQnt1CHR1iJtfh5l6mYKeOJZlB5pmWYj7/9AgheGS9UMfQQOXaMQbMaEb0jk2s1mbQoedufmTYeiX3vmZw6M+RUKcazlxNQEd5OAOOiUXAnEZDdGa/aODsPmedRJBBLF3ummEnRmIwSmcgzWaspITNCKV6cCcG5ET7gkOsQSJDiolEEqf2TmhDdidFgqeGIovS4khe5MaEsmK+MRRNPGMykYQJlcPJyopKWp5EsqiKviTY3iS+imYxZMzUUijj/ETU0mT+vAww/URVToQG9J6AjFyQSqks0mkHamdLeqbfvedv5dR0SJoUeiSRNUxAoFTGfKj9MAwSESi9iCLl1M2Yfql09mnfKedIMmZf6ikSJmU98KSTOKmcP/EjHJkKT3odZgnDyfXcax0KXjnp3VZEIEqqAz4gL+JpmB1MWgGdYu6UOBwDu6ARV2nj1wIiECaIQdndJ3yowSlqXLyQBFapHkpf6D6oinJn0WCloeYSy0hkW6Km7Z3e11oeZRqcgNxcPfAbh8xq7GKg7p6jz2RqWJan5rnqy4KnMLDpGdCrM3hIBLpqAUxfdRXfQlRkOBwrQTxbNQqmbgaG5XZrbgHrmZqqOOKqOW4WkuCW7uYDgKxrL2aEHrFEwcnYv1jovf6Gvlqmbm5or26gvkpiqNoN/U2sCqxPeBQQPL3fr2VE9DaP58XsUiRrZPRkRbLr0nor4G5sU3asV7/IVMDcX1gyQ7NShPySald93EqCxQs6xoue5nfen1JKrMIZjfs5bHo8JEjS7IlSxBj+HUR2qdDu0pHi3u4F4FGB4NNyLHXdrOVJX+9+X6YyYVjSBD0YDiFpKXOtrVyMqZe+7W/SZbjyFMX8zllyyZu1LP8aH1qixagN6J0ayGdere5p4SfWZVqmpA2a7A04a4+yawKAaQ5maWxWXkRZreMe7VKOK20pkZ9W6qN0z1wxROE65GJCw5vO2ygG7qf+J0zK6wnAoWIFBM8WxC9+xrs+boy4q2hW6gGCYymy7H3NBh4qBC/m7OR6B9XyrmOF7s4R7y0O5bAeaiccbolES6T/4WHuEd9ZiGvXSpylkqA1ssYWouvSFu8xmuozxZYN4OWGQMvBGVDd4uXPAGvbiuvoYeD67uy7Rsb8Nu4Fjq/fFs8xFo+tBW+CHuL7Xp9SAFywqsQRburE3sWByyWBSm//4q7XtXANTZZXku+KxgUFhybA4wWBQwboYuEopvAIRy59aQV2DVZCIR9ODayz3vBafHCWMsYB4zAIFyVF0OsObxSCQFDPeG6ljkQ5nuvL5x3MRF2RNzBMwzCMNq3+6AvBrW6AsFh5lAQXkmU7wcOeYWbF9fCaGGd3IrBRbt3aXF72Fe8Jkl2gQewkutcA8EmIhlVc9VLOwvFU9zGSAHHGf9cEHHsGvtaxLULjLXGfyN8v/bIYbglyFLljZxZE4h7degbEz/byAmxyGjBuHeMx9prdKTLniaSIP3wxYrCqjFxxlJVV1qmxlKcEA2KyD6ryFXsTo4cw5C8yqAHfJTcf/tAbvdQSD+aE5bFl7j8kXGqg4YDsdWLvp5rIUWcytnreccseBbhVf4Qyx1BbrxXqzzBieCgDtR8yAJxstEVzKJMi/pRxHbszbeXx3rMG6LHKvXEEctMbkdnrwrBgO3Ms89WEM4GgnYonUI3pMOMyvxqfdmre0QXtlX6zwCdYpihG9TazNaap0Dhzu/3wvoQt8LcuXUo0WxcE/RH0RUNrhf/TYasXKW+Ic4XqCAC7WywNKu1eq1DHBPwAKTUy8vNjM0nOtS1J77FO9NQbdFeG3Z1qMc4PYgViF6YIdADLdJAHa/QaodDnK/1cA8B7LAMTa0RRsqwgbW2R0nwO9M7G9V3u3cteNPgQIFop1zlzNXUCtQ/Sqc/SLGdlxAsd9QSpqv03BjY28HwF4afWtGM64u8R71n5xTmLBB/7cwJ8bPRB3bw/NHBy2SmfB1gF8GbJ8NoC9ll6quqzM/SyrlnOBEfTW5IVNAk3dlZqJUrnWesuSosN8+lTcBV/L4XC9WsTaEwW9d2/XnTmqW+lxm13cx4anB5eshva5vxsNj5xt08/+HS+pq0UZ3c97nceGvXxzu3eY3VgscRKf2woLLCclyHkNhnA7HMIfqllvjZFiuoj82ZLaqCyS3Z3sx3kazel7bVGkHQS+Mp8tzZ9jfa0ZZpCkpu3QfRP6iVk0S8vqqC/z2o5D3XUp17Bv7BEojgf7LVIE3d/XHdIZe5SBHcePqZZ52r14GPewfX+wqUyg3iId6bSlvgJW7iwHnfvgfSBG3N8RzYD44UIzoVWeopw1XjHliLp71OXvvfHs6vrc2PIu6X+1ziQ+e40E2BPZ3kKg1pQb2gOVFrQLXiIGhwZu3mSDXkBk5Jl5iAOx7VfE7TNY3eY/55OsgjoYfkKW2tCf9RdFKeFuzWG+tt256y0KsUUZRe6ZaO5THc55oO5lNt4NU5dj+KcuCAf/nX1V6d22resG1eE88t28sc56zsT5c+65WOz3yezyPu33+O0Z4X6qqOf5cRy2gO2C8uxSnHK29u2yAxNrTe7HrezXSNz0ga5iWpfWPegoEt6qOu1+59dMR+rcduHUdR5jzyGlo7SQnh7Oqu444909L+rWE+5NcO6ibHezpI6iqe1Pa+6L33Glu67cGLYDnh3U3tfgSx7utu61ANycxt5/PO5N5u5EeOzpniH5LuGo2eECvnwr3dE5R08Ajv7O9+3DJ8tRVr5yjP671e795+7/i3cK+u1ED/wRsSzhO8EexmYY1IEVEHG/LqPvINn/IpP+/07ustf+88AvMp7R+SmB//rq2N4X4+P/WY19/4LPTyTvQr/3dH7/JJD+UiTaKqPhlVqt53ChvgHfWUXnsFT/URhfKTjfVZT/RMrugRL2JmR+jMvOwxQedIod4I8ck5T/BmsU5sL/VuX/Vyv/hCr/VbX+/2PvaaTeo8wsxVYtm05sKEn+45ge5S3/bNnud4zvikP3uOT3RbH/l3P+pmSOimHhSa4fdmITxngY+TYfA0ge6WB/qWftqkz/jVSYuf/vB1b/RHn6Uq5/oql9dyUvMlsq0dnxYGj/sFofsUy/uU7vu/3/in/9/9xf+jqn90c5v8rg9tdWLfNfHbjh6n0X8Wuk/9II+dzq7926+FH9z9p//9LH/8jU7+ALFP4EBwBQ0eRIiw38KEDR0W9OdQIMJ4FeO5A1fx4UN48MB17PjR40GQJU2eRFlS3kqWLV2+ZFmxJT2aNW3etFlP506eOu39xBc06L17+ozqA3fU6ECC+xA63XgQ6sapURMehWoxHsmRVg2CFPk1pMiUZVFahJlWrTycbd32hLvTnlC6+IgqTYqVaVWpDftJfOiUn1eHRwuWJMyRLNeRZ82mXBv5pVucOmvGxayzLl2lRvMuZZrY6sSEfA8yDB0VsWiHXQ+PJau1YkfZtf+1qqXnEtxaypl9xwW62W5npAVBkzbd9ylg1gUJJnbdPCxCsK/hxWtpW7vMtDR1877ZE9xvzPbkCg9KvLjz5+CSG0T6XnrBvwcNu2+4/vD8lLOr08ZupQBh4k4yySjLSafxyOvpJwcf3KwovPRrD7+NPNMvsb/+Ig2cfuRraB997iEJusZMmm2r3eSJx6PrajMwRrZsWgnB8Bgs70EI68qwNOXm09ApfUCMakTqTLTuPxVZKiim22Q80MYb4VrwNx2vDK4uqiy0MDnPgDRoIah6PKgoMFv7rz95VoSyzRoRrMeguKo8iEEssayLRKvqI/JCMut7qioyHboHnzNXK2v/QDfdpKmgtnaqUsE4H/Ltzisj9GqhD7nM70yEitMzKUIP+glIRE9qsUkm2VwUptxmdJSmei6TlEpKM7NUR0z3/JDILwkTM0QRMzQ0v6DoNBQ2rx4DsNVF4RQvUgXlnFTaXO+MMFSJNN10vuKKpe+9DhuyByGhqpxrOsKYfdFZRh+dU9pqF6RWrmsvzTMqgTTt06q58BnUuM82mheccunkj9kC3X2TxpmmxKwgW+Ws16d7d8xXon35FRXIf61CKmB6G5o24ccWflfKt3yTeGKEKs0VvdG4FdHTxIgC16GCdzJU5I3YRblNlXtjWd6CK4YrZpn15bdmmxPLGZxzG6LH/yd8KkRzLIXReknVyIaGuGiXq+XpYgfRi3pbMZ1+2rij9Cw07YPkvsy9D+U26B299SbrLNlYbOkgA8FO0OiSW4Y0IfPsvZeuf6f+NMN91oYK8ofk7tEobYvF+9iEsItzSJ/35tssGBUVPErCq0bcZcRfrsdsXdHGe70hJ+/V0/vMBRfvhBSsKSN45JnUd9L3ThLFJ3UzaHDCf6P09/Fkx1i4hyjcd1zp8IrK0IMb8twgegyS6WiEjue7b+W5Zt5r8MBRmTzR5Ird4ouX7jTQfr06Cp/vFfdK1CyTEY0kZB15Q987klcS9nWteZGBX6wqg6PDEaxsi4ud7IKSJcLsrv9jYDKK7wz2P96F72UNWUcKVZjAE6WkIYHbjfsCF7jxSXCCRSNMgw5mNv9lyXL2Ic6ndPelg9XQKob6Yb0MqMIU6m2F6TPLC9fUPBmuqkkRtGHYojW/CxrkfmjLTxDbZp+COE40JkTIT47GRDY2EYpl8cpKWAXDgxiRaPFKDHC+90X8kZF70hGh1KSWnv0ZRIT+G6BB2shGvbUQJaJJS0LsuDI8WgVXpRrhtWiXtuJ4MDEfu5z30uOhfugnkA7Z4KQaFY9FMtKRJ4EkTDZyxy165ZLl4iEYw+jJMwoMcsWaS3EYkhQ9Re2UaGxSK5n4jlfCMpZWdIiUamnJHFFvdkn/dBsvAdm7nHluWCEEZtuU6UbV0OaZU5yljaapMytZ85rIzOavgJQz85XwlA7BJAoZSbp1RccqdHyINHlCzXa682x04d/TzCM9rxjRkhvZJz/HmDo5RsWh8HPLQw13QYP68J4TBWlzGBlSKVZ0lgihTFSmJZ6kddSjgiRpTME0Upk+EJ0nrWNGbxWvlrpUSwYpirY8Vc+R1VSfrSFpJBvaFoz+joJ65KNQJBTPiZLQkBUcI1YPckCjUlSpWETpTSz61J42ji4SWk+hQmq+oMxKOhclTKO6WlK1XFGSwcup+BJEVvuZVary5GIOLwckuM61bQ4MqFzzSkmyalAoWDEs08VaJj7ykexMNonsRkxq0WjSsrG5lFBTCikdtuJDlQdRUR3nRdSAOiqzUZFjbEUzPsbyNYOaDO3kwtUc1kqSZG5FbWpDCVyrKPa1mlXVfGprW/NYCmCgYcgwWZO4xBgRUka0yEMO1lbiHvewN50tvGxLPzyl53bDFJNa86jVHBZMK/4aj3Gj6d1Yskad49Xh7Iqysfqkd7q91Shpm0rfMcqWion1LH7xtF/+0udD6iXoUMG0SgI7RLiE2exSEzzeBd8OdxtKrwgnVTZPFZY1F/ZKQAAAIfkEBQoA4AAsAAAAANwAqwAACP8A3QkcKA+cwYMIwdm7xzCfw4f5EkpEyA8iP34JL+7Lx5ChvXntQs7reHBeunPnzJFbOW6cuJbiYsqcKXOiwXDhDua0ybOnzp8JcfoER7Pm0IMtkyI9Cm6g0572Fi50CA6iwX1DL2rFmHFrxYcdqSK8BzLdSZTkkiYtWpRnTqFM44LDuRMuUJ9sxclVO85gS6ZOCfKMGhai2KpZtQ71p3Wf432KEXL8GNLsSnLlYOad2dOu3KF0Q3822Ja0XtI9+YJTOzSwQHkFexa2GnfrUX+4cffj1w9cb4oXHd6jbPZcWpcxkedFuHP059Ce457WS51oXL7Y+/Z0DS62QXsT7xn/jijxsESMF2/nxg3OX0+Nwssa5ztT+Uy6zp9DP9r8YPXq1qHGE2urYccTPAgS5B1Ps5mX31Fe/SbRP8BVNFw76bCUnX3iQNffXKPtF5RonfUH12lEcXZUdqv5pd1ECMIzUHfyzDMPgx3d8+BnXvXIFW7/BNlVRSYZd9k4x2nWoYfNRecTk0E9NxRN/qGYUF9/Eegilgmts46MAnVnkI3h5UjSQQztaBB7B2k1Xj5crcmePxQKaVBwGBp5mYbIMelkQjGNOBeJN32oJkIApmjllQYilaVE68wIzo2TzgPeWGZ6pKNCUS2UpkQ6fmpTbuC4yVGODyW0HpsU5VOWWcXp/6mkn4amKNFbIh46ZYCKDqiaXwX+JVGYJVV6Y6fg5NjpslHZyCxhORp05lEbnZpphfysSqeQu3FkYzsgYXjWcUv6KVGgt3oIGqGjJdprai8Ce2VPN9po6bIdNWvvvvza+6xC0x5EXnlmQitqRJG1l5udpXp1qnxplWtulTfpBOWT+OH3mVGmoevcowktOCmnz3bK78j2GpvQpSSXTHBHlvZr6Xu8LcywwrgFd0+eEdOUq8W01iron0fVpKKKqQXrqLw+lbzstyGBG3VI9MrM77P8Tg3uyTxBZnOQYCOUcz72YKjhfXR5DKJoGsfV9saIWjfdokwvhaVSSlUdM7P2hv/kztQCtQOO4AYRPqbViPer9dYp9wRnttuCHfZBOZNlNrnlthW0rnJZqfa7SyF0N4F5T5R41lE35dpAi0vdOuqtx2644xdFLrlElZd9EubhFBU00ZzzhC7dn/uqdLwlyXz4vSlPrbprka7ezt+uTb/69YELDttRcAIp+e1iWwjSfJv9LnTwExnFWWlMlZ681ctbHbVA0a8DazpeYr86mAMlqL/Isume7cAXvn1YLkOa0QytBoW+zgWqNNThmERUwxqtnW5f8fPbQOxnFnTcz0tfAqEIR0hCL8VodQWRlOME6L3IUS43/NiI7pKkwNCsT1D5UReIbmU0KiGqPsICFpf/gki1xVHKWGSyiQbplw50oAMl53Di/WDlRA/ir4Qj9J//VOiThtRMW3MKo87aYaTMuAQ6vhuafjYXJV6BDlBIs9uWYCMP2YnEdBgMl+rg0cEnQhElVPRjFKUIK3YYsoQn5OJRxPM4MP7DPaSCIdnIuJLMSKx3PhvR+dwyqAVO5ENxrFLx5kUjOsJmccUqFgYTMr2mgKOJKSlHOcyBEiemxBy4pOUgCYnFLyUoRnFpCGS++DWcyYlIu7OkDduCLuC5BS7myxgoI5g+o7XGKafU2uCO+L6ZHSWWsoSiOWRJTlxCsYpmOaSXwLHOg8DjM8K8SD/WQ0CE7IYsu+sTTtD2/5KVdPJETBFKNPfjpOJthm5+CQxs3EFHbUpklT4h3BNpaZBzkPOiszRnFdXRRCuuQ03xrJ336tkmA5qtfC85RzvukY5L2uQthXpbof45sY4pang3DWVCAmMQhsYmdfnRVxITAk6MlpOWVXQiRx90r5B+8Xs3W1NF7IHA+sSkd+Rox+NWc1W76JCmmwRarvpDpR6yb1hPceX26DjUz2DNRik0yDiNilFdOhEc6GCqp8QzTMiNlKR32tl81JKcc8zjcflIhz5xpcOailWgMf1QcyJ4UAmGjI7u6KmYaNS4oLJMqJQCZ1LoqkuDpGM0TWVkX+f5Ncm5pz0KQ6ZxZDnadP/Y4yEbUWxXB4qrHXbSYgxkzkxtlVObinKUpVwoHZHITV2Bx16xwSU5EXLUuMBmHvWoR6dmM0zWthZsr40kP3ZWHMyU4xzp0JFVFMvb3npGmsBr0k44NrzpxE2nBzFljU7WXISwbDTNyiznaqRdfORIH/rA7Wq1BdVH4kw3RBIXeldKHrGkoxyX9CRM7+LMmNoEvz8EEEIRwlauDUZNzYqrLXPJYnCcgyf3MvA9EJyPao2nu/7wbmvDu57gUCYkjKywQ8g4Dt7e6qXruti5zrWZz5jYvyBdXlPgYb8qoqTFO7WUjPXxGBubySGO0Uo/xszgF4rRWuNBTLLaQY4ME7T/gWDFyw/fiNonfwekmzrcQt0BwqSa05322DKCN4JgZYEHWmDuqzxZKzZSxfYrNhaLt8joZrZVTE3Q7LBxRSkgGsXFzgp5UKhGPZyPwFUgCFoHO5KqDnasYx4GRnCh87UsieBjy49JmD0ZLafdxDDN+RBXm3/nW855dcP+CfGi7NtTRdpEeQf5L08clKwgg4Uh+BCqKV9DD3oUuGBP4yYdvf0ZMjfaPVupsY2papxKZyx4hoJs3JSN0NPEKEbb0xtE1fQmiGTq36UON3S9I494xAMe73iHweXh7UDHetD7GLNByBxehd1pK30lmzvOUWQ23sU5koXmDsP6YXDcO0bx/yCWvifyWWlP+8aO6be/S80v/RpEHgg6eMITnnOGN/zWso74mIcup/X4xkfxyZC76+I2Tq5Npg6EFAhPLiOmtJXlUYmLzMcD7n1hVh4CjtHOE86OsSs8Ht0uMD4gPvTe9AaMvXHYcEwybPM13emfLHZ+RPgOqi93Itl9bn/j5838AJzWpsbsUxD0Di+9w5CQj3zCDZ52oHNZ6G4fem6IfvGvkLfu0UTfhr/KZJ/wve/3fk2+nSyzrIfH5XmWyFvBHph3JtxLkVeH7iNf9rOj/eczvnzbJa4bc8fdTXTf7cWcyfQSaUzJzjE76k+uerlcUFrVdpr2fQJAcNwe8roPv//4IT/533v71msPs284n2OKv7Yx5FUmlHqrK3n/dm35obrf98zWptVcv/4SbaCVOE5DJrR3b42nauwQfqw2fuRncL9XYPogERKyfrx2cTJESWfUWPAmIiayI/qnfwq1X/o2D/q1XyZ4aFl3Qc5SMnB1gGOngLqXVBsVfpLne5U3gTyReY7WMJOGQBuoLprGH9LUQBBocCHIPz7lUyQoe/93gtelgiy4L3xjgjC4czJIgzRogzdIeeR2EG7HFIyRgRliRsr3MzsCU00CZ88Dgamneqp3XTahL1BYYlPIgnuGcIz3eAuoDlWkUTXogL33ewiBeZz3HgZUJJihHI6VQ5b/xoY8oXhwGIfXhV14tG2qd0FQmDgLdXJk14d/mFFauEvosHtnRw8JMXwQwhE8MytCWH/IBok2sVb6xYQnOHgDZ4deV4d1uIudSHVkJ37oIF0sVlfmUIqtdnYJwWVtxxMUcieTlCE9s3RpGIuyOBS8SHumZIkrM3BWk43guG1JqICG5IfDWIzGiIy99w7L+BgSVxVYcRDP6BsmlU8yEXr6AW/oI4kjeHUKUQ+nE44C6Q5JaHblaI7SZVTHyIUJlxDpR3RehDsxdEA9Q2wg9yDyNoRyUYev4VP+aA8AKTOYqD+2WItJCA8GN3YH6URzdVHHWIqGxBNr14xgNhG/VjZm/xOENUVy6TNvODRcGcmTGzmStthfH8Fc/EiStdg/IXiE8fCJoDiMdYWMrdYT+BBxYLQwDUMW7lBeOtmI0uExyDVQl8YUqzeLJziC8lAPeGSFSfk/tOcUJ4mSEGiQC8iSR0WVNsGO4HCV8/Q9I1UqrpJMSrJ0UCc8PflSZNkcZ3lZBWFK76NKS1mU2VWZaUmS1zOXVFeXdumHLPaS6gAOuicRplgPEddgrmUhGsghvWNkTAZikdVe+5Egq7dctLh6nVUvNyeQk0mSmumJ03dvRyh9j2eOSeUTNmia/YCa39MeZJMOKjEr7oYXYhlKjCWbHpJIlMibLzgyEnGZk0iQMv/ymwXJc3tonjnnlA3pfSt5V3FhD1jJnM1ZFSYRnYxoLoRiWaVxndjJn9qpIJfJm475lmBCnvpHnMQpnE5pcAbxieJ3FGg3k38pn+DznIP1lWwTHS4BR5rUnwRFF1SHmdgEhduZlgZ6oGMndghqdgqqng0ZjKLZE+VHDw85oRQaNuPFM/LXiMiTZB4KX+FwokJaoqgmpEYKjOiZnpxpdgcxmk0ao+BQdmhXDw/5VzfqnLpDPm4mPMiVLj/KJEc6pEsonmFapkmqpCkpfezwpAkRmlGqcBKIlQN0pTlqj8qnNtqBHHLxpR9apkJ6gH66oG44l2e6oMQZkwbhpm1adt7/RqVcVjM32pwV0Yocgi5BRFxuw6fZ6af6N6hgAnacSpeCaqSGapeQB6Vt2mpTGmjMaKORKiQ5WkYbYmyaCh2hinK8WaS3ioRCCg4M6n0vunO8t4CiqahvOqVABxmu+qrOWSR6QlvY0aU+WqvhAIEDIagLinJHyJuKN56BGqYNup7syIfDOprGKqXnl35y+qq3M6mxUkmE5UNrRK0ayX2NmV9nqV8Hx6sGunNmyqTkWq7ip6gKl67CZ6WR2h51Oi5mVKnS+kn0CpvXeHM3h5K3qpkrKqzDCn4DexAFK4GtirAUCo0Qs4guUammMa2aKhOXGm3oxywNFBsFd7HlmbEa/7uxfTh+DUp5VJp+T8Wuz+gP9ThbDRut1KSy/QlE5HAO2ndr2gezLeN6EyGzN3dwNIuiNguVGzuwiOqryKqurAW0FMIYnwetG8IhRPilLHte6XBYTCG1+UFH8WCb/Gqk0heCWXuzOLuAvHcQXztoZAa0CjuYREtORos28baymPQS5gBkDSOLJziodfuveXt7IHSoe7u3fmuwISu2CkteKQGv8XqGa6i2bIEkKtV5cQJn+jq5KOenlWu5jqemmau5BgF8jxq27DpxrtKVaNGwbIFJHtoxyXG65OAOI+E1Y3YRcym5rXuEzWu1m+mplIugp6eStWu74JB2rOoYususn/+ro2txj7IJL/TBsku7Um3CG8vLD1d7cti6oJF7sdY7uwYZrtkbeQjxc4P2swk7uJRamPdxVkJ0tnmBJG17GF0GH+/bohAIGwu3cPg6s7dav+twqNibv3x5u9kVa8r6XcwpVdEYusB7thMRL1nisMlxXu3wXxHxwg2RD/pwDw2srdtacHM7t91HvUe6ovaLuflrSBu8vR08Yx8ssg0mwrpTXnvSxOSAEJX0mveYOYXVtjaBYGjSEfhQwzYsqPkmMtD7myx6njEIxEK8t1wrxPtbxLn7vVfKGK4iLmfxR05MW/QGVjY0DizMV+rWZdUyw1p8a1wsqt33xQkRD14rxnn/e7mXa8YCy4Vlt8aBZsTsC8KoCcAS1sQGTL5BMxPlQA5ty8eRFmkyjG3LMsg3fIL5dcgGIb01W7kXfHu0i7MDu3tqfBC4672rkrBwnMnnG7zR9BItAcotXBiOMWuHhxD1gMoPDIWrjBCInMivPHYJ4cN6W64HmcaRjMvfdnnERE8h3MtmMU4CbJi0giS05A57hW1rh8yikm25aHJcnMo2R7HQ3Mque28IEbuQR45oXMuQvM1ETKVGfMS7HMKCucSD1VXmzCTiUA5mgbxRkV3ehopseWcTbWovaErM/MA7BaGuDEwSUbm0DNAmHdBrerucK3SOJJ+COXd+My4m6zOt/+nQCBwm1eerBiHSIbnR/NjREowQAjYUrjwRWfvPJ53UtnyqKt2z/dt2B33J4rM4UwQrz7pY+8S2fGYT5Nd3DHVERKmrYRq/zTy3EhHNRI0g1WyzSC2MW6jUS83U22uw3QXVSAyrB3QWKuHEK/FipnVaRpIUS5tXEpF7reZqah0yJIZZfgqO23rWaHnP77TPK7q1Jv2HWtiAAD2s3DzJbWzXLj2pvruINL1Pa9vX6HVaqDYRtmwQp5pz2zsUfjqgEKzDAITWl3UgCGeqhq3Umf3bVKnNck3Enp1roH3J9MmwGOonLGsOBuFLuz3EO/0gUYGmJ+rYOazKA7pZEqGi1//s2zMI3MPIkpqN0sPNv35cyXMaNmTbiqTbybNE2A/iHRf9HQ6XbYFK1mRdcLsJmbERzWrt3QEL1zNonH/4meStVLWsvavazt6sees9tlNlNjtqPi8xS7X01sV6ECnNyuN20c+S3/qNrQVXh9BstTtNxtlM4Ax44CyW2SaNs5sLshCn3sjtY/WJ1UGjx+aUElH0kuV92DeYngxXD95mI5Up4iMOvc2syv8tvcCawSw+sOL91pst47jccB3Bdm7crsERHzn53mkjS7p0ZYOU4QouiP2MenPbbSW2zGXqlCdq1v0tJk8e4DHIsVMe3r+951jeygzncMHnjl0Oq6dCGKb/VhkWpePhgM5mfkukGIgLTn4oKSZuTmBwPtb53LwEt1Zi4qkxSI57TuWj3mpqrr/Q/HMPF2aFTiET3pURTdXjjGErTA4sVku4BOMxLsQKd7srU92DfJLyK7d1K7uiXurIbstx3beH3G2CHnQsPaelkoiU9MmpnQ4iATVzfEtzpVGRnua7B8ln133oF+wGmq0qOkK9bZy7rucsHsRd67dF7nDQ7n7N2Q8bMXfQWbRLi+3gMhHrMFG59OikOH7ijnbbGxvZ1Zf4be5hGuogxHtwvbGuTfEVH8QeaxNT6tRc7l230w+TZik80yHJ0e/pIGCJl2+2dI65rtnFKuRDDMFr/xkV2SbnwX638oykCYh7j3zlTN3hPrGmnD3cGX/WG295wgfh4OUbvQsr83MStL7CqX1zcYjI5nhlQK7gOfuA0WxKjep6OBzSVxu7WBjxbS3cRW/U0h2l8R4XEPj1D+fN6q2VEx4rJx/TUN8SZI5ez9NzEPxRcuXcNfjyDzjBH14PtS32sCt9vdT4/gzvqN6ge7lzuvL2acfxbMe+OubqZDMPvgtFsALr77r37MTzlP6UdynfCLHUDYnIObxwjRrSwRm9Yu/DCkiOWAT5fcjZaz3ETKomln/56CdrSW/XdFIqXCkQsQJIVV0c3V7xV69UQpySu1/YO+fFDbeiv8nD0f9tdmav++Df9lFuhMHfbY3azRDnvcbvHvswDxbFts5vTlNESFJJ5qL5hz9+jFL6lJ+IEADBDty7d/DiHUQoj169gQQJroNIEN5EihUnIrQIz+HGdxDXsQMZUuRIkuw8nlz3DmRKdu/AvYQJk2BMmjVt1oxHT+dOnfV81rOHD9+9e/r07UO6rx+/fk39PfXXL588c+XEjSN3Ll26c+TMmTundeu5r+fQpUNHtly5r+hennu5Fpw5dOpaHpwJs6VEhPEUAgWH0mPBjBkxWuTo0GNJxiQHJ954U6ZkyjYP8uT502dQoUWPJlWqtGm/qP323ZN3rtw4cVezki1rNp27dWj/q4JNC5stWLPovpqj+a6vXocGDyqEuU9wysIX+x6uONPlwMAnG5c8Cbmgw8rdvb+8jHmnZqHljRoFjXT0aHD68NVLx1pcOPpsc4et63Gr77Lo/Kf9rT/fXqpKL3DwKi4heRi6R6nsCGvOOOiao+6ljqwbyTqITIqII3Cc62u670aECSHxFtIMKM6EOu+z9NbbBxx87KlHnnWsmi+c1sqRDS3/tkoHIng+Suu/utThbzf/AmzLwoEQNE6n9kTrqLgIryyspocWE2m5xxoCE7zn4iGRRBNPTHHG8lhs0cWkRuNHn3ncoXNIdKzS8SoefwQySI8ogkgdJI8U9D+6yIIN/z//wNnLocsYOqqpfTbCslKLYuLISy89hMmgmMiUDNQyaQpPvBTrWXPNNs8Dbb3A0jKJHSRXW+u3H73MSCVBd+XVv7DIMvLIRoVbaEp+kNJnIgg/nIhZS7O00KUtNU2Jo4qG+05U7w4Ss68Te/rJnhXX9GxVF53qR590av3PrkF7Q5Idg+Shl16NHjNOJXaMHPS/X38VlqDL8Hkpxpgo+tBZZyl8qTnpZLpQMO0swnbUmOqlp956j6M3p29PHbe8cs39zCl/+GmH1t7Q4XDQXdfxqyed5BlS1pWEi0ejQoNdkuddW9LJnpjuEVdohGvCsmGHI4tWO8goGtNiel/S+P9Eer/NLMWQRV6VKFZFe6qfudjNruaVYk6Rnnh0FTQkl9aWlWff/DXrZ3qCoonoeua5lKaM/KZQI0ydJhzE50aduWqsPz413FSHIipyyVtUj7So9JHHP7sghGehjDFOe2Z9ZbULpCd1lXtJutqmBx/0kNXnnvdovhThZ/+GZ3DCrb12TIRG9Hhx4cFtXNzHJUfe669NThccdypSaKGiNVs8npB+BklaRnc1ki7/7mq969hnpD3w24/OXcTIKL3S99+/2+nq4dFsfDPjyfUseeTRY14fcObRGFAeJy6fxO84OoEbSHjVtpYocGftYkc8BOi/l7QocjM63+28I5H2uY//W96J3vwWVz8V3a8zI4vd/ijHlNH4j0bkedyMXpgx3xHEgQtkYOlIt7nwGaUm+sugpRJWGQ5GyHckwpgIsUZCFaVKeRacXJsqZxoK0uiFm0nVFcGhtuc45Ho4xKFI5GGPciHFJk8MYtK+Y0QJuQ8c8pCMxhSnRBQxUYAii2LXnvi10OyDgpv5CYqKdkWGHAhBoyMJGHklr/AZzGAVbE9RYGIULPHuSiRi4+EORxk5JpGOdayfCV2nQqPoL3JuoiLBwHEq4oVOTF4UCSwVubl6UDAmj6zg62K0D8Ts7pKY7JvUqAZHOX6SfiAzYbmeaMrJpcePL2kcZlJkE0TGcnTu/9qccAppEwpS0JkN2R37/jZEi5VTfvH7XDGVaMdBrgiFKZTc8XQJO2jWo46YCeFOglPNkSBSYNJzU8FiEjtviqYpvowO0w620HJWhpjnRCdPPMk4O4ZrkFxrUzxj6BnQ+LCeMoufPPySTwTK5DobyQmqbAkacJhxaF5rqUERmlDuIK0iB2tWQ4c50ZkJz5MVRWYy36lRebopdh/9lkhHypPfra2ajnpUUDy6y13SxKWyYxFM+qGsadWUiDjVKSfVKZ5OhpCnQNVM0fD4zlJi1Yl8POoq7clUD+5kTE6TIKpcd5RbpkcyslNrUSYVsceICJNhjeNYjZk1tNrPnXuE4v9G52nLAtrVg5eFTEr32tKCTdGlknGPuOahIn1sKi+5y513UovYmih2sY0NVwlXlEJzXbCoffxjZbl4WcxKRCFSxWVnRXMsmMgwKERpTylnZD9ceUhaCvUba20C0cW2srHt5ExRINvWGA5Fl1Wcq2V5O967CTa4zjQjUYwbWOQtd2/NVWheDCvd1nYyY9Vl7HXbyabtplCyX8uteMY7pqtNMLjJYWl7iju9i0JOuS+k1jooM1/6vtG1+M0vUPfbGZKdR71OfKeMZijgAaNNpTURW18/W1xwYPd+p4TnPZZTYSSWlaQYBiVsG+zgDo/vcW2CyRVPVOJHua4yK47JjFr/7OIXQ1Y5gmloTkd14U9ST5qwtago2RpjrMK4RS0O5JBDJByomsh1B/YOVpkcspGJ5iVeuomEJUxh1LIWw1jW8I73WltTUu6Z9lRIx9yXGG8tRJVl8rBQjKfWE2p3eTGZcZwDc5M6I7a6csUzO/Xc4VPmMaD2EO+gVfJPFLFpRH7MaHcxyioU9wPKJ6GJnCHWKeneeH71zDQJsYvHUhK0rbLzcqti9B4EepDQrduzLb2jR7cWla9aTTE4moKS6rz5zbDG6Wqlq0Sb5FrXej5e/jz8xDc1BZqh5m0P0bzsjH640WWE9npGg+1ry5natJbytrkNTUz/BCaNjYljt/bW/17/WpeuAnOxyWvkdSP61/pDT7zlPW2PxBrK0c23pYc3KiYGnCYuVrXylKm8cksq4Uqt690OjehJ5tKCHdaqtCc+b3rXGyKDqx19N95QzVhsTTIiGI9HntySG4xGu/VdT7zbcnYnt8d8fKS5J84PcPDD6lS/tsUrXp0iHm3bL/mWTqdJX8ixVbiiMfpc64o3Zdek4U/3s8RnbtUVS9jamrKStmm8d74Xt79ET/Byi42mldO9O3CfqtzNTRlc2r3im1Ja3yU/ee92eMWKDq/n6iiUsCLeJjBaPGe5CWmbQ55Zk0c937fs0SSPOGg+MU/bu2Mwc0HSfz5800uacixHJv9l9HGmFlhTP3zpbvkmrjf0BFk+SZIJF8EGXYpfY1qmCAuf+NdvaJvPYxPkG7ozJFr57ZvvdvQmRfwDvcdLCl8TvBs24zSBI0ymhn36g8PL21f/vzMvPQ6DX5X+Q67akwz0oqD0+6HvkxHTgYnlWJb6c8DOW5UgE7KsYRPZk4zyYLHCYz3ni6mO8rCaeDgDNB3TYUCve8ATLBMUCjIrGw+9wj+dWj8VQ7KMyr+XyB/J0YsuKcH3Q8EepIxyoYkwo0AgC6v0s8AO9D09Kg+hgQlJsr/0M0BGWQlc8cEqDKujMxUX/DK+Qxbz+yHZkZGYYELvUq+aCAlN0TsrVMPvyLz/6BEgGaHB77AicakMZSs4ygA3VeKM6tAUhtKp+VvD4dMtkfK+7mJDn1ilQRqVKMTDx8E0cQm+QOwOelBDW3K9AlO1GPy4npMtTbwJzruJbWqxJWRCf4tESZQMKeG5vrtEhcjE7tA0vOmOn+s3faJEaCKkLSoWassLVJQ8USynCBSxzPOYV6SMPPNEUAw6VbIyQKynVbrFW+RFCnPA+Es9fyunMnrBhEunQjTEbgsdJmJCWQxDyQikuXLGmKDEW4y1CqExa+yOh7pGYFxEqKMggqksj0EV9TNEeqzFHGscm8DAFgu4Qgqki4k/bVE06YKWhiGTdJS/i7EweLSzFvRH/7lKs3OhJ3y0p4OAvVQJxWfUv1DCtTLhREQEO5R7nxVhyHGCGgu7CY15o4mkMcYKRcD4K/MaDS/Ex/i5o4HsNpHst2kSRYYARmwsyPHAyJRUyQ/SK08sk0oBFYqUPzmiyZoEF3PEyZvQSXl7pp5USlq8SaTsOCYMwvwKuMxYJXWkoYPQiIsYRbMMK4PooA+qL5msl73Tp8rYyh/in4l7po/aDH4Eym7rCX4LyJvMwrXUxcakicRpSlFBScSiy7qMSRujyrDiCVikjNeZua/st4HzRN3CtZMMRfrhty0Cu5pIp6bUCG1Rre64HbvcKRurMMzovCkCTIKEITURy5rQLf9K7LnUPE0EyhqwW0d2VMepkSO3xBnYvImZYBilkUp4xMy81DnlzL6S203exMn9OsYrG06aAEW5+hjEaUxBKwjapCaJWJi+mU3rvM7MbCjtbKiSmTmToxG5GseLCs/jvEAlY0P7pMdohIm2dA4iKpw08pSqvM6JhEj4cUyd6sr8jBFCKiQXS0XchEGgAzN7Ak7WnNA3cs5enIzotKQ0QsgHtcoyUUVV/LdROZf8NI0PRUoxlEu25NBRURX3wDyG2MybyBjL0AgTdZITbZq8U9HaxEwIpU/KsE/9IxGOgr7PXMrBDEIoPRGtTE65UpVUAVHvsE+lKlLDsjvDchqFAZz/PySmQDSvfWAhCx1K+1myVEROW4TRs9xMo1S1MsnMnHFL0rM71rqpGovIQ73LA81T1nrTOLVSAkJEbMxRMV1URZ3QjxRQm4hS1UTOm4DO79i6yihU1qJImbzKvWtUGk0lLbrRSdxS1rTFgrxIyzoQUnnScoo0FH1PwDHBGjPVWy1CXXLUiVM/Vg1RLW1BTlXHxtzUx0S69ykR+jrF6Dwfc2rRyaNSOFXVYvU3f7xIEV1NKK2MAZOumyu9i6spcapWEHJS5pS8yksKq8vPBRu7goxRZk3Oby0TUEEIQmNPi+GQBQy+Bc2g0xOrJuW7ynORqyPWgnGvyRxPwyyWciKTrn81pMvSKYEI2HOdxolh0DRc0XaNUNZS2HiVV4QrGL3ZJqNsVeCczFGBVkPqFoyN1u8QCD6MsIoj2MLImV9qLfgz1XctI6RgWPa4peViTJYVxb1ETI8zEzcqkaixWJvl2OAr08Qwop6NkDha0ZElu6GF05MNPYd9oSB8WWU1SsQ6In79oKb6VO/Q2CnMWYl5mmahGK2dTocK2r6DV5N1VKtyr0nMUuAJleE4IvoKCAAh+QQFCgDgACwAAAAA3ACrAAAI/wDBgZNHUCDBgwLnzQNnT6DDhwLz5bM3r51CigrbtXOXrl1DgffmpRvZcaM7jenOqVRJkty4l+JixgwnUya4mBBz6hQYLtzOnw99ghO6syfQo0iTKl1acCBCh/M+Hs13z569e/eoYg2p0aNDifa6VnR3sh1JliTTuRxXs61bnEt9EnU4V2ndpXjz6sUr7+HThVGTSsQKUSLVilLB8QOntWrGrmRLdk25Fubbtnh73s0cVLPnvaBDizbYN6FAq/dGU80n0J9DfvwMN8aoMOrWimrJVWZ7Ge5NoJ9H8+TpeXNSzcKT542KmrDofQ79uX4Nm98+w1uz5tsHuypKyrt59/8W95C8cp1GixuNO3Q9UvN6x52vfbE56OoQpU9/WL3/doixUUWRWSrpttZ4b9Fl3Hl7zbUgg8rVZ9VVqYnWn34Y7idQP7BB1I+GER2G0jkHIoiZezmheN56D0LookPuQGQVQwxVOBVQF2aI4UP9tPahjjsG6F1uvIknzktGzoQccEW16KKTL0K0jkBTkpVTQ1g+JBtrIW6pU45AgrihP/38mOE/0glk3UTtkIjkm0i6VVyDT0bJ4JTgrPOOlQ8ttFN22W0pqGHc9cdPmCAaeiiG/zTa6HSx2QMekrq9WZN6UHZmZ1Cb6rXOp5/ymRSgpAI6mGGMFWpohjltCaajj+r/xxiBBpJDYqXiYZppe0NtqmKnSX0KD1kxtmPaUVfNmNpW4DD7kI0S7cOdqhgutpiW2uUD5plounaPWSmldatLMuka3E3w9bprUU2uCyyMxJ4kD31JTWjvhEBtNaiiQpaarbbVcYvmYoddVBGt5Ipj7pI2tffrXXMq2Cun74IWrzwW0YsUfRwvJNWMpzVnqkTWXafVjLQxhxWhAevnaJqKiqhWkgpj+htxch33K3EOVywasaXVBlrHBjNnVWDgGC0ydo752WfStulL8qL+wNpofv7EJpKbltUcsYLuCiW2uz7L9xPQexkLUVcZEy10QvRN6PbGWK4MsHRWX50fP99S/9b11zhnKrbEPrtY2nnFst2224wf3FVeFG63aN7/fNk3kWx55tu5Kb5IduFKHQxjTvG6I09ZireDserEmhRjUk1dufLkVu+kNa0w9STnzupOHNqSP+UMumiQEZvTOmQNW/ryxr/O109WkYx31bB+eZg7bl7GeeDDgSaXk+l9PrxDrn+alkPpgJq8sKC27z6ewmXFXZg6ZX1d3wkfWS7wYPPOmV38U4pvKua08pEEHStBBzjSQhKBMDB97tOL8x5ylanRb2+x+RbX4rS9njksbKAbIIPUBhSNEGsdI0EHAldyDnCosIEuPIcK0ZEWdrADVMJBjeSoxiqsZdAduMpdAP95FbjNiA9C6bKTRn7CthOO5BzmKEc5zGEOgbQQilRM4AxpCEEcwg8vUdshkLAmndjQqhxCRBFyXnKT7Y1tiBVLYmgmmJMlQsRtGCPWE6M4RZXwsRwOoaI5VKJCdaTDhojEIeQqWCgzUU9vrdEP38xijoRpJl1GGUc6GkIOhSkMIsIbX3kcIke8WImOUHGajDj2EJOsY4UFkqIsH5JFGapDHei45Q2n9MV6rayRLqsdODJkHfzRbH/gOMc8tGWPTtIEeEccntmQckpwoFIhQ5tHZNKBQD4iCZDgkGUWt2jIT+VpKWGsjpkoF8k0KeYe7jCHeCxzyXNkZTHtGId66uT/OyYxSFQbS87pOIKOKMJpmoGUoQxpaEO9aEedwRTmMN05qw3SkybnsIdEBJLPDkIomqIpjemOApjkZOSVBn3TLAUySELmUh03fIjxDJK0nLQMb+xsp5rgeSs01gSQ2iGfPj0qyhcd7ifYnI8200FFWTr1qVac4S3zNCyCqNJ2ZWJUTicKKa6khGvlaGFQI9KOcgAuSiDNSSmVcpCnRGmpKsTiU8UZ1Zciz2g64ZJAuONIrTrKdhPBzVc7spM2DRWORU0OQHPSVmBp0x0o5KYfm0pXF6rjrhTSh7QcYqOvqAo2WY2omL4iIo1odCdhcSZiEwsa87wDHPCIB1KO+iKM/7AOHiiM6x8HKRB2yMMe+LiHPvSB2ocEV37SAi0/+kpRcFROTYP5V064cg6vpZW1QIEHSd91NIWsj5sqNEch2QGOeghXH529o0Pq4ZDgDldawNwRRNCkppJJSzZ9Golq/Ydd0Niwl0C5anJQxdmqYOQgF5tXYpYi2/IC172a5WuGQisQ+g7TP9vRaz62tt/rKue6iFyOgH+S3lYRGCL+KvHRnEJbeLzjxe8wp0DoUY96APe9+yiTjkMrX+rExmSyEYlLztrfTdE2lUkdcIbxIrd5DHSxr0VkiAUSD3nQGB/4eO9yd8xcAFVHW/d1jFqIXOSi+ult03UOgw4cL3i42f8h65DyVNXhkHfEIx5XznKEOcTlHjX3NYopGZvM0uEyj0aEe7FHPToGNdmll0Ig0YuT17cOF8NZzlN9iJ3vnGccS6vPPcLRmvp2jswR1dBAwUyEWEliGy3YWdCjCNQGitv2IfKWuFYhRNjxYk7bGMLJBfVR1kQVs5TDuvxFdaohhGbUouZpeyFI8mqNJ3bkeoYyfAgie43nX+NY2MMOEJs6vNrhITopax1NkoECXCQvR9rucDMOrY3LLYrXIbrc9qY7/Wkd6yfUOBrMRshlM/TYKYnpNvOIc8KcY+kF3vI2J73Dy8eH4FqX4OA1njutWX/rGBwAHyaAZEZwXfmMPA3/E46bV34e2sSO4Yk5MuymHeNP2bDeu31ILsFBZ4eww9f10HOO+5wTihaTw7wxV6dUfR6E3Pnp8dCuaBTi1qPIPCk0n/ctKR5FKgpE1xBRR6/pQeOgd5zL13qIrBRT7JT4dGEHr0m7kJPsn7Q13gKRulLw0ScnX1058XaxIjNu7RlSdpZOHS+3r3z2MlmHjLLSmt+UVHAX4QSTNjN5Zzyz8sZCBMFLYW/fq64TVC7FzTXf9c1x/senileXvX4H4/fcj+uoXUfvbJMlK68cphdxn9/rJ9jy7uY7u5ksR+1LW/++E41tKvU/mXhBZfkSQL5Uyr6+8dA5pNd2ymofkjqH/0+RXfeluKV/Si93Tla+8qhXlTTLf/nGkrpgiJgeL9CP/tan71TL4tqG+8Z4+yBJrJEV3ucaGURoSbdPohETXbN5DAhK68J+sUUQdxZ/y8dizOcX88BeIENb94cXAKYTN6dCrvdS+bZpdgYO9GAPOdYt/TAR95BjOXEdgpU/ZCZAMiEe6BeBokGBshV/8CeEC7cT8lBj5eV31pR3wjGCO1F4BSVIAnFxMMVrrzVV8qAP/QArWZN20XEdBEIi40d+7uKAPNiD0HQeFOhmsZN8bVgQRTg69vciMoYU+wd2VMhr5OVCuRQPWvhI1cMfE+E3cUJ5n+EkO4hy5rEw6WEnLP9HZTTlEG6FEMq3gaBRh1SCiXtBbxc3hXQGUw4xQyz4h1vVGpKXUpcCfEdxJA/4QennYT/xYkz4PPAWeErxWkVFhToBY70WdDkGiIHoIflASeMHdzphhmyEhiYHUrB4FMPCfkqhiT7DiZmmbXbGeKFFOc9VdJOUPWT4K8iIE4xYfk3YPhCBi6PxZspGgrpojQKYjaW4Nzy1e4CDjGzxe8YIOu8jjeuoHO3YW7JndkOHU3nzE1mzYW5nahEDJ3I0js0YGoPXj6Gxhznxjz83e/BYkAa5D/O4gLpDHuMgRTDRPTezJOonkSgZfVOGb+14jWZ3dsD4VwGne0bCRuSARgj/FYE5mJI8+YS9tZKe2HM9Bw7dhmV7FpOQtBP+MIxqUQ61ohsC4ZGXNEAPqRz00JP+JWVTRpG4pm1EyW+/iJRI4Q+Xs0fFqB6IdmovInfiUGNu+ZZw+ZZkN5d0yZNa2VA/mXFBOZQal2czOJDaeBRZczneiCkph4ZR0hsOcS8Lxpj1xxAgkxNuWVR3KWW7ZnFDSXguaZSAGY/1g5Dilys0YYbooXTJURM1eZj10nROp3fAQpFJkZkCMXbe9mkEKVFK2Y0l8hK6AU6khI9qmWqoaSlyt3k6QZc0Vl5XGW0W2Hl9EXVYCQ77VpthGZhAMZi6J0VPiZOGyIh5YY+FmJau/xgOGFie5lkaGPh0a/hm6ugisKkc0wlcwlWdnql2kgdFtnIrf+OQ6ucWxHluyhgO6zmg7WeBbRV16kmgljaL0Zl97iVhYqmU2PlVvek136h5agWe4QmgEIiWCvqhIEqB0XkUQMeZyxVRMpmbpEaPDvkTKsWQvieB41gTvAhjIRqiI7oU8ZlltnmbKfqZQiaVxaGa1edUvQmjpcSfuuKAtpKjrLWj78VjGvkTfNOUx+QbIfmUN/mfSaSk/OmA55AOy+SkdoKXsVii88ljMXmdTPlVBaISybQST5mMwOmlSnok5NARG+WF4/OIRVaN54imMOlXP5ofBSNYclopEHGhdv9qpzHhlMZiKKy1nu4Zm1Qom7PJaVc2nyeqI8FoU21HGWfZqPzpOzM6DnmqEdqiYx1SVOwJjT5zqboIqIsXdJzKXARJpaBZGYxKqg/CiHiaDhXSHxzyeMBCqbClXSLaYJ0iq115pkV5q2HyqYLIYaPqq0jhkMHaDqnRH59le6LEcsvqmhDirJ2oki6pfVsGJLj5GhuGOwrppQBkLqyYp3HYLNjhqq8qruS6FHfJklRIToAafS4pkAPpqaW4lF5VICXSneSYIkuKqh0BLSfWLIDCd+G6r6+aFHcJU+Zab1sUsv66mbfKZT76owfpHeDyRC2UTAZCp3phmEdiDps0KBn/Fl2l4jMiiqM5UZmY5qz2VlAhK4pKwWnyqQ9bZrIRaoqBRWg36ZROaSBWlKhIkq2a86jncBIVZLPbAWT5gF724jPGp7EKqnqVaa5DG7IstFBghxSbyaN8tWMnC0kTKobx+pGsmKVQ2bJHujmegarlgA7zoB36Ii3oNTJMo2gdWDEJqqw8O5u39rEgm7Zr27K0hBdFCbeqkpGfOkmE2KtTmbe1EqeVoj/jEKbuMLgXe16H6y9YInpiO7baBXVQR3zt+WKrh7ZpG1drqxzdpn3wdbAJyw9hYaWg26Gj+SbkMEjpYE0ZU2OKFr1v+WBY9mA04hfylxciChQIynK0+3QM/8qLkSuraStIBdW7R3GusWhl3hZhcTu30REpxHi35IiW40Cz8+JkyHmVsQO9C1YbVkV6FRNbd0aUD8Gsswlj43ttaRuKusZbQPGJ/7gTv6tnONapW5WyYzEz5JcZl3S6ySqLsJUTuFgasKuBT9aew1PAENFg2iXCCzy5RLsUkvusQPEO7AthEdapYmk/0XUwk/ewDnMkU+RzekmC77mcfYJgyYNqyvpa1bbADZwXH7t6R7wTdmZlR/ttKKo3GVQfHLMRlhsXNHG/PHepTGFl65aSL2xrMWx4bYsXsvqvWrmLvmaUF/wjGim/HDESqFMbJESSpSkORVxIZ2zD2VVlNP9Gf8CFL/pKroJnc1p5qVu0Fx5bhT6rlwDIi9IJdTS2xcFGqBsyaKIatWGaDifhQNk6sxX5iSq5yYqcnB44IVhWVJw8m9IZYz47wU9omYRHXj4rZbjLa3XGbd9bdsDWbwKzUxqBG+YwnE45EjlRcpc0tZiJyD2Li5smI485PO5To5Lsy2d8FMD8yz4XzDWazt+7zhtnq9/mb1o1yikjZNbFpAKBOhwhT55kNmyLgrysaTpxVLWBhEARkRMZzAhtpjzXy9v2niSswFaYzq/Fzpy2cWX3krQnty4DXY5jEcVLbrrTR6hsQl81SFXUz86Kxef4Dq6JfIu7E06IFw2V0DT/7a+bjI56QdGaur9kB70W3G99hlNsZw99PBIW4UDx2h4OGFaonMrWFGd4mNJe+dAs/XnzcsJwFmcxrRTBLLl1zNU3LRqy9b0syNMX/Ws/vX1KWzVkwiYsG6ZQY2xkOBREDNfr1VvX/M86UWU/8T55EmfCcbY1DJS3eMujAb4zRpdxidZY4WnbB1p67C3cdBa6wVtdUWoXiqc0JIlKDMw/i6mMtV7+i2Xm+BBbnRdfzSASjdNWOZdxqWhYhsfuG7zB5mdpMg8G1UehGbULZCziZ5jycZOvN5Sx1bPiHNAQ4ZbUe9xRAtqikc65LMKtfdY1hg/UK9uzTdtDx1X7gNvz/+RHPhWSvQ0O+nxJUvQQgHRvZ7zJGTewRkhjSlxeQYexTrra2ozAeYHfZf3asR3b+pDW2g3UPwIO+jAPmG3eg5QwqJq1MYLZRNx/AjFFXjeFlglTrM3aFn0l4EDfZOoQLMzCe63fB9xg+wuX1+3fw5XiKk7b/rZX91AP6XC3eAoO4gFIqJtMlTRX5x3hRfx110eR6IjTsdzhEDLWFFwQJW7i/Y3iKt7kPPJx/10P8JAS9Iuq5IAuS11FoajlOh5OUGVZlknMAR3fAzGZnTIlDq0U/VoxyKnkS67DKS5cOpFVPTJpr4RAIE3jFRrSWu4QUOQQOj5XfW7h0u2MF4jVUf9y2il51id+XE2OXj9B5/eQEjSkDlF0k8jmEIC7zxI+xt0U6OcNVbkU0aydE0/HvsCiJ06q2NPb36z76CWmJmZyD/J0vwgkRVC0gEN80oKuQHnCDrcO6l3OcxpX6lTmyTZG5Odh1tQ92nD+6MSlE2GZJtXlgN60vMeGbEdyTlDkVIOEDsCMS60n7Csldog94lV2hI+pd2sOGsbO5g/B7MvJ6q0e26/+6DvRo2kS45xO4yGZPaNJxFoO7Fy3UBLMf+S+UhkXe+ie7mbH7iPMoDuBekhh0Gx+lch5FIvt01jW2NA+XPk+7a4hEm9HHldOyE3FihI+Q1IGSzPc3rd0eIH/rm1WmKmevBAzyO5reBSFzvPvvilzmdhIgYRu7ugfDxTKTCbWxH8OGOExYdJS1FJSdUPvAIUvtYvkZemCNFfZnMtQp+4zGHLRDWPrZ9goGfR4wV4ELRBMfvRI73GT/lRZjkY0m0IrlEvgnsV3VvXYXGdT6OvkLYVYbIWaynefRsJ+r+xkdx5t7+RIcbD9YA/ogJP0ZOsvBCr1hmuVtn70ppLOrXM/DoBHuFdlAh19rfhkDhq0/OwqnhQQCn6Tn+0/VffpA4C49V8rKBBrHw/WFsF97+OFlILxIHo5tg8g7zNk3ykEkfqhYRVGj+86weHgYJs9Ig/iJ/sCL17oUGnC/zKXnldeJAgUu5u2//di8oAPwavsdifAo/FgTW64x99etQwRtZ0n1BeSnV5I6xB1VvYiAIEOHDqCBQ2iU5fwXTx54PTt26cPHL569sBdxLgO40aOHT1+BBlSJEZ64OiVHJmyIz589/S9hBgzIkeWLDvu47cP3Dx05XyWM2fu3Dl06datg9dwI76OJznG46juo0CMBwsmVMeu4kWIGO3JQ6nxIjuVHt+VRSvyJD2wKNOOtMfy5UOZXWnai8txXz9+4OStO+czKEF1SN3JUzqxZs23HQtWJWpQHcKs9CSC03nxHr6v8th9bszx3dnQoUs6NVn6I16WLufWzYyRJV69e//38RwqlCC7de/ceawYd3FIqCGtHsc6mh6+yxf13dtsr95v1aKrq2x7XaXwuTDr0vT4sF+/ffLQEeXdGzHYkKwthk543NzVhOzk1QPZcvY81WLFagdpPb8AVKmm7ryLKSXxyLMHnqPWu68eCUOScEL4sIrvoITWiaee5jxajLP+jjqKwI8ENHGkmlw7cC7wOqJrPJ2kq1BCi/ATqUKO3Arps88wtIodeOphSqfYQITuHpFIZLJJjUpMkaPEogypNRZb/BAc4TiCaTyJOMMLLxw7qofHtd5iJysffcSwvnjes4urjpRUiUlwnLQTJHi0m5LKj1rD8iUQmeKSrszCDPP/ojExKhO1k8pE68f61lxTOeZgC6+7Iz+C8k4nPQ1pz+v69HMlubD8E8YDLwqzxkVJQi01HkViEysfR2PnHXg6JPIy2B7aCLZNQXqSozwBbAhCFEv9E9AWVepuIzFdDWnWst5Z09ZcF+qQOUGFhQhYjGQar586NyqxUwIhZLZAZ6NV0DuJXKVWu7PiiWc0XPXVNx56esUMXExrK5fWNTtSF9l2y2IMnCuz/Kgu8rSk18Lr8uUWX4wXepRI5rgS+FfZQB7PI0opNfa/6khdOCVCJ3JNJXJlpLheADXOWON/W4I4YPJiajFBilnr8eSDM1K5ZaVD6tmjmMqdmKJ/X61O/2Or8f03L4xKHvdXOp1zkeJ55qnonmHHMhocspZmO0qIoC75HuliBUfHtK62GiyPmxb4OZGiG3serTkyGjSMdKWSZZWobptguB2SOtYzU+I357b27llGcP2WNi46k+Qs8Pc2WhttHzcarXEKGVc9YH4ef46zydOqPOeKLnUanHJF7ghR4ZKM3Z7ACW+9OvxYb/xp2KMrkz3atx1N55e31t02c4X1yPcwVwRdutHVLr40u4FDvvdEQ5Pp9YJfmq1RukfiV2Ow7HEppOtT0t73lqB7KcmvwQ+fn8pnI4v4riy+khjUHLIZzrjPWh2pHNYeJReRGAkzIMkfa0LEP0PFKf+ArTte/rK3FM1IpIOYil1NKvRA0XymXztjirhUAyZELcZ/PBPUB1Pyvnadz2XMYVHf2Ne+FcIvfsuZXm3SwkAaCsdKq7rI4zpSOh0qzYcqetd3aAImm22kOBfB23KaU7KzoYWBNdxf2DYCN3ORjooXqyJcriiSLMpkizSS0OyggjerTVAi5PKgGR2mGP255khsLJgbTaS4OHpFS2nB4QmX0sA8rsUte+Rj1pKoRQU5xGH+g05Nfvc1RLJxio1E5UquJLSJTMuSlvRiJqlmJDvKiWnNEdRzbhizKJZSiqRLZTAvEklDaYaSr5wdGP1FD50RCSScFEkOc4mqrvnylxj/eWNpvihMAD2sOcxzoL/wtaN/dcyZz6ylc0BiQohBzJp8MSU35TkRhz1LNhRxn9V2pCgJGeiWHXRIDkfStHf+DCLqa+M8U0koYgq0lZU8yTg3cqZ+RvNAdYGiqhxqPWvmRGAKXegwVzmTYdbNfeDYJqyINLhMeTKgwnJooYK1l4IaNCIIKqNHRAVSZjGGgzJRYyU9IsGdxQuXgQrPTZRXyoGpM6A8reKK6nnCsM3tfX18VKHaKVBvxXSdIKPp7kIWJyX5D6pRddbbyMM5Rp1pmxK0WEwvkyWmMOVKGPFqwGBj01/BJIdMTOJZwwc8ta51ZA7sCFw3klfwvGx/0zuq/16fNtZA+U1Jw2kZIwX7yRjtLkv5TOy/wLbODw0nRBip32v2ytdwdQeUBwLl/9qV0s2i1iVq9Yc/aMaquq2FtqIdrUtHNknM2jBoIdOlX+cCWGJysH9KY0ht53Tb8eRWt1xrKzNpuxW8YjFE38viCb3Wkqnq8ozc69+V7kGiheFLsyDl316sm1vsKiqi24ThWxbzvaVc9CGVZUyIGjZK87pWuq2LLz/mS18SNuqtLHyRTYYZ2OlWFlWnbZiWuMe9AxePZ29bcG7xypT7ksR57hpugWALHdsyMVHT0+B3C4gWxHX4OoaUb4hHXA956NMkPAJTlEbXGgETl78buZ1wpv9VPrPs1MahwfHrdMwVfdiDLWFkcooEnOFhHpkjwVlylj3SmyeX5qc46ceCMcIPfciux1ejEo5ehaMtvywvR54VvU7iPC9zqsxQRpCU5zuuKjfvahBuTDKb9d3O1U1KiBEJYqZWlqT9OSVBPGiaB80VuRlaZ1GyWH60t0O2fMRM4xtJpS39N9WiWdP+WPM+Oo0Y+QG3OmsJtfiq9egpVYS7q9YyjnGivk1jptNs6bFSxEyhH0OYwo7OtUq+qDFFOXHM7AX2WzA97OpuWtZzg7SJIEXHl70yj8t+Cjzi5zEJEw7b2WbYttUHjim3mccN4WGp6kqRZiPT1sDZSEPiAQ//deurbpjF5toMpx0n8zSNHeyLuUSsl3tEu4chwpG/J303gr+Q3R85nZ/RQnA/hdtED4d4FCfOpQayzYnT066/PEK3CTEOXwUnTflCzvCG88lPTzxhxOm98nF1+tZoEfCEFA2S4yk9locjDcgp9W7V9DyYK9IUXThSbCo/Gy2IZtQjRcQUVCPanE4HSb9oe7KQqNrGxm31QVV+EesSmt+qmRUPLS5nGzXdgZZE9UfGmTq0YdN08F401uPOD6GrebEiKo219M66fiYdoriukUoID5KdI94rLx9pTBivu1ffpM0EgiX5SMIoAw0Rn/4W6kXcAmFcATDh2Yzje9MC+ouKip7x5So2rCMi27fMXvakrvap2tw+jb/SJImZXeUM7/n22NC56WM8sbmOGbYyHSSzXzo5T8PPU+0XP06BpfNPw8J39Ebh1F9NjIGH098DP/hUJv7XZZ/6XSO58ip8PbNDifADB3XbE9yDP1aRv+sTPbhxPHrjtLsrPllxvpn7vqnRs3zDiC8iQIwICAAh+QQFCgDgACwAAAAA3ACrAAAI/wDBCRxIcOA8gQfnKbRn715BcPwiSswn8J5FewfTaWw3z16+fPfaaUw30J07kuDIqSQHzty5c+TGjXtIs6bNmzhz3gyns6fPnCx/1pQnTyFCowzvUSQoUeLAj1AdtpvqcB9UgRwPThVJ8qXLl+lizhRKtqzZs2jTCmQnEB7NouAOxl3YkGZTfg+bWrXoEGJEqyAvzpsqcCTJdCeDql0cjufix+DGolVsky3OhHLB2cuJ1+9AvE7BfcTrrzRowCAHbiWsUOQ5yGkbw14seTLlhyh/MsR5t/NAf/0++wZX2rREqxUVLlSab/Ds5zsdQxdY+6xKm+nW0cxctndEgcWLE/8UT7x48KdQP/pNPb19Y+ntYd8miC77QLdovUsMX9qmv/H9DbTPPsPhpJJM8ZkFX4JmrUSQg7epI+E6FApE1EObPXQVgd/pxw95Of0n4lnpwFSdQOKIw6BN7w303oIrlnUbOuioA4524MDjjjwEbZZhTQPuY1dvPv0DXoAhFmSPa5SlqCJOMELpU4tRxtjgQzTaKNA6OrqD01LpqSdgXqHl9M8//PGH038QgdTOawM5SdCJZVVp5Z0pDSShljfqiJNSooWpnqAC5VMmgA+lqSiS/vHTHEoyRUonnpQuxpJiErJD4TrvmMTjQxYJetWoouYTpJBMMQrOmeZ5Vx6bA53/aSRTfYk1znVkOSZbpbwOFCE7mlKIH02hMsdcqciGOeBd4ASnqIcR8SdroiXBpNJLcP7EU4srctvrSpQBu6mfxPIVFV/opqsushw29WpxEykrUT9qzqrhPCelM1W+rynm7UMLPvnci3auCG5Bm1JoUk3qotsQQxBD3FfD6MrbFL39xBuYuYbuF96qQIZ5z5Lg5CbOrgALJJ3AkP3b64MIK+ylTRRH7GNHdEFcEcWhWtzURzwz1260sN4UoJs5vUgQywoSVPDLDgpk0sI3JcWXQBkqp/XWB9nsdUPplnoRRlqD3XPH3/0EXD7tUEcTwS8/N2lOVA/0dcR86YzVXFxz/0123zmb7bByHGUVl2YVj3bTtAShudScT3rLtMpPx11TpELNbFDEdu/2o2aZEbZa4VkBbvrfW4+uHN9YS/x4rAXJaq/j4DCJIDgoy+k0rymC03tZc/ek3NeXje7O6KtxjfxUgxGu9fJbcXfU543LvirjaPqD6psxoRjn77vrVPmdt2P+E2ZlU19Ta+1M7f77O64GP/z7mtT++6MT9amZsvc/a/aOCklYfNe7cejOcmq5HVoScpTV3YRw93MHPOCRMIV1aX7wG9b8wFE3ofzHf9YbDz/2cY95DFBFkQJfrsYXN/PFxygPWcdIaHSY7MjQMNmxoXZwVBIOTq0g+6uJ+v/sBbtE+cNRJgxKCnGHMsqxMD6TQ2BZSvSSgWiERlik4UgqRBANCgUufdFJ0UzDNpiUw3zcUtF7xHGrc5SDiVK0iQsjE7z4tG0g6BCIOcwBDmz50Y/1qc+WuGgWdygkVGQBoD1KdKCZwEeNjREHOdIBknNEMY4FqU0dreQOGaJjj185xx7f2JI9ngOL6ggWDzO3o44wp0BmOuKjTOQ7FPXuZOEQRzru8aF8WFKFmOzJJmOUDnS8RpTlSKYyB/KVLKlykMN6CPyKAraO/aYnsjQhHweCOVyOY5ccugc5gBnMh5xIUj3sYIzgkZuCkJKZAkGHuLg4QZrMj5pK4ZBOiEj/xjdR54yRcdI3HQKVeYyznGeRDFEW9sNeSao625Snpra0pS6BQx7zW46p0laTEB7piCRLyRsNyEZyuKMvBX1npcgpTMlociBB1N9loOPGh9YkjyUbyLh2tNCpFcWV+dznmQpCRu5EapLtCGNB54NQmijwREGEqUxjJJdPKvOqKo3hTnn6UwcStT8fHKpAGDdGR1lRlOdoB/Wiko5hNpWbD+ERDAmiv6kyqJPFHOVVB6LSTAmrlR3ZTaFMtVF+0Cs8IGTVGE2DtcFQ5XWB+kg7DvpWnUzqpw9RDlzUAllQEcSToMRqOZpZIwpRM0PpORWH+nHY4iQ2e7EjzkCupqGo/7zJrZWlCTziwTfpwdS3z7HIXNrnSWOaA6vNXIchwZHPU5lKtYZtbWleS8Qi5gQqSwoLbnNrk5/Wox7rAy7DCEqQQXV2ZwwZzNRAe9xk7lEdM9OHPoI0QtSkNiKsXVT/aCLWnFgliQbk7k0UeJOi1OMg4CWIV3PCsacM9k9/MwkFi5lF7dxDvqpFzbqWNS/pyq5o1+uvqgRCIMmG5ZICLgtdMiteUAn3ussiEGB6BDGFyNQe+JCvfNPjMK9d+Lkddi3jwNO/EQtkhEBTSFtTDJsVF2SuPdKMxCommvIO6lR/CRKyglZj09UDxxemL36nyyqiftgmAVzSVJjKZLR8V/99C6bxlM9WqgzbeUCCyluXtVZXk8QjHvKgx5fxcWEMj3m6IP5ooo/sKDfRss2zCaxgESLE1k35wYNN7Z21zGOL4CO986hrnyf4jndwareCxjGhDZ3fRf/G1X+Bym0hDZ15fBnH2wlvYK9GkcQlS2TpIpuopzZBUq/DMm0JdKpXPaBWM4VaZY2IbcuBYloPclM+2TU+8CGUXTOXZ53mcpe9VOxyT/DYwCLIO/4cj2VjmEA1geVipT0ykVCWV9t6YnwGve0HbmczDbNaj/E2ti5jtC3FLjWFgAUsCYGDHaVmt7vnO6AQwUpERwygCd1YbfcoDScE7kk0hWdrgfdFfU//3rWepewjvRF8ZH9baFsq2PA97QlYEf/zxIPkLBCraazwclOJqN3xgX38IU6SE0sLHI+R92TQtKV0TrymYCW93ODqpA8qM8VwiOu8Htt+d6vNk1/ZJqofJLT3TIoOG4KtLOlwj3tOMAtTCTt9ffz2tNRxErEWT+9rNtYcQdRBo4Gc8uYMz/l3w74P1kq3NBn70KL7GRaAMsjtSI/7LWEj06jaJLDbDqNUd4Qh0OkkcLsJteDXQvhP7jGeNUK819u9eIpLVyBoJ9BhjciPkDza45j/nuaTXpOlTwf0V7MxRj1v+gf6DSNxudBD2NF6UMI+izjNOT3ogeP5Oh7ESoEl/6uQCFejw21pmucu8vut/O1wB8qH85tmbYJuwr++j6Lc5jbBEfHtg937rCVb/ZAPQ3Q9piF6s+F2uTN8ccR8KQdmfSE9cpEZ8GcQDcRnDlgQ1Fd4fLVX/PcO4PB1OUZxzXKAHWEosCIrB8g9LRN8tsSAs0EU9JCBatERhHaDFqhgWyNqpjN/F0WDrAcOVoVcBfF1/wcOjScivdcQKDhWaJIxIGFC2kVAxlcTCvh2bAR3K2JXQLh3OXFrhHYPnwZ9vYWBonaGogZEPTGEypRHWqJ9b5Zj+3BxJJSEbFJUXGEiJMV2TuOCKbKHVTgd0teFZmGDY2gPBxZqOzhVaHiGZf/BFmy4f3wSgu3mfzl2Hq9GVAGkOWckEwcEJcHnGGzkiYGYW0YhfSwWWAfWiECUhj9IiDnhRuaAUwQBcSH4DsASD/WgD5jYKGlnRpLxiVaogN+TQnz4GOamhuE1FymnYDSoEN8Fiy+zbvHADlgkD/fQi5yxcbfBNNJxhTwxiqRYiisyQX9WbLwlVQ44VfRgbTdRariYJfSgD66mFleIO3NijMfojgiVjj7BDuymc/bAi4nkD4/iNn1IjNTxUMLIj7QWkBpIE6m0bpaIKmVxRPfgDr93jyhiUw75kSEoEBBZizUxe/SQY2nhKCJBHSmCeX+YTLdzdMF0dyApkgHJbgL/AYJrwRY20pMPB5CC9hjNkRIx0ZK7MorlIBZM5DK9Eg7mho7s5ogDcY71lFu7dZNTyVvpiIt6Ag6ZQpEJ9hiV54kLeSuNtJRMGR/geB9PCQ+NeCH6c5Pm+JZ1hScBuVvmOHLRxJVdyX8JAi7Y0j24lJbQAY4yCZVNB2iD2Ip0iYrS14694o86oZMrYpAlYxjAaJSE2YKG2URCAZlu9l3fBVM1mRZo0nv7QhJEd3R/SHyx0Zn6NhCiOZuzqROzeTcQU5vQQZPBpIJsw0h7uCsPBYjk6CKw+URJdzfbdoi4iZvL+Zw2M5ugWZpFooL7MBjZIlDjoEzj+CRVeJyb+YKa/ycTX/Oc5nme6JmeEUOb9bB9dimZL2Od9qCRZpRM4HJGWjiM4OmZNDF8f3gr+sKetNmcqhYx27ae0rl97kmdagFSTEIOL7ESZOlE+3l+OAF3xJl0ADoPBOKICipo3wWi7QiiAhqiHzqDDDob//GbVGQtjpRvFcqfxYehkjKe56AvHWNkPeF5qJiiP9FfZGEOYqGZsImPNzGew5mFrtmREDoPaEMvProYpaYW1bU4eKGR+DmYhqkT/zmcDNmQ3IRU83AoltOj0AGfNQGPavoQlNkTQGoTaMJBx0WKM3pLXbqd5CBanSh3lmUO7YA2hoVJZoonalqoU8qXZTFkcGqQG/9nLXn6UGdkn+AyqZ3YncAzSU4aXRzVgNL4HIa6pjSxbokUS73nWFOBQzcaofdpjGrxh0glNBZZEDPWK53Hhe0RD5+Ki+mWpjjpplX6EKc5Mo6lESsBk564h7CRIkjVEHjGXbXKiGZxk/4YkLmKqLyqc0K1TwYpFQATm0LBRkmZDk76EUJScQ52FVL0rIuZE9Laru1arTgBcdTofzQhLb8aO/8xGIyUpWvpreIppqFirnmhWoJqV+zqrtWasKUmrwxXGdqXaiT2aogVS7HKklp6nCoDcjBxDvOgFD0jFChHq4NKEwirsPAorwvbdSo7EMg2EP3nbs32eP7wpsAqS/X/phEuGmAUCp5Idw4m0bEOQWggm14Fe7DvmrAqm7RKm7Rr4bI6B7PfZ69rkmb6ikM4ay34iZadCa4+G1gCwZ7gwG1Vk1lMJq0mq6tJuydeaXOy17DIBofdp3uO11o0axNc0UjbKalgkaqN9DsKWA6IwRFhCQ4zSBRR6aOGS61n23Vsq7YC4XCy93A7qW7zCnZhNrffV7eNExeukRMClZQQGph7qiLiALikR7JTKRDTWRJZJ2DyYLZI27CPC7mTOHiQO30kS3sjODSGNbOaO1bMZTvjIKOZJxOgey1ggRihxiM8ko5oKpuDa23M+ymKq3BM+xwtq26ANmgUR18leK9O/3hEcaFdF5uxPVG657AOdbV9idurOfJnFpJgEPNpLCeaoYZQcGmT7Hay14u9ksumtNd9JKh7IFOlRjJ+QleUHOm55ZC+7wAP8HiVuCqtr0sPgEaiBhqGnia2wTS9r8tuV5myDOe4/nsTF2y58kViveu7wLoqGReFanexMtmf5eBMkptuXaemN/mhb8YQYahjJyeyPBqXVAnBaPtwDtcebJG9D7FsFxaxh+VRIGOz6KKv4ICfnfkQoxV7bPu4P5l48KhzyjaamrGcceS+F3VRinmXRmytMTKlNxGUKDkQ+eU/1sVBbYMz7GMiMnx04zCLXGxzGgjGOVeXX1vGIRuZ7v8KwqTmsrk1xwAys0VEROkgpC6Bx89zQn3MEw38ErR4Eyqbc2isjDs6smTRlhIslwnXpkIBx2fxvDfBwZHsu7ODJvuQIedAUtt5mRxBNjH8Imy0f/+YeB9IN2mME51aE/XUlhHcxqsMj9QptS7cOgcRE5GkIhCqL1lxqq9xMqW7R1mkEznsyFMpg+BAxuc8aXRlsGWBymcbpZkIMuCBFxHTNtQGNw28EaZKRX1kTNjHgZWxqzq5bvvTw3rzis+qFsxsavAsRiNCK44VWG9yz0pzK80UuO1AFCDYev9cuyS5FmG8oIcctldjyKSJjG18Fm0KqmzKymixumiBiUVTqvn/oi+tkcvla7zZjBjyIJr0AIIdTcJpOq+qS7gJJrTgoA91acpSihYgyFvr5tIuXYQ1scMKWtTPMV0uXEJbUSKFwREaaUBw00ZZkkpcomyv27JJHKoFQa8EIWgc7BDJfCeiPMoEAb8h+RB4XYTYeqIwPRus4hDkYA6IwUhf7RrDu0ZX7BKolEXqQI1/5soRSbmEC7GE+7W49mIhadeVEsaLvNd7bcLtuqAinRaNV7Ff1Q/3ACdtZNhv5LMiYQ57mEyldEpZBM41Mnu4ysR6HYIgiiHqDL9VaTmI6b6SCctvfdl+PZ1/TRabltq3jNPUkc1zOhM32rl5u0wt8Uf5l9so/+vGfP1ngYbVvMKbOanDOMnZP7HcJ1rZV23adzYcwLEP+rAZYu0YAOpGdNRHx7OSekpK1qdHoCRRXNfb5fzXYFZOqZzeirne7P3gCqqbZaFj+kBi8AYeaCestoQybdQ9M0HYO0JBbOiBNQHIqdR1Bl4TcJ3ClTIsLo2VFlLZPTGiEP7g0WsWFY4T/WAPGDUSvvNxkhShyjSLZx0P6zDitH0TJo5z0GyTqUsQ/yewmMTgktncqkvj7n3OJTodOS4gqM0P7lAfptTNfkzYxtQSuf0OygYPbKFXSV7ijI2yoR3adoMPjaeNlYLcFvIp7w3hqjuaEk4T6JwWXT4msRMco//lRq/NErj0JNspT8fmlWvBKT3dnm7henwkzA/B2BNJjXdNEwN5502F1zL4oQPh15ctmyMNvSV64xP+EKiNJvLwRqPViS1BdDMxWrP42Av7WWDZnrzF0ci06dudJXWd17LJrI7XXXOtFum4vqh+6uy96mTc6qK56kLB4rIKrKqdG8fFRqkaUajEDni51+ZIe9uXjsIuzKb0SW6o26Ed5cseVya9IuJd6sst46xOm9Ru7WArv6rWE4VOEM0mHtqzcQL+RuawKZOYKW4Z6Liq5h8KvxzNRziFRYOHcwEZaKE+729x0oshrd3l3vkO0wJ6zl/b6inPnvNrxjih7TRhh7P/tQ7t5V5YFCxtSiESf2uISD0vm+4bzdEYTxPE3G5yuOz0jcycl78FpmztreVanmC1ee0qL+gG3W8CP/CyGoA0MeQ6lGydN4PXjmsoX41ZWYkWnL2A/BCIt267eOdCog+aHSO1OhROb+opH/X8HpYnjxM878OybBNaD+tlBxH2sA7INNiHh47c1/KIONIMce26etftFtk/AXFuaefmOjJxY8p3/95Qvvd87+8ozzk285w6MfjbvnsXRUWcTu6VDnbLiYCh/2XtGYQuC9m42hPvsOKNJxD6QL/K/BxDXO+fP53gpfIlSqDKifqPISSs1XuIf0rZsVuBxm+rZhEVHvyB/2/Ugx6qEYeoDb8lb597sVoPPJIhw2LekNGYeO/vy9/zzN/8WL8YFkmA8lBM5O6WttbDAIFPIL574AwexHdQIT2G9OIphGiQHbt3FQ2quyjxXT19+/r1A7cPYj154OrBQxlR5UqWLcHRAyevYUODMxnWw5lTZz17PXvm9BlU6NCg+OwJdJkUoj6F9tytW+dOnkydEAcmVMkQIsx4D1eqAwt2IlhwYuHx7LhP5Mp6St2+XSjT5tyGOw3qFAqUqNCrffu6XfvWKTx583biNGgv8VWFWF9G7Bqv4juFYzGWFSt2Y9qPIgsavPcZrlJ4o1/KpUvv8MG2h10r3nvU72ykSv8Du703b57QiG0P9nRs0vdKrxHZrZz4jh7njx/BhY7I1DRLeMVXTsWOOrVqu3dd74xdlLZfwLfdGvXJViHOgd6HT4fITh6+tGrBgQS5Up90+NOza5/pO8QQW4+n8MIbjzHbXOKvv5tks6eqx1yyLj7l6LPvII/yO2g/tTLsz7T/6BJwwN4MPHCv9gyaLakPGQypOfNaek+12nCiKal3IrMuHhvrc+lDtfrhJ6QQR8uOxBJbI9Akk1KMbUVwWmxJSNs2nJGl4WBKLEKblNqRRxvpq29DljZsLs0j4Upyrqrec7JJvaAkSkoqWWpQP4XSgivHg/x8K0wf68EwTQ5X+mz/yObWFBE7JZss0MQ56eQrwdr0hDEiBR3USikfbxKoIzVbyi84NBlFcqqZHuvOSeEI9K0tSuu0tMM8wbl1KVRb6tQlhkJlDr+37gkuxkN39ZUmmGCC88RYh5tVPEuRume/Pa1FFhzFeF2o15V+5EwkQ4+NKLCCfCvUuWyT0mpZV91qMlqfpr0qNH2qZQrbM0376duXivOTS9aO8tDM/AyFCDp7O2oKIVHJjag0ZHtltlWlgtIWItiGorfee/cDOUi4mvS2JodYCpBQDNGEWCV9ijWIYdYOusejddkVWKuc3t0VY9k6Jqigz3KFyDx/evtW4JcYiuygCn8UctFFXRIt/2F97+owyyNL4jVn7nYerafREgL65qRLVoqelac2iG2Xq1YJuqbmYRHuNbNbequUXXvLwIy3banYaUOzO2Z9QXTwrUHTdRsicguPaOGrp4R565i4XppLmwSED/DfkvoLoUv1A/nFgw5t2UGe8FFUajWFDRHfMq1EtiTMMze5Lr6TwitFl2oTvCWQmUIcVaX/BFfR02FPHVG5n5OudJYbD/H2g+RCXvfdaZyUKG15Q4hyle7c06AsOVyLaLd8JLh16s3XGs/o88X1w4/8wT//0Zp2C/vcK94eW3oXm++lpzGbas94nmc2lbAvWAhDFXQKZr806Q8cR4tYA+Pxn6Soqv9Te1tSCOUlEOAgkHIJgpxChKS+vHUNLe5rW7YW5j5DHc2GEXmHxCASGexMZ1nLCmEQX3MgEv5sdPRaoEq0NjqmaQlYrTtTP+IHOny5T38YbElKDCKx6nSlh0f6mhDFmKIi/oVsJ/QL4QjXOUhViDVkslLx4mik6QxvQxbEYlK4yKMNTmVdkHqVGAfmvS6hBylSQuNA1KjGfQkQMiZRGqH4dJv4icR0SrHW7N5HGnB0kYdfZJSEIiXI3xAQOGKrnOgUucgkqtA0AmFS+4oXkileUkPmsQ8FxwUflHiyj6DsoEtEORJSdmkoGdOWIVPJonqxslpKnA7wyCSzBlkSmkb/mpElZzSufuQxIuTS4kF6GQ/C4O1yt/MjqsQ4TLF9TmMrudQqWUk/OpqPXZrCyjRnqaEg7XMlEPSmHkujxXH+Mp3ATCeyhBiRdibmLfEUiDOfIxoQTZElh3wmnopWJRdJzSAB/adCetnLTqKEnDq8XkIv90eVWIwlngOdKlkJvVuiL5rD46ct82XLjSZlk6YZ6UBNitKUotN6DOQXfOT5vETZ7EhwTJ+QLJknPml0JaeqYz1LStJxEtUgCD0qUuEC04dGdI0dMhZ8biJJ4qmFPyu8VYOih6s8Re2nIeKiSVsSVrH21TF9YaSG7to1guHUcJnMl1xx5TL42XWwjPJq/18lCxeytSewdwSpUlQ2PH2xcEpTshu2HDuqt5gnhZNF7VPRSLOCDMmCMdPsZrHFWc+yaCmTvI1znLOP2vIztb9lYOhAY777TUdl05zftWDrvJhJ1Z8xoyiD5Ppc4FZXKcKFzj740c3M/o4gtKVryCYXNztSF0/xq2LWrLveljT0gFKyl0fwp1TxZtJwzwEdcq9m0fMsjL3/VQkhNWXbKbW1m/2hz++8S5uehgiRAIawMTE2vogO1yDb7e7MRjLNi55xfC5RDL7kt+AKwzPC1QUfhQlCU7VsF8E4DRk+H0xW0gWOWOsh6+hOHGEaWyUhC2weyjaLX7oG7sE0otlFT/8IYh0P8rM73rFZFeLiiGT4JYSKjvqE+9D9ZLQxviplkxezTAYez7ruvaiXwYHhKvsKeGVFczLzWbkVH2lANVqdmJFqZpXQbb0YzROVR4Plz+qYzPCc84fb27felBC4fI6In63rMYhgeL4f7S57Dim+L19Mzuw10KHLDGmFSBppYq1XS/KYWZxsy8PMTEqPCfzqAbeUSc1iC31OK87IghFtEDH1SLKV44i+dc33+ahmCYxPZMGSoXHmGU9cIhPkCnRdgOqzlpCF5lWG9IJu+Zmi9Ry4A76sHtjW9s5kbZB4cIS3tQ3n3U48YWZ2e7zIxmD+Mku+/igmntI5Nzi6klT/rH2LTKTpdSfZpNL+NMulK5lwGof2z0vru9aHfHO9owmz4bhxKwUXtpaOsu4tRpakbwFmw0f5HlyXEpWAVbNKQILF1zL7yGETHadHw6WqAA7XkxEOwkUa1L2iMyYKSRJ8VsMzZDYlPYBNyna5q5BLU/jJXxZ1+ISbymH+qdU65vNDKIMal8Q7qNXZK9JBmXTjPrzpTn950N4y9X/8I79X7/R1zehQTe3HMWTNs2MAeR2+QsTkJ/8iB8+p0uzoJtjpXg202mvErCtk5uCw+0FAuuWNV9YoFzXsS8f9Krig9PAp+Y/iU490xzseHLoR5ptEuS2xeY7yRHbLDTHdYYiOvD7AhV53qNwa+5Z7h+lZFKlKRrr41Dcfc1NpffS5J3uwFRB8JbSsS1ysrlV3WOs3D+UTRbLMwdckkKV/i8T8uHrmPz/60o9t9V3Om3mVOIVSP5Q3uwsb24Jf6esZiHsLOQHaErdIuAz6qq8yJ/aDvvdzvfgbPCKiFnthCbfRvwyDKf8bGbaQDbf4oF6RPwNMP4F7vuZrv8JwwAfkna6zPhX5MQr8J+6yoQv0LSPzPWWLNtIzjXaREFIDh4AAACH5BAUKAOAALAAAAADcAKsAAAj/ANmxW0cQnMGDCBMenGevob174PJJlAiOn8WL/CCaM3euI7ly5cidA9euHbh05MapVAluo0FyKcchZKmwps2bOHPqBCdOnEGfO4PKDEoUpzp24AoGnWdwHsOG96JOzGcQYz9+JNOd03oOJsytBttpjamSHEKY5YYapFm0rVudQBHGfXuQLV1wZnWORGrwXVGnTx9KnYjQoj9/4O61c5euMdeO6UqWHJs25EiPMNmqvcv5YLjPd3t2vrn5YF6bp3Me7ZtQnjyEgMEBdiiYosR9ChHvuzdPsmPHJZ1ONveRnOOOXdNuLs15blHQdEWPZk439U10SAm+g+fOnevXsmUz/xUfOCrEiLergut3kF++ew17i03nLvi9970bb408H3Pm0TeFE9Rn0EXnHF12cWadTQJpBw88CL0G2IROOZTYQYQlhFhV7kkUVW8V3jcRb4vVJ1l/XXm1IIBvCfhWTwe+tRJ1Oq2oE0HrJPWgd99ROBtUGFK0Ez/7XOShiPkUSaRE9lDo22NfwQSOStKxOKBbMFbZ2UpWEuVgdzzK4yNTgkVU1GEJGYlRex162KR8v/3m0Tha/tQlizB2KRON1ekkkEE7hinmhEBKpROah22Y5kU5dcibcPPxN19McVWqk4vPYXrnpm/ZiBBfgILZo1PgNJRYVAphhRE//STqaqJvWf/kJqQnTkaWQnnGyClRWW6aoJVIgRpomD+eqhBVHF7U6quuGqRoULK+FxVtDzUpFllqZakrUQXuKtd0fFr55XeDPnUsOEqu6s+yzDYLzrMatltRtNIimY89YmE2k7Z3EejtT3X+u5OnOL7T3aiB1ZSuuv003O7DNT2M5rxEruoefJONNeVK2mo6oMejxRhwUeFWtyCOBB3sWrFB3mbxy/xI/Gpu/vwjM4fsvcuhm/mmSGWvB22LkIvd4pSnwEjbhPI63K1coT0tuwzzyzIz+27VVkd8mKwkjsUxv5eCQ3RbQifdJ8FLNx1bQlPts/DU6mItN9Y0+9MhvihRCnZOmIL/nNPRZm+sUMlEwZP2weMhZK/bb8Md99yQv/rP5P/kJiu+Xc3IZdA8Bb6r5gntSdRpOD5YusqJJ7R424wzLvXU7EYu8eQ1Uz45ze5dS5ZXCc0FmoB+31Q2r0ANv9bmdRHO4EAFg9mOawhBbV7bU1Vvfdswyy637ZTbZLdiyX3V0UtTdv570XB1BjTgnA/+a/Lv18Q80zuSq5B59l6vv/WNWyz31JLjXuUsl5F2ICcyBhlLTMQmNvTBxXjCO1qu2OecGQGIeRASFTjAYxCoTG9/INxf/zBSNcfFjns4+d7ToEYS3cmEQN0KXtAgGEHpaKtXAdsTn4ZCuIH4JSGpK9Wp/6ZnL/wZ8YiD4d8IY/YwNWHPMJLbid0YVRH8aEwcMOybQYI3sqKs74Y4PFD8ZqKTdOQINit0CBLXyEb8hbB1jWsXkfahv3Qxa4ACBMcAcbcbA5rFOVrEVRej07sbCoU0OVHKQtTYRoigqoPUok0j81c9t/lva20aUf6UNTM9JgSPAqRdP/IxD5SUz3eFFM0g8WRInewwkWhkZBt3ArVIenCNIJyaJo84kbflpHIo5J4/7uU15qgyjJVinxedUzxlxkhzyqtJGidpqoOw8Ca2lCQb38M/i9CxXuYRjBtvUyQO6awmtjOIMPvoNbn4pJWd68k4MkNDXAFMlXb6FvygWf8awv3olmy8Jnl8ZBNC2XKS+cMfbZ4yzgxR7JyfvF0oVagxmRxzb/LcTztTuUo74bNzrtThGAs6zUkCcaBjShxTUppGWbYxPhUKDEARkqSLTEwhEhWg3d5zLeWI42fILEc6GDKZc5SjnjaRoNCQZ8GltBSgCpXmSlNaq3asjaUUik+1xAmfN5HKRxYyyAclAkV0AnOiOy1l5jSXJTrNMzLT6k3mRgZBCnpUmcezyRhTR61pCWarJ51QVatan9hg9bAwRWz0jNhLrJhVj6GknXswh5avyfOtVg3nteiEp2+9s2wjVUgQS3XQacEnsIA5UX3AxNrWusMgopJHd0ritMP/rk20MuXqRJgY0cjabqfgq6zmQhIZhogIbylBavp4si2WiHQ0pQ3rQlAqGdaaLlCmY9prweFa19Z2QmJCI0sjKZWyHiSdvrXZZP34kRmZpbgPGdG1lBsUpEZTJ9mkDW5TW6ISGW5pACZIY5KSsu6SSzLgIVe5bAuVfJgXst07q06xgrfkhEQkxU0iT1FCX0ICqCRByeZ+aVUiMAk4TulABzpSvOIBE5h+3e0ObF0jKNsylKzLOm861TnR9SqQIy2kJG843GEssYi2ICYJTiKJE8GWpLWOQQdypoycFqfDICjjDmu5693vYrXBRcoxhG0iTLvJpmf8mQclPWRAOhXZ/3MHQbJk8MvCapKUxCVah36QsxFzgKQcGzmHih1zkKUlJcYIQ2x8LSJmFPbWZmjCWGNMouY1W5Ecb4ZzWJ5XK1KNxkfV7Q48GiPlc2zkz6jmiKBVrI6jADjGglLwgmdzHyXleMc4pdzWIvImk2h4KoqZb6bhLGfJTKgzLHVNnlNsaj+j+tmBVjE6Wj2/dSCagyMO0X0Y3Soedy/XtDPzewxSRybl66gd1TROaKtsL48Wm9JtSrLdoWeunPrZ0O4Iq9WRZdfu5EdSwU1FdOxohPw2Z+S+DTm9ydO5plvdNpG1uz2dk1o2eUyyHTWznQ2SlUCbI4POspZlrBBZB+Uwkf9VJ4TDzTZyOjha9kCJm5kL8bZIfNYUomUt9Rs9U3lVtgLuCMdnlO9Vm9FBN1HwsRuMLscepHYpJ7jNknWRt0mrlJgGWs2DYnKcE3TJO7dlQhZKY8aUmuPKwXe00zGQpH8ntk8bDCcTld5HJwpudHyUWDgL0q0j+7A48Wt+e14q4XSH1KbGt+LLsWpQJSTWo/Kg1GIHdZ0a3Nt3h5mH5sGYc8y85g/PyVdRelubCF7EN+kNvRGP9sWDfNqOnzHOGblwytds5d++/G8TdRWMfLPhacGr3+ni6an+U6D3O6LYx36Qw6u42a1/9qpdjWV41LavSVSSqyCNmMjCS6e8973/JtuR9X9pqm8ytGffSSrvheQW+YpTPlfPY80mIYQxLBb6vfPN6hxZP+5I1EvaR3ewgnu3A267ty5VNyvtYA73lSkx5C/qZyWp81TilHwmpVALVWiIN2Wt93pI4Q7GZWmsw2gEiHK+hRis4m0JiEkXYy0yN2wKoUUSOIH/8n5IpDoItUbxAVv0Vm8sJmV9BmiC1hT2gA8kWIKs0i7pNTEIx4Lcp4D4cW6h5xZZNHz1p01GFH/gtINxlTgmhiOkVmrYIRtQoQ/6EEJJYmsP04Sq0m0E9ypXsWEogW4yuEVZ5ECaljDYd0Q0hVAjUi8LlTqyRXJJcRD1IE75kIYgxDhL/9iG3qcqS9hbrkIkQ7ZWVYgTeQhDAhNeopeFpAVV5kFuYgWIXaiByPdVs4GEi8iIb8SGTIhekiWJcOh9aZUvyfVmm6iH6lZ6PqeFvBR/bbQ/8kdeaoSG+uA2ariGJgiJe0Q7EWFrzoKCB5cRnIeJ9LWLWIhb+dWHOViK2xRC1NQQSJiEwNZYDWN7dPdJsmJJ7BKJVoSJ+bQTm8gpzgE97vduYNWNwOiFDbWM17NGaKg/AVhTjPaI7oIQO0VH5UR34Odj2Ch8npGHEDdxY9JBkMSP8+ePALk/+uCP25SMlsRtOQYv77IkNXVCZeYe+eFwWjeRFAlno0J6DKaR/bhNv//WkdXzkUZUjjwYSUiIjI7IKq3CHgXIJuh4NQ+5G5xXh583gzG5KWUzkzaWVTZJXsM4VjppPT2JD16JP/gQSQZlHmg4kitIeU93MS7TbWgFkXoDk1f4L1NpkeP1JleZTT45jFtZPUcUltmkaOVYlrhBlA5zlMAVcEbZlqTUU9mCRXHpd4kGGPXAUvUwmRZ4l16Zl3q5lcVolxQia/QQmvRQmYmID2hoEG6TjrHzdLvhQbhBjbtXQO30kp4jkZHpFJZZk3dJLV55hF6ok0Y0iD5SdioTD8YpD6FZmUcIDkK5D6qZkMNEGw72LooZXD+zdRJZlceWj7vJjyD5nQ4xnN//wV3c8SDmCQ/HGZoGkZmC6ZyFeVOjpEYOVnm6hpIxNxL35BlY+FMsJW85l1Ld2Y2aqYHfeXpvYnLu8CAK8Q4/BA7xkJzsKZKqyS4HMUrwsW3UqWtSOIXyqG7FMzjnYFUXCRtANCZMBkkZeZXBqaI/mViyJmoMchDG+aD1EKGM85yKsi73Yg/TmaGQNofw0ZLJtZ8Z1Q49+i92lqLeeQ+9uZuaSS1OIXEJCiE3IRDvMKOjeYSmKZLuSaFXo5Yx46N3N4Wdt0BYBHqYNZ/+kHMXN6JJShQCGqD8aJk3p6A3cRRWeqU0Wpqm6Y7paJhE2X2xOYWUATDpRzZgVCfyZBzz/7APnSReFCcwcjqpUSqldnqnAsEODPqgo1mZXimYOAovE7OSi6kx9sgv8GQc7bBtWZN64JCbxkeasiqrISagfjmpkUSnEnepNtFq1KapxpmcNbqlElqYZDZR7JQiysFKYPNZPjFPxvFyf5qQSCOnt2oPs5qIAaqrsmacVJoQrQYOvuqrwMqpnvqpxQqHBpdeFoqLb2kgE6QlLqKq8yCtoSpNn1gUuEotlUkhs5pf2VqpEhcPvAqurbZv5ZqcWnoPoCpmUtdjpUocwZcry7Q3M4QX6XAPq5KO3JaPE5KtpOkjICur+5pNIeuvJEsbIzsPN+ca8dCr4ipt0qYOehqspP+JrhJqkumlXopBGdfZHK3EeKsaZg2jLFeBmm5DkyMLq7i5tNlastjKtNr5sZPZsvJAsL16sDJ7FHoqmp1qo+q6rilISgq0rBI5Q4maJyqxFfVaU3BEGEciFSm1sijrtP+6r1KrnbIKXi1rnODQoAbhqzI7bVwbD137tVvqnCZpgMIkmxJLJUETDmlLmz/xVmq2hrvkSBf6kdd6WLPquXZbslJLlzaGnF77HX77sgY7uIRbrsE6muiquGbVhGTbFcczuVryRW9Va2vYOrahSZzrVVgVsHVrt0/rEKSpkf2KVfRAusPptc2LujPqt4GrDqwLewxas/HgqWUZtg/bYzH/d2XHY1HJhLvigGGr2rtwpCT345vCObd7K7LGe7wqC7L8urxjEpq3KZ5RCr3dOqMMCg7soLVbS7Ob+rrDmozeC4Xelw/uqhxAdUNutqiMd7ms83vMeRBJa00H4Zd5K5nxW7zzq622NMIpZbrfAb0qHL39e7oKNr2GaxADTMCtq6mHm8Cyi4DpJZtewU8+7FYhmg4bybAb/EjMh63yIKvR6xr0MCYhPLVOrJzIa8IY578KpsJOY7qi2bfUK8ADXMA2fKWiicMLzLgT5cBl+8P8xKjvx0IDSn9dFZ5iQmPW53Ug/MF6O7IGsbRNy1IrvMSg6cJW67IzehDvMMOES641/wu7iVvGO6traKysauxx5lBc2brFrjGsHgylyPsd5rm/IAzFUQyyrwqyVfnHLWvFg0zIXSwQ46rIhguhjby4jzw5oySkHafGjEcfTLzFDjqj6JnER4itLMsjsQYmn1xbdizK8kvFJ/yZK5zKgrzKMHwQrjyumSrGX9u9tPzIh7EPTZki7eXDgMbLhOyg6AnD8fAayXuyAptx68Cg66B0U/u5oOvMGDfI+rvK/Ewu9DC9hjzDv3rDseswOgyPnAcO4lw+G7MSxqFd05u92tvFNgcoBwHK8OvO92y3BMWy/LzP/SzN0fvPhWzNmXrS2pzACuzIO7tT/SElDe1eRxfPEv9d05uKEKKZEF+JhuYRljihdM6bx7Nayifrfhcd0kgt0s1L0tV8yCdtw+Za0DcltimYO/qBFsuKEDNdEE6dqX+bEA8KDvSgEDuNjPoQlpNpEKNicv7JzHfMx8c2Hlic1HSdwoCszn2B0psqy93L0m5ISmX6ERA8DiGxYjjixU/9JwhB0dGTGPgAjo9tTaAc1FVpvLe1UnNd15pNLursFwyazXvNyH3dzTvLkoE92CAhaGz3J4p90ndBwtKF0W7dzHAdRE6R2Zu92Xid12Gc0gX9hN8bWRfzwGlnGWwXrqMRzKPZIyR81MssyqbM0VOFRrid23Rd0gta01HdyGFby+H/1ken/WcYlg7IXaU2obo2UbXvRtlCPcLLGx75WN3W3c8AfRMSjcC/PdVmPGHB5g5ChxYioW++ihOKLaPojdPaGtkI8ZFtPdsZPb+HFc3zndQ5YdMIfIQS+nTB3cAk0nmmBhOqJmivPOCfYsMGUc2dKsURataMA3gNXtnuHeF/jMkpPOH2gxM2fcAKy936XcuHgSwH8RhVtm8jvhqIfd8zysRPW9YN258OPg/ujce3PeOobN1EkeOLnKWNfKwtPUy8kRUDFidEjtzUhti9XcjrDLtRe7NkKZKsMqIvXs8xzrxULuG5vUE4AcA5jqVazrA34d0/bi0mESdJkal4es3q/2DNCHHAMMzIUfuq5cicbg7c8C0b0v3WUf7EFFLngIycXYfUeF4TEY3lfF6ap6nhoOTNk6V6hK5nhi7DAl3eiz7RNJqZ9WBNmXkeCgypK5Xpvk68PsLpV6xgak3XCgHDWM7oO64PCokmEtbS67UYcXJGiK7Ysr6g6kyjy3nrzMecRaKKL/7rUgvhU87pM37jxb5BEpcTL4vsEn3m+L2lBtEwBw2xJBIpKGOwr3wQiS6ui53tyakQiRgV7rjRvk6ZxmvuVI7ual3sxH7e2W7T8L7d9GeU1MnA9g4njYEyscfvIy5tYP3L1DvWYk3ypdLXDWNbTuvg8UuaCr/w2HbUbf+R7cYp8UhO8d6D8RP2HjDoGAMxw+CKDgZxvUJvyO0u8g56ECRvD+l6GCpf28zcxP768gtvJRFvuMme5ZrM7FzehFcRV4vB8bFuvQhR9H129kV/4tgt1ghRoyutmk8e9x9L9TM+Gmje2Vmv7H1+E7AJj2Dvg4Zj6K/MugfRZyCv9n7rtdbEsBOa8nIv9+au9Jk98yJP83qe99mLwDWaQvRp711FcfC8DoJPwypmDio29KYvozhd8hD69v0gcI+fz7INGFTO9jjdywyP3uBh+bxf85h/8xCqwfOeM32PVnkXpNuZcfDwDgRxzUQ/PuAwbTixzV36+gahD7EvnuRiW3//bBNjHfNg3e6p2/udffnJbsNQba7So8FEeTWdX2bH71W0euLm+dlfPLiqlvb+rhCw6/oA0W8fOHwF5x1EmFDhQobyHD6ECPGgvIX0LF68CA6cRY0dPX7sGE/kSHgjTcZ7l1LlSpYtXb5jl1KkxXoF7+nbl7NfP3D9/P38F1To0J/88uW7d8/eUqb26n0UCS8lO3bqrKpDl1UryJDyaurbuTPnPn3gmDJE2zDiWrYSFWKkp5EjV7rg4nk8WfLkS759XY6kWVAfTp1hf/obmvifP6NHkxaEjM/pU7zxpFKlelUzOo1WQdrDKZbsYLP1ErLV2Fb1x4jg1r7lOLfubMvw/8C9G+lX9+6/M+nVs4fvJuGBhoEqXsx431Gkw29CngwV5VTM1TWri3l34719AnMm1SjZNGqP8liTB2m+Y1uEDmd7jHvepFSpvPtiti/TpLzfwYePBYcf45BLjp+cmBtuMOiiA2k6/GCqrjp4+APNO33uMUs4yeyZqLWHXFNNvfdSS68t10ZscL787qvOr5NepCm4wYgTcKfDkCtqLMcufIygyeoBkqvpdKuHOAtLC66gyUIEcbX3RBQxNSZRJNEueK6sb8WWIozppRe/jBGfGQcqzMYbkzusHwPHUrAggvABB0g5gYzvI5ZO8gqssNg06yA5l6onRA9boxLEQguVZ/8+LN9ZZx0tV+KSry8Bw6gm4WYEJ6cafTqs0zTXzOnCyDyak07ZNJo0HuBC8y5UUed56DfgBP2wyVpRjPLQJxMVCZxFH33pQS8nhQtIyDDV1DhP/QkL1FBH/Qiui7SrDDB8xjJwsFA1eixQiuaREiJbaRVXV3OrJQnLLIFlqUtJU63UWMG0xVbATsPaiR9nO4rMzY6kpcekBukRs7s9LywrqaQS1ihJQz8kF7Vcz6UronTVVZfd/FL17SIgkxQTHOL20ZfTT/UdiyyP+sWHMrkw6vWkjoo0GF+BEgYPpBn1cS9iWikWMip43CGaaCzzylhjFzmOR9o/IfsvZWWZdZb/tJX7pXMjVAUGk1WbvRP5IzJT3sfnKU/U1R11Q8IYY1QtJgnYve7UD0aAafoYanqTNfmnVjH9iCnITK1z67tM+u3amsfaySO+1dR3U7MHnfhQtTG++MqObBPpoUmXFsk+eO/GO2/BRE65xntvnhFDOEkFrqAgpyWWHhm7W3wgjXLS6GvfBT0PvXNrU1dRzTXSKx7PJ123bqafp/TuUmM/FnWp+1ZzNFHresqpjWjv9fsivf76o7J68t3mcCcntNC233f7+PXWmhs36O8nvfQ/34R6d7JVp1qo7gGZOLlsZnH6Dem+Uqb0feRSvUvfTthnIl3B72gvskuJ4HY/DiJO/4FyMstSwnOsspCtTMzKnqhGZcB/1cNpsaNXBBvXu56AQynB2Z36wjJBcbnnUBa84H6atJ5xLW90GPlX/vJXKh+9jn+AG1nN9kQW6MhOa9FymphYJUWb6Y4u4pFRXXi4Fl0xDW1E9GER2/Ii/kgriUp84Zyg1T+NlIVehNmUhQYoOxC+DD54EwwXy9cRlXFFH5KZx1PO55GfjPFWQFsfV3qoxjV2DI5wnN6cQAYnApLmfMQxUr4EqCQ50eSNgSkYA31nPoXdxCOi4tA87AGSRvoseJAsz63UU65dUtIhFvnlJYtFOFll8mlu0humdmZCg42Sj/p7GQwJI0OeOE5ke/8UDobMF6dEoo6RkzsPLqlUqzSuRZhxNGY6SwWy8CxsZyIbEzNdtUcQemxmBVHlKmmYqcE8JjI5C1vYKONEjfiDfbkUp7nKGZFzxkudDzVdR26SIGXGU548Ek+cotk9bVGzmmLj0R4dVhdtZih4DlEe5SCW0IROEj7fcyhE1dkUaNVxZ++E597I1k/x1KmYtxMkvmYTUpZt83y8E2BJLQY886SRpU/lCt4KCDuIajSELCPoTXG6TBPy1HsttNQ0GzjUkLbSdeZj3NdAxY+RoLRzJmrqI6F6qFOZq6pcISBBO6LVRVo0ZV51IX+aFtZ8hoUuvINnK/1lR62e0FNCRd7/lSwjJSthaa5PfQoLURSkh84Sr/6y4Se1uleduuqQLfPp7WT4npsqbEPwhKcJp7Ysf/jKslszz9psc1neFsplBtTsZ6HmypziNKc7bROg5FKwCL5nIDetI4ZESMjC9o22m9utbYnXW+4eKrgo4mR4+Wrc4rKJp69NnFgHiSJPOtCzHbUZs2i7LOyWZLf3zW539cvb181rvH397wCdAijVrpcuHy3Uf8w0359wJbsjqa/89jth3lIUujYNsHiod5NmGhZFCEYsXUJp3cPMBsEUqxyFVUyl8b5yTK0lJWFNCDQAHdZ3nTJxgPgxIgmv2McJvTCGu3reyETRixSrcaaC/4pCwzg3ZTz+cZSBDDjSGnmeRdap2M6F1Exl6murq6aaTqzkJ0sZqt+NMpW5OmQVWnSuALoxmP0XYjKX2cwf6aN372xUDJfWvKSJGp2p25Exfzh9DRZbqBArzz3jeU56bvReq+znv/r1yNbkyQwPlWkDE3p3a+ZrpGcWJHM1pWHT3W9JzXdTeTLauVsOqqYdxyaF9dOfBBR1AR9Npel6FtWpVvWkKc1oL15aZ04uLFeYWVbXNuXXjZ7eZkPYEc+quNarZnWrk0xIsoqKuI5rbjWRalpam3VDzs61rn3bvWr7OJvfLu6aWz2iCzkQ19TNp7KVHFJQktfZ7YY2qUcEnP9TR9kmC3NxY7Xd5bocMtgESXRaIUvl4g5wOIeltqnTTTGAU3i4xP2vlbdtLrEys4Z7tTiAvX3xzaIZxd/zsa+50vGE/lNh8Vb4jIFmaTu7eI+utPW1C+UUcD3VPIVb8bMbdtl+CT3kJt95qHVnbO1hs3U2OZfLN77xpmdT5dnueW+t5nNkjvDeK3PdgjS+X6Rv/VAs+3nOnl5IjnuEpouUKECvee+aBo56WF1xXd0+IqxiU+5PryMup4fDvD9mgFf76mx+FDszt33w4LVJNg+O8JDjnaUDBknaQRueybtQ4Afcn7moBUnBX57wmXe8Oxnb4prrVaJ4BYmGCadZU2n/3cHHc6rr9ftPDcnek7Svfb8+8vCZlyojeDalvd9z2zMKH0VKp1LXL7VV5OMS8FnXLNJd2HbQ2r544UuU9a/PFHPB3Z1P/m9ABz4brNr+TRCnGBKJzPixe+SCvaSwg+gt7KM/szs4v+qznWG+mmNAmjsRxTmt6WI5MRqicZqY1qOLohO18BouGqGuUFvAgXu2/nIie8o+6EiRu4BAJXExXKm+c8FArtDAPSPBf6KRMDOt1sE97pkZVHMiLTofYEqxLzq7kNCO5FqZ/qNAcZoLy/uIGYy0pqOXGoEg7SEqfik1alM+q6EHXrkLJ8w9ugidhrGiPKOLHkuoGAQJKHwq/wekP7jDox0jNAuxNfzjOJnDQqsJrJk4QckQkpTYCFLLpN+rmCF8DzV8wkbzrMKbJpCgw3oTJ3bintMzC8mbpXYDwyaEiN/4CDRUv8u6xPrDo8NSIZbiQLogtfqLvBE6IBTpwibpQk50MKP7RLsjQzjUlNnQJvujmLzixZximWrbpF9Es5QCQ+ShRRWjRF1hP/6RQp2gpZWxQ6DZJK4QOFqLjFV8EzfUCDRLIxZaG9vyxHF6wa1rRgO0wUYkvOQDCaTbm9NCRb2yPAO6i3cACc0Kx3A8F0MUtXNEx3fDI055j1+kmEcrHP9SwvdwIUfDR2s8Q9t4H13hx37MPffTltQA0bTa2h3u4qzxq0gSjLZ7ZCEzjKq4kEX/u622OZSJVMSl45f647CBEBBGsiugQTOXkYyWGT8kGrj4cMLS+b3schtxYkkKEyFhhMmYDJCP0Egi1Cvfs0nnAxi6ipbM2rVORMbIGsonkaSi3K9e08LCi8mSocmmlMbR269SsogvmcRooaqQxEpfQUl9JCLWKJF0W7th7MBcZEpwMMvwcEZS4cFp1BWYmZR2FEyRTKdZlMu51JzV80qKzMukjMO+/EtnHD2X4ySgyYhUQcVuREVjsoeAAAAh+QQFCgDgACwAAAAA3ACrAAAI/wDBCRS4bh28gQgTIrx3D1xDhRD9SZTIb1++ixcZMsSI8d68diBDgkyX7tw5cihTkhs3DqJLheFeypwJMVxMmjhz6typsCC8gzg1bsQ5cWI/fkiRcsyXVGk+jfbmfRxJ0qTVkyt5Iox5U6vOrl7Din1JTiA7cGffvQM6U+g9jESLyvWHdF9Tfv3o8lvqcWo7koCrnmwpluvYw4gT8zzrk61Ce+DsbVwKbt9Lf+Dmaka6+W7GqCHduRNZciVhwjlvglXMurVrhfIQQnY4maNlmppz5z6a1CLDqH7b+U2HkqXxmatfK4coTmDz5TThxX4suXa+yjt1a+9s8ek94FLDj/8sbhz1VpvQ06t3Xd369cpIdW6fT7FuRrcaP5ZOeXw98oHo+SegS/a0t1Q++9wmVm4DbZcUR29BCFpJJpFn3oAAAphcYuI8hyFE8xQoFEfgIGhZggoqxM9ME+E2V292efbUcCRZ+GGGN+YolYi1lXhRii4lBU58h+V215H3fadfhVnl6OSH4fEYIVw4xXhkP2PplldT9e21lD1/YTWOh08q1yGZ/ok22o7tRYjTgQkeSaRCmLFIX1FyPjXSYB8GOBCaNcG03IUuraOQO/IkymabF8104FJWNoXYnRMh6VFpLCV0JqBObjjoTCwZCo87AikaXohSviXTo6zKOeRy8yn/dU87YoLT3K1jbnqYTRt2WCZEhLqEKDjynMqmUC+xqixGkc6pk6syaYfUrJja2lx5xnHKk6e/ipVosVEWKC5Dqy5rbrMrIoSlTHIite5l/8QrL0V6EnfaOCplq21qfnY7lqmLilugTPi5Ze5SrjbVz7sItZtUXi1mhlC8/sj7D73zlCYQSlaRt69Wuvq7E7jhCjzwSwWn7B6r6N4FkYw/PlznzBNbfLFE9VoVGKa5ymTYVgqdKTJPJJssMIFtqpyyQMvG6bCKXh7IZWYSQWQzxdOKdOpf5JQz5n8JcTv0TgEbPdBskRmtdtJKT/loy85Wpmykukl8Nb0GM/QRn9v+//ncrWPnhOraAp1c+NqIC9z2ysy2nFBH7slcNzg2V9qdib5x/TVMyfnp65+B47S2RhAJfCp4xpZtstJNuzzQeyPWJiTVcg109c155pOxaan5fSvgoc+kNulIp761cMaXPDx+b1sJ0UMjciRnUTXf/aLu9gbbFa+aOvd56CHLZvRDL4EHjlQDiYR88sYirvKBbRmM0ZHU0zQvxsR5Lc72vHLV1d/hA9/3zrY66gysQOg7XwIR0o6BzEOB7Eud++T3HpQxj1l3qZ9MKreXMDUJHP0L4UsCGLyEmAxppjsVBM+ntQe6xIURVN64kCU6g/kIg5yp00w4iD2+aYh7tvKer//K87EyAUpcwhNXiMKzQpeoDyTpg2AMT6e2nKTKbdLjR9Xsd7+97K0sYVvNpsTRko4F6ytjEZrgXCgTJS4Rhuhj40tCIpDRiEYkApni4JCoE8hccH5a1OEOb0YX3XnwjNbqEL7OkY7R1AiRrVFjIosoFrQ50IUNxImaNsnJTIbkWwCTohxFF5nIXBAvW+RipfIBJq5170zGIQdJQKIf4kjSPwMUUBx1Qio1FYSTwBRNqdhzxYugUpAbJORevqM5hMAylukAh3AmdI6ecaiECBklTkhSkIKAw1DgEGYd1aO4jcQImXaqT73AmMgxjaMc5DgHqeaRH1qVg5KKyWVCMqX/Hm3SBDDoQAdgwBEYDJXTmBCTD57WCQ5sLXKWIXqLR2i1OSc51ImZDEsC/fnPgJokoCANaDQxhCpzBlKQ6ESIXPYCpmiaBp4mSQct3QYmcuAzPQ6F5HQ0ephzmOOn5rjKOQS6E1KNZUeTcVcqXaTOj4BDJYyUqXAcAqF2mKOi1+QJP/uTHhXuBKhg/alVCKrLkhoTldkxyj48Ag6dzbIdkrlhRih6U5zoEyexLAtXtWJJhaSOJ+Z4yUcFgo5+Du4tdkmoQukFmZ3NlGkQmkc16wqdvGJrLIbzKxMVU46BmGQ9SDUpxFIakaJYhIUhkcpDDvQde1FWOTktT1c5+qRE/+EkXEk9ZtVI26BKpes743oPszKin5bcMkexhaRiFsiacgSWl0alCRUlEzO8jJa3AlnpQKIHWQRdpJW2PG5Y+oUjUOWUpLQl6GfB0dmBlOO9YnGMTEh22OpaV4OXqZSjONLSk4wROuR1iXn4+SQ2ugMeJAmoQNrL3vcyGBxBlYl8bxsufETISgvDr0pnRjHsVsS7ehpMru6qldWIzSvpdc0oD7yOBPv0wQ1OSGDPkRiS1YNH9s2whrO7xfsF6cOXs4drSbir8/yMaLbNY4pfIxV5sDgd6HgxjCES4X8VzR4WvrDCaueSHhPyZXW53KxW8l/loOfIRLtkNgnEGgR+RP80LYayT80xZRnPJLrhVBMor5xl++p2qQ2imu3+8ZKmeFdJ7SCzeFnTv/KKhY0PpK0l+1o4wUkzzwmGsIPrDGEaK0S+Tt4zwA6rZclFTCCE5nGP2dUb4oJkskQujP9Uc2KdFMuBBPQKpWUilQa6I85R/ummp1zlQ4lG1PQtaW2cR7tUxmvD2B0Skr6LqViPFywBZjKqdH00FIqnHaJJcJTnPGyEPBch69AzKNtXzlLfl8uUo5hATjqTu4jZniMmcd8E0uh/sfFbLwwRTyZdvtmgzpfrUMe4hS1sBwvE0+pgh0GOfap6WHx8bouRjuFtsTplOFr2vs883GHT373WZ7X/tvUod5qQHaXNK+Qrncma7GQ4Q9mjVgGqg2ccUIMAzGj4wIeBGueudcE73heTNl6ipRf7/GZ3X9N3iVkD8DUSfCcxRyHqPuLkggAUpFcR61DRke6AZZl4DtGHbYrORXknhbdGcXpU3DFkqQ8NjjzBBzG3PhWEF4Qd6lA4zkG6jmJhuToCyTpCcLiwtid9al2uj2+WpGhstkbxiZk5cEID524COx2BT4d0bpxlnSAoPgx7icWwFKfUQ5s3M6J71zZ3ch0dBvO3/00KaQ7Mn3geUaiysOntwpN5CaT1+eWNRZakP8u/hLm/csvMw0Oyb21SUVguVwWzU71/pCtGqvct/ysPqVznB450UHGj8b4l8GQ9SiF54XEyk16ZxDJdLxNNB521F7wlh04oa9M+CnEwgGRd8adK6XJWOlYzluMRsscStXcj/nd+5IMfM/c4BIhDBghoCmF8kHVOS9VFOcM7LpFyZlJ+y0EuH4I2WJSBkbJxyUQXr3N6H8eAemFI1TI04iBLGfUhaIchGpGBcIJhC6h6/3AUwkWDrtdhy8R8mRKB+YQv7cAU5vc6JZJ7LfgoEhU9JsIlrpcQF9MPGeEjiYVM84KEYPKA1nQjHSJL88AU0QYduKd9GQhZTMOFy8I6RCcp4eclkKVUg3aGXuRBzfchZOSGTDE75ieEBJiFSf+SfgJzdo1DfPZTSB8IiEjHhKxEeRA4IGR0Du1wD+/WeFXoiIwIOZCTMonTZz8CfsmEhFRFg3VSOYz1FzwDhTlxiKAoinNBiqV4iqyyOJC4deJydvqgDyhSiWJIG4i1dJk4L9NSS8Vhd2GhSLL0FjlkFP6SWfEDjKzVNtOXOjdWIFl2jMmYE96hZbNIi8u0Jx/0GvgiU6K4MPQIaEwEfX/1Gn5EE4zDiBaYOKkDMOMYdPdwjMiYIDjBDwaDVneDhPknYrvSb0+VDthYdEeRekTCPufTcpbGGsLYj48IXEYTkMiWKBY3kBZmkOd4GUmCIAfIQV7SX6aBi840DruYWA//w3ooEikzAX1O8pF4mI4i6Wbrh2zxcJTxIA/0QA8niWUpaY5A8jK+ESGBhGpM2B0ySWBjEY9vmIitdnxC+SNVKD5AWTAX2HJGCQ/x8BNqmZRL2ZRB95QISScN4iVUmVAd92HjxzM7sRrvBIr2MFyN4hb6oHshgg/HOJYG1Ffg+HIvYX0H9hPxoBbvgJTxsJRMSXpBp5IJ4oupVEjehVZWiTszYouDATwvIUJP5Q5daSIgFotCKXRUpJhpkzjFaJa7BhHysJY/QZm+WZlHiZknGZecuQ/vEjEScRStJ0jQWJpVUXmBwm83EY+BaRE7OZcJcQ9BBw5CVyD1sFm0aZsm/xOX3ZmbEHEQ74AQv2mZl/mW9UCcUHkbMFgUFxmCTPiQEJkToEhPrYgi23d8pyV0A9GdtGlCZiM+43lCYrGe7OmeTomY+qAu9agdYIg1e3kSXnNGMYEv8BSKHHGQCqIREZp44vKd82BxibKWSVmg3SY+h4M4WnEWZsEOvsme7cmUD4oQnTmhM3NqgXgxCulBDaU9MVEOjeQO1dGdejcQhUk8hWkyoLSWavETLGpFMKoT78AOWooQWtqlWVqZA5GZTqmjO1qEg4Q1s4KhDfUSNikcJ/mmDhqXRvOdSvQtbMmW4dlHV4oTatGlgacOXNqlMioQlwkON5YQIDqhOWExXv9UGg8mNOXASG5aD3vGnuNoDyhqfTUnGnf6mwUKIit0qYSTE32qpX8aeDO6pThRnIrqeP5woV1DZYjyLUf5m1ManG/6pic6D9b3DutAmROWI9yoGBdXRaSapaZ6qjzxnpvJqhxoNfMyguy0YLLUqaXqpVM6ECfJZucTG/AATtsIHcZ6rMl6qoCaE5lJnpxZg2caL0FKIdMaT+nwq+kpqPaqFhBRDwJBkMfIEEGHqSz3qct6oKS6DuVqri4BqGpxoxZHnhCKjOzqEneDg1jxXkHFTWdhr/eani/BrwapD0L3nU6WawKLE7k6rC8BD8gKeOb6pwoReDSKlO6pruYYsdD/mpfUgqHymg72GnGAp7GDihAWhzImZKioMo4lpK83orJ+2rKnGlCnGrMym5maCaHG+aw/Gq0Z41M7G3Hg4LQyEQ8zIaonU54HirICsq2GOrQfwrQHa64hBVIwu7DBSbUPCrFYO5o4GyYfhQ7n2rIJAahayrG6WSqKIqok+xJqa1BrWyYqu7JOG7dQG3ELW5n00J7DabUHKLG3865fJxDK6hKCKhCECyK3VjrBg0RK6y8ry7J/Krl+S7mWebnC6ZR4265aa4t+W1gI8bfnCrpbSqPpWbou4bHayZ1LOjQCs7qsS7pd+rWChw7mILc+C5yzm66IebW4SzHjR3csyx4e//ux1xmVT6K048i8JRR4IAVUUOulNjqzeMtbtwOkDvh3iUG1A/qwUEmPvtgt+vqmzue6ITW90/unwtugOJq9isW5PAQmf/e7YoGjmDqgiQeV71ayHxKwaMGycftTkzu4dCucm3m12HU7heTABgvBYvGeNLGjeYvBA5Klryu5MCu8lQmcCRy/Rng37Wi/CMG7hMW7KqwQLIwTZgrDriFqNBG9cVvDlFmrl0l6OszAPDQr3vTD0xvEIfWYCbGUO3WoA3HESEx1xFJ1M6G+62vA2IrD9IBlU3yzDdyDhDV20gtU4ADENIGZGuzCLzzGwzQyZazBL4HGkxtxlPvEbznCC//cgSbMUnLcVh8VVuw7xAqBmQJxYwXJx33sx4JME2asEEcZuGhswNU7te+ZyYtcoTzcvQkRbGI3EOyLE0tZOAqcYfToybFhW0nmx3nME69rrjaMq+9Zs3k7vyf8Ed96xwo3Z0JFxwpmFqTbsRDLv/07E0rMy728GE4LwsKsyMXcyDMyclmaEM08VAPxzGgBDoQ7y9s1zb6InfO1Z9g8E+y8E66rxgccxcz6xoy8yn3BYkE7E8/staVLDwjhzgLxsXOIECXZySXk0C9RzwJh0BAhtqkKzPm8lG6MjKLZzzy8VlHhZMkMvYtR0AZdy+vir90JTPN8GBINDgYN0RuM0SH/3LDZq71wzEEg3WQqa7AySskvaxYce9Lu3A+WoZ3eybYt3S3liq24utGd+azzC6S+gam8ymIbDHhLDM2lgg/GuTDJ+B0naclL/RqfPBPI6rPuq88jTMLoNNV0kSDAxau7iRjxUA8QmyAR6q+YSg+J8tJl7S0DsZuWiRNAK7VietOj5dE6DdIbqRj04NVGHaEECVz1oMcyHdgJ0dCVaqMW/RIaW9P7HNUcCNcVsValJNDo3LukKw83pg+TzZ3k+K+XTdaajcucHaWePROhLbM2fZAwqMod5w/KCRtaEXjvMMyduQ+FiQ/fyayYqtStIc9ekdlUl9udbdFIydv36tuj/12GgGbMxF0RipHcRX3Uzm2S+jrBIwPRJQnT9OCTAoLd9E2r7EmuX+rdbX3B3TfcRm3cWnHXsE2PYS10oLS4h5HbmBlpXqUe9f3ghF3Yny0TK2u92HuQbCfcw03eDhG2YXvTej2XAMirl3zdDW3Q8c3g8l3dnQzhD26jfHqtFv7bTkPFG87cCx22eP3VR1GY4NCvP5h9CJG8LH7is8xR750TDu3i9Q3jLjG8tiq1bG21caO3tBjbXhHZPE7gP96kWVeY/erlSq6bnE3W/pTknvyYDe3ZbN7m2/0SttqndDvl5ljlU30zRr1W37ETO07NpMjcCTG+42vigdzeipGinP/t5khp34WN1nE+5zMLofMGbXAd10+R2jSh3PybIrch6Ajp518YFrmsyyvuH4mu6G5O4Y/+xHX72yPqjLRT6R/G17mZ2EXNegAqEKAODqBezYhx1i5h3VZWkhPe5lqx6qyOuVI8orx+nBIh3rOue/+bq8MM3NR80Mio672+64dexriG28Jua2s+4YiB7DXa6rbL0f1bFCZs6RpRnm+KZajM7QtRkGG82M3u678OcOEOSkmMbBUdyl4htuae7G+Z7pZhXb317I08lUg9ntZO79mZkrcRh/EM7LBB3eBu1rqsHEhZ8JCewJIubetyXe0e7dopdJlcptfeFt1p77hs4jL/rfHKscuv8fEgb8rLXn9EsnEV48/vrti9Tqbk+6SllOM1ryh5ROYYb3nsCfIGL/KJGSf3zu4fLZT6YIB+Hugfm+0HHXOYhxkWrxW5vEubLTL3nRACPxA2CvVRr5nxmS48yvAdZ9QXYZBDrxDMHeZd7vUJfX+bTPbE0uCBg+r3bZluz6DKvtEROpf8KxeVwxvbHuqVYZAwn5jMnhBELn+6FDyG79mJb6s6j/AS6vO78fjEre8AuvcGGRQ/GPib7e+fypY22puhv+qh/fbpnhDUTB/Xlbe30fWIGpU7GXM+quSyX2OscafM3/zWevvIHtr5rOzNyuzGaWpagu8z0fqI/8qZx+fnQNbRSGbzXtFLxJIYzt/8tmr70B/9gvqlFp7YIw8fObkdlB/ofd/94osic5+cAMGv30BwBQ0ePCgP4UKGDRu6A+dO3sSJDhfGAwdP40aN7zx+9MgRHkiSJU2yI8lOJUiVK1F6jBePHr169ezhw6dPn8F9PfkJHOhP6FChBBvuA9ezJzid+u4V1KdUqtSB/YhevWpR61aHGg26gwhWoUKuMUVyNJlW7UmULd2+bdvy3ct3MWXSrIfz3s6CU6ti9ddv69KmTg9GnUr1L9F//wBzhWwQnlavBcFejhnZ7NmOa9PCBR1atFy6dmfWvLmXp1SgWCHvK3xPNjh8h/+T7quam6jDoZcRVgRHFjLHjJMPckZu0e5mtJ7ZjoYe2nPM03nxPYU6tfXuyEwt6uyZ22rWrRC/BjcofHhxyZWRv4cv8t3Id+vs38e/7nN00OpUqvPvrbVMw+um2qACL7zFurMIO6aiCuoxhsQbyDeLjNtqMgyLMy4+DzkrKT/+RoQLQBMDdGtA6vCyDsEEcfuLwdcU5K6hgX5S6qeNFlKosgwZ2rGgD4fc6CP8SESSnROXBBCu6VZE7cDCEENKRoaQ8ovC8Szq56fbpOLQygx9JI5I5EA6MkkSmVzSSRXvosmegmQrrEoxD6oysQgDM6qgPgviJzGpRJIsI642RIj/UA7NPBNN+9SEjk1JUZSLJZIIjHPOvfhCqCor7YRxsaEWChS31QSFTVFE79xQQ1fpKyk+kx6FdM1JKV3pzeoOfIrTg3L71CBPBRt1oan6SuxBpxS9syCPhDwOwyJN8jCk+eqrFUkmofOoUpiW21UroP6c0U/xChJK2IGUAq+vKXWSDadmD9VqrebWWidbNdtUUsC0ljOtpgOv/NXTyBQEdsJ1e4KXL6fixQkfeyaWc95DV+1MrWk/og/WfPXV9kTQ/gUYyhYtUpBBpc61sR92H5YtXopnrqkeyECKTNoOvco4rY2tJYlWkPkzUTqQSsa0OgO9Q2ip21QOtU9Q82QY/+bZwJk564m3Kgmcj6K9+GfnnBN6tFuHProupGdiu+aIVWt6KSztNLYvcxP+cqoEC0MoaxmDBue+g54dU+yx1SpbSf+aHJrbo5FekW0WDYS7brsHwxtPp2FrCkE8fbXYa68Jd/Ydys46HHH9PEq88dFIhlxyFt3GCXSukr2bpwR58u5h2y9vqKbITH/26/ZOly/1WVdn/WP+us1VeZMgj1zymqOUdytOcX/685gPg7fyqBi6B6eJbZ5nHnnUhwy/wO0b3PQLUZd+bOdHrn9s6mVv+/qJI5aRgo5lLHjlxCD60MvAmEK3AkrsfPVQH0W6s47BMWhn06KfxmD1nBTl7/9J1IOT7K5HOwBChkpO+86DHDSn7DnEKRHLXk3mURD1aIWClGFPohqVQZ9tMHkeVB4Iq9e/EQoMhpHpHBJ1okDatBB8DoIhE//2o1UJCUTz+aG9NgjENwmxZPwrov+OyBCdHGwhZTygEy3CxAOV0CI3ZAj8WEWcRWVRgz3DIuy8uMcv8q86YTTQGJs1PmUZ5oAIdGBB5HSThUhMeA1KokHguBAfyehVF+QhteATD3jE5Ft8BOUQ/Ti7mgVSjXfKSefK+D1Nmc8eI6yYQfBxPdq4EI0HmSRC5CgmnmGSOGN7TyiFCbBR/rGIpmwjQm7JldpNSSuutFlBaHKQV9KyiVL/5B1XdmlJQ9VxR2V6T0jiM8zYJW2UYSRhFEMHFWUxRIGujGXwrOnGM75RkrnMmYaseJbjeHOczCFnOUUpQnRij56oLAgM+YYQeZlPkVqpx2kSesqdrHAhgnufxXrJz2iZyS6dBGUxRXrOgv5PkGtc4ymb2EhqRlMr9AAfImO6FYwGbp3+RBSjQDpMivS0pyMFIzpNelAyPrM2v0uoxWAKU3wwjIkLjWN+CrLNZiWno//kqU+1ShGgGhOQFCOqMpl5VIPUzCEHeuRWMJLQqOyEYi56yisbIlWbanSflbxrMMkZHK12NagFRU3WVCrWszaRbzZL60ES+1KF2AUceUEg/9bMCo7ySdalc30fPruCMfcESYc43WlwYiIPL5JlIvSQoDQlBw6RAtYmWmNkCqXYwogdtiYwXchlWWqQmRQEI8+yyWOtqVjdYlajncWrFdvDEcfScKslqwhqTSuckbq2lLD9n1Z2IsWtTdRFkp0JWRbb24PUBq3k9W1dyBtR8sJ0uPY8LmeAJK1oZeY3PR1tanlE3dZaN7CwvVN3B3tb8S62uFiTJkPWShbpjqUg771pQ94z30IZpLn3pUh+f5MQ/hbTv9h9q5huEkvuBtcgIy6uStF7EIzIxLmsjbAl5avgtYKjxja+MYe3ahHgsLa/JQVxd610Uls21I02cShCcP/LoxwnWJFhjTG0Cgct5tqXR87tKUPYpp6uWhfEkZktlA/DsOBNNJ6KbQgn5dc3IkcZp2HD8YXTs2OHZNnHXfbvaxFsMSY+csk5YRc9l4wQ9j5UyTY2HoyRnGQ3L5dZmy2OcNTjUyzzWILy8CspARvieS1NuBEtK1vbBcNoHnixNB4JDfsn5ggnh45X1UiT+WrnGtZw1mPJtJf9Zuh5sZd/3uVLxKo5L9LeuLfYO3CMH/1q5FhZx/pNiJbDG5xcu1ZrJ77pihk60VkOd9Bb+TZvvdpoWLeKox0qDka2SmlJW2TLmA7vaUm66V3HOJrhJvRtZcfbXtMy2a3maF57edeuG7PbzujhK8JVyz+u+vHD9WbIZO+Eb3HTYznNuuwIya3Dc8eH4HPOMqWxLHLpMlzef6X3zPZcVptJdONIC91r5fTvKMv3Qx8fucifneV4w/vdPv/xMSH+4JZrW0y4NbbFL77OU2/c0Yyicid3Du2crxvoDcbzVzlN3DtzheIWbm6Ll74Qo8/r6/EF7YQXtWCr79fqDf951oW+dZZ33d1l922cxX7hJrPN7AeZSUAAACH5BAUKAOAALAAAAADcAKsAAAj/ANEJFKgOHDh3BsHJS2gP3L2H9/LlMzhxYsKL4CRq3LePHz9wHkPy69fPn8mTKFOqNMkvn71589q1S5fuHLmb48Zh3Bmu586fQIMKNegTXDijRXsqXXr0pzhw4qJKnUo16sWcWLNqvTiQ4FB7EO8NpZhRo9mOHjF6LLmyrUqPZvPFnGmTnM6xePPqvcj0aF+mQKsKFpwwJzitiA2P64oX7MOdEA2KzRgx7kaRIQ3yQ6lWpNuU/Pbluxezpt27e1Or5ruU6F+/Qq0Onm3wbuLE6AzmbowxrO/fliVyxPzxZ9rOJD+zbCnXtN3V0FMDRqo0YXWirsPN3m4V4+2tBtMF/533c5698+jTO/5dOa5otJgvxpcfkq1buDFtot75NLr/7NX51FR2fBllYH9SQcWdVPt9h5VQ5AGlHkzmoVdhesAFJxFxmsFlmUHw2eeWRPOkcxpGU/0XXYDW+TXgdQIytaCCVelk4423YYSQPDxSCFNDDL3k45BDqseehvB95JFocT1kEUgeKeePR/fMdGJiT/WnYl4BvojRXwQilSKNCzqI2DrrwAOPOzzKQyRMQb4pp49GsufkZUoypxFwCaEl4kotzeNOXTndpN84CW6JV1FCAQbba9ppuWB3WdWWmJoIsSlnQhfGNKRMoIL6pnoYhnVWSExCVGdExqH0z6ssuf9kJTnn0GRaTloq2qiXQEHqq6STivOgbYm5Y6ymb15k3puhNhvqnD+WClFwD1l44XnT7pScP6/COuVoc81Fl1256rorowUa6GtfWQbLII6JtdmOm0QqK6ez+DYLLZ3r+SbknNjeqZFmJ3X7z0l67lkiueb6NyCA60JlkLvvDquVsc5GaO+coR7r8bHPwhSynKR+OvKF96wnUUImGdztW/xUqV+55rb2U2t9UZczdblSfFhhW33cTnn7gvrx0R7nmzG0Rict06gCW8Styy4jnI+ViOZFc1A2G8hTjGCu2+7EPoNnEDwGIbTTycy2g/TbcIOstExxuyMqkQFvmBDVVX//O+5+D1+09aKBfxm2i68pOHFCFEeF6H5AsQkO20SCKs/HaGaeDprHZl7353DrGy1YehvE98sskWbaWIluua7N0/lUFdnuVmoYOGmuKbToTLvt8Tq2Bq+58JyvA7qx8Bj/+dMUkt6RP3vzjVLMJdo0VHcr6txli17vXFTrtDeOKzhq6r475W3/DjxNXdk6UPDEJ5/5/PRjWjfz5lW2GfQsH/zWPqSxUjlqdp0WgSldELMOmRLUrsZJpXxvU9qoKMSjo7lPIOfI4Dm6wkFb0e+DaUKT/NzBOaThz3kjMclF2oKfcTGOcYN7oeEKhxQFcq+GYcLOAh04mNyV0Gn4GhKn/3zUJsylA4MaPIc5lpjE9tEEhFD8YQTbUaGIdGRb/GNhoNxmvRRhbyfjKEc5ICcdGOHMUU3hoWx2mLu45YtCO6kc3Tp3RHRk0BxizCMTNYgO4kXxg+WzH8h+VJkrcsYggGoJaQZFrjGBkRy2Ikd/mgKbscAObDkbEHd26EWqtPFt8nCb6IYix6atT4l5TOUe3we/zf0xc4IcZP7yEaJDggNQF5kZ+CY2jnM8rR3n0Am6aPi1pEQMRYoL3+IIUxURutFuk3vaaoYUShIeEY+p1KM5MiiQC7rylZ6DoN0IKZz6qASR/LsIkKyHqHIJy5fzeEiJhOkirw2FkhCDFH96Rv8zqkiMKoGM5bHadDlNCQU9efFdTbLJ0G1yUB3qYMcf3/EOEX6SilUsZ5TaspMtCs47tKJiREhzjknmkEsznI49A5dG/qAoVwE138eKyCNOYUQ9e7ncEc/BUFXykSDskCgUKQpL+9ELWxrdH0dPAiXVneOjwoKkSEcKTC3V02HaY1HXXEM7GAJrKjGFWwVrCg44SeimeCGhHbEZxmyusps0Eer8iArLgRKykGs5531i9rfDhLFWU5VIlSSps8Jy6WGvc1R2HMnJBIUVaTQl60/Sg9a0umOn2OzpNn+KjoiuQ650dSayAiYfLKrwliyUlYnIMUBIpiOwgp1HMLO6VUv/Aqh7xhTb7L5qlcdCtqCSCwqphmsQ4hrEbTThaU/LwUQ7PlSodBWkm0irrZSg9j6qqwk4AAvbPZnIgLGr7c26h53c6tOrshFMIN2xXo8VkU2S3clw50vfhJBwHXZUYmZV6dCBeDZ34hxtn0SyQtSi07om6cdokCuep0WtWsCkZ+JWc0banpdsmtxhLAP8XmMRdCE2LS567ERfhF7EmpjVrDn8W0KCkoc8QMLTSEjCsnReNyTQi1XKYmKQWY5mNCmjywATq0NLYrJLvjJcAwUnDoF+7sMgvumI7UTllP1LY+tba0MdurngSgYfFxHOcOpDkn6wbIXL2QzLmPMYh/gG/8jVIwdUiExh8Fr4cNpBr1SOJdMnX65N8pVWldmTHrOieK37ZS461iHie+jj0fmA9FmSRJIZoxPNnuGfh1amoZTdShyvUxHiaFvDxKUXQeIAcJ/dC1xWx1fEgh60v6yVEOAhEZtLFA848OFofXCEI2aRNC391I/M1BidmU7IkgamoeYcBtTHpDCS8bnVvzDw1BStqJM9XMGZLsRNcbyWrKcFZFWdB464y3J+Fx1PX/8a2Po4kpjnc2Zlm5OpItkHRSzzkqEhKtquMy+vtNfJdtVPplBOeEIAjZHR9avKlglLoX1kEEa3WzSPfnS1gKTOO71b3xixcbLtfRxwAFuw9v+QCTgkGWpdUdKYOGRXVHqyxlTPVZwEVYjCy4ruQMda3s3utKzPMxZHC+dJBqGxvdFiYyhlJjR7ktlNZp5kRTEqyTKHdjPp9w4IQpniPO+xxsoz3EEHnZZoj/jG/xU5+T7k0fTZHyKZU/K4g4RJQLaHidoJcKsLKKt3VoonP9h13X04QmNPjcPLbqqzN8ncZt3J0STLcYygZc3vSaFxNJOqx6SjHFSvesOKCTbapmioRs152IES+fGU+OHteTChe25fPgcy2/EISjnVopGNYqTYmqHMcU0U+sQV0GE0TGzW/yhdQNNe7HBq/WRfH7BBg2XiQ7uImi7CaMK/Ix7xkAf/PephD14XsqN4Kol85CsTnha/76MvtfJ78sr2ErQecKQ44g3CcPiqc0L8Qn0Tx2PahxEVhSZBlYDskG3wEH7jV35GNxxrJmPppHSSURruB23KN3osdUZHphSvVHjNRw/0IkTRNw8f5jsuBmtXhjf0ZTJCkTkKyA4QFVFBRVHg94C8pg/Dlhax0nsfkUU2tkgmAnoaSGc1o0Nd8zpoQz7wcIBFZX9tAi08BxM84jusFiEtuC9FsixWGBQymIA1OIYJiIPxoIMReHk/mA/mdF1mJhlC9m/zV2d6cVWBhy5N6IQxFUtTiDdE0m1Jw3BcCDDnZoXGshMIOIaKSIY3+H1n/0h+O+huawEOxQaEQWhgCSEXWPN+ohd/j3J8+URDgaSHmBJQ3FaCVUhEgMhqG+Mj+DMqhYiCl4MRCMgOHNQVjNiIOVgP5uduEnh3GnVLQBFAurSB8TdDoYgu4RcPaqN927eH7QVf+UdNf3Y089J64oIvPdI8hVhB21drNIhBSzSO/hVRELWAODh+vIgPvnhFlKgnfpJjGAEuNHEaR9iJxxh4NjQgzRhlCQGNpiiNySKLq2g3GJV4StOHP0JB7PWNuBNUA5Fo3LSIN7iLvJhxv2ZmU4J3hgQUC/Zp93hA+VhJL/J3euGPAMmHAoluBJlwqIgR2qiQFHQ55fMOCRFU6v+gZT51izW4gDk4fvjAjpLIFlBXTuq3EwBUGo2EhBxYW+iSU/4IDuCXkpgik9DikmszLwlHjQ35hDZZceGIDkvEXMy1QbcIVLgHlEI5HCXRD3hHS8LYGR9pj/oEintBTPeElxiRh0NBUBDkW31IdHLiklHJfy5GkFZIk2pCUQZBUTgJUWI5jht0R3i0RGjpiPRAD0LpbmVWbEzijnIZQHsXktuTj9HhkOTTl1AGX11pPn9Wgp1iD/iXmDt3EYRJUF3JmNnmmDjZFeOoWZ3ViN9HD+WHkSnkD28YFFAXQJsIf6apF+sggjGVF6vJXt7WIw3Rgi6JNBhRnQHFmFz3WTT/GFERuVwrFlHvgI6PGJSPtg9scUvJGXKKRBcZtJQi+ZyqMSCM9oR5yJfdaZvVySbeNo0teTyHqCOtuZgVRz8zGJaoJEZtpWjnmIDgJ34X6Wvql2BMtUJ8dSu4QppFhp+rwWjgUHhnM4oLd5sBmoW0CVxUOZ15EZ2hxZtiKBCJJqE9iXvriaHQ4y1TI59VsnftJBUqZZox9CW0SKKNKYJ7CY2/VZC/9TEvSpW7yZjpVqVowpvpOZ4C0VCdlYu4d5FqBg6o8w87MSWqw1pDGpJGyliqkaVT+qJI46QeA41VeqdQmKVYOld4eqdcqlx69KU9OYPfBxZjejryeTUeyol6/xkdp3akQMGnFBWnclo3Kbmn4KSnUdSneDqe6pBZlrmI5liD71AP+nCUp2MwiKRaasqoNwQdu8Q1QyGp0kmpe/g5l7qbmbqrnOqnXCqZBEGRY1iqp5pOqdott9ShhwKisAqpjdIr9AenDGirKWmpdrqYobWrE9WruymGOSmWwSqq48kO8WAPp3oRx/oqmiEXjPSh96kX/uR32gGnXrmbMVWllbptyFOThdeveQpCdxqGDcqt3Vqj5Siu6CgPpuqeGJGucyd17nph10MjyPdyUQFJ0Xl79vqdG1utDQk3Gsuv2bateBqGmUOw2XaDj4mLFImDF8mw6OqwIHE1y0qaLP/iFIRRsTQ3DpA0D/lwrx0rspMqpwIFkCKIqQDbq2WIsn26suFKhsNZnPEZPcearHrXqjbLKDPid1FFRRYBtBvbp9RaikZbslxntkxLsOjIm2P4tDa4oyBnOjFbtRkBTFgLajM3JoNBsa4TVb50D8VxomTbn7d3cNSaoGCrq2eruEElo2nbtDT6mDUoqOgJt4ikrnOLqCBxDx66pvEqLJ6bJXd5M9rBs+1gDxtScoJEpYZrq/u6h9P6ryeLpQr4uJ3aoN6aky27o/2DuWaarmbqD4pKKIjhOJbipiuys1LFhvHxEVIKftCrO2MLDx82eR8rsuWTqQNru1WKuzYoqjn/mpm8iGaqajp0q4nOMUZYEj7OmlJd0rWkUxyhgRnchhcqer/VC7bZu6u1y70p672SK66PWJw15jKZSzWbOxPOcRv8JB2B0bNIF2ZipnP/8WoGUQ+z+RPyoL8ju6kFu7bci7u5C75B9YjjmxAlYcBUezBVA0AKbBPqmxXIe1iAISzmkA6s0ieikYmm4h8YDA4YHMRBHG4EFQ8cnK0n67j+26lb6r3ge47DCZQXwRblS7VTg6zoS7wyPMPnYpK99FrtIVhiYWUcJySVd4wuacRHLLvRqcTd6r8iPMIkPJw/rGwpjMDm+zJYjIFqusVczDUyIme94RBlRXTgYMhgphAH/xp/UAZ+tpe4QnuAnCqcaRvHckyRPkkPHUXFeEymfJPANWEOffyhU9Go9nQVkAQWqsFxKKiaIIa/fjm2Hfu4lMy0YijCT2yDmWx57tkyn+zJCBwol6XFnvuUCgSKT9UOObwyPHhQiWeY1egO0KvG08uxQ1u211zJtcytM6jL3noRmMwOP9Gex4moBvOjM4uBMIwVpfyUYMKzvTQ0v5EQZBwZysJwCkHN1ZyrSwzHS5ue3GzJNYgRihhUP7GWx3nFmou5Lpxch0LK96g9PBMep3ses5k/+hAkGQ0UUVmr+wy7/ezPwmnJJN2gCVEQZPgTF8oRWJSqHVUldCHKMdzOHv+oSeJQDq8FE5lJgvKgxuJ3yDjVY0Px0XYa0kY9ySUtwuBcEEKhjmtpSL78y/KhqKYxRjR9QH7xFLSSDpLT09g6svAwfmXlorYHFGWbuB591GqttkmdgD/B1BjxkysN1VGtwlOcxX08G4LnVZB0LEuKu9F5hrP6WUoaVGjNtF+91oqN1AINUXiBmUDZnldkH5rLoTBdE0o0yoiBTDzL1ahJg4D9fYUpeRdBg9aM2Kdt1Kntq5bM2iU9hkJRkWcIlI42Zn/SyWsWQJeF2Teh2WQEDoomzgQdzurpgJmp0gpx0out2Kv9wSTt3HE8qgMd25DNi7VNbK6C28mq2w4tyr7/DTn9ZdDgANsF/c8/Kb5nLJsR4sbL3c/N/b9tndRPPBTqKb6RiN3ZXcUPGxO7XZ8QGrqOU5ZmedKOTbk2qMTnrY7kJ2L4V1Pc65WHza22qrTxLd/zDRTibIa0LYlrcdt2vd0pt9tVDdGR4jjkwEQr5lxnOajCCb3ip474nNxL+rgQHuGcOuEUXuGXnMtw/RPFveFj1uH5jawsk5R0YyswHMOeOw6bxU2WGZlPHs532oBeDV/00iYPPqlLLMuMHd88nsuxXd+QKIm2LSKd7A8uzGDJ1dts3tti1ORKxEeUSY5STlRWGn5qshARwiPtLeE43rQW/sRPu+KwvRNLO8A7//hxQl7XmEuJH5lEN1EObX4TTJQQu3GW4MqyYDrNCVEPbVIPtkmly02tgN7NCvjlmA7lT/5Qjo0Rsq2Dkv1ri97JChakkf7fuJIVzPUTuSEQ4MBB403CFfniUnbGor7YcRrQDfrlkxuRHDSOq36w020Qr47BkdiOeZXfLPPod/sXf8UYQuHYCOuTOie+kBiU5veP/LzEbczex17qASyq/nWW0B7t66bp066LiN5r2P4n3FJjRt65RCp4EQrtqkGoucd/O72OQdlrHNHnIyvJ+Lru3XvquZzqXaFfkplE0O62rT7er46GkibrK7FCRj7MrDXTjhOhW/ZUA0Hgrp7hov9tm+HHi+dx7fvAp3pq1N43rdhMVE68iBhvoxmfREbfRNL+8SCv4efO7z1oWjaG5szp0GyeR5R+oy2f6a3+z19pECSYg+lx3yHYz2N/zactnt3c7EOf4imOREd/9Kxe6AaBnpjZ9BlHSzNmXci2YzKB5ON49RpU78vFXFE+oZQs2Pz3hDWPweXHjjlPsv5b9iiLy/NO9PTe9gPx9kiP74t40mJu91bknn9SY9QjLv2t+W9vDsA9+Ktu+LpoEPFQUV1noRDoa5LPvR80g7Ob42mvu9869MAP/Dw+99W+jhBBzqbFMsXGnE2D5Jr/8gmB9dpEuf1rk7lH5ZHNmQqYtGn/O1e5H99ov+yK2FnBX/48mfSiSu3DroPmd93Jj05GrsA0cSzwc0eT6etAAZyCWv2O6IAAYQ+fvn37+vUDx07hOoYNGb6DGFHixHcOLTZUmFHjRo4Z1X0EGRIkOnQiTX4kmVLlypMtQ4KDye5dvHj06gnEd08nwX38DvoDChMc0H335rVLl+6cOXPn0q1z545h0nQqz50TmlUruHJdy5krGTLjxJr1BhbMapHiWrYXMXaEy9HlXLp16bIDqXFrTJo16eHUeU8fT58HhQLtVxSpUnNemz51By8qw6zo9u5lClasxoh9//LUyla0aLcM4aqLq9HuatYt416GOZMmvb/4/2zvHFywMMx+iPfhW3z1amawDKPCgyd0HWbY50jmHQsxuTybA7MOBodcO7zRo0ufRp1aoUi8rc1/FK8XdmzPN23nFJxbt9De/fj9dqfUedKUTdElbSgtvLYyZ6+UoMtIKOrsuWcfcBCCybbstuOuu7YcWqgjBMVDb6PzNksPrtjWy6o9nOAbTD4HeTuIn3zwyY8kAJPCS6Wn1qkoNnYSGtCyy0iCqUOFICrrLHBWJNHCC98Kscny4hJrQydFzOodcKwkcTabTowvRdBYvO8eexajiiHuMEoKNYyEUojH8nyEDTXUiKyHINjkkUdJJb+bsk8//9yRRNj8qse927zkCf/J+/QRcx6pGpJKMnniieq4dTbaC72XwPlIKHU4jQkiefBB8rIKIXJLz4pKuxRQV6e8ErZAr4ToMpqE8sumQrlEtCAk98mn0UfNrDQe6myiLU+OBOW000+dHWtUffayR6gzWcVRT2xfzegt05rsLiHYsIx1r778ylVXs94TrEueEAoTH0fhccgdPNUttFB64nkHU2ZhgjNImcqadlpwqo3QWnpN+7YhbbddqFU/u4OLXEEtXO9c2jZW90Tbei0IwqLsmRdSeeZBOV+V6ZGH3o0sBifgONkpctp9DE55q3gwvMhCbL39Nj2JVe13R4kuHo1ZjpfO1x6n38vJS18NK0r/XjyvPnkelVdmmV+PwpuVU3SEIzvm59ipR7AVB8MHJqzdhunn7n7mk52gOcqW6IiEgvlfZm+FaemNVYaa3S6nRqhqe7ZmnOuuIRoPbNXUIXvspZ57h54G0RJKQnAiQ87YmDZSi9bYUF2VbtVbVUvvvv2GXSjBaVPZ48IP70lkffBZ/CbGZ2d5Uq/x0hCllUhiB56/3NWKd5iOg0ee0TVqnaKHVsf+oXBFi737rQRn3Pbb5TsIIUZ5N6t3fZO9d2Phh5dc05BUUuederbKqe2snFZQ+ukjdgiqrpc9AuZNSVV6nff+NbvwOe1pAuGS2gwCod3h43cbO5dn+gI54k3u/yV5oYd1eLMi/VXrHuA44WXwVhpwFDB7B4QJ4BQ4w8CBj3G2cWAOoRafCcJkd71TF8c2mEF+cVBykUOQ/RK1osTsT3/rWaFbWuhCbBHtdLaiIewY2DSo5VCHhyII1X5YD9ot7VxEOqMRQSSkmdTJV77aisEMJivqUdGFE8HR6SZSoiz2kWm1KxzvvPi0qL0LHGME3r42KBokHnFI8TBLooRysyPN8TJvdBDppmhHVrmuVsnpYyhrSDvCFQ6COPFiIdFyMwuSEXhpZEsjo1OzJcKEkoPZSam0gknScbJ62qPIdvZWLlFehmN3OpYNAdnFQaZyIKA5nytfSZOJyEQiFf/b0jOXiMnORY1zWeFmLyF2kbhVb5jZkU5y1lJMEglOK4kk5dZM2UwHvkc+h+Rd14hIm0VyJCJDQmNNEHYkTDoIjkeK0NM2ByFw3Kcn/6ujxHq5yXIGcI8wqRByaFUrdhqTHln56CjhObitEVKQ9DRpiiJkQUUSkYgcjE5nZhPJXdpylTeTI0wWp7Wc6DIrcblbRM9pzndQKJ1X0k5H/RjSUZbUabtCaT1RhJ17sPR9Z3Rp0ThDpGyqSJc4RdQhD3nCeuBpHgz65k/95LCjbTSYRkUOR5Uqyo1lxam9cyBU1UdILyWUjFmVTQav2Rl5RHKb30RLVU+k0qzMw6wMspP/Vv7EVrm6VSIU4k5cEzhXUdaOnk3TK076ejBXClYiLi2ibKrzJYJy7mYkdKZOtOLYk0GWHw/C7WQfYjq+pROzSeUsO2nzTs9+9q6iVSn6WkpNiqC2LAP9VVpxqpOT3oSQgUmYY1N2lsL0Q7cGzEpyKDQh4MIGlMFd4NLAEc+oeta6fE2uvmC5lgyuNrK/smlBGKVYlBouoShDmUDCiJDvVtZUv8VseNG7npGS9L2DLKlnwZhCMl71nwB9ZHXOUtBSvfF8J93rFwWzlRzqZEXfzeO/EFxeQcVjru0DHhmL28zGWfd2sgVHaVMrGpq4kcMc9hJ/c9g0nfr3kJZEYdR8/4Lize5lxQsGKcekN9KVSfiUT62xSQtXw0VqNaCF3XBBeYIoXL6Hngfz2AmlRp/bHjIfPWFy95IqXp25WIahbLAyZdw0CII4y4F0Hkz+2mVrzmRLPAQyotpVVWbuaqW3wY2KygchhkK0SS2c4XjNdS7Y+Q8cWEtmnv+orxl7sYE7ZDTC+GnazqxLamImM3UDiWVD4RicBJ20YbbypynSkMUl4jSzQD1sUW+R1HymcXHZlaJA4wmwBEvRj8Ea6y62jdbuSWFNH5Tr8rHIu1OijMMU+GtcBVtQwwY18GAc43zhC6V3BSMuq+XsIu7THl79MZlTxGgcVsvaixPIkfdiGP+G6trbJumIFBdsbmGje93uC7Wx94xs415X0fdjboZp90xMRtvD+t43vz3XtkOVKtf0KZ9D30iehId7OVDutMPTLbiH6xlfoYWwobQ53WrtmE729Lh+yXxkkGMnK9m+TshybfKDdHwwLF8hzBUoc2Kjm8rtblxUU0rmnjfXLEQPetFBTnQfinUvE6QaHFOe1hSFiDJSjx3V5X61qx+7gf39GNfBsc/7CaVXBBF7WAuG5En6NO0cJqjRj9wRNkWsonBfz9wlH3Gb1xjnUs17kC24dy313e9gn3bgsQv2gZ9d6LX0YZDd1CYeiUs5lIX8ViYvc/bBE+s3v7sz9f0eu17/xl2nF3tgBq/4rJw8v7iUIPIXLVtMsT4mPYu9VmZP9drbXsa4P+4Xtck2qK0HlyAT/YjFanT8dhvWjA5yYMzsNMbHJCHQj35W8PTp2S8Na6KeeJabuez8BRI2ZS45sNM33Eg9cDqofNsvQKuu9dm1/7GI+JO+6XO4Yhu1rIsqBdyy5vmY8VG0qkoh7GAsfGst4Au5fxOkxqkryVo9u3GI+AO1CJRAyis2y9M6DAS6o7NBDPzAsjNABNyvnZC1vSiUHGMfT2s8TYJAt3kb+YtBGcQ//atBDCQ+kWMmQeKdHSIRbpo2WYuavfCc9dIXrHE+B0zC/mlC2nPCBqNBZ1Kf/13BQA0EB0AjpDTLKbMzqO+zE+47qdu4DiFEluCRhzZhPRZ8uzIcNiU8Q5ahQI5Zw2QrJQXMChvEvCeKo0T5sMxLtacSiB3kQdJSRH2Kh2UhxEIsQ9k7Q+pIQ+uDQlMrKUiMREnMwD5MPc3TsvXjohPCrjlaHEAUHngQxRYsRVtBLcn7xEW0vAd7oHwRNEDDHzlUnyeaqjnqwKoqsnmitYDrPmvzPP/RjmV5wGD8F5ogxlRMpGN0xFekRA0snKwjuR2iNv9DMwdCszjst347JdgJFGAER7/pi8mjQHOkMRITFDPbGkZ0qtvIQRxqRJ2qse4Jm32MHWOhvppTxdwbsv/Ysbw8c0NrBDEg2qK8cqV7GUJBu4kZGsP1gJkme7GJJMcKtDJT85s2LEiNLJR6RB+QdBxl2sX3oY6RzLGB8p6HRMm2Cq/zWkkjpL/7m8HwYSZ59Jtj1MifNDP0yUgMOpeebDee7Mkcc6LYUY9xWafQUMk+QsqkpLulbMX+EyTYyck8A8NuWsAaM6MhijieZCqteBqHPMlN6qQR4a2tMEr0akmD7DtDAcB0LEuhaMuKLExkvLYLGq5Vu0r2+bSPUsbjwkdMWR1MI0WIfMqNdBdqJJEhXEx44srGPMb1gSfnujO7QjafZBZvpJu46TXPxEhs86rdERTIjEpBEzRlWkT/rOqMAiRJzyMt4ySRllMdTGNO24Qdp5EgD0vHrUDBGcwx0hw0Y1nE4VqvLuOqdBzCgPvNn1IhSxMnKdJH5/yXTTws4qPO6jyWdUuX+3FDIrzKs0wWycwVLmOuomkjHFqv4UKlsjLCvXQ98cCWx1NPv8k7WFuP6oS4VLzOOLRPmggdcbwal6orq+zPR2o3wqwwF2tAtVrBKHq9AKmSBRUU9vQVfvAJ/RrN65QmKYOxAE3BdWEpRbpQDEWtu2wpv0wIrtqXSZkUIZKhT9mLWUFQrfjGckpRJxOUwJy6+QMpauE43XBRGIUN0rRR+9POyGTEn/zQq+I81pQdyeS8vdMj/9bsR08pUUFMj60gJyflmwOTUoUR0e6h0qtZUW96I5UjPNecUS/9UpHSFRlNwe9ZtVEKnADtizLNUx7DUOkBCYiqVLdj0ibdigSaMxbb0TwVRkT0Hz4lkZJrUUDd0kEFRYksUkWNsZXiyij7KKaKTDO1ErZ4VE/plNUDkUB5jbTQ1NCwU/I6L+1gOK0ItiUkVdhALt3oiTdCOq1Q1avKlZpQ1C6tK20KtHc6pvWKISIq037xMpnSCuMZiecQkjgF1vR8UifTqO3AKGPN1U2bVFJdVthoUBfNUl+hMJW5TkLVGH66Sx0L2M+jTu5Ur+4E1zT9H3Ell8JUhwNBuPYDqv+KcjnK8i3AdDKXYlhg60cjXML1YNFThVbFVEzV1E+JPKZ0WS7PCKm2MTqPHK50gVROM62XmYnAKUyWgDpwQ9HLmIgEU7DwyiBhJCIqVcL19FMs9RXdnFFE5VAMnUt0cS7uXEdpKlpwZVOLaRMr0U59OZ6VQLGhFA1QKlaNOlYZcql7TczLaNA/fVacGTUjldoUZFNOs0zIvNu9RaCAIhSzCVvkWauf3QuLoQh33dE6q1k1DdlPY1BEa9FnTaGI+9eoDTVHbU2PNVS6na+9nVeOEtH7DNyU+K7LoAzDNTCt2I55LbesdVy2fVx821eDwU8ijFqWvV2/aF3PHQ2+vRX/tXWbogVcwD2bPmFX5QBL0ynWFitThmXVtiUR9tym2VVCwkyWDKpR7gzdKKtZwLqwrQosNv1WUI2hMh1dIBncl4sdLDEweOUjzQUcO0PamBzZU3Uo2v0j98FeyntUGaJbC4kLvzVTO9OS240ZgLEMlTDP1CDc7mlfjUJWZM3cpI0dhTosD6vewdHf/TWjmRXe8aWIQrOSsQAocv1djiVgNgUSsyHeIxTFHemWzlxfmCG33Z1gNe0e6IxOMTsh2uLfZE3UDV1Yb/U58CUXhz0ahlNbz3UxHwESBXbh5nOTBp7h7FAYCK6zY80iHb5g/WobYrteIEbYWgXXWaUmyzqnQb/srZkIX0gdX+8cYoBpYbWiWABCXr9ZjgfOmA8OJS6WNtqdOWoVUerw1sCxs+5tVBe71VuNYKAli/5lzUd+1IAAACH5BAUKAOAALAAAAADcAKsAAAj/AMEJHEiwoMB7BhMqXMiwoUF+EPfls9cuXbpz5MiNGyeuY0eD4UKGdEiypMmTKFOqJJlvZUqIKu/Nq4hxo0dxIEWOdMmzp8+fMYEm9PeQ38t8EytmtOmRoM6dQqNKnWpQnjyD9hBSbQiTIdGEEPnlm3dR401wGwfq3MrWaduU8uYltAcOoda34MK2LLgXnL+/CyHeU8oUbdqCIvEChaq4pFW5Be3RbUyQn8S+Rfv9/Qp2cM2NGTWOU8uYsmm28MBdPU3ycr57sMEa7cf1Xllz4CxiLAdO3FNw4VgrXCu8eNR9Eu9JXp7y38Ck7cDNpGnW92/jAq9jX+huu8PXyueJ/xdvkui/8wL9iW25nmI6s9qNPw3ufSXkhORVRm8IO/z4du3cpxBSBP2FXkGbiUXRORxZVxpr19FX30/5sWXPfwC24447AOInmUEGHoigetK916B1E5ImYYouyYVhQht2t+FJ0wEY44wJZSgdQfvw4895Ij6UTzu7NZhYQTixqORA+5H0okLr4DhQjFPeaOWNDXVIUD78aPZjkH59xc9gFlV3pEAfJbTikpR1R+N486ymUDoOXXkjPOusdA+XPoZYIGDqJWViR8QxtCabbFEJjpslwTnenOigQ2dDebrEKEF7QrTZnwWKRSY55XAUTppJ5nQookrCeeFMVgqEzjmwFv9Ep0WTUpVpl4At1I+nNIV6VkM2oYqqeJLBmaGisCbr6kCR0iqVPfn0iCtnCnk6jzsM3uRbQuOUQ85Fown706VAFTuPuY5qOKk5uCWrLDiR5lbrQM6elBVSYeXql0G7vkaWaEaOFJw445yTDoDphIuYuCu5I+dAlTYkIDjLVWzxcjOtk86r54DD7sfmdEyvQeigROye0vbJ1WtKiebgSAUHqFw7Cmd3JsN4TSyQxcpd3LN47mhcMjjlFF1OyCInJOm8WZ67Z7T56rtvZWMR6fJaMWelXMIqrnUqW19L9bBDOhOkNWw892yuPEEPbfTR7xbUrGNOoxz1ptXKVJaoHpX/c047T8t0Dk7z3YyXwFOxozhJDzdZUn+Q92fxtengRrTR7MI6tKubNxSX00ghN+1m1FY2JmENjvNtO/f6O3jhhab0oEPBhb0SOuqwo1DZArUztkGRR44p2hhXhA67A2Eea8nMx8sQsfeKDpGXeIOV1Gd+gyMzbEjN0zHss29lu0/qlK8O0wzpyFDw7LOP8Ya6IQ9yspHivvmGVuUfl2Qop9wP9V9yjvXIchGDpaNuSNmTPehEKNipJTs4K4j51IG7dETMJ/05SPvctyq2aWxjr/IYyMzROYedK21Igdr0/kc6IBGENgMRS40CpLUU7kkmRHtZ7CKoEArWb24/OZtd/za4wQ5uSGgle1vIBmIV/unjifpIYQql9b/RBVCAeeHMetB2rrpIETYzeY8Od8hDuUXKh5JaxwV/0r4Esg88/vGgRUKIOXCsQx72wMc99IGcPkpxiv77HwzNE0OjxNCGsekPeOQyKPCFj4fls1/9FMcONe5uIRVSCOTgyL0/Eu9CR5yj5XKDxz3ysY/7iGLwQrcPkkyPalIExxeVgy1fObKMPaSg+c6oODX6siCPwg9/nmbDP85ScjMMmgVLyUcoPpF4CUEIgfJCzU51xXSW2QsicwMf8OEyIeyYoC4pWUlfrvGE+IFTQ1K4JWN68oaSEyLkJiMd8XxOVVo7ZY+qqf+eV4ZJIBGZ5jS15w6N3PKbBSGn4spHTnNaciDzqMeHgHlPR010ne6MVkY5yRx76g9/MXrMcvYINX76E28RaaXZWMWggyI0oeTMXS8d+tDIGMRFjlIVS4zpGmNCUzV3uhM83qFGeMAjHvKgh0T1yMeC7MqQpANoRDC1wJq49KUGWUclKUlTcy6EngTJn0fHA9adlfWGnHQfeTZkVDwNFU9qVKga3/EOpC5VH+Do0f/ysteoStWQsvRXOkJ1VawupKsOFYjDxlZW/VnFd48h1kAu5pCKrdUdRjUnUeMaTpmS8x3wSGo98PFE0fHVH7Sp3lON4saZtNSbhnUIYn0J2rb/Ruai0nmslSI7GXRdDF1kXRWrgtZVSoqToYqrazyUylTk5KVL4KDNrga52uS457WwjS1D2rpZh9LVqPgzG27ZdiXfBTen6LWocMlL04Xq8rjIVS498vhEgehVMwDF719Wy7K9OXJ82hVIW7ta27aCl1HMUQ15d1vR9DrYstcirjnD+cMfTpCSdaXHfEmL17yyUKp7DdOu9kGmmoyRjAFeCHcLbGADh5diCV6UnQKUUwDVWL0dhKsvKTxC+pnvs/FYbh5f6NRppadf7ummA1NckhY7+ckIxgdY7RQXgYgnQ1jOsjqZiFk7apXHbzsau+r3Y8Utd7QMqaJf+3UtjHhk/8lMbjJmn/xk8V70So3Lsp7F2hD3Hs8cYSZhhXGnDrrGAxz14AoAicLmvYlqPnGGizyCTGcDQzSPzLEK/sa2Z8fqD0qcRSOgMUfCERKaHUFWKr8AGl3SiYnEqDuxcdKkJpPUlCeThsecnbyOd1hZMlIWyFWs4jlPL/Z3MN3ln0EW5qOVz9DxWGpRwuRXGYIrYChuTKnU9EiIddUlH911Zmt6Qtw2xGHHvhGxUxKpczS7aLhLboZHiw+nUvtHgLHMpx4NacV8ZNs+kesF1+gQY7PVtgWph0QHkmiC4OjhdkI3ucBp3IGMOtCnNrM8FE7a9KRnM//IN1KSzO/4TAUnv//qiU4UOtPEmuTY60bJanYt4Eo7mVIsp6DHiraRbpGwzIZWqj3wCiiQhzwvMnGHbsrRwH5TpSlUYbnAf0mSAz8M2Qo5eIvpStTuepfrvoYSXRVaPoEEWiDIZQe00fyjjweQKGN5j8tu4nSfaEt2EDRUOKTOcqo3+cDHdoiud21Jus728GJ/B4bda/aiIQ/tnuV6POhyRSABCe6E0dYY7X73ldBHQuDj+9S9SvCCONlKNh9qr3Wcp8MjlpIEqRTX1T72zqrDYwlB7o8TXXnLu3BIJjrR5leieYDjfWE7EYno+05TO4K66yx2MtjnSttvf3n5Ch2I7gYCdsUbt+xkvj3/OG7vZ3bUYx+9933IxaIUXzXdcCTxyIkOV7uQYN/1iHW+QGi79enjf8LYJ3UMAXYxpUtnVHYKgQ+aoX4MiHTth23ZZhAd0XNQpxj1Rx/k5GX/53r7R1vTZ3gbuGMBKIADSFfgUICRNEEEIWT64CUMqH55EXcmdmK2I3/Chx2wt30aOFdeF4Le1YH+x4PWx1l8JxBFeIIkgYLvJX7gcGb4sA8uCIO+B1CeYSaFkxDy13mIcms76IN+JxDdZ3gmGHsQI3VEyHIJZRLfl4Lil2FDB4UhMoUC4UIxaDVMAWc2eINSAWAKEXMGkRoCllURw4E9oTs6qH3ZZxCLgxLuJU5g/7hcpAWFCwiDBIFF/LBAoAKBR0IwFJhyQmFyw9GH+RNpK2F7KtiE0RaJcNiACuEPQ1IkxWcYc0drUSEw8FdrTPQY9BBRCqdwGtaLwOiLcuKHBeFpnoYoplh2qCZkkRiFlscQY1IWodJzh8EUpPKJ3XYSYmUVGtaNwQiMvxWOvwWM9DCKiHJc4FBXSUVfkhiHYIIg+0AWGBEaS1EzsagS2Yhrxpg/3diPwSiO4UiOjiUsp4hq69iMzohFrXg6upER7kdrWogSoOgT4SAluTg2nqZU3/iN/ahhxIiDh4iACkF7oqVHyJGQDaEeJVaPneeJuAgSwJGPsiOTnlOMH4mMh//YELkTdKO1R3BYeV5xiQ8ofKWieYbSNRGIjyKhOqTIiDk5EEwIlbR3ZuyYkO84EK4oj5lIjYeBJsbnFP+1h6NCMOQAOInYlEKRXKnGjrhCiUMhlGXhkNMYLAthi5B2i3gnEmRpMPdgFHLVgaWHlgsRlSeodmupipNIh63YD3FXQPUofP91S3xIEiExgd8yD5jxl4KJiKVomMx4SijpFfFYEY6mLZF5hTyRcpZ5MJipiA3lcivRfenIfWFnHE9ZEmr5mScZmkPhitc1d6dZWAxRfP+WHQTjN4CzT67JVd5lVGE4hgTxnN23YljlmcxVWqOjmCAyJmRhDrP4fo4EcCj/N4FcSY1Z+CuVqTqsySWm422zVVvflXrSOZ/VKV+jhZ2LFpQrOZfl2ZUF0Z8ASpwAp5dkeUCYMRB9FBauB5/R92TzKZ31mWoShZ+uppAIwp2kWUDzGBoCQY+PyZVGWRJPIQ7ImVdhkVIScRChs6DO2aDS96CyWR+EiZv2OXR81Cd+tRBZSZrzyHNc2RviMyqg4Q6Q0VMFgRB0wT8sOlTP+aJhSIpTGW1ZcaP56RVjoXTu1ol0F5bAcRJPkTV2URf+8SEfchfuiVgMGoZOCp2scXsIaD5QeYoS5BBTuWFU6mopeaWl+WanmXe086V/Y6YDITyTFVZXUU7591KOOH4T/zRo8DJouMMQTgiarlY6CCIosDKN4JldMTk7I+otB2QQUtRHgdVhEkVP9TAPlRRp8BVJkPqqxxOpC+Fr9ICYglQ9QwEdtAKLNLhDYSOkJHpAnTRQRwoOz6QcBHGq9XAVgamorYpGsPqqM4oVPtklt2qpBVI1SkcruxoaJYeXiCES32IO7pAVUlYx9YUpz0QxVVGOZJhixwWpJHQOpiatDZGK1epPXlFi3umh5NAxjqkRDYE4OiEOf9Md9iCM+bNU9QZjeuQfCoeWzwqt9TNC9fqq92qnpEoSrmg1c6l5aREasCKw4Tqi/1orbENpBqFqDJE/gBhgjdioP0Q/SOMuNv9rsz9EEhLlkyrlEP4Aa1nKp7CDEx6KJoUjDt8CbuNWVPvHZGVHsRxTP/SaOTfrLpkjaCnRkx3GsbwyKL06oh0KDhxKKCRqMDJHDzbJVt21ULcZQeJUsdEKq1Obs1OBrYHSH/L4rf/VFLyxEG2bEBqWTsQmD3D1t+Iis+02tedgYYgLX8tCFQHUKf6BZY0UnHo5GhYEnURliD/RcHY0rSmyiATxtrB6iotaikaIhBz7JQVCYmHErfBTuQ5UsH1LaAw1e2hIEnl0D/V2UVpVHCOYgaNLuhUmfnDKEzqoUGyaklLjFxiqoQZkEQNhYsIJeZ7Fct0XZAKBVKIFjjEGvMH/m33bF6/1kziL86Dl8RUCpJIX0jLe8q+xQi90orej0rcG0aryBm1BdmhNmFTFyETgu4bHlXPoGHABKJuSt78K7BDUUxmT67WqYzm6YUAdw2/H2S5JY70qaIi0B21/iHBh5W2KIcAT26rIG74dDHYKrMD92BAsRC2um2ViNJZpQcH0miyi4Xhj9jFzqhLcS7ihxYtxgnVsQcLXK74iecIjGIYrvL8dqZFLdReABUNbYg/bahEBUhEWTDTwS6/kgDTO4ypgDC/wwoSgu4L4YRWnmrCe2xhGvHydib3eJ3Xz2cTL1ZHgyFSl1bOzMRCMGUbuwppEMg7X4S2w4p3mYBFx/zU0UztmQxN+Z2wS+NCwI4zCsNdnywejmmzHd+yPvQhsHIZKeaWcfmwbFFw0X2y24IBdRwK/p9ZriudDZCzGkFwSbVwf3zeCs/qc+avJz8nJTuzJazzJeoxKzkXKSDdYfnMR02jI6zJG3VLGP7Z674BGGUwS/CsuAegQvtzN+gvMnfyLn0zMk2xKe6xPyLwPC5Q6/2oWoNEx3UEOL0OiR/OoFjZ7aIRr0tawW7skhuvNKgzOAp1qwqxweUTM5uxMe3xfB0EWTOcbBJOp8pc9ZjfRjpdLakdh5Yt2CnFmxXiqseXN+6tcAw3OT+y9CA0bCg1FfSRIskQm5jDPfiPPNP9cz6v8bkrELkXjMehQThp9gB0duAlh0BzGQ91c0kgdzMJcMSkNRQl9StZaF6xSFvOsOgY1lnspxheH00bjKuR0apFseg4Txc4lLg+a1Gg9aeWYVHj8yQfd1PoAOSwtibThDiHTrTpEoqBS1YlscVz9bmhHgg7xmU2FKGeN1oitwNzY1ga9HA8bPOXM0tOyD4OlOiO71yNq1Q5ywdI7flv9110db7RXEhrrHQi8yYmN2E/M2I190OxDznPtJfzQDg9t1ahMyAWrOvypRJJygscD2s2GG4UGdglRm/epUnt1lm8B0AGd2k2sPyy82gXt2OUM2cQc26gVj9lClqHiLbj/TbsfE9yLW0kUBNzNBoYkHXYqvI4d9j99lLtsAdAGRtKJ7VgdyY/SXdDD/LApTc7FbK39EI9e6y3dfdV6SdGNHDKO/LS/bd5HEymeqb0CdsdDJxABnkpPBN/L/aB0Bsz5vdb8uNgfftLe69qw0d/+XVqCRBtWUx3dwhHevZRwIyk/XbyE2eBcnTmyStLbe52jnEoIEWysoaZMnNT7KOIj/uH/CMrVzbv+7d/V6tLKrKkkCmh6TWr0k8uuqn2zqdU5HjJhTBDz1WF9FNeTcct48V1gaFTOHWRHjuRJLt0lDuUn/uTkHOUBjonm2RFHUzSLm7h/npvxMFTjJ6sFQVfi//fZykNm3IdHHoYc9UVPRLwVtTUQbJ7Wb27fcZ7fS37n/WHnUM5HgrQP8rAbxSdokLqTSHXoFBanbTh2BQEyq/wqvKR2aDvK/by9wtHhSG0Vbr6PLTwQm07ijU3ncf3kBz2oUN1Kdv2QfYPqiFhJRyXUOnm8wis38CJoDDV5AnHsk7yCy4sXTobUqPjDRw4Oaz3scu7WdG5KyH5RPNtK9rAOVM6JM25BL6sawnbrJLGoMhWVo8RLddXGvYtplp7NjYFwR4XYmb4am84QnQ7Xce3k53pWpSVslT2BOgzhurYQ1K4S/04yEF6rCR1WvXgS2ye6PnHpAu3r5n7uAtGNWf/7jUz+sArt5N87EFCkGhex1YG+DqE16UCRxGTGDvyOKfqe7xMy0L4+ijAf8yixka0t8U49yWWl881kRwmeRrpmjmhubhJ+EmF+z7WaV+kaVjRnjsVR0k0/kLkY8x9vy1Jf8yp987x79cZ6SnilzIIWJboY98laD9Rem2JfvpOUimdfEPU2xEDMjWooFQvf8mqPdWx99Do7929d3St94nh/znb0KunQ9RtHjsJuEIIP+IV/z/WQ6wbx7ZLRi1D8+FuxwpN2jAomiqgP9WIu9exO9U7Nu5qk94tiVGzNkZafcMHObpoTb2WfEMRs4nVuMfWxv8Jm+8KmEMm/srvP+8X/HtkrPfGCqq7IcQ/L2r2CH4zHXxAdeWhhzxAymzvcbm8HIfF57+2UzOVr/+s3qf75vbIAUU/gQIIF69mzh08hvnv6HD7Ud08iPnAVLV58eLHiQHocNYKL97FiPJIlRX5kp06lOnbv6FE8CU7fvooQZTqkGVPnTp48TYKTp5Pe0IpDjR6l97EjQYsGET5d2BBiQ4n3YFqU6PDeSXscj/b8GLInO7Lv4r3kiTMnuH1t2YKFG1envJIk5Wr8itfg3oNPEUaFGDGiVY2BTxI8KhZsvHc8ybY0G++gvp5bZ7btZ5HfXZ3rOJ+kq/hzUaNF+Z72CzWqVMETsTZsuy9i072J/0WyO2lX5zveZjvicyhz7U7Y+/plHp1cuVyiX5eedpr670KGVQcrtH65LWXaBoeKXh75bD3gF2kOr4jeYsKZ/JAvhx8/JlLT0AV2le6X+uqqWbVvh+k0enSLqbGeeBuvPJ1ksykme2BDjh8J5aMQPqSGsm8g/PJTjbqssvuvra3AOQqxAcEr0ECNxKOHPbd00qoqmT4KqiLg9tlsswp3jM+oDO/ri8OE9hMssNiME5G0C09E8aTeNCLpt8tiOnI2nuoBysb2eOSyx73AcSpIISkiM7CHYjsuyXqW/K7JnkpqUcGdYrPyJO42qhGcG3Xsss/PsARzoEAJ2lBIhPRkqP/IM9HcbkQ2T5QLTvLunJNBcEaEqx555pmnJhzf8zPUuH4ER0iRWFv0SNkcbRNOuXBLkNI5Zf3IHpGCw6ceTuexlS1QRQX20YIGNajUUnutCNmLUFVLVStbrctNkRAkLy7ZdgIUxokWehCcX4Ht8lEMmRKUWGMPXe9UM1MNDkxoGSOwQJLkIQ/T5brKdkE6V8UnH3DDJbG00j5iKtCNBLUV3WTVXdewjd59UqfxEupzyKhmZGu4NGPj81/58rpSoIO7O1dZZbFqWDCFDjaqpN5UFOmslf3Ezr8pY/rW4/jkkYeonsoVmTZjh174I2YduupggVomCeaY6U3aTyNzytn/In905rHngUcr96KnPkrUzKgLajUmeFu0V75D833rRYu+PS7u47CmMM/lul5PYYuqs/lOcSE9CcOok1u5cHygSrsnuSXsmO7ReLZbObyT1dvG/h7ClB6tl4wXbJo9bNdx0XmmcPJjT+aPKouG4pnNziuCmkfKYswuto9yntAiWkW/K3L4TP/6Ig8TzZzJaNtUiu0d18UsY436cbtq3mPy3SLSq49P+YSF57u/q96tqzR4wTx5+VR5OjI9t2vafXrsgXq/y4R7rZl2TNfUPFo4O6oIHv4rlAhGKLO+t31kOwNcn5mmt8CdbA87ZpKRkvQXPuX16Uw4A9VwLhOjS/Un/3EMpJ7HUhO2wEQwYMabYFJEMjjltO9tG3vRcKRSlf0ED4RggVz8JEe56fwHaTOT4AQlxZnQwYg7LlSfqm7opxyGSj/FodPgmCZEesmuJldUj3kYVMQlJgdyotMPQzCTpjo9DHxDBFZObGeRLX4QUUDsYk++6LgnzkRu0JMV/oT4v/hcjEpbpBQS3wjHOM5ljnMElmogdEdK4Q+FP9EIC+EiFYyJBD3XKmTWDkk6cE2nOHeE3v2mqKRIcuZwcNlOYQSpO0q5MZOw26TvEEkhqOAkbv7wBxlhwrqmoYg68HFhRvLGlY8MZoY7gcdOHkMWcJDFM+B45kmSmczP6FAjs/+ETw/bcxxcHocf+2BV08zCPUnG5ZefWYhIDjLIcy4NKPGARzx1gpuLPCYuTouLDl/HyXv9RSqf6gcuc4lHMIWGMePk3vT8EiSRIOQgQMyW5kIzz9vc83G9g18/h1Qc9wS0m9+kTP6i9UqhqbNr+RKUClHCTJRYJJpZy42bZNlEsChSLbccKEjfqT8/qTQ5GEpO0Oq5zNEtJ4f8bKBNLwPKfvCDO/KIJzwi49MdUfWnTUHnSu3puBod1ZoXOSr8tlYrxP2zo3fMiabi+Q54SMtCVmWOOqE0kp6oQyMszaTd8tRVr4rVR3sJ4z9xdNa4JWseUJUqPL7KGSwJ1UZvVWn/+PhYUZJyxquQKxFgpxO2tkgIlJeyxzzgGc+z7KiCgFrnW8WCWZQKtXyV7R1m/xodi1XnMp69o0xCO9rX9UmFFdyJz3RyuJN17bWwZY5wlaYhRVqns4Sd26U0NS+4dlG5YXmJIPGFXOWMVbMWq91gPysTTWEWa4td3U7iIQ97IK0r5Nwud0u3kRHWb1G4FShy9GEPbFYIuPFhDDjewdKXKGRNTVnIgeVrWjHxJ1UdFWg3dds63rlVvRUZcDPrQ9W+/HfBf2LuZkHEMW5G+Gp6GiuwQtNWSI7EwiCZD+suwscXI1eHKi1IhzzYLPzm0sc2aqyFSHkRtiUlWj2zW0hS/7yYJtXlw6ChXs+6cx9PXk47jONmYZFzj/j26Lr5+uuFPuMmFLGYn/R8cpZAo7V50LZmrDkSlgOamcJizMNVTcrY7mw2i0QsLCFZL1LTbD3fGYVTjk3N5fKRD44xDrd03jJW5eNhqpazS1obNE9aN67vJsQ6i240dOcWXd41KC4vRnNccJNq7vJzc9Ap6z0WzejnPjq3FbouWIDzwxjLJcM7YSFe5Us6+jQ2x82VNagHe1Y5kzpUI6VroPYDqOre89fMhNlBlCfsVm+OKEEWVIP5puxlx83W71llT8mW60jd9WWKWUqmr0miNoOpU8TC0hOrMutad9TR7ukYl0kkKqAU0YeqTQsPgnorH2qCK3K70tWu2tyX0z1o3+R2NFN/xWVN0c3JfqoxfBruxcU+/NAR55SQLq7sf7c8d1gJLXrlLaqRP07mJ4S4QHaVn3Hzu9+e/bfRjovraDuG20zudZ9q7vCh5DziYnpKf2ZN62W7/OV72/Nyqv2R3tBzwKxOTmm5NE3l3Nx6TT/50/OzcnJXveVCV/MCG4NXfIY9LAEBACH5BAUKAOAALAAAAADcAKsAAAj/ANWBG0iwYEF79wjmyzdwn8N9DfkZBMevYj9/GDNmHIhxokeCFSsOvGevXbp0586RAzfuo0FxMGG6nEmzpseYOHHaLDiup8+fQFsSJEe0qFGjBQXuTKgQXL6HUCFKDEm1X0WNWDsW1FqzYr5789q5Q7myZs6daNMWzMlWbdC3P4cenYuUnFKb9xIu3Ps06j5+UKlWzbrRIOHC4P4Z5LcQrMlzPAfGPau2sk22lNG2hMsZHN3PRdHaG7nXKd99fVHvDTyY8MTDGhX/U1xQYuN2BntGBifTsu+ZmHUSFOeSOEuWnN96Bv25sl7TfKNLZ11VZFZwsLHOTrzd47yhx3P//x5fHPNN3sbXSka+OXnc5cxD1/w+Mq/0+/hXC269EWtIwrPJ1l1NPkmWHnkIEtdbZcIlxx5QA8WHVFpM7XWPhXlleGF+C/2131WHfQgiRgEGyB1tA323Uk/yIehigr3JVKB7EK4kYVlqaajjjhk2tuF0IvKT1YcejqjRibIRZFJRKamU4Iu+KYhZgZLR2JKNEuZYH48k2eMlQlzad1qR1WnklWr68XORdibWdo9JJ8Wp0jgHQmnnR8EJV6WV4DE3npcafinooIDuCOR+GQGWn4drsokidozpOA9ZUd6pVp44tWdlgVg2l5aXBI0GZl5fzmPqqaiKWqiY0TlUnaJfGf/6FFXXPYqdPxJRxFhY59BpqaXpYSrjnpuOg2OER7l0qkegDlQoQqWiKi04pqb4pY6HOhQroawuJBhXNk3KUp14xvQrTcEORJm5PBVr0FzuzGfQaKES6uWp7eSLW4rV0pfqqj3yReq9pwIcnUho4ZoQZJcteC5amFZJLJ9yFRWvkgV9h+pMzdKLb74F6SvtyPPYU/K1GZpMcsEnB5xPrgPRhqKJ/+AKMbsP3yyTnutNzKdQA8kjz8XgtCOPv9RWy/FEKosVsr5QR50vyQSH1Y6pUY+8KkMxlyhgQTXTFI66OOe8k54OI+ezex4J7Q7IfzJNH0Hu1G231FlDjTXe+mL/TG3SLW/Vpq2J4ZoPfccOl3Y4jI9t9k3CpZ1bse+NI7Q8+cpDHr012e3556BbBnfRBRtWYsxg18zYQOmQAzRvdB7IuDi6PT4Rzx7ppinlBV6u+eacf1T3OqyftA7on4NT90R2e0T05aYGzxGSSZZoeNGtt5ve7MamA06vOadLNrm578675UJ/tK9o8w2/TjrosH785+vUTxDxBuFPE/Qe+UMQidt5FK72ARbvVak33DsHbuyRjnKQD1g7i5G6XGI+5VTQd79DkPQmgq+xoCMl8TtHnEboPf0VpH4mNMjQ3JFBm5wORf6wyptUQhRfgSMcMCFHOnDzlXS8Lnzo4Znk/9pVwbgEBYMtJA9TaIK1930QMuiIohRHeL/72c95zcvYBg1CuFvloyQ0BBoOdTgPvdzDh7YLonl4w8aZCKWID+oJEi+HoB3VRCzwS8n3mnSOKI4QheC4YkGQN5C6XQ0hM+kiRnZFlpbApHv0aQwaHyes4bRxJxAyX92ERrLKIBIv3oHTQMoBDnMMxBwgNB4gA5lC5hmyZBdKZP8qUsAV0U6Ec3PKGR94rjxN8JeWLN/kTgiPTR6tk2kkyO/SYY5yOJOUA+mjKtfBjkDmDx7Kc0cxXwlLrn1EkZHCTTl6osC5MeQrkHFcMs0jpbT1hkrvieM46vcOeBSTkyNDS4bAsf/EvPhmHeho5jNJ2Ud0wC8ddxnIOuzJ0IVu85gImdU3ZbaV1aFEhO7I5Tm9eclkjo+d45MYQRyEwoUaE5k02eJIfuMOJ6bEHKZEpRTjp1AUbrNuD43ehRySyDZxxGZWu5pBLDQpcgzRbOsSVnqM6DNWorCe95SWypS2FH9C6YPN3GMUa1q/h7IQn4Hr38wC5L//wcwjAlsSLymJno8GZ3Jsc6pNv3q0eszDrsuyjH1exLC+okMd7KjfV6PXLI+oKTY0I2tFafKVx9jQoy9RatmAWUGFWtGhmyTsl8bDUbWYSnMexCpMzeHHYpYMHwPRh2pPE5J+NAqAXgvbTz0CkYL/zNB1a01jBCO2lqW+rnZXFGQhISoom3xyqKXRJ8HkAQ+XNhOV5zgeffThF+q41lGxLev0BhIScPDUQsGEbGTVaC52pi0oE7GfcFl410Epy1mj2id0FjLfzhJkYGFpaR5h2sd44UO11VXNQ9T0Wth6TbuK8d8ic/XdvOTLqOK9XTt1stvMSIxKO2FvPerxJXyoFL4A8yd+BkLfj5AqqHU7CTbxEWBtxapDjCowgmXLnf9p17ZWa2CEI2ucCffWwmrDcIYH6yV8ePjD4OBWjxTCFxKn5iHJ9Qg+7kFdqKh2tbHSEIwtYpFGzWbGNDZIbZU3px2rp8doU9xkZ/RDK7qE/45FNrKHD+Kvkmk2vt6cTov9Ip0M6YNHRy6yfVzVmi8TRLG0bQwDXWdmyKG5reQNFu02E57KZLa99phyYQtLkH8VyskBq66IoJzlvAT6ZFMt2JSrHGMSadcfX74xSLbVDvA1WsJvbQvZgsJQbFqGk4K+x5w/QrX4YmtMHgowhqJFMgy2d9V9sY6hZ4sdtDrGHba+9ZkjHemcHHGOBvH1TIBt7C0uS1ph6haHSr1cY15Om72Oh9A4jJAqWwQxR5K1Lh/DaG0Dh8IVnuwcfZeWY7YsZfyaSAthGagQc4mfA5uqWOBdzIY+9R0Ylzc96gFtcFz3xgrWN0W4do5x+vvfkv/V08AJrhZygwlUJqsJvewVX0FZFcSnwqk964lxarLj50D/eT03nml9ePesMxF5pU+uuKYHPE8rZ3nLVS1sj+XSJYLyNKG2FK0VwrvnPmeHOgALdMDWUx70KDp1CdKPrSid6eg6UOTKax55R/1y9Mj71FeF2s/KPOadtrN7k4zfeQyt4s31+dgXz3igvyMe8eDwf3nq8Ve/PXdwVw953WqeYtJt5Xmvh0cg/+ajxTdFoFXecA+SsWLPPFp0g8c76if2mTJ+7I6Px8ZX7apG3eryb8pe5s+T8pgwNB7wfp7vQr9h0e9dQ6hPnrJWFr0kZz2JBfkgQaK4+KA/fvcA/vj/kWbyxe9B08yMKw4bcadGgvSaoQVB4sab33xPFgq14EhfEpXGf+qjut3xInsDIUUFQVq3J3S6x3Hh53tJJ0O3NjaNgydqxnll83695m5zNH/0J3r1V0j2hFNaNGUk4R3n5n9SdX0BKG7goA5RdA5ZNVN/pRTfl3aT93GJtEiNZUDiFYG4Bmm8FW4WyFAYqExCo4EbuGEGES/LYxAMN4KfZXAm6Hp4hUET0YKjhUowFT9/BQ6Pl4CTtw+uVW3fZDglgW3nlzONk364xi4AF1LkEoRCeE/pE395Z4RHmFczIXldYg94FYUrs2Goon/yEA8ewYI0ZUrg8Ew0VU2Qx3GT/1d5l8cPM5QSZ2gpaaiGa0h3k0WBMGGB4PB+A5d/QVOHpEgPpnKHhqdwmBZofbgyUEh94FYTA1UOiFhNXCgPeuhdbTcTucIw53KJ6vRjb0U2/zY+ngiKKyeK8Qc9qNJ8gbiMprhhX2JXd1eNA0eIsjhQE/F9osdilxcqrdMTuZUWwNh0araJlxJEcBhvkCdvkHc58NCOBKc5zOiMp3J3p/iEK/eOc4R8F0NXg0h6kKeCBCFQtDgTabcP39hp4fhYvgGMs1N85NFOHsGO7RgP9mR3GGl3K2d4aEeK1ohEdrNNH4iBK9RrBHGR4HCRKjkRozUR7IBxj1cP+rCQdgKRjv+jVL2EFvY0EBcZjyEpiCHZPOt4U9kUhJ9IkCvJkpD3DjaBgAmoD7toE4fTSORYjpzIfjmzDk5JE/EWj/wYdSqUjAWBjUl5fBaoc/BXEEpJiEwpbrY4EbgHeUQnlTvhD/sARokzEY4DkcKYVGnUlZWBkUToOxi5TQhCiErpiRPRk6O3lG6JkV35DnGZFDHphVJpkwqxJDOBkzy2RjuGkmZDRwq3jHP4MGYpe06JcZU5EGane49YGeJCEBCIk5iok2bWjhbIlCyplL/xO1F3mBlJE6S3E8U5EDLJhZSZFIDlhQgyTjBxiWXzdOOobUE5R+83kPw4bv0Ybz7pIse5kjL/yZpxOXbf9yKuEzsNAhe6tmPoiBZ3l5EcKXUEQQ/VKJzx+J0u0ZL7aZbiOZ7LKRDm6Z++UVYqMU5vRCNa6VG3lA6nWIpEaJ/0AJ+k6RFHWA8g2Y8DMZyjx5vtOHoqWJyqSZ7VlFDjoToG4UxwcUAL+jByJw7lkA4vIy0XWqM26nzgUIdo13w0d4TXuKH52Z+82aE0IZOtiSCzIYlwQhQqWjtAIxTViVTjoEAvww+nYof0x4dZSnM9Sm9ceoT2iUSHqRbhORFl6n4EwZp3ojpgMRZMWok2BGS6RTtE0Q5VWhE3Ko1ayqV82qde0nylGKYYFKRmSqBQYqRHSh7+cDgm/zF8PAZJVepabVeEOhqNNuqnhOKlg0J/gSqovkOoKcmfh4qcy/kwRAFXn7lOxqJD99BlU5l/VEipeTqrtNqpnopBHsqSxmmoRYpxtkNKk6Eg7UdJkHQhXdaYAwmULId2qFKHtAqI8zChA2GKtnqruJqrH2qcO9GVMSmYLpKkBEEWCOoTFhalYuOZLKFD7dCqVeFxrxqEYSmWCWcqOnp3sPqR1iqm2Hqm5OGr4NCtieoRXcRFhhMWZJGe5GoTfZl+ttmwajil63qnCDMQu5gr7/eJ8YpEhYlB9SqvQROrIcmU4xEP41kQAOqtNOFTE6E6+ZAvlLKGDhuzWLkWkCoYNv+xlhsqj/T5sddJhQonlPepq5YRmSWLnN3qry6UJEtzSggrjkqFQ+KAibfDbWRTDgq0Ia7CZCR2c+7nmGwJD9hXekH5EXQUlCKbFh6anMqpnEi7EwPrEuPKIMVXXjrkoD/CNQkhX0wBeKE6pp+4ofZqmhpLoadpjUJbE2lbtGwLsGmhsi7Bb8B6PsWCEzEasVF2XxfST8yim77WuWFLtj4bNMsIuoV7dyIbmT55nEyptlxosr7qeGjhuIvxJnBCQ+MqueRKO5M2aeSAS9FRELXlYjNBH5yLTcbrm782uD9busF5uEKbuCeLqATheF2YsqfzEbkyFgd7u8nhbeqJZj7/QUZY+xQcxbX85GFURYQY+ys9e51DypsZd5Ey2Y7jebSI2ppQmaP9A2teg70FkRKJ872gCWkToUNXu2QfEVH1YjItNIjwx6sI0r7tq5LwG70nG3QYHHQGIXSPl6M4amP+078TIYm5dKDtaRnicA51czJJNhAfjH8rZX0foZpluROhK7gS3LMeyrbRm8E+7MMzoXsE4RAydr2zG1RUlIhOm4aa0bsOeoqi9zu+qTEeSZqfuz8eu7E53LOpS78A+sM/3HgZDJOrSYj1BoaSmhEizIR4REIn0SQ1FJ0zm6IYZTQ1sXGiu6F/27WthMVkqcVb7L7y+8VgXHa3d8gaXBDV/1TGuMh7kroma3xfjVoUTWoUfBTHc8wSIuS1xFmHBSGoLhGwYxm4bRO6Y8uz+iqZ9xvGgHXIYxeDuBfK/2qLuld0vfdxsVUQVUkOJgdM6MEil4wewNg99OQRR6pxzPKn1KhNaDGf1jjKyxqLhYnKQrO69ftzZGfIrsx45MFxVEZot5LLE9GQ0Vkeq0oO5sDLPSNCwjW9s/xzZWmWzpdppsZpxsnFOHyvpwm68Qy92tx9xowWRwp0E6GArMYRAzIgprEwDhS1PFgc41AOTJIOq+QS9NS2o8ij9AzDH8zJBuHMgXzFWLyUkNmUqzx2L1JN8OzOKz0v/1UQkHxotnJiuP/hOpksYVZL0Rc9oh8RmXTprBz2waDywUjY0yF9w0CaqwFZzeGmypSZyCtIHlC9E1NmGPwbQB4hMrgxJw7NxDdBi9xHduPpxU6JjRoHkjSBox04ekdNn0WZncm6xztHoi09HhwsmCj70TQBybI7Kd4TJ1CDEg6UyeMgUwTRfXfdhSxJiimZRHr6wUmmOfyYsTkMq/7Za9HLUBin2dHrG9Q7mDQhrROByxRVVvOAbXokQunwNn3jGXRyibwB1toX1dx817kaoRwGDtIoZ5yDo/sMyBJ82Zw9e1wJdhfd2WnhfY8jeTBMYGpcY6HCOunpGaq92mMxFK+dfrJNUyt4Fyj/Dc8W/NPzF2d+dmXQx52BnK1nKXu0VxMYbRCrGZfUy7ppRMTuilitZzK1FjueAV1ujBKJ6EwwVYiLB5Pel3H4yqNGRmUA5hd+fJ1EOJBdu3O+YcEnC3ePHBtK4j2szSvfayzVfVAULXbgIEV6dNhh7ZrZbIsZx9jOImeo1eCPDKvAjc+WTZiY/d418X46/iui7RsZrhX8UBIXBQ4noS+94tDpGuIOZU/Ew4IuyN3M2coE/clrDQ4wDg4yLqlM2daXE9ddq7YW3rZD6hv8Wp8QOh4S0Xa+lw9/7T0SjUo75OFKDuLocOBd6JQtKOXdHcujV3+DqNublVpo7Fpefo3C/wnfiqu47qerEPwigWoZtYV0G3EPJfc9AE5KTnw1++3QMGoO28wOTVniUURah13gozd/+deTL0xdj3zo/ZjoPImmh/s4QC3pEJG119UQRu4rOV1ycS5CLltydBLRpDVTh/14aorsYlzlS4nHzNWVGVRlrw7r1wqHzVzrLuLiBmGElQEVbPeqBTTYvNG7kNETEp0ScuJMp3SFfBTWakuAuGeLR/vsJO3C/+Xqj9wP1n7t8JqsnljmHfqRaNGpBV1/oodkwNsQA3YRI0EvraPkOTQnm0GL7OxEAlVK/PVSV/hXxS12SrHSJ9uSjUzt+67P/Q7wcL2Rx/e+qUvjpbkTkf9uoRzYwmrBaru+D8wkQt9j0+oE4g8C1seDTQEVU1foEQaoph4x1heJi/ZAXQQ24yivvKZJzfoqn7y58qHaxQj549PqyWA/8xYaPDC8RB9hb2viXeDD8yuh5OrSu9Mt4He+UHrugjZhgHetyGn6eB/59EQsqby+D/SI1IJr9f5+tinZofIo89z+yQRxhBxDL0aWFkS8ETrvQMaSVbgVjKva7jJF0clZ6jUxWn/F6KSagAqIxmN2ZfqgkY8+ylN/rQJPnKOojAhZE0UN+UVtEDA8+TtB7ZbvDri1HFfy2jxh7lAU1oHFlQLI5wbBXzH1mmUKtt789xDxZ0b2JWDptyP/Hfuy35Lq3cVm+dsTkeZ5yIG6/xG9v2o1IeOWX2vQaSxs1PZjM2lWu4WzvOKb3ePuTvoAgU4du3fx4oFDiLDevX0NHe7Td8+evXoV68HDmDHhRo7g5MlD+FHkSJEGTZ5MaFAePXoiwdHjCBMhS5odbSa0mFNnxZsJ8eEDd09fz4T6HPbz5w9hvnTmyJUbB27cU3HgyEkFV66cOXPn0K179w7cO3Zly4aNV9AgPHDoEJpDh47rObpd4aIjqBZmPXz7+vVzCC4ivnrzWn4kSpTkYsYnDSKMxxjkTZaJOe7MubGeZcv6hhb17NlvUoT2zpXbKG6qVLjnutL1qm7dyY8G/8MWVHsQnG6ErmHb9Rp3IEGPfQE3FHzvHj57hw/y5sxRnmOTkqfzVpkQcXTLPDFz3wgUaFCbnkGbN/pXKbh5p6MirDqObtx06RLKLrhSp8zbYSE/5sgurgYER52B3oGnHqMaiki5n5irZzLwbJLwP5Ws024k8GRKbKcJOXpQuXs2+qyj0ELzqx+E9nHHvaoSKie4jdYBKzKaeOqov7H8E6ujc8AJzi0D46HHngUhYm6i8cDZTLuE2AIHow93c0wy6abszsPoKprIHoQePLGom4RSTrS/ELqnKaheHGcrdNKhER4b6bGIpc2aXHKjHsMqyzK3xsLnSAYhbPKyyrDsKP+j6hjbaKWZRqLp0EOztAjLLsEJMUzBSuxoxDIbUhEc01BDSKuuvoJHv3qU/MlLJgt1tSezwGEHoR4LvE+dd+p5CKLPKIK00Ho4RDTRCxfTTtJIZSL2Msy+I0qnLrsc7yehTjxyTHyuRU7UFkklxyt2UlWV1QeXxFEhm2q1zEB24uHLKNFKHHGiQhW6lygopSSKumNJSmjZmjriUEt8m3wWs2nHFGrTXm0SUTTk6lnHNXOATOcddz6ySMnwfuop3QnfXfC4iBJS7mNqH4y12I2os07gZW1K+NlXa+by0pa/RBMhiQP7uEwz97mnxYvfTNXOSvP9Ms+Am02L3Z7U2U3/wb+uRk7EETcNzcFzt3Y5JdqsW0lmgXmiE+fMEp62bS/FW9LaEod6CERrhQIVU3jcWmfjeeaplCh7QCbYJrISY4eevvxK8TgTe/UVW+5u7alKsmV+Om21M8PpWbcvxfTcBzflqFu7t8XbL0zlSXUee+fhjiKme6K8I3jT+yuwfQRLCPJeAXM8utpttzzmmV+6c3OdNJP284U/Ppd0TnfnKOVrS8bUS9dBB2/2m4jzL6V40wO69KvPR/98fsIW+1/jZVYe2oNzdn4in0Rf0rzEROQ6ItWT5N6EmvUSouQlP+N7GEfM07j0NTBUevqQnNxHtrItK36cu5lm6lcac4mO/0ScukmDJMYpsJUmOs0a2KQ4chuDKC51CVTgknbnwPRNKCP8olJkKPgRllTwRsrr3Kto5jbRddCDPgtNYk5Ut52x7yWR2g3xiLQQ31GvJ9ZKiIquBo6rJWU94MEhgHZDwcxB8YI76RL9nIc/woXOaZILIYpA9UAnckQ3RGLJHeWxqkAxMHdWtMzgQKgiL3oRjDd8jm4oyCHMnRGN9WsbG6s1OgXqrydy3KKo6mgTf/GxZA3kzIg247oSIqSQpOHODeUEmQwtxmyRcqTCIDmt0UmyJw0jisTOJxinbdIxdurjHDO5Ef71xFWkzCI4TvlFziBShy7xCKReqbRYrions/+kpSTxd8k4CvOBpfRlC+PFOKyF6kxIXE70TNQTQqISjMWrkDSnWU0uXRObRtRmLzEVQnAcZZhBaWKxAJS2PoLSRENJZwBt4iX7JcSQzOyJKscWzUaJZJrUjKXs1DjLbdqyMyt6yC6LAhTvfQiP4/TjP9GZziR9KWUk6t9LuXjKxKhSgu5rVDRrYrZY3sye96yl09R5S9IhR5h1hE7AfvJJkYaQpW0MXVCSWMWTzRSiN3EmThMzz8DN7zuyBCrIoOpGfS5pa9k6akf0yRkxwiuY5wNk6XwmIrOG6Hq6bCA/+HHOm/QHQYoa23Y4A7+v2mx5G73nTYZ6OqF16yhTEqP/7ZAXqCOplCgypSy2MNlALzaVIzYF7KKgeUJYYtCrGRTi/O75vNMRLnpfk5gSBerWFzIOPOBE3c8cstfzLXOZytzRX/0FMw1lyDI/7Cq+Usu8ziF2lvdrGiVfmynR9POKiCKSIH2HJU5ti6kO9K1vdxTa4U7HIx0BSYUoQ02fyo9mP4VkQhrqWnVOV27VJcpa2UpZGN4krh/Un3dxR0Ok8NWU/jjfbchL3PSqN70BW6/mkjfh5DoLvhvkYHTJOkmxUref/91IQAdIMAUJijv/DRO2vOlAdiJErwrGyHCPFU3BTmYyI36ihA9rWgt3DJvydVU+yUrWa21yJlzir+k+/xQ5Ff+Ohh0JFT8g99esBna0FA1JTQQ7k1fWaXk99s6qpuXcz1Fyw3HLlJFttNQlIqqKDeEtKA3sX4eEhsoL1qpxQ/LEVnKZpxXRMc7am0YyR7KN24xumRA1uymiyJJYejOB6dgRQD7EM/e4c4xjTJub1FiF0OTqsOgpZo2GFc1DpS4IPwSTkwoSv3QGT0glvZH/KhlEmZaoSSpq4wc7WLChDvQFCb1aMyM6dHd9dPeAQtDMqrrS5eOMpC2L4rkN5Se4bh+AAEbjTv96p6XFaMLa27zVDu7QR8TU9eqMJcK5OtlE6W9RqJdS9FEaNKDh37km4leESAmeV85cg0F90f+92Gzc5C63uYP6WqnqFlGBAlMSfZYYEPfuwx9+sr1Rdi26Jklat3kSlHIYmer0hFgVgkllptlepTUXrAnPp1gdFm9laxY9xYJcPy3bO0AitJZtw0ztbnVTXVtmOyhnZKgBHWzPJRyfHU3dzmtu84/SuW6yLp0VH13CVlnTSwZL1A3/MyH1EoywdZIwkw5+YdnB3LV48+yHPKlZ7s7bn7Ze0Uqv17OeAbBzdKqpRlIypS37+ew18RDOgF7oz0UVUwOeM3f4SNl7cwaqr95diiyTTkWfR/IRFfyHJLSdb/95WJVJfM0WT2pToyk9hZyS4jIL0wnJMa5aLybvnqrfz2P/VeRGLzuFeEjwkI2a7UoanP0+pR5DCrDEyVb1JZtc8eTILTlDJh2AOVNSsgcfvcO/aPGNz3iPRf23PFNXTID5bu40e4nUDwrhRlQtnr0UnCpzVYWL5f1Wgn/lT3M54+OopYIzpKCpiQsZhXu36MulCSmlsWoa6Non6GkVhTIy6ZCn/+OygBm/QoOtAoQ9Zrq/yTIzz5sQ3iOmsWootVKtCdwn1NEaFPS93yu877Mo4gPAI+vA+vnAfdgr2DshvigrS9Gk/NIvhImwyQMRoZE40NMIwfs99DqvPdMp4lO6UVuj+ypAAzS5jlDC+4HALQmb0zM5O7GJVGM/JwSP0cvA/1fKMdPDwixMHd4CQpTxEvWikyMqwQ7ZjCJarA0ZGMvIEwFrwmbCIcWgQleywivMqDLTQh9kPojSB8JgnZgQQjYCD5bRJpfBsegZnPDQmuUgiuHBoSjEQJcgCYJLOcxBHgGkJYVrLEhkPgWyh3mIh9+riE0ED4XDxCnRv/DwDFT7EMoRO8VgFBrzITe8qPGLJFjkFgZyJ5+pxVvkwD0Mj+jgRWvcxZxQIZnoo0lcwUK0DFI8RMjYoVRcRLNjOiASlZWxq5/poqvSB2BJFiFULBmUr15cNB7zCXlhDgBzmnVIJVWiknO8QYEROJBALiBKF2lhvXZ0xliURaQwOj5ywf8IRMEws0h0m4ktQb5KOZSDkL3luJdgPDKEEMjosKmCJBtkNJt4yrEO9EC7YsLd6iJTSoj1eRp7VKs9zBdpkS6bUKGboB+R8cLQuZc24r4ZtKkJApiDXBY8XMg4zEIYnL44Ww9DoiM6+cSeNDPOWZtchBvxkMJooR+187OT2As/O8qAsol9Aa0Ya0mojBSpDDd64sG7YUKJ0atZVCbSoCMx66VeXJqE6bA86Sqj9KqfPL080o3jiUmfaKZ+i0s5ackqREj1u0tHyku9vJ58OJK+fChUYibB9MroiR+ZY54KtKaw7Bim4UZ6ABA8agli4RL0C7woqUzLZENUTMZA3Mn/wvib4fwbYXNEvTyRfMiH3RLN5nMoDbouxDTMB1HM0sgsltEoNPLC2JTNRCKSpCrCMPyskKvMpHrK3xxK9iDO9RzO+KlKq/QM5WTOH6zDhXLLi8QZ0anOx2OQp8rOL2MetOtOC+mcWPEYlAwugozLtShHZGxD4EQI9mRP4yQi5NQH5VxOOMPKaFSgDDOmANwJ/dwIYgkmJDmXr9pObiQKYMJOe6CRlISxJ9zNGDtFRYTM4KyI9VQee6nKiLlQ+ZxIA+RQ2ivCnsw/tXGjfJEJIcSWE9WM5VpMRsuyPGzRF7WVGCVI3WzKGrVRCH2inNBRtcEmC71Q5uwt53xO3jGh/zMkFHHbT2cRnUnURsrYCQ5Ry9Iyty6xUr+a0U1TFC5FRy/9UosI03p6uePUGgzV0HisT2YCRyA7NyR9UyOMPS3hqYXU0xcFiz7dFwYLCbrsocukh+I8I0j6GuXA0AztS0Y9QC5CmX9c0+iiMDcVlqV7L36MosJpxSYpLYNDS3DQ1E2d0VvcNKd80MPAEPXkTOcRlVNNVVWNMyG9KleFCJKE1AkkjLW7oEA0m8gavA1UmlWcyv1olmDV0vJUFIP8zUUaVcApVVPVy1TV0GitTxORiBBTuNKY1WoaSoEBzxEtPZXr1WeRFGB9UVwDLWJ9JnWtoPchVYdUPXiFQXn1wf9oFVIlglWF8Big+DqgHB0eE8th0czv9FaxUcWBrVOVM1gaQdhckyCGPUjJoImHhVgfWy03KhNFXdTeCqWMzRm46Vgkwx+NelKk5CSUsKORO1koMpuO3AhOVZSXhVn0/BuWaE/3vFmXuhad1atVPbF71aCuVLtrYiOKcNrL4I48ks32WVoUOh6aCIvdlLGFndpIkVDFs9kx9YmcBdKK9droiIgmYpUjFVr8UdHY69ZfUsVhLE8rm1obvdrNsRfya8dOEYq+7dqunTSbCJVJZBpq+c/JM9xJ7ZeLeowWKlgcm5yW5c3HZVerddcdzdvGYxXyEJoMndf10Umi+CazZR51QrMnTLwToUwM1D2b03MMPlPdvgofPalM1z3HmaVZxSu1+HIjNLndXuna6Ohc5oCd3206D5KdLuwX2uzVSTGJG+UMsQC5HllQ6N0h6TXO2W08sgyK7J3P3SUKvUITiigYH5MlRCspHCtZcAvJopsQ6KiV2wgIACH5BAUKAOAALAAAAADcAKsAAAj/AMEJHAiOHbh17+DBA+dOnrx5ECNGtGfvnsV8BDNq3MiRn8ePHwXuy2dxXjuB7dKlO3eOnMuX42KO40izps2bODWK2ymu5syZOYPWVKcRoUKGDiUqpVjxHkahUD1q9Jgvnz2TJwWuBPfSpUyoYMMO7FmTJ1mOX8WqLTjQKDx3DR8qhUjR4sWnav2J5WcVYru/BFm6LAd0rWGbZzmavVn4sFCiB93CTbqUqV28GT3288dZL03Oe0neu+o3HTiVK70qdsz6ZmKBPXcKbNz6pjp2uNetUzhZ7kTLFml+3Ny5eGeO//6BSy4wOXON/viKtvf3ZMrU5DTSrs19rE5wZ7d3/994O7fkhnOZ1gTZj7hx4wSVO3d+fD50qqJNmgR3XfB41q/BdpZsGRH4n23qJMiObru9FZdElhFUVT777AMSP+25915xnxmXnD/PERQdPyONpp5J7qjEEkHjEGjgga6ZJZuMMOaU4I03LqhbQm855BtFGU1IoYXsZdjPcBrCl9GGSmZ0pHRCgnNVdSqxCB6NOIUzHo2x8QRejQjiqCCDDfZGlz0SCjnkhZo9CRKTHA4EZ3HKZcYmP+BUZdFVGc20GJg6eenllTK+CGhG6CQqpo4MOugQTWpWeOekHs3pGTiWxmknP53hCc5HVgFGDlAxGUqTloYViuWAhB7KUaKK5v9IJm8OuUPQPWlOWCGRlLKZ6a/vdQiahPek1BI4MY3V5YGqBujdoD4dCCusYzYKF1zgzCNQReDgqmZVu/Y6aZLAZjpfncLlY9JWyApY6EDhxItqWO8aOiOry8KYHaLTolOtbg42lO22uN4VqaTiiluuueeiu1F09+xXoDgytZjRvPQKqliXqn5Jk3iHTauOv4yWaWtGTRl88K68EslrrwsDa1+H/BRr2mwV5wzvWu9ufO+yib2WLHf9kmxtbxrZ5dS3TK+85rgxd8rphiFC1dXVIEPFsakTEwqtd30OzZq/IyfK6FE0pbx002wzHS6b5Frq5kceVn2TzSzlnTc55Vz/uRHGNDVb1tZkOcui2I5Ni9uCOdV1GUltRw6upC9XujClnTm3EXPoRkdSdX+hls6otMkL+EY9Dw6b36iDjSzihsGa20Ec/QacypGvLXnlF2Y6N9yZayRffP9wxtdoJq57TqngmC4vYn8O/nVsHlcv9NBZ45SjQTSdeTuu3Sot/vhKS05hr3FLDSW4dOsF4vDEn2v8RyN93tJMzscbeMVcTyx4oKsLW7uyZ5PF6aYm3vse+OyyEfCpTXxt4x3ckgSqbxGJQ5obiHwaVjzj8GUeo2uROJynmHGQQzAEdFfHAvS1sIkthRkhE8A0YrumdOuGDBQK+XAnpIRZrlP1+1b7/y7VnOVw8IgdtB9hRvg8nZgwHcaCYbP65zq0qIVMPBqIbxKoNByKL20ceWAExeWeJ01Id1WxCRLXCLF2tIQn+tMJOdzhl+Xh5H+qY8wVG7QQgkCIKerplg3DtxGmaAtNA9GWQHbINoT1SkiPS2MaQyK8NTYsOvy5HxNZRzFypGMeJUkHyKKnLK+t5SeGwRYN5wHIVqIpODVBJJrOpJRtPZCHTaucnsg3EF216ThGtOR8MJmSUVEPNk8EJUlAuJ3U+e+Yq3EVDQFpSykhMigUkchfamnLW+KyaTsciFPW9rJhBVOYxcOTG43JIk+2Y2kRE+UzSUk4wwkFhhm51skQSP8aRRLkmjcx5Fz8sk2BcHGHEDwjLxdZPiGVUy/opE+3iom9c3xybcWyo7JI6b+c2NMm2dOnKgNqmKv0k6CgawdEEllDb5KvlYkEZEKrApLmRDSd/BldOcpxQiii0Y31bCFBXFS4jXVHnz56FFhkaRMTZVObKU2pQSvjSlf6saUK7CGnbBrRNq7Eoj79lj3SUY4p2jNoQm3NduKS1KSKBUg0wdVToRpVqU6VqqSBK5oAOVCZNpR9GuzqkdSlkr/wMJ5l5WjghprW6n0lhVlja1vbmpGVauSadYlr8ugKOn2C7q4DXWlo01NVxxkMQ1wVpvFIUhdwFsuYig1c4dKamIr/4QR2ApHsZCkLWn+izJqxPClWUirSa2WFP9us5WhHW1rT0rQfgVWt5yI3peXFFnqLeU14cpYWK2pEt7v1UWUjEkYp2USgEelscYtLkOpoa7nwZWVp74La1LJxRJML4udUAlsqypZLBpINd7sbFPCG91G+Je9b96oU9epTN+uFS1TnotL4zqMeGHYlfTEFUemOCCQV0pOxlnjdoE7xS8vKWVdwW5PdguPASmWpRHICvoGgVz9/eTBcyBRhd9T1L2218B8rcr6pnROJ6vOIfqlzjsTS1qxQzteVZOISFAblwAIJ8oyvatlC+rXG1hRueh8sOtSsQyUiretkx8tcx+WD/272PWKS9Tua0a0qyoKarTO1Y8K9sZgmvH2xj0LL5S4DN8zjs/Fc0duOHZ+5zKJbR4S1KI/uLbe1RIJunC+pvl3p6SrWxXOUS/lR7ZywJaMCS4wPvGVFsxJlCsyhNf05VxSlSCXo0FuiVAIwhfRRI4HOVmjdTCSBQPTI8ut0/SLmRhGKOrvcMSFMWKNlBcsYrmF2KSwBquhsNvrWudY1Osy8m41gWcZ/XJqF4nPk99FnfkoWcQifPSMY2Zbagx7owBT9T23D8rx+ccejw623cyTqgPmEsVK3KN+1earDGywepz8sndG4g3T8gzKMSi0Ut06V4b85L0L/jROsgNscKP83B0vIto6E10oeBs5yun1p7IgjmTNPWrbNMF4qLh2K47k1TF/zitlrjvyLDDXRRlB05ryhfFo3E8hbeHMtF7/4N+SUCoiMiOxh4hw/zL5fxrEkTahUOixtxrZ5k3708C00kTAXeLifPq2B8MjXjlqzsN38tNRu+t3+OFKJrsNzZze27DkRL1jwGkhEFuzo4ksZt7UocFwbXNdtwXve13ymuyCMqxm5eeCPty6v9JzsiEedf8XC+EDeCvIjd32W3QEP3Vg+b+gAR3nc0qPw2tjz60aOJaW2X7HjMfXPPFACq4qPjMA+9txCiaMHTvDc7z4hvUnqPOTiePZ5anM25cz/MDvouWK5oyUkPnzq92wTxd+ky83FR/PFCc9dPj/6gr4WmUaGeR1tnrSydhMb5G7JNljUkRqGB3TShHo3kW9Q0VwUgQ//9jjPl2gEsWORwX+4l3sL0iNDljK+RBw18SEEmGzHYyykc12usnoEcXYv1j3gQA/1IBTx90UWoQ9nZH/3l0+1tw7sMHcGl3uS9hCtJIGRlGlNUkk3RyLMhoAsCBWmgxgCEkANqEU2IYP1sGUYljZVtUM4+C2RpIP2l00XKHDgACsrpw6SRhdGaBf6oDsW0h6gYU4PU4JeR3r81XNCcTrwEoVqUWouGGMbkYUKhmFbeFnZBkhtOFPm41qj/+FbArEOGph78ECEN6gPX+hQSDiHRFSH4leAJ+iETygQ+VOKPFNUWRZsGVFpDkEP4ECI5GWIsigQMwiBEbiIf9WIYLgn/eSC6SA7lVgRmcgy9JNpIghMHEEnnGaAKOhsWVKKTSQW0yMbChde9CCDtSSL2lgPtsgURoiLaNSIdMaLcxWJiYQP+ZUw5GITdeN1zIiAInQxqAKN0XiKevYa1ZhU1wiLEbGN2tiNt2gP4BiOEcQyIaZQSnNSAul9GNIelNIeHEaHnviJd8gXB2h8pNg8zQONpMiHQUFU95gsLihoHkeS8rCPc+GPsgiQzMeIkUOMBmmQFKIn+IBpvGIkIP/2eRF5HJ1obO1IgvilPKRDEPTokR+5UX+yE090XKlYjSipFCq5kizZSuMjGt80JI5EPxfCK1b5NHeiX/vwKZqRhEuijF4XHfvQhKpRlEYpFAPSM+JQDunwZt/HET5yjfQAEYb4XpYVlVI5lVTpkm6TlW1iJBlCIiMhQSzjNnQph8EiIj8JlHh4Px1ZjwAyTxRzDu1Al3WJdhLhl38JmIHJSCpDmIVpmIKHMDEJhuHjSw25IZBJkSY4eKPThxoJJjwRE550DxdSG6AZmqJpWpDnUHeCmhkSLosJSQyEPI8jKRmiKT4pm/QxWKNRTN2ROnrWZ+9UmFLRHbNIEIYoS8H/6W/koystAzfFeJA6SI6JCIIUYph0SIKcJh3UMWIAgkcCxlPpYA9vFnio6Z2HuGC2OJCMlF8xuZXJGXnUlC39xI0CeYNx+JzxYZb08UEpYmUKmCrjcFGN6Z9HApHIF1wAWYEEGZOraRc16UqWNWwPqg/OKYJ/N0yEZQ47hU+p0knpwJtFYiRXNpJ+ZIiHMZ4RSKIvGUR2oaIzJhGUcWFD6qIRein0gUR8QVEWM4WBIlQMOGWa6RSV4iYgOhCdCRWQKKBC+kDNNZwI6VRipkjbZ43cKH/34KKviSkR1Q/5UEyEARSmclYdIyAntJkX4pBhGZafIpaEShCu6Cplynwp/3qmR2eVajoXCwdjWNii+8CjdshBntOMzcQ6jCU4SulJ81BkSpaYAmFB4HCorZgRedkaQLqosPplCHVjSTGpSRUPuJqr+1gPEuikz5mplxQqIXR6e9an4DEO5bClbNOa5FgXmJhveJmoNnFhM/iKNwGcsQqrszpX9MBbmqd5uXqSGIYPmOicESlMNZMSNMo8HvNss0EOKkWQeAGpmwVIdxmteTmmtKiN1loT25itACurR2oPhLhmmvcOCJuw76CrMiiQ5Xqp4EAc6Io3efoz96gYnsSf5skyqRpizHkP8leTShqtUFmtr/ib+/qbAbuy44Ne3qqwuKGwCYur+yh/D//7msBKH3eaGnkKFX32SbpinhrxhiYifwNRD/qIl3q5jUv7m06bYSsbsC1LsBDxsotztTGLsAz7pnHqqxKLZPzAZHzzZ9oBDpqpTAaKGRyRhbXYlEtKrU8LtUwRt+EZtVI7sFcxWfEgEO/ADotytTMbD7tqsx0rh5Zkp/aJlDISDuLgSecwDwN5qEGiD4dmiNcoDwrBinSrsoDEuXb7udvXph7ng2KCI4ujtYKLhTbrtTlbPPsAQuinuNACRe0QkBRhiPPXLY16u3OLtA4RDwqxt/Gwudj6ucbbubK4fAJ1uTH2DpJYun+7sDQ7ruTqq627qQjIWO10DnREsNrYrQ7/wavyl7e7pUiY62vACw7D67S3+4/H+77t65d8dWHMq1Tx0Le4kSBkEysKgro1i4kuuhnDxw+wO7bxSChy6WMRwYq3epINm6Inu8AxthDw8A7gyb7e66Dw243jG5zES4j161YVjL83UjRkww7+67DlKsBgm1EGrCrmoFu5CrzB6yNbyG3Nl7uTd7RPC5gdfLwhK5ofHBEhPMEI67dlY8IkI72qS66Xer3pqlMyQTFKaQ7pgHe5KrMLqxG1KJC9CsAgW5NL14+eO6C7+7lBDJhDDBF4qXfykMUlbMLlwcTiG8BQbDPryl3kwCAICw4IO8J9LBDxsKqKFrJdC8A1iWHd/wq+k3WNcOuPG8ySPwyQvwlf9ZuXeCkQ14irfRvH5oAOn9y/02uzT8xGUWx8FFMOVuy8PkgQFmx34ZrJGdHBIZvIDnrLCre2xRvJQuyXZByV+LqNMbjJ99vJSRwrKLyw10jKLCxnp8xzyZoOCIEbHHG/M+zA0mpjtMjFGkwRMHat7svLaqySEoGvuyqLwSzMl5vF+au/yEyz9GCzhtvCxgIOO2XPFqUb1KwRWiu9DHuNL4ioSVGte9VK34wT7MuNu7yylUzE5vzQ6azOxMzJSEw2orzM5DrPzhxPK2EO2XEO5bERryzIIy28qXuSGyGD4DB/IBtm+HBuaxGVvKySEP9d0zYdla8YrRT9t6PsxM2sqRaqIiyRDvtsE3srvepLEzlstODwsPsAwM/qe4cBmsbrtDZ91dGK0/WArxSNxHOcusx8x40GaVgbFHvLzV78xTeLmjB9GE37rwBr1Vg91+cszJqs0/eLtXQc1jkLMfNwa6JjQAmLwmCh0N5ohA9rnAHNHSX7wbvc0GxM13T9vayK13l9talbx0/c1zWzLpHmgwtyutwTFG96uwMBp06Ks5xhqyXpmb/s2LDNj5I92UCaEVvN1V2dsPu40nbM2RED2Lzm1TfScTULwTRxqRqSy2qRkrEN2+U821e9zYP40FnsvzLI1y3815CWIAQBGRv/UdS46sCl/VtOUkbKDRVK29gY9sjNDZr9CN01jRM2zcl0zKtxutn0vE83kXs0McOyvHa0iEgV4phWSJKHkd6fmbztTbf0C9+ZnM00cdVZvLW9it8bjSKn8YuwEhbXDOEZEcC/CibMveCwDd0a4eEDIdkzTOH3rdGXVDPUcTIaPi3nQBDmQBOoG94eTg8Oi9yb8aWSe+Akm+AkXuKzHRSzveLwrNkuLj8W+dcpQhA0jnIFlOMAbds+/Z8iURsRXeTtLdlCAd1KntkV7pjOvEyOZhpko3uJ8nQZ8ckakbpXbmMgfpwisSus4eV6js7mjKgoXhPwreT7qMLILZ3v1tm2/8YgiwMZdXfjApEorvxi6WwPda5pmIh0rMfee+7l+CoW0urggv7A1gvFrBVwtKcQR4zEj77hZxjnwZzlIBrGMKUWm66S4wzM/x3mfi7m/j3oTlzonD0dpNFWXe3VuufdBPHP8awPRlIhTQ2yvEuw0zoXiVTrC22L/Hq02q7rKe7gxEwPcv6mrBvswg636wzI+FvUt5ERuloPde7sb5ii/Oqjw5yvrZYt1l63wbnN/niyJivfierteAnPeCnuA27ow3Q8e/LWjEzfWjzawObul7orlEu08VvblIbNhJaye56tOB0Wnw7qvV7wpLzZwc6L2xett4ruMFvUiIoPE//Ubv9nEbaM8S2o8fqG77Ueq9954N3O66HO49V78KSO8h7nawirz1gLuJps38zeD2EZxnAK7f9ubjhP7Tq/6bCa7a0R6GOe1YRu8sA6XQu/fRoxwkuf9uwQD5S+K1D/1PqQyAKpdoZ4YPgaWiQetVzvGAI/0crOq4n9tZqKlk8N7Rns4cJ97IAr8W8P72+YTa/auZSK4Or9wdHO899Z9Wrhin0/5uE+9HGI8CSIIRVy6eNruRpRwjkCD9zopBwLwLYtELUsf0V8r448UM19+Vvf83zf934/8nUsp+4hZyNC8XFf84oM4fmLwrw64FD/sAQB1a8Hp/sw+bs64o4d7eE8lXv/DxadXu+d7/nFHfh08h6pCdUd7I8TXcHyAPOoGeR3bvxQXa7Wj4XYb/kEe/H6Tsk2v/kAQY8eOIEFDR4UGC9hPIYNHT4UWA8fPn369u3r18/fRo4dM/K7WFHfvYn27NVDmTKlwXoWM77MCE7mTHD7al7EmXOfRXk9ff5kiXLe0KEqjR5FqvLkzHrgUIIzGVUqTapVrVot+FPrVq4PvT4E55BePXsULWLM2NFjP5AiJ749aRShRJcwX1Ldx8/u3owXufpEGDjp4KROn8pEargp1ZRXHcvM2lPmX58Mf8aT91Xz17ETK15Mu3FvyIokS8atZ7AhvHgSQdul+Zrv7IyU/+UFnktYN+PFilU+Bv44Mjh5xCtj7rpZeViHND2fpd0vpOm3+FAXFEv2HvS7Mm16j853o23cB3UTDk6zd3r2BpMrf/gOfvOGzOPNfC7bLmnqUVdiV4gunbqjqSLv0IJJLbXIK6+g8wazqjH2JlTPPa3m0+wdDTeEz776oMoPQZj4sw41lcyjSESYrhrpHppeUnBByhp08MHEeHuMKwpxOw7DrzYEEkN6FBpIprK2O0snnETSxzqkIhJQxRUdI8kkimiKcaN/ZqRxLBtvTM82yYDjsacfOYwHTYaA3JCdIOE7yMgQlXTrraeOKou72YK7J6oUZ4rxny3/6tLLLymcSf/MMY0rjqbyiDuTTUknZXO+OPEzi0mLmITrMKNS1Cs6mUpzUZ+ZdgKnz6gsApQjQQXlstAa0UOUskSLW5Sm28qMlFJfJd3sUkw1JXakEpHKU0rYZjLVNBepMtDPe77rSCZYCZV11sNwpFBRb217iLUg1WzoV81yc+65YkUiyaiyPFM2pqpKm+gee0019SYDU93uO6tizdbQq7YN81uDL3QIHnE5JNfHhgArqKq3kCTW3nonUgreeK3aCV98ni3wJp1qYvVfbAMuEtEcD2b5q4U1TBNmh4l8lKp6122yutNQ6lfU2MDRFLiNHQO45pkEUrlglgntcWavuCqPYBDVLVb/1ZR0rmsvxzreF1+RYkswRpOLFhayiJN2bKClgXJPIDPNdBhlgWl692OcS1qJrqyXpaqfAvMFWiQlRcxyo6rENLpIg9Beee1dA9tKObmh/E0mnSnWlDp39STwMVSZTVI/GAvniCrkTkaoqsUZZ8/gBgmyMLPJtXXXHnAuv9tJsj7uN9TO8aopcBb3Do30amk6HerUqVqe9eAiU55G2I9+fPLBosI006qPtRsnvoX+O9/P0DLe8Jn8fpEfhxj0iarqkXaezIHmn1x1WVMzNCmp3hoWcyZNs1LPtJY0roWueFl60Udw4h2FWeZwgGmfrnqyuvipDH7qeRJWFjeWiD3I/0rWqQ5+SrOu6iBJP+BAHwpTCL4BhU1BV5GOTkQCj5URh2gThEwFk3ZBxjjGU5X7jW72F0J8WA5n7LIb56oypaoMLid78UdwFChDY9GwVsbRYRbXg0EfIgaIjcHTST6os4k454iY8568zhcTJsZmcLSRohM7RpKkNapRWcRj0ozixTulRCpj5J/EtFe1JLVxhSo85KlaCEeqgCQv4HAknYxlnTrm0ZJoO4pvDPPHP/KPjDc74vgQdD4ULvEqCxQdX/CSkwNlTme2u2QsZcmbpmyLLEay3RCLaDn8+O+IaVQjoi6SwDZyjDSkaREA4QLLWTbzkltkCi5zCUjLYY1JVP+85jAPREB/IdIxkdTX/yx2Gk4605znnMlUoHI7m71FU4MLmhu7GbytPRGRiRxcOEcySSuVpZzoBOgsO1lGQQ4ydFR03iLbCM8lfW1U1ZFK5axyn4CqDJrm1OUu8WO5e71TjvMMDuBElsomIvOdQCtQf/wjIaoorKITkhpA/RTCdt6uo9nM56jYI9IDia6n3hHn+KAFUqc8xqUyOeolU4Yolgb0kxq1mS8Pykr22Atk3hmpTNS4T3+x614oDR+FFDZWcJD1gXd8aVpvR8aqWHWfxMophUSqpCaO6quB4x2SHMNTsZbVfWhVa1EvOsunQpVfUhXcyJq4r3oukGNRJdX/dq5iWMfQtCo0tKJMTpdWaA5WloWliVURK0q6orRjVhEck4aHL6A9VZBiLItVksipyyY1LJMB7Dk761TQcvSmxZIjPSvLLr5CS7YgpKyR3CWxju6kY7YtqxWtqChH6RBCAQUkW3dZxN/Gc1SqLa5V6pbcmdw1nSuVmIli29bPMMmlRx3rUal7NOsWBrvjZWu6RvtdnYIVODMNJLOoUy/8mEhqBn5MxeL73gXfilFaoW8Fv+jZWALYtZjabyzzNeAA82apS4npY3a5YMzGdzJYtBVB6vtDClsyo5/UbygJiyngpGY9vXGoca1CYqSa9ScSzNVSWTdhmVr4wvUabXjZ/7PdCZGXeYox4kWeBUuHxsUkNJGuWROlq1tN8GxDDqw08QvjvCbZMcxsJ9acZ1mE2OMsyv2uqVCz3pZGF7doXVSj6KfiCFOoxc58MYz51SLvJm29u8wxmhGFj8XMrz5moWyTFEPnq0w3z3nOIQ8Z9+dmBpqtHe2ukmtMaeExhdPZw1hvhuTAqtzYj0bN7I8ZtWU+W3dgp2bdQAtbZkIXekJihGpxI7JkgkqtIQIbCx8JRlkT4xbIktFz2iyqVl2D9qahzhmxT0LQ/rITdg4CDrefjLyICObPzX6wHduXWwkrO8Qu9vTEXJTkbDcZY6Te6Le/fFxxa3ImNLvgWK4MnP+k6uiZYRZzvJMYZ2LZdbKthiWu13nmDmPwKUgDC1OYadkdG7xb6ZEoOsnCSZKP9142aejXKuLkifNR0Y/JU844PrUI3Sjj6Sqjk8f641zhsakiL3nJJ/bmlxSw3uzZVsXbeZaVL1Ml5EVJRFPzb4bMS+l+7TE8oB1BhGtx5EHXdb9sUnSu0RGm6ZI0tyaSk6bj7eeMQfOf61bpLGsdV1zvuoS/DvZ+aowfKPRHX1S7Zo3WEu3INOyfByvkWr77sg6edd7BrBS+D1Hsf+eIdNhlSSF7G8ytLszbsTw2WV8FwpIHPeX3HnS75QM04Mj8TuwlMUxWN82YvOhRStLvbqn/+4alR72p3bV6Tg79In+HfeA1X1mmOt43ctn3wGruLkaXUfQ3dPbvex7YIAqR9SFCvmikc9V8N184DjrIhzQLU93s8vrAwftf46/WL/nx+2bRZvLZEl6WOydCS2Ee3Ki65mi+xJAI4asz+IM/4OO++os6oQsRQBG8fuO9h6sKqbMfACHALsKKc9q+4OMj4UMWsEMuscMSwWs550k6jBk3pMEOkJM49QBBWboTEQwjEryZ49Mq5dsJSjonirKgHYq+SpvB2rMl/ak84/sOjQg8kKiSH1S/CBtCacMKhli1qlu/zitCi6q/ynsXE1rCl3BCH1TB9ADCChEs/KmgcEGT7S1UwRp0N8rDwSR6pFL6iHxIwc97Q5TQQsaJGTZxwwkJCs9CwvtrLuRTobYokTBLmauZOh36QyAJxPQwj5CzQfuDQCQTKq3iByf0j2eCqiEZksewxPhJkzzSsoqqRDikJTkkOXnbRE7kh3ywmvhZj2ELQJohxcU4wzPMoYrisZdaRcOrwUJ8RU1MkpnoxH2gxbj4vEfUNH2LxklsKRLLLHQaxhB8Plc8xuaiiU5siz5xvuBoPBcUsoiZQlm6j3X0RcfYELoLRoAaRmKMQ0yEQIoRLr2YxT5JjwqMpqYwxw7ss6vAQtZZx3+7LXAICAAh+QQFCgDgACwAAAAA3ACrAAAI/wDXCYTnzp28g/MSzgNnryFDcPfs3ZtIEZzFi+DyadzIsaNHjvv2YQTnr6TJkyb5qVy58uS/lzBjluSXz167dObIjdvJc6e4n+JGCh2KEWhQcEeJKl3KdOm4phgHFjwoT2FChg0dWqRY8SJXrvm+UvzYcR9Loij9sVyr0mVMmWr35ZuX7hy5u3h1+kwKVajRvoADE30KWCpCq1kTV+QqVKzjr2TLml17sZ/FlCrlhsy3FuXblynD3jxHmjTevYJHGuWburXSnYHXwSN42Oq8xA3vbZ3Y+LFvsJHzhWRLGfPHyfw8+/scet7NdNDr2vXZevVP19idEsa4XajsqbUV4v92yFu3198Sx+d+fBw5cX8kM5NtmXY5c7U12+nfn07n9dTWZSfga7AxRRB4VSGmXm/m7SYWbgnhFpFj7Q3HllAfsdRPWp+BppJGFDnXH3WBBYhROAOmyNNIBV5UEIK2RYibUPacN1Fu6tkTo4LrQRYcW3Lls5VFG1nYlmcdzvRhWPO4Mx1rSlkHZYoqWrRdTxi9SFV44iWGkVYQSZijjjvy2CNwx7EEIm8jFUmfWx3+U1I//Mglon9QSSnYlFSyCA5shPVEmJZbciljjV9ihWNEY5JZppln+gjSZmGxR6RwGpoUJ0yh3UMXnkzp2WeJQDH1VIGCjvOiQYU+qtSZjTr/atV+zunXpWLs3dMRV7hOtJFF7iVX0qac4mfPiKGKCk44zI7a1H+vDWbRqqxS5epINUp445g77uetrbaJ+du26qGZEXIb2kfsnPzcg2yUylqEorMCdmflioXmuyU4VyWabayKNTTrtwS3U6bA5ZIL8FhCajTZhsQWy8+n4/AJ1E7lkEhviX2dipG+IBO1EMDaZqVQwe1Q6463jx6KcMviiZURpslFDFM/c414XVJGkWOavQLOS1RQU/IJFcj6inzbbSRLtO3JBKv84rcwVx1jVmBldKTNctJ07JMXXUxOOimnU47R9FqMVGtI76tUhC43SpHAUHsrtcoog2t1uNrq/4YpxDbjR9d0Ff+00zlkJ9TfUDyPWmqfbR+01I5Nz0133S8SNNtsdxfUjrV7Xz2er+CYBXjExt50F0/ljN2O0+2QM/TGj1MZcl+ikwwRo90elLlA60An1d36Ffp5vi1rK6SwXON3z2h4IW6wrs+XI5jQrkGbItJEyQMO6Hzrnl5iMfpeUPDpoKN+OsC3L7V+CG5pdY8akaTupjOJJh10r+saVjpPERramEXAtLEtaUJpVYLC1ygaka988nAHPIKnvgpGh30C6ZzUDHUwp2GKJIFznnNW1r+NuOts2FsKAZu1sdQU6nuSGwnyYmSRrAwFUa+6nG3Olz50pO+CGByeBv8jx6X1cIYfF0GdCCPkPxDF7nEDbGF2uPcxfdFjR9hKzQN3OMEeVtCHwmtfBjdIxAUyTSIOExZG4pS/SjVxI3QpHFLQJkXueOxoLxxKoehBD3lckV9Vw2Ff1KMQHn7xixcU4zrI2Da+4cN/R4LPRYYlJ9DgJzLPI8fO6LixFeHFhd7znlJAVxWLKKQe4KiHKvnlpYvUqCvmadBDIDRC9F0QHaRBJDuAx7lVldGMuUmjsExymfrUKTL8AuBf6jgUQOUFaN0TZVNIaRV+oRIjZxSkg2SWQzJF0B22VF8uc+nDgWyOUL88lP8edpJipkU+HNHNndbGyRby5JlQYRUeSwn/yH5aRJWovA1WRvLIcXUFW2Q6H/pwSRpzmOMc6xPIO845lWohTUG+Qg5K3Lkcdh3zVzZR3Rzrac8/nUYw0pThgGyIEYPq5itfSkgEJ4i+hj6UnOzY5Tomujl4xCNyGF1nJIlpv456lFIQGZz1tMdM7cjOdt/DJmC8pBWXLuagF5mH+brI0Jt+UR065elsftrIM46FnRu1n5wwExKRbKUd53gKSZv6pxbRdZCCtOqDtMmvz4EzfaUZJ0TREdaeWnSGTPMVzfiRrpJgRF3GcWuYzDbXu95rVNXsyzWJote9svRjFBRnQ3OpDrBKlHP6Ep1i0erYx66VrS21SVyDYldn/wktHDvDTmVNyVuobJazFFqTVcEkjy4CNrC4VF9Od3ogxM6jHlgTKmPbOZJKrpVOSHTlnQIlxdsu07IrtZGk3KhXG840tIEtDTpMOxv5XSWbToPkUCUplGJh1yvbtZJrUjiU2+L2J8xi6l0XIhgcBtcjw/2sIUWr3pxOVJ9LWa1KGtvaodiHXUPRiX5bM68CLouFH/5wgAO829QQWCgndo1YPtLZbblooQyFKETVIZuUMiWN/UgXSZYCF1NBkygrZKGHURRkIhMwXhtLcZ8opA8Wv5Ej+tAHr3R0EYFAp4K5XGQNI6XYkajEflCBi1qEopfuDLDIaC4giI+M5KJQqf9fo/pKlINDZ/KCCRw0VUcFtcwQNJUFI4zdcZiL5Q/LMKQdFtELkNOsZv72RUoCNpEewdtSrjS5znWWMqNGAk7g2YgsbZVsasRMJ4vcBByKPhGji7ysAcVL0i38bVMaxKaZYbrOU6bylxTrsFD7GtCTHPRrCy3ZumhY1asmsrNgHevW3Bki0N7NrSsUJOFOBB8SmtRkzBJqL0+4L6B5LU08pbrtJNvRy65dU38r6xs2ptJPnravKbUrH/maJW0VEpFEQh+l0LeonYKeRcSRbEobHCMADYxLoxxvbc873/XW9lqQehHhoIu67nysUcdtk/5YT8TyOjgzlQwVvjIFq7//8ci9LeRrULd1JRCvuJsmnOMKY5yS+XueSEXuQovEsCkkBwx0H/IqwKxYMvfODLdDrfJ5/2qbunp5jmuO8Ula0nn6sQvPtx4Yk89o1uzp9cuJA/NqlyWetG4IPgq6zuFMnahrlAmd9Ec4rh/w53ddkNHHa3HkGAnfZjchY7Y8uonM2e1v/zc43jITchs7Y6NC96gkZ2O6rn08gvFz3+dNnGp/BYfkAyh01W54fVio5kOBy7hFVPeNedg1Kc2XwXV38qMX6eETt7YgdVgPeqjS92ovqOlNR+G4X331o8lYiVUY5ClG7uBNeza8ee1yp5NXuxD0Ix8Bao+132P4iVe8/5i9Br3aZgfNzt8XVaIqso05JPqfZZDmHQ4ibGYfab6vx9qj3NapGzqJ9oV8I1Ix54c9zYcdsrd+lZdVdQR/rXQjGMF2B+YRriQrSBMPZEVW29d9+MB/+/B21cUpH+J4eLJ8dUQOsjcPfxRVfARICjES7SYgDthANTQuu6Io3pQvEoSBPNiD2qdK+wd+OgaAa3VMIQU2JqhqKnIOsmRKZcIvDAiDLTSDOeJKj4RtvxEml5MvPfUOXviFPRgP2xeExLchxhcX+VEXymd3YTM2nNEnMZgiVDgmDhRfsKRDhRIPm/OFfOiFYeh7ZPiBqGcREpOG08GGhnMO83BE68eGRP8xh01zERJoEdhmD/UgU3k4G1+YU5wIhjw4hvsXEiBIiDBRJ89TF444Dq5zRGYIQ3jniIQHibQXgQ1xiVqViRPEiexQWp3Ih2KYfx0ohK0IF3OBaFy3E+TQDvdAc1OXR7BYh4mhStE3eiYDX4hyeZZ4ifmih7mYU6X1jWDVi7+of8HodvTFePq2da6jK8PUihbBR1dkG02xWavUVLJIjaLHfVmBjdnYe4UiQe+wDt4Ijt+oi+zwDuMYiIO4eDGRXQcnDuOgiO6xITmGO/+Ujwk3e3Moev0oes+lHr8Hj31UXPDwDpxIkOB4kgeZkOUoiOfIKfqmdWtTR+LgMwZDc4z/tZACgpGUFivSGI0YmRAA9VzUmBWXKJIjqYcBOZAoiZIrKYbQ1ZKDKBPF6HE/liI/MTbLuBJT92VUUo8854AYaYu2oY9G2XsiSRV6KJC72JRNuZKgGGWmZ4bo2HHmkDFylYTNpJVtQRmB11bPqEVNM5aPwpG1iJbwuCXxYJJt6ZYE+ZRQqZDw8Rbtojp4qW66FZHKeEQwVylrohj6EJhyiCgdmY+FOZaI2YJRVVyM2ZgEWUEF+ZRAWI7DCJODU2YCJhiqmA6LKBwdsTsMExFdIpqjgpoeaRXwKJQZCY9DgYFeyJSldUjqE44IuX3kOJcv+RLt4iR1p5fJ2HYWVz+l/yMXX3F5L0iczmKctpGcRAmWTeGc0CmdvHiQ72CdHfiB/waT0HOZrjE29tBrfYcRm8EoHHgP2IaW6JmehLmefJQQ1pkazwmOFeRQ6wVWfjiG2Gl8/zAx7oATepGbSuEz6fCfTFc/Ygec2ZgYI7mACYodq0SWSMlHVBGj2NGY6uNQDjWfn6h/GXqG+XATOYEl2oFqI9p2bRWatSYUB3pN9MCDLNqiLuqgK9o2zFmjbXmjFGqhCImB9GAPPRp3/vCjj8cTaIM456CMjhFhtWiUt1hcPEhXcUhpfSSjZVSlegQyGHgRA3lIvLilkYmf9aWdtykoA8ca40A2r1OJDvF75P9onraxQGrZU/EApS7abr+EQDI0o3vER5MKDq75mE8JiIAaght6D05CDnipMReBjAZDlL5Hpz8FiJdXD4ehL+7AjZtDqa6hSgtBDxdxqbKXQDM6pzHaqZ8KjmAoqu5IhJVpbELKHYjjDpjYg5uDgX5UlByID5SorUJRku+gq60xlL06pcDKot4To9ono8bqlvT5p8sKgM1qF9ZDqBZxDgaRlN7ahwh5rT+5do8UmnKpDwdKYPCwFK8IrhcppXRargfrc+mKrn2Up576luyQkKNaXWrxPB2aE6naE2NTEBiYrw72nBeafwQVsAx3mJbqig37q28TdAoag7yqgmnJsA3/G0oxWqwSC53hyKX6d7FxV5nQg6rlgJflgDg7tYkGqVNJ+4u+mkpR6a/eZ6CWiBvP54xKcy1ZBbOahZpQC1A5a7OjBA45m5Y8+K2e6o27WLFieJ/vmkQQUTamYbQ+Q2MOxpZLKxD06VMi+SX0iIP7eLXcEzqZBWfhapyXmLi+2oILG0plxBRli5Rnq6e6yKVuq3hw21fScRdF+1CEpbZLu7R+yKULm39X5D1RuY/dV0UvVFaES0O7apwJq5qL20eZ2jZQEbkiObkW0YmWi52Yu3gZISLGhqrmsF45NbFrq7aU64lOOqOjl3BccYXcKqyO2yqvq7WHK3owmLiTZr3B/wq57xi58tCDaOu78cCj+FlhSRSmHVcXOeEzyMsOvZu2a0u5Izup+vuDNeKvFiGXoRZlfYG92YtF2eGe3RunziJNEFu+YWgRnkiO64u5cpKG0uG5FaoO+NuWyauLo9upSwHAgjh1fVLALdqId6oUienAYQjCo6u+jRWo/PC+yJXBjmm/HgzCF6koEBGwokh1I3eeWwulLes27FdFLdyDF+Gzj2Q67EuKE/Mc0nEOFoGSVRyboguD3beoHAgOAJyTT2xZ/aLAW/ekMPSrDZvEbwoOOxqKQxi0NgEOV0bFV0yQ4KDBpZW2egoOaGuF1csQ1RuaPxzGCMt1eIfCGKHGnf/axm77xlDchCPxmk15x+FIv0rKrRmpdqE5XYT8ZoUMSirFoi2cyJHZyBT8DzgzQkORx+AwnW6px98qsU/7T9bZfaE5SZ2cIkL5yQPSsg9sEaSrf/cginBHiv6wD+TmDheRDpT8jetVx05Jn34qhqkkklHJy5Rqpw6byKQssWzMxJf7xB5CbimjFKx8EdF8kMBsrbPse9gMrtr8ijr8zaQ8hsPMyYGasSGlzERhyUKBx6zshd8cq0MxwhaRY3Xyzmw4y2g8EvPs0MHcxPgcgscsGinTaXjrjURxziM70JU3l1MXEgGr0IFpxMDMFBHdgRMNpuQJPzS1tN+4FNQZy2z/TLYYAdKWsQ+aFn8kvXUr2pxL8YmAeM+ObMzIJ0Hto4vgWMVD0YvrTInCWDpStqRkLBjy2NO5y9DN6c0QzZLAK35dwyQX7a0ZHdMxjRHz2a5s/LQ4ndNTjQ/ci9UHp81EwdVdHZcfCGZgunojtIdlfdYajNbi2FIGrdNTrbJVLdcC8oraBxV23c14XXwA6Dw6ctHcGJB/ncfnrKcCLaA5JhKadtj5qNgtZNIHodWuIdTX6ZLiHBe8E0EOrIl4C9B4HMl83Mel89leHBHaaqBUndikjVIK6LCLnMQ1/Z6qHYqsXWFdQ55Lobf0C9BKYcmNDNpUO3TBTVeU53NrrMgS//vQS5zctEl1rSUncwfJgcHR9BvVcskoGZndzCRKLFzc3j0U+irewgh3xKbTSZoagf09+BDSoC2XEHGgBPXH4DraULXV3t3g+nvb+uqneD3IRBUXhk21rZHH9OC2gGnYQzG1vq2riMuTwi05eergahzhKt6H+C2E1EUnF47hbNPI/SDSkjV8R4qyApygIWnNiAtKJj7QSYyQW7riRr7i4yjM+U3IUnuYK7zGEOxT9TDMb1eRIeHFD5fl0tSylCZTuvvluUu2iqm/R17mZn7fUHmdppeT/vfhlQi2idnC+9qB/kfCnl3neG7nsIiJlxq5gCFNznnmgm7mPtt93zd8bP8e0odtcszZwlKODyOs5xiR55T+f1t3fzb7pKJ8toPe6UZe6P/qgWVYJ1KGeUqhlAjppZFekSNR6ZW+0DWb6YjM5ULOhw4mzZ6+4hDui14twr5W6lXbj1Nq1/IA6Xi+FHheH8XMdY0r6yxL6+Zr67lu5HwsFD24gUEo6iIN7KXJnAfBg7PBEG1t6QctaqUDDmCs7MELXk9Lrt9urZmO3Jy+idMe4UEt3sGo4wz320j5jt8uSsJI7pVhaAZaa+SdFiLX7rbrc2esxsCK0tFukiRb730I8faZ7Sjr28Kes9gy7oYGmJPuVor6fbgMcOs+Ks3euj+Xh2HIPY2oL2Q134H/HuH0iREqDsG4DRj5l636LrBvnprabMs/3OZS7cMjodMjb3ojQUlNRUUN7bBj/ryCu41q+c1nbvNfKCCzDFBSm+9vTdUcT4nft+p63t6HfsvAgvRYo/Qlr92Yuk+X+uyK+YpXPyBarZo1JLXf59v+6uQ0Cg73SfZEz3CWhvYXgfT+Ovbm7vbhyxTlyrqNLxSdjfM5b/cI996A731f//PEerKCT+77DuI7LsjAou+LH99vb7CIjMazHvk8Z6cxqPd9f5Y/fREez+pp396Jz3ACLISTXuOmE2yoD+TTdMgmXUePfRF/z31/3PV9z30JZ8u3T+7bHrAUAbC3PPStdfLE/7n6Pdc92NHgQ4GU7Jb51ev8v71Zip/nQlH9AMsUI1wfCEvr4OW0X97vPo752xqBzt+RAAEOHD59+/odRHhQ4EJw+xzqgxhxIUSGAg0e9JdRY8aKHT1+BBlS5EiSJUfSQ4kSXEqWLV2+pFdPZj2P+PBVtGlzoL2ZMQcWTIiwo0OiESkKjEgUXMKNTTmahBpV6lSqMK1eFUgP3EyZJu/pBGePZz174ApeTOjRYcOHRz0ydeqUYdqP8eJRxZtX78qrfVsu5FoT7MfBCx0GDbnPsGJ9HSkajMvxab+FB4kq/ghv72bOJP2q/NiVZGHBN3+eRauQoVKoRDHKraiQMr/LmP8738Z98m/ugaZL3kOdGiTr4RaDauzn72M/2rUf8oYenaFWkDSlV0x6WKjItR8vI4wbG2Fz5/vcXkfPmXp6kRBdb8+rHe7bffz4ISwP8atv9v2nBsaNv5Hcc40z+cBTbi7L8jNKn5xI8y9CCXEyKbjuNksNsaUSuqwgD/W5J8SvxCJxQhNPjOqy2zJUTcEFzWswxAdJLBFFG2907ELDiiNJw9Uw67BBEB+csSwcUbTuxsaG0rEi4nYU78cgg3Qvov3wsScnsZI88jouK/pyr5yiWtIiGEM668eG4HOyKKM6tGhJB7XccqYubQzTxucadExK4cwEEkYhbYtzITq5Eu3/zi7zTNQjI/XiE7jz1HpPtewY0w9Eo6KyU9EjEWWo0Zo2K5MiEEW8xzvWKEMKH0mtdFVIT2ctCdEkOxUoy7DCEpCzVM3SlMB+CKVUvxAhsknISUMiklY8QRVI1IVojG5ZtpqszSibrnzwqFRtEqvXgV611ln2bAXso7JqrLYkZSMickxD9xuLrI62zc5c/+xEN89cqS1NTFfbexdYcGl8dEaudGXoJnLLvG49T23tFySAA54IqXsH4lggeXfSCeLGTg2xYXBtJbLernp1lVx906MYVGnDYhenZiWqSMabBDQy3mRLHTKnX3vDss6ZssxyYXFvglXcl2EWzV+axSpt/0xZid754C3L8rmwoOP1+MGeYiYY4qdPtI4mXHMFiciShfR5LKpNHrNbs7ButiaZUFr7ubbnPnvCtKGdtu2Pte1a7kc9tjnvrCHsqJ7dBnrSXoG+WjvwzggHM1qK2SYMckPBDstfgkZ/kOje5l4cTJbsQmpJnnLGB0DNcbO9860+pzl031hme/axBMMZy48ZApzuaPmSJ5537gq1K5pIPPp23mZOlGzQ7x3M6bJm7jNsRJPP3dDFU7LLLp962orvzK3fnNHo0d3e5oY7UllqhoqX3P1O6TefR1Civpj0ryUySR784ueRL6mNc4IJyeDA5xiK7I0lMhOV0xbiEgP6T/+B0Wng+3a3MMZxz1BgcuCtpNI/24kQhSPkCz3iwRJ5uC9sH7ye57D3OQ1q0IEWgxlg7IS+9MWjhnz7iQZx+B/toXB8InGa2pgVOuzA6z8eqxNfimjE9nnMQUvkTMz8xTupfE9iFHIUBYvSsTKWLklFnCIY8+K/8m1Fh9VbYVbOuDEnyoRpHdoPVBCIpbSRRH9ynA5LOnLA90nQclB5VP+Y2Cm4KXEk0pMfVTSjQHl00pN/6csEGWa4yElyJbWio3W6NScBqgQ0IkFZqHTYOo9s8jry4IwndalLmOiRkW2DkslC4xLPcDBJotsgMUVSwPJl8ZACsaW+djnNTvYyhhf/fCZbTOi6lDSPLwyMWk+wSTGXFDElJxnh0Xo2vGxG01PUhOcuFelLZXLHIvfjZvOMeJc9plN3n9niFvvJQDtWJ10icWeX4rnQT56TngcciWKGhZmiVWSA6dPKQD3Xyr4E1Jwl0coDp5LQG+GSoQzdjVUi15H7NKcxNdOiXXAZFbBI0ioenSdeQBPS3YnkHSQdKTyEqhnYiaSTHjkpSkEJk+zZq0wtdciIaIkSfZ4ygj4Jm2lUItCXXPOVUElpPUECVKkMVajxGCr0PCLTjiQ1qZ9Boud+1hCoDgkk+uTnVRun1YB+1aJayatJXuJRtY61M2ZF7Ef06daFCkSpTJWl/2nOYp+HDI2b6ZupbqZVmC165i6FXWZLZpi+d5S2tP5BrFkVK1PGUrMiC7UKJmkyMG1S9ouRoyocBdgR9W10IZ1NFwBhp9G/yhAcWzTtaU1CVpKkdqh3bW08XwtbyB7zV2txKX8seNHe7naDH+Ut9AorOUTVTiDpO+50RiJe0po2JOvQi3Ple9bwQi+6nnTsY5matixJyjlmk1wMPwtakMjQeTMs5HmPC709DtK86UWvX39LWPG69yPrgG9U5rth+k73vh8+4lKxOkj/ZiuRrjTuDEFql+cNVLelBBB6gcuQGS94wM67MIbzwuHUEnghII5uKEeYJYJYCDNdaUknA/9b3K8aWMV4wZWMXzxhHy9YwR7BsI7xwuMetxXIHo6nkB1cYuIEeIBO7i5gzrnmvyZTKuu5MYU9GpUsaxkkyhUInrls1s8yBMhHBQdjQ3k0fBWlssyjMJNBucj1aLTRDqWynOEY0EiDts5ZDolph1raPfcYs/l1K1IF3dV0OvhdDpKcpE8s1kVu8JsFzmmlKV1UkACXHbdmx6UxjemFJNfXneYza6OrWGp2k5eTu2O4igw3e6AZp6tmNZWjctH6zpnWJsH1rXWta1+/o9eaBvZZhd1aYk9zp4EOMaSTnZN31a55pSVsCW9K6/a6t8rSvraCb5xeqmRb29uuc3I7Au6EcBfxvuX+pFUVnZIUkoXID0NWs1mc6I4Rk7vsZXG24V3rKdN433rxN8Cz7OuP/DTc8DD4sEXdUIm1nIPpVHa766HP58W74qId7aRZ/A6NW7ku6A1JvqHSZ3Bk+9ILCbiFB35ylGNW5V5mOawZqTZlL9somMOlqqGd6InzPNsiqTFv7BIQACH5BAUKAOAALAAAAADcAKsAAAj/AN25A0ewoMGD9hAWTAjOnsOH8+a1m0ixYsSLDx/e28hxY758GzOKdNjx4759/PiB83eQoD9/KQ+eIyhOXLibOHG2BCdu586cPsEBzRkuKE+eNZMirWl0HLhxUKNGfQq1oECjRh0S1NpQZMSKYCleHDtvpL2OEMlGzFjyY0p+/bAWvNcuHU2bRG/u7ClXqE6ff/3qDZq0cE/DBfkWdCpVKkHH4Ab6lLdznsGEDLd6/Rq2s9qy9jCm/ayW7b2P+VCq9Pnv30p+++4NLDcOb96WiuUC/TlYcG+fTJUuVZp7cWODVZ1GlvtZc2aRDRterChQYGeLpMdiz67xdOqYBF0f/2z9D+Y9cOfI1bYd+G7f27yL9v4ttL574YaFH2zMuL/y5QcJJM+A4AxIFjjz1BNdVxktpN1E1UUYIVicXdeZPNmB5lE+4IHTGlZ1qbeebUchpttufRFU1EHyJXZYcPkx1RR/VT0V1IA4GoigZQeJxpVB07UT4TrruEOkhAIOaB2STLaTI2lnebSPQR8Glc886ZCjXlI38VVYiigaNd+KBoWJ2Jcw+nTcfljliGFELVkmmlESCSnQOunkqWeeRTLpp58VGTgWSacV5Bp5O8GUjz3pnENbfsOJWVB7LcFHVKUq3vVijIft5F+KB7mJoU8XpchZdemgg84556jKZ59/xv9q3UQ4DkpSPlQi2pKi9rSTHlQ11ahffGFWutulLWZKpn6bxugpVaAaJGqPcka7EzyrsnqOOazuqeeRAsFTJDyx4pjkmxoW5A95VRr0Ej+Lhshfp4kZeymLOrWX13x+AYfbmcVBay2dO8Jp7UMFraOtOdy26u2rRBIJD7nlVlfrWme59BK7uypKV5YiAmuQOFrSNum+9t5bpmCYHtSsYpC2RKPAAxfEY2YpdoQWOKmy2nCrru6JZ8SwynouRueBk9K6HLukMby9NhoyU+OUc46e5PC1L5l6qYwppfa5qKmmJgb1n401p70RQajpzBFBPWsrN9DoQByu0RbraBBcLzH/LV7fffNzT6+sipgUOenMc49EWau49W301cevfCuCPTKaX7qHHFVQwWMqjzV3xDZIIJ2mM0N5ZmtOOQxzGzTRE+OdZEuqAV6euoGDhGWWj46DeDshpVObb8jmGxTlKJ9MGNlkl21cVO+YqrbOc5neNlqhwb3q6uWw7nrdRBdtNIEFmbT0xlUCzmuI3fueTjv26C488Y9bfjLy/ZIZNk313jdc5kFZR/ToZLCBua163jGdAjmSPZ5tr3vecxjE1jGxClKMSeSTUkr60TddqU9w9nBHerT0PnB8ZHHCq1/XKKW/SdGvZf76n7OwIjHmICxabisUOHSGmh4ycB4EahT3/7r3PfCFj4IXDBfFKDOX7/ANfelbicfq0i34mRAkdaGfCk9EvEzBEDicGtZOwoeVBoEqh7giiHd6yEbszWMgQuReEScYsdhJpiVRciI/bNcuwMGLLhNR3EfUmEX2bFE3ymqhC724l0jFLIBEG6DndoKZH8nFbbg6Dxs32cbBRcQdnkNH68yxKlUZkWhlPIv5nghFlmjsXbpT3BoJ+ZSabM2FipQUy1ZYOf1xCin/w41Bwhe9SYLDmJexJFaodxBOOrN0gwuNkcCRLVE2TFXqQCWQRMKRVXIQiq15ySv78cc1osYgWbOlYXppLRUOZTBFgVEY8bOUgrzjnvcExz3Xcf8QZE6vm+XD1TM5GRIg8hM922odq1wFpARFiYd6/CY4xYm7lDhzcBM5x4gM+Zdclsmdh3TRPCGlH3ziU5vH9GfadjJQTp6kbaGRxx19xrCF2gVDhNrQJlUjUXCWx5V9IydBAdkoYNkSZZH7KEhv6VEvjTRS+jQpP2FXQausVI0taelLU3OSfZxwcAMypuochqA8mqSrXeXqW3rqt3C60iWw8WobJZKlET2uX8dDqjt9c7IZAjM4UI0qOKZKpHdYcGKRueNCzrjDlpgTNWiNbFpLFxogTlNaZ9FHZOM62VXukY9ufStB3uJVucpvS0etH74ix8stcq1Mv5SR2BI2wAH/Rsywh03sVeXyTMm+BTY91IcnLVYWfXBVsnLVqRPZajuKjjYlWy0dltLp2vvZbyj2QZbj/hVbkSZFgLV9R2FxW1WCVCco+MDHbnt7kt+S87dxFe498GEPfHins19Fox5Zqb6DvBe4IIkadfeqRf0hz3Kq9WXM5nmQ8FowpeSSad4IArqs4Mw5WXVmezfYjw57mLTR3WRH6GsWnba3w+oTLUH+e0K6bonA8IlPXlt7VxnK6JE+qWoFkYSjAsmFIUAeSYY1rBr4GhnA+Q2JWcjiEPvqQ7McBlx43AXdE8qLo0vN63b318tjqWykzgtKPMYcDx4zkXzRspUyd7JG5Lo5/7+jOZBP6ouPJ5/Ew9/0kLtgAtzFuQO1S/Uai5SaS0sJGpjNE6NR0FwgN/m4JeoNCpRuGJTHtpSBDomIo601paD0TWl9rsujAg0mQhtrl5JLKv9kexRrUYZAokJzPWbNHO5Q2ij6vV6mNZ2jlpD51/GgBz0UhJUPWvRjLyY1mLqsSPyFTdX3CXNfmNjoXp+5YMSuTIYwNucLI/Ae8o3mRWQqYWTCw6QmHbOw60FnzXZMyn/EkqNqk+WBaReX0E5eiTaV5p28uscEcVNEst0VcNRj26AxixkPksNdKwmUiCXIPtlBcYrjk8zDrq+d4RIXKfb3j75KNoHb+dr7MTJllP+S51Wv/e+Ai6rClzm4WgSVcIVD59vitmxuB7uOivu84vdUN7vTq9kOe/zj8Hrjr7Cs70GzlmseNTDKXZammhG8ILD+97mYCPOCkUVQNg+NWQzixnJXteLqSLva0w70oK+7znfuaUviHXK71tjAh152yVdLn04FDOtpi7Wb3IHTncza1puByNjVON9My/TB7FC7KdGh9p+7fehFR7GKCwJyqQFLtXyN1i2tm2+P7rYgV3e54AWUIErKHEqlyTS7X0/pkGQ74pFXhymBtnZ1tH3MmN+H5n0i1I8tnenFwkqy8veTF57e6v6u9ssxgsfXM3kzAz+8j+obKpkS5Nzv0D3/KVuHzd77/h1CJ7rw87wTi0rk+CN//oztJ/+BCV7g7K6+9betfTWLpB5KMjHxcG6RpyqjRErlV3nsgH7xgHke5lwHkRLI9nk1pnzPh1T1d3q8dn/5h0cZMWv7NxYgqH2zNhIAKGG/9g65N3kMM3mmxHbo93aZB4EuIVQCNmqjdzynNyYFloErdYLSdzEd6IEjGILzIGxIeBGz5xDsBkQ5QmbnRiQFaIANM0rld3lwJ3wrYSiuYVG9UnfIpzz7c4GEdmA+CH0U9nVkUYJBYQ/9NxYCl30jOG6iMoAmtYIPBEGsQ3kLGIP1oH5x4UofAhsfAzL0pmzyB08n5zimd4Y7/0EPB0FsCZIha+aGariBT6KEMid4YwZ++ERxuidKetg95wCDwZZxcLcaiGIeIfcoyBdjiah80OaIQZiJY2FwCvKGIshuHwiH9xdrvliHFoRuKzhERER55yd0GtdpHsQP8gZo9baDtAgqANcSv2iLCQKCCIeJsXZYW9eNAwgP4WhB8UCM4gdBrcN2C3iKsxZpbeUa/rAPjDJvqRVS03iP/jYtWHeNuziHdHiN5CZhEGdH1XFYnXhYBoluKph21tSCfLiO7KheHNQ0bDNddleB+JiR1hhrLrePgkcaAJkjSTKQCFmSJimAZJZu94SHk6eO5XiKEvmOg0gXv3KRTSd/AP+UNhH3fQQRD9QoeB55f18Xko93kkZplMCWlGO2kJKHjGkXdMFGbBPJLh/iD1eSDqsTFfWYd9byMjlpLeXlOZ7jk6dHlGbpJuN4lGqJkEoJbCtpfi45Zpwnk1UiOK1oVKDXlX7Fas1nFOX1fXIZeNSmemcJkGm5logpjm2ZgqAIl/lEEHU2lVRZlVdpDuTginfViNzVLBlYHGMZmNQofRtZmIaZmCZ5mIq5mCmpgo25duxgEJFJl4giOCJ0meuRmVgBZp3JlyvHkT5GmkRpmhWkmsSZgqzZmmlXEMMWm5NJlVYZIoaDkWCEYyvVHl/Zm8CZnTiCmmpZnN5pUgaRnMr/CXeS2ZytwQ/zaDhYZhRhVH95IW27pZ1uQg/ZSJ/08IvciZTeSZzg6RPBRp4+NZkmxD632XSHoZW8eVXwlBPUWX/aSZ9FeHj3l58nuZ9KqZCPuRP/WXSySZWC43mFEQ5lkxRGlaD2RnoMGiy+k5HCRhBIeJ/ysG4R2hKHB6NoKZypaaFLiaEt0YcNCKAdiij5UHfrwR800RiKVp0oWhjuAzwa+XyzFmvEKZyqiaEZShBAB3ypWJ7maULPeJmjmBwIaqJK6htM6j5J0xe01m3p1abpBQ5tKn/1YKNPqJpU2pZWeqXgkKU/CmVc2pxWSVcjBKbtUyMlQovvWRO/o0Oo/zeCbShkBeGmkjqpcZoiIEindWqnw5in5JWUnNpgEPmf93BnQRpOV0JFJUMbRuqeICUOvkMO7ZBGPsGLzhF2D0GpuBppmhEUc/qimDogOrqa6MeA6Yann2pPobqcHFqq8CIkUmObSCocmjl/KuSqvzMPHPJhKHYwCwenbgqZkhotvvqrwBqs5QiVFsqpAyRxECmDwhegHjqkeTJCqlqi9XiB++Kq5wA8HOJe0NUhTxqUvVaLE2quF6ej6rquEseAyvqupcoSu0OvUsElXAkq+dqkoEZa4JBWHEFmg1lthDmwLjqu8kmudWiuKHuu6tpg6TeD5kkegUpF6VGvv2SBfP/3nlWzr2kaUAZxQgkxnAcZDyFJsPKJIyaLlinrlgfrqQmLTwbRsusHrzBrl40ys/NSG+sheo+jr/AjUD1UPQYhXGvmT0V7jUR7tFKatCrLgEzbtP0ZlfaFEt/0suVBtdsCrfb6JZpZreOgsz4hWSChRpVaEGSZImbpkURrtIWptsXatm6bocs5qppHt6woNaqaH03XbBdrNU66sZ1mEJElXAvRpkAbjoW7aOTzsfkYkmibtinbuCm5tivbEpEbtUEajwKmnq9IY1uTFOXwPl2XYSchXPZlidlYD6ULbJPhaKorLQBpo60rKvcZrBf3uOrqcwMEt+A2uS9rlVFTk3n/u7vv1CVaAqs7JDrg8GThBm6aJbZNZon3CWEo+Wsfa7aJe3/jGr3zKQ8IW73WS4w/Z3Hrym7g5rCUa5fuMK+DWq8bdVR8lRfjkCfuUF83B67pdav0lYuW2GP0m5QAV7a/6KuFOb37+b95GsBth34EQcDLesCLUxd6oi3lW77dgxyOcabjYA4UNoKQCA5jFqM9IiqE97FC+2/lWsQg/LwivLglbMJ3iMKWt4Cj28LdGy8KPMNYrCUFMYoM7D55UiBAZKM+KV4UxI64KJIFiUz3F7JJLHj5q7/b2cT/C8V0bHGoB6RS670wzD00sqr7ARXlgDiREVYqdVtCu264WIQF/3RmPVa/a7zG9+vGSBij+ttocty0dZzJFkeWf7isHTSZMQvD9Ii5IiqiWxksVmMXWMEOPafClCwPawqbuspo0ee8kHwjA7u/lCxsu/yim3bEjovJUOyampyh9WW7n8wuSWcnEyFE6lnKfEsOM7HKFCdAZNZokDh0daa++oB6bbJoojltjBxrbzzJucy/wfyJC1jHcEnMmRx0K0yePTWZ/TCkI9QwEgyi7iQOgcwqPEMQ6hCeWFrN8IxHunq+qCey0iIXCs3QiVvOvHyy6azJaNfOvVfMA9TJ+oBnydwa9ewrruiqVSPNMnyI79nP/hyeyamAAnwQLdqoHeiGJ6iPj/+GurTcJkhrtBDtusJ6nBSdexZ90e+8rsvIcXPLLrgrQuWAZdZaOEtNFE2tLehQEGoH0CydvfQbo7N2n8PGi7HcfQ0N1s2LyweZo71MshK9mnRMzEHdzj9d0J3cVdwbTkIlqFDRu6/6GLbkOz+jKj4h1OgGbOtmnyXYZDUDlL/oa2VNXuJomIu5khXd1pJtfhj9mMEntxP1R5XVzNGJs+CQqqwjN34N0FQN2I1LyYUt03S2s/annWmpkB1cnBjqcxYd2ZOtjnTstBn6hwXMcW3VD1PCGUGSwHWVr1pyNaoMDuPXklbtzj4amCDorW7KvmUJnBMjVSaVo7KtkLTt1j//d9u+l9voZhCoqFmYzTT+ANzgICR1oydhgZUm3SW+Az4F4YJ+DZfYy7CNmhnsa2fTeI3XfUTjZViPzanDzNI/TdFWWrjlvWFzm95TcoMkvSfdEhn0KKIQNM09ZxCTp9K43a4GQXDzpb6fe4YAvk8Cjk8m6bYoTMzqnOB9qK7XDA4ymoUbBDjq7Ul1BcjSPK9gOs3KjY5AUxAUV98t6dz6HYl/mF79/d+ZCoWemLCH9biVDeMxnqc9CZruylN+tCgScRZYstTBgjggmrOR4TlAs1CUt6ctMdVIzoDkvW50Zl/g5uTonJQIid1ObOD5/cQp7OeBjdU+fLoj2+A8JVGx/yFv6eAOioMl4yDfZI6VqloOU13aokh+e/qa4QmKr3mwPTy9A5JxGmHnbbniew67snvqsA2aWW54IKh+h57e9fxGUsMt7SCoT43hyG0X27KHB8EwQk5NRP6aRR7Y6kYPPxzqvM3aPhjHeG7qqh7tTcvqcgGC9VXAh95hseEO7c09Pd7MjoIXJHM1BKEqCTXa9S1HrhPQ9hRVsI3OqM0QRkeLzg5sJynt1lulSzvjljrnRGfeHCZU1NQ9JC0i3PI+dWEOjx4OVUNKqWLf6E4QwE5ECBje+uTuSxvv6bt+pL6Y9z7taouy0aLNbkriRTa8NLkeoS3mqTyvlkmoReSCrf9zENakh6rShz15sEb7hxuLZ/h45zpaoSG/nwfxa6Di7yVv3igxvFqh1IXBOqjV8ulRhcdIhRGEHjrM4aK4h+ig6YP+a0iYf+sH3CXuiEDvsUOf9kkpZoSOFZRq8sIHG/owD6uy6Apj0q/61F6cHlfT61W/9ayDjpUODgHNgnyIruzIfWM/vE7eluUKzGqvlJShvI645JJq8nAh98pdNeiAJwpvG/zcPUlhDqnDPTRFSgVojHrokOXekikMtz3vYftAvPLH0x5s+2o/1tNI8kkP8Nq+D+3QO1QP+lUDQT2eOueeDqHIglz89y/44etID/aw0b8/+/MVn0/u+MBqxPX/bq6JfY8RivTcbGdy22HoGe4Yzi2rA/pWQzffgid5Aoo7MdUJ5T1W+JAxHv0931VPxuwAAU7gQIIFCcpDKC/eQoYNGSaEGNHhxIcRLVo0mFHjxoL1PHq0h0+kSH0lTerbt49fP5b87qU7V06cuHHlzJ0jN25mzXPo0KVjxy7dunXwjBplpy4ou4HvBPpEZ07qOalSoSp9l/WhPX39Uuq7Bw7fPXwcDyLMiJAixYsWG7aVR08uPYhz5SKca1ZvRnrg5Ar8WC/kSJInS6ZkyXKfPZjmZIqzeZOq5HM9ib4z6k7twndLmRqE6tOq1avstNKrVxacV7ADRYKrBw4eR7QZ/xsexe0wIji4vePOrWu3r9+9e+cGRg5y8EjDJhEr1tcuZrnHNnsu9Xl9nWa8HuVy7hzUaUF2oqtOjerTdDx6qlOmFGhvHvLivBMOvI376EKM9n1DrI+4AAv6KzkDkVuOueZQ2iexfe5xx7FyxqHQJnTYWSerpC4sKq7k6GEoq/A2Co2qntJT5532wGmQIH3wkW+e4+oDkDd48suNv938821AgYbz8UfYDiRSMMIUbA6xfV4ExzEKazIHHXWKiieuiAIbsh4Q4xGxs/A+I0gddUIj8x15VCuopHvsqWfHvWqcSL8bq/zvoiDv7Ci2Ig20J8Ej7zHsvZTumScdCam77v+dKgXrMyQ2DwSxSy/B+TIogZYSM9MUU9NnoAXJwscjvIpTiCE5TzWKzt16w7NVgvYk0k/C7gHUOUHvkQedyk40DR7UjEzwUe/s4lLDpYzFNNNjs6Kn09X6YdEwWtUE9TVSTUVVTlXv47E2V12VS8twYRXMyCNnrfWw916UZ50pBdLs10bP7XNYYpFdChzPklJ2vfacJWjJBRe8Fttsc+vvt7y+HcijAI8T99c9ZT13rHQZVJNNeTSbp2GQPDpSWOAU+g5fSy9NNsV46kGpIGgFDlTQ9/SiSNu1qrwrLvuEA5LhAcmNtc+KR5rWVrBgrNdhj/e8S9V4wCl2X6k9U5H/K/g2kvk9xVo0q2b9bsaZLp155K1nn4sDGkGhh/7zYoFHapTNV2H9jiIRp5Z6ZXwY3KcgQV1OLHBoNwL765sjElse+8z6K8CP9ko7sHnZ/jPQo5F+NE9xD8SvIUnxFlHvkjiC+WqCBNcI7NtU97ZV4TJKDvbIg6a8YrfVJExzewNbWCDwJL27S/Y4HUhrg76qNaPAC8pR9TkPV/zsjR5XWnfqI1+79sqbqxbGue3l2ezfgedyIbm4Kj7rvgffqGWBEjPI5pufZ6t16TWHLf/vHwcs7eyHNkm1LnYSWo0EMLAJn3AWUhDOmCZ0DZHL3gC2tb+xaHr2AEdYWLKRU6kO/2zcup9Bqqe/LMVmf0CjmEjIcrEBLih3fkngWggSIq04BDUh6dtAvOKVCm5kTR/B4LPYJxA5ZYV+HtSN/ULIv/6ZcIQnDFoKa1W0geGOXggMn0MUxZDOPZAhqNlbDt9HQdOJJU0BZNM8QoIS+A3EKMA7ogftFMLv/QxWcfufClsYs6+8KHsESeCWkAjB8+3NIIHroWrK4rYlrWleDNogEYGHmThCDy01YtgT70QuPMpqj3xEHpuE9qoserBuw+MUwHS4PDFmUCTzolUsMUaWR7LRjZNMFRLvozhM0nFIdixSHs9FxSrKLCwijA3PkGgXkNnqkFsrSFgwt5yiCQossf+clhgnScn9fDB6SzRhw0rIuXGqrZPCHGYVT6KkJaGpf1g8pSnBGMb0ZaSMAgnZKy1mK/UJrG/bNGLzGlIQJdJxdsE8Jx4p90lbbY1Jc1PgRLY4ETC6L2B6QdNCndPGjFwGeEQUKBd9aZaDojChk0OXOp/zlaWVUp6G9FvfWqmRssBIhUSTpboG4g9w+MOnP/UHUYSaoaxQ6mCzGSnkSkok2Jx0XtkjZqAQyaRAxvNmFR2QKkFVy3XKLJI97SlQgzpUonIzW0lFW+QOWM7YOLWTsyqmg5b0o4hK1IbNnKlGZOopgcQSbn3q6irZJ1axClVSR0UqWtMaOxJaT3JuBQf/SsdSzAb1ka7EsttEsVqcewqEWtVa42E2QtifJgaXiFXsJuvDJ7fGjTDq5Ntc4TkXU9KzVdwr4GQPMzjS+qMfvhXcV2WDVOLKKbXHnRtBWvta2MKsLBGjLUW/GEQf5bW5Mwvrb4MLXETmFaTDNS5yxdta1xINticBjDJtGK6xSK+f2NWhb7kbXB72UCOoEm9+44NBPA4kiMytIjLV+8XUaGSIAVKfQLxL3x12V2ZmMYps9Hu/cJ4NrgRT7kdcSg/qWlCve83I6Dxr3zEKZL5yfS96J7zi+13YJFCEbvhSSbpWejdJLcshg4ObpnUF8JgsRq4mpXexV8EwXFVtpiov/1qc5rAIPuvTMUfBATAC5tadQEarkH2mWxFnqart0VJqJKjk+gQ4rzrWC8D+imU236/LA/mymEH2rYHVU7Dd9dEo27xnCoNPxi9kcpo8+2IPCzG4D06zmvi86LN12c8KBKNZnPXjgWCT0gamIIq9azpp+TdzjAZ1cdrrsQSqxUiX5ghO/QoojjjIWewkiLVge8ykVTjUtxa0CDELImaSRNRiyShMP3zPw4jYWoN+sWE8zURc37rJ/oUnRcWs4l/HNKYg7tukVXzldKF62Vq+desKauTGSU9dAstTdBMyz05dM4NlfvE913VGfALKgAXRo7dj/cpmmwWEBLKLRsLsI/9+zrXWtCUZewsD7KwSOqZvRrZr7i3xY+MbnxXvt0F4yRtX6SlA6nJ1fIZVKg+BrKauYRiaIO4iJWMcn/t94sQzvpG+lBtPtt7IZJ8DHZjH84ZXblWf/Otys8it6I8KF8VnfhCNj6rjHk/1bgUnWzadUh4m95HS9ESfm3unIy9HetKBbS2gm0VEpyJIYl0Vvf4YFOeuAdTOpypyEJHMXPvWSBC5HlkMvj3rvfvlkPISTqEzPEBnDy8RfQaXkYJb5w0KLj9aozE6Yf3iytWf3w8YEs2jTfDlHrzXc46yz6xDIEQxSFHxq3iG1ejfAhm34xwfd8gH11mi6s5gOOJEJ9L/1J1En55xANnXmhY+JGYkPTiEShCnFBW8+mF9qxIW+46bpVZyT4zkEViX5SB/92axaaw77HmD2DzWJvHeRvKlfNM3RURpP0ravxuk6X+TwonGPs/btG5zyVx2GL2yztO1WAOknlkgfPiKK5MggvgMDEE95oNAkEI7tRsQ+6MNC2Q6hmmoQxOIedARk6up36sjjhi/smusdzKyt2uaYnkalnkRd8IgfWOKB7wM5hsPCZOwCFM7CnyT1vOZDZw7+fjAApMeRSpAuhC7AhSSWAsnsQEPpYMzwYgsjmi/GhQIzLhB4houH/wWDLwTdVmJqYsPhcg977M4PAGYkWMPwPsL/4kpv4DjDI8BOGYjiAdkvwd8IzeKPi7Ui9jzwiABQw6MLIj4iNcoPGj7llCJGOrTspqbIcaZEfJwwIGwQ0oJKBzkQT2swDfxQ4a5PpXgwFDhP0YRCVs7xK87QZrSsEgsP5ozP6gRKThTmFcMCjs0rPG4xEzsQk78w0YLRDEUxe4wkilExf9Lq7XRPLMZkLXAC9QwiJNRvjvMkOLYwedJHY3juLRwk2/5n746jDDcsTWRkRFKv/jwEX4TofEzPIb5IGXsKNMbqhuEMDfKpadJnQWCvWzUCOoLEj+pJlDcsSkTFpAou84DkhD0v7VysrmCmyBpQkEqli1SnL7wu6FiP//lk0eOoEBrtA18zEcv5CV+rA/+8kdbAUfU2QdF1DwsEUDkM0HXYKO3eSVwuyx3hMgHmshnpMTlu8OM5CDmESmH2Ed99BkswTxPMkn6co3MUce9Wy0TUkaSWBfCGBaay5OOLJ9mfMbS40nDokaDCMqBSguizCQ65C8AS8qAzCCjkx2a1AtlFLPCoMqqFJDvg7O8eIiAezswaT/288m9mA17hJoeJMunk5z9crHYOkmOcqTpccvkEie4JEW44R0GMh93fEMgGQ53BBODiEeNxA3585FeVC1ziqyUOreUWMzVwDzH1JJNSqYiow867JwvestW8YxoxEgOgj56HM2ijCL/f/zE9+CHk2RNAnTMV1ytIwS8GcLHp4HOp8FMI5Od41BOfTmZKvxLeow/PRTMCUsOhUJNBuEHlShO1BEhgaNLhgk4mvEdWBxM6hw+vmCm68TOgiAq3uzOPRQvWwOi8nKxfFDN4lzMA9u9VZxOZEpPmpGhwcTH5rRPiAGSzrzPAOnNLcwvOvxPYSoaAR3QAjXQVESOBM3Mg4SRzlMdBhISEi1RFsUTXTwu/tlQ8cSp1CRQpRS/ulwaH2nOVLQNWBRLFXUd+1w61zQnADUvxTxP+uIHT1FEyWxJvvCd71TGWJxS8/nOIsWyA3mr7eGbG0WzKTvRJWSsO1EUzXTRu9TS/xXrvbZE0gsjTjBlMOIbIQNJU8s8072g0mtc09Rq06XZULbhJwIF0Zboq6qDsTsdPkVBQcLhiyg10z69SmQ6Uk8aTvNcUibFJ3sAvQ9plQV6HAPMUlcZVSBNve1cOi0LTxrNNxuV08ApzhzSmJpE0CUMEonBzO8cVRct1c6R1ANVz8cqvBDMKSUlVHCMVVmtjfpsTxbtmTY8slcUSo5A1R/91bQKViAixrEr1tjCVEJtiZkRxbtMIDLViPasydfpSL3wSed7z2uVvWxVjn3bp66K02NN1qtpE4DjGb/4UylF0+/gNcLxyPi0QXeVR3c9WHiVTb8zzX0boKzBVwKFrxd9Zc6Ac0Yf1VGw7FXnZNfUMzuFJYiAAAAh+QQFCgDgACwAAAAA3ACrAAAI/wDXrXPnLh04gu7aKQRnD5xDh/fA3ctHkeK+i/wy7svIkV8/jx879vNHsuS/fyVTmkSpMiS/ig/v3WuX7pw5cuNy6tQpTly4n0CDhntItCjRoUaTGkWqdKg4h0+VJs0JbpxUpeTIgcuadWtXhwLdgUuHMKHCdg2JypxYMd9FjPw2dvQIci4/lXjz+mOpl6RdcPNokiu3U1xhn0KFXi3KdHHSxkmjRnXskKpVo5eTcuXqcDPYgwfLglM4r2hEiW1T73Mrl+PHfi5d951N22RKfoBr4tzJG3FioJTBQQ4+PDLUqMWDV5bq+WFXrQ4JhpZO1J7162tTa68I1+7ckbVpn/88SZL8Xr78ZurmnbPn78SLfzpOvnjy5OCZq/Jmzvn51+gPiSWPPPNcZ6B12W23XWvefRfebONFKCF5cd0zj26D8eTbe4o5JF+HVyX3m3HKPXSZZVTx1x9nW5WWlD0FHshQghWxpWB3DYr04IMTjudPhTSdw5WG7nEInHBDBTWfiEgaZd99lKVYVWVWSdmZVp5B59xDLhZ1oD1rhakgOApyl6OOO0LYI4WAtXPOm7u1V6SRHMYnX4lF9dSTk1BhNlWVKuLp0DwxIhjmoTKpZWOZbsXV6Hd3PehSXmtSmE9g6aSTFWHj6Eknh1AK6pie4ED5VKhKsZcfUSwGlxahsCL/eqhEp0G0KKNt5VhbjuBVyhKZ9tBUk5ByftohcqIm+9CpqKa6n5VXbpkUodcxZB2tsyKalEz5IMroW97NptFq4Ga0UqU/dhuYYITN+alkICoraLOAEsXeYisaVeiX2kYkq1HaOoSrReHiFdJq2nV0bo/+gPPSpZlmuGGdpb4nr6jN6ofZTiVqySW1B87Tb6KzxrQWRNgqRSNrDZIEm0YLylaer/84/JI97hA78YhI8nxxiRkXpZOJUkLrnFZdDgprafvK6rS/J5vm75eGislduXYh3G2CcKVE80P+5BOskDsrVvadP6e9WJX7YUWOPEURalRDVT8dsFJghkytQ3Uv/9ia1muByS1FGYHXq6/gpCtYp7/pyTh8akcuFdscM0fgx0vHPaNMgttdq1TXLS26tdhZvV3gBg6ej0bmnlepQ2FfiJOe7vXUqTjl4BQvZWhL7lhmlV9FENyYZ+5l6t5G7RiMoo8O64FPG0htgQlOxKDrE4It9nq3257TOQqdsyGeR/o++ZREG10UdcQD1jzTSdc9OFsqq2UdoWe9D7/oVDPPP3ZgaotcsCchovAjWJraje3KYRCHiG935vtZvey1KqOURSxK+9Lcqta5bmlHLbbi3NLOQkICuah599Pf+xDUwUYRcDwPqdlLghQncqTDHm7ZStmaIpzIMcs+yapgfv8wCBqHEEge/auO/Fb2QalZaF3zkMcFFTKg/alQdESU26CI4paRZI8oNSOTQjQ1Dht26R7kqJNi6POzPZGqVEHUTwXXBw4C9Y9qpzFdEykiNRgp5IIXHJAJYUVCErqjfURZWuocNrMIgVGGlyqIGWs1jzSGg3bji6BSMBk0P9lLjo7B4DzqcUfS2QMf+DjZwPKhssAUJFOwTEdYhlfHdsjDlrc8y/AuN73/CQ52BCzKSRx2KdLEjRye8pkmiUI7QQ1NaM+UCjwOSaB6kPKO10klExm1LT8WBB3gzBQ6MjUQQCYEIVI8SxWvGMB9JC6YYHTIaqwDk0HNbofLlIpk9nT/nKtYiW2CsqYGGUJQbN1qYO4EGIxgiY43naOhsiwnOgNZR0GuE4Vgctg7CxjDMD4sNRJpx+yUab5mMhOOfVrW5OaYrNJk00AFNajqvvUWA8YEgQ19kzkeCsuyTJMoFrWo/jK6kcOBo0cP+WhbLKSpneWzVPw8KRB/h74/iSqJAPMXrt6CEXf+hSE0aag5djrOca4DHtM05y53acJBNuRR52kkR7VGEQsJxqlPVSkzOYnSKEVTOfCIW4xQicq0qOygAuQq1jrCt3asQ6wOPUem4CGQswJSigkJ6jpp9SjzvE6pxZTk48qnSdpZ5T6YXJZJhYY+9TnkHe94SGAdMtu4/2UzlYV1opi4yhHFLrYfNWXIPB6b08iigx2VTas5NSu3drZOrtn7qF3X4xtm5TO1e33jcaL6J9fSNra1ra2+botbqdhIsXO5iEUYBBvgQiRYrxQrWc0qELQqN5CCpJb1POK1Ce3FIR+pEabu+UbJlJS7TuKudtdWOfs6GK1EmS0RHSJQ66Dyc0a5Gm9zVK72OkoiMJLiY407zojed8KAgRGCMNJe6JJnmMQUsDsIvOC8btLAnSyRg2UL4Z/q65rZBEdhMazhxZ7JLny0ljxGPNY3gZO+Pu5SFQWKD8Lx18UvthngMFUOvtpYOTkWFIR5/NP2IXKU1iIsYYm8XiN75/9l7QUuaAHjDuLaxMlmHbP78Ghl8LwwyzYT8OI4ycYvp1SfCL7Kjq8yoDomEs1p1iY+MiqwNjOoQXH28FxgMo9vNjSn4DyrEQt1D0Ox7Ll/TgkxETbg7nnK0PJarWMWvRjiIZIo17wwKrmo4SPTxc9x7q0+HuLYdED2oesYVNXo+qjCLcxHe2kYOAKsLje5Wkmw3uShVVvjWYtXKba+yigtjNttssbNIIFNSTL9sn1EhFCedmg64DEPbRIsLr9VCbqk/ZHVqKddFMs2n9QW3m9L5dYPsabIyK3NiNwIRyJpMbs97G6wugMexh4nPMAEF03bxc/PhnbDeguxkVpM4D3/7GcEDc5oIyKyHg2/RypPWauDujkkcdZLgBMFGPsi8R5yyTSm9c2w/9rsJYE5x+0CDutCE5zlSbG1RUFD88CVOkxkejh7M00bTYutIfv9zss+TqnPvkQ99zw5yiMTZkXXNh4IdwzcBJnmzukxyQ+PeIslhW90Z601II8rPCs0ti6fbe0JTvTFRqcci9bDlE5LMra2tiiIOzs8Ho9LR7i61HurG+TRPbvsRgs5xKv2qZBufPuudWGZtD6Vhx2cb4POdYONZOwbeUtdn3bq2z9b2md3U5eZbnqUKj4p9KAHnpIWdaBWlO6lc/1atFkdRa03sR+fuKYBh7r+seUiOXdd/0kcgnTdHL74esUTPdCsxcU8PqAJt5aYGr5rCgtUyEys/IYv3Vt/c85/Q6VN+gB+6uZf5Kce5wBwEIR+JZJ8o7Q01hSB7xdTpJMsSEQ3HSRzkrZBNKcPNXIoZaJ7utctkyY6gxRU9CBQ9zCA+nBl/gVcCNgumcSAorI065c0QGZK18I312IdE5hwpBSBL1I9pwRTOug5vMcdHwiAmiUP8fCE8QBb8UAPp4QPA6huMxNXSMcupOd0T+WFR/EQyScP9FBFFAYOQIZNVIOG9XBCEWgPPzg3sqI3IDOHdgeCSkh5zDMg1CRI8YBWsMUO7/CEyYdKV3g40JYeXEhSKIcUbP8EH1OHa2+ohgxXWIY1bm1YIFdRNfrwfymkSGEyaeR1hzP1f4TSaAexY7HFDqw4iFOYgvpwiHKVOOWXgONAfF9IWr3zGEqCilsEGIBRYdikZoRlWHBYYcbDgTLRiTL3ic9ThJRoYSsjQlHUPva1DqyoDuAgiK44hTAHdFgIQ4kDg4OGi75jLGDYfHBzQqM0iTxYiWoWjTtoFLm2ghooir4kj1WXGtRIFMiFjeygDtq4jYPoiilohftQgMPkF91CQ7eodvLCFGrXO7vYdkahfEojgdakg/BIjKJINe1nW1WHOoqkj8hjI64HI0URkALZkg7BioJIiIaYkL3yTu7mkGf/k44hYiRA4232tRjMVy0G4pExZ4kH0oZSQS2p1IkfuS8mKY1rEYulVg+IFJDoMF8DCZODmIIwd4XlATvll3YQST6fcjF3AoZxhzdfomaI4pHXEYePdodPiU1RWWoq6Y9PNlbgJJAwyQ6E2JUJWRSKo3RdiG0lkiRjqTY6qRx3xJZ2U4zVMl5gIpWeuJYmmZJweGvZCE7m8GRPto3g4I0OMWyJAzYvQUY5WRwiYo6jcnw2JoEHQoyeU4xJOZKhOJex+ZZlaBSs6JlXOVadOZBoOJOlCZb2gJo+UV27uBSIuYBgBlWmshRNYj5wI4yxSZQy53q0OS1QaY8fSTUaaZ1f/1IPYxh36pCX5ZCe5vBar9iVIwE7iXMPOXMYI4KOpAVmbtRtvLicEURKD3GdHglC9ec+hAJkknaU4SmBEJiGxziGSiGQYqWeAglb75B89XAP76k9bjIYnOIu9nmfrZlarnkUzplXcGlemCk97dg/EWiDp7h+baiRxzhKyVeGAxIPRnGev4kOfOmX3qgPGWqcutGhH1qieZKf+vkYPSMUOUaGUpGgGymE8gKZ0OiMsJKgDtiEgnSD71OeN2oUsQWhLcmK7RmYgpkPNKSARZocnNSmZBkUqRVURYGKNVqjPwileAqXEohr/3mUV9SO5GmjWtqES0OGQYWjOPoQTwgOLf/Jl1sJc2ZaFOnBPamZmNDZpkm6k3DqZc/ncgNSp6Cap3h6FQrHfO/4lg/YPBpZp3JqFGY2qH4Ymg5BD0/Iko46hQjZD0kRO2RUmDx5qZgqa4fZOKblMVehfKEqiVIanvICMqGjP6vqpb5YIpoFhThKq4nKkmRKD7mqFJNKLA9ZlpcqJ8IqKsTqOGWUDhjmGBh5Mcq3p+LGP5nYpaAqqJGIJ4dqraH5hO/Ql34JmLqaFIoIrnRyHIeRqcN6roZhQ+3gMAHbn0Uhqhp5hgrqrC0KK1wZqNIqL5qVfFC4r1GolfEAmFIRNhtamG+kKrdDovypqaCSEzZ0D89VFDWqHBL/a38SC6+PV7GFwrN1ak0bqxSLGnVa6rGEmKhRSKEja4V3AWNE8SPzAK61k2gT1Fcp96YvSw7tIDIJeXkX6XxPmrN5yobMioZsyKJYWq/3ClR0x7aw+qm0iq3W+qhWmDhOa5qykyE6UQ7gwLdU8kxnOZ3K8S5lBD6r42Eu87Cz6qqzypVACJsGAq8ViKB7CrnYBKWs2rZzSneNBrdvS4ZTqK8O4Y1Mex5G4Q/7ECQ2cRNacSIcg2CG+RCr2ThBUUbuIDKr4zJXRhI0m3zBIaWGFX8ciZv6GK1r+xDH+7lwa7TW+pf4wEh3C5aqyxWE8bftYZbGYhjlAD5HVzhj9xr9/1Cvvkuqlku85uuWbwm0XlpRjKa81Sq3iRqaB7kRDRNGkoozDhUnFOQhiym7dLKw4DMPq7N5cLEPncga4huqG0m2k2i++miUVYi+x6ixNvp80+qp7mtRodu87YkP9HtUu4qmCcShB/urjTEcRiIO5HAOt/t95IIwqoOZNdu4GLmsMnq+RJnDOkyMkau+5WnBCJeoc5fBHBy/B8lIIHy6kQQnROKha5rC5OAO1nNu6rU1F7GC9sCUooiR8iC2N6yGEEw1Huk0OgyePlzBQKylGEyG9qrBHFzD8vSe9vu0B5Sm7XFJnhKs78KkCyvFnEcRLZgRVMw5/zegOPt+XuzAEf+8ZqFYxmirtmmspXCHgm3shxsMhe+aFnIcvT+CQEJCwnOEqdnbEwy0tdzCVQdMxQa8GoQlZHCIDzsrvI/LoA1RvsRbjN/ZmLmcvmdcyRnsuZIMv1OIhmlxF0cljkmFdrmTnihSQc3JGIkxDkJyDhdaEQM4gvd4zQacSDsriuR7tj2sQWIcxop8uRKYwBYFqtVqrdK6pdgKv++aShtht46UzEHCKeRKKkmyJEHxNukgMrISiwIdlSwYEVV4igoXv0kRpWn4n6Y0vOVskuGZwIKqzvn6hJ9bxBYqz/zFUQdIQ7TDmiwbDjCbDnZUpUFISpIWoHQjXFEEDwMiuUA4y8f/M489GNHyiLnorLyTDKtz27wbPYAd7dH+oB4GsSk4camlB80/YRUwDagR+Klb2tBi6It+aF9Qan+yXNPBmxY4rYZ5StE77b5FfLSEeJBC7UUenR6YkimRtRlUEdKQAadRLNVj+ITwgNd57Y3XJITU5FMOlpbMeqIP7dBc/dU+iKdiLb5vW9aO3cEr6BFI9dFu/cmsuxnUy8zVOzSGka7T1LzwQKHvsNcYnbHkSWWPV43y8GDu58Vkm9hSqqxebMsTnLaMzcZl2M6g+thQ2I2YTIWR/WfJ3Na7wSlXMhhZMTTsUQ7mIEuj/WCiHYhS+IpwV2EqrWvPCw5lGIXkO9ve//3dX1zbtp25wNzGcevYvs2vsSWrpNuCcVXPP/JEB5EO5uBqmGTfnZ0TzB1R0d3fo520cGenVCZkVsiCpMkQq93d4L3g3s3LOq225X3R6s2vbwxbRDG0ABttBYS6nZYpoCEkagoUPsEYC3tc7LCN3Ojf033WAv54rQx7UjmjYYsnDL7gDp7SEWjRbszbjy3ax5qr/eUjaAquWvEmDmEOw6dGJN2ZDiGQL5ni0f3GdcqDz6t8VQiHxzjjJVLjXA6b0Vqjlhy/FPpaK87BV8GK4GDh7U2TC+Mwo/cT/JQVn+yrcA4O5+CSTZ6V/h2FZr6vYGuhMOKfSnGiExuxXX7oX//upUN74WUd3f4Ik0QR5Ut7iIgISReSgJlURjuVIb8xDsHZqA8xkP3ditPdvmz4jsmywIiM6BRs2gsO5qLrGGj+5P7qr3uOo4DZOjAEXGIzGjNGeqUyDnx7E2oq7A+FDnneqCf+khae5mO+ibCcgg2R3cEbUKre5RRd46y66ItR697el7dOiEJ2zQopQ6U2GoTUt8nkFGWU3J0i7Ez+EMjeoyzJqMteFOv9iq5ehcsYixIhKmV76BCe7eOtzgr9EH3Jm99u60pb1sq3lA5bHg2jLmPhEFuLKZh+SfLxFPqdO3cO6kUxpuqQ8C+Z5qML6BHokQeeUFsu0zb83eTdhIv/fdtJAelXQaELX+ZD+7P/XlTg4SgyobpjkQ4X37Bp5yG4s8LggI2M6uQ5+u3rHVuPCnNvKGkHDvALbOiI7suH+raUAenrTeYqHu4fq90/mxZwMW22AmKXXhUrTPSB4UCGV+ePno1Nj+dN7+1Rr91FCJv1h5Dz/DOsrrEXjHzyouIg6+P9XcRiaNqGlVCa9xJ0RvRBr0B2Llkefg6VkZ7MHe/03qjCCQ7zTuoWLoXcOmk/yMgDSONhK/BTHkFjD7J9ztvx5+X4RxQX8e/S8SZwfyG3uCfbK1ny/mnHDk7yruwgH+r9Lb8wB4dGtLRsCQ4sLy+sDqrsOr4zLLRF4diK/7rojC+JxFwU2V1pdZVAkpWAufPPboIkT7G9BiFZAmGVn2n8or+XoA/6pD7hI/t+Tgi3AFEPn717+vaBQ5hQ4UKG4Oo9hBhR4kSKE+nRS4hR4UWOGhsyjBdS5MJ4JEeCExmS4cOP9xbmuxdzXjqE48ilS1du3Lhz7ua1MwdOXDhx4sohRAduHTum7NQlNRc1KDpz6Kyqw6quKdN37N69SxkSo0h59B7ic7lvX7+PbRdWhCvRYVyPbu3ebVsPYUdwGjnu9WgPn0KXCQ+CgznPXbt27mgKLXfunLlx4salY5yOXFGiPNFhvcoOnDpwVs2VQ10uKNLPW712VVhSJVmzg//38euXG2/euL19611Yd/fwuRUdAr54PCG+wQj16TOs9uA9e+kko6NJMxxRcOfAlRP3HXO7nDsjWz1H9erop+gmp06tUOtrsF8bxqNX1iy4tbl1E/fIrN8GnIi4t4AzsDiK9uoLIZbAEaw5cAyCTjrc+AHnnpkmIyeydNAZZ7twxkEIvBHBwam0ycy5ziqqzHkqK9PgS2210V5LKSGROGJJH//8202/jQgsECKF5ErwwQQVNDIhe/r6S6EIESpIOun840dD606z7KZzQtzOqHPAs0whptCrCjSpXPzsxapoPOpGsHKcEz8BJ/wRyIwakge/hoiMyEEEBdVLySXvehD/yUEVklBK5px7rkJ+1uLHH3/6uccd98whJ0RxzLEOHBFHZBG19Gj6Kh54lmrqq/aSKo0pydJ7Dz6EvBopnlQveujJPPtRK0Dh9BOOUEAFPbDQRQ9lEjgE5VrWrimhi9TC3CzlZ0NOO6wMHBY3E1FMnKxKZx14QpKnz6+8Eg0h0hRq0z3J4FuNXXC++opXtPgDNrd9CnLpInlA4mslQJH8k9k/m0xI2SafZOjRheyZckLn9jHotn4s9Qccd06Dr7IuOd1pHBatWmeppcAi6R2EVHIXq4SemlWyqNJLCisc3zHL1x/Vuoc5iD8aeKOOBIQLaWiJi/bIQHejiGKKI24U/8IIB4Pu4oxxs7SffNYBuWTOwjkPPaucWkfXePr0aNmTGmr35Kt0xvWrdPXqz9/D8Cq6waOVpgjwRO1y+OCmizN2aoqZa1ToJwd7HOusJ8RYLa6Bre40kcO17JxyndJ5nXSjBGcgQ8Nyi6msVucqJLAwWstKKvFhmM/gju5NcGcJN9xQZBGSOnjhGSe+9IEEK/3JoZ9LiELL/dtnHqrIDLOoccpBB9d1tEpbnkWJpz22sEqC+0bXnJpTHnxin06wmGj3fSPk/u6oIt0d5L33wiUSvp7gqzYe+BxXPOZFKmP64Adu/vUxnXDuemkyV98Y1Rzm9Ap+5NNRjmYGGhdlpf9VZREIONhCJeoQ704LgQeU5kc/XgWuQHjR38GG56QACrA5U4PUhJxXuUlpiTJEsd552GEu4NiQccZDmELqpKuZtUlGc+MZPrIGLEjZw39XfIgEP8JC3LkwiXmZS8OIJEb+CQ9iUluOAPUBPjTm8DmVs9I9GoMOnVjmgeVyR18eNBAjDsZ0EPFIu2Jzr5jF6FVXeQdwoKdD6tRjHoBMjkLgMcl0VdKSXKQfw14oRjJCpH+bbJgZ8SIx8D2neIQ5SKTyocOM7cMe65ieTjy0jjx+pIICdBYkMdgWV6mOg5+BBz3sYZDoJKQgVqzkRYa2EEs2E5N/0+QXldQrAjXMQaL/ZMgyEeLHUq5RYsakUCtX2UofwuccoptHQyBmRG3Wg1f02CU4RNOU1c1HK1h5xzARwpYRGjCNVnzIfhTSTIIS65kthAvTfGNNvQgvYjhMI/FiEqlvNq+Vt5lQPqz0SnmhTB6PXFQbqXmW8L0MSu9MyPlUR0+t5Ms2i7RopPijj6Adr2oFdSYmkdOb3UhtoQqy2jL/txBuSrQg3mTIG600KYtJZx6rimDwBkUxLBaOcYs6mpm40pXzqQMs8oCYWn6mkGqphZUxKQw4cLpWFu40Lm5BkE+l+rTinHFxxzNjHxk30TUmVamWS+BhCmMPEGJRm1SFFuAiuZe33Wsr+MJX/1PiUY8KWclyftXbQWSHkLXitK1Oq11PpQpQ/jlJrmYcnl73SlGyXvRKsrOiPeZxN7guCJoALda9ItuqrnD1dVLkT38su9lf/YiZnU0mFw2WqC8my6fM9SRiz4La1Ko2Q2gtoGut1C/d0C5d8xDoSowFyIgo1iS6guwSxSKQyl7pZ+4t7sb0xFnk5jSrycrl7tpixjIC1K4Rou7/VPsolxjwr5Ytriu9ZyT/AbCTekGaWTCyn/GF5XXr9R908jTcfmEMIXnj2K86Rt/6JnexC2tStJom0kAtS4B3HbBRjypTanE4bz/Da2g/AuG/+a1BIlHvjvQFXH9BT6zvxVhhNP/sn0v9qGMlJijpdqzJhGXzuXSN2DbvWsMBY9fAM75ofLt7ZbyQLrcvq3BHGPfG+KqllR0G2l4PMsL/gMMfayVxlE+ssI/MFctENS2XY+xlA0qxrDd2cncd1zSs7hkkaYZnbabIzyIbOWuu1XKDiWncl01ybZZUK0E5a00+34W0zd3mEQXdZb6akjkGPHKlr6WbmgpNxQgq2BbDchE7sVchbQaWTBVyGGoBdCD3mPMIdXSuT5f4SKV2i/IW1JBTMg7GesWuoSla1gQbl43KEaOETyqc8UVawrWREKV/lbckA48gz6kSvI09zP6I71xQTtezob1f6UaXaoqrbh+vO2P/baNFqbjB0qz7gSHwBfQtBZuwR9I82dpUKSF1/jD7pAPvoL4bLXyljhVf3R+OvcwdoM5zMwm3b3VG16EBvrYRB25gmtZcqdBb9z7AB26jORrN5c4wMRtCaRECa29EBTBzCB1ywVTLziNOiBYLiqj45e9wwHM5zPMaY7QQD940PSqCN2xWb1oxt7nGYJD1JfShY1zZq76a0ifq5vdhV6xQP+64UV7bwQ3ncE9iSVWzHmDVYhetMZl5xtps1uRZsUENiZLrdi0S9k7u1xhvHgmtHfe9tlqzluU45i/5t0qSermBp3poh4bDNrrbygDmvA3rfvjrGnDxRz+OO/Hiujrx/wi4HwGSZp1jMbDXVGpeN3grFWKpov861Hr+LN/pyuin/beNrbeaLas26MO3ms1GZnzQCDWcctPj90NfyGabd3jHBS1ShE72xjgWYiB5ln6nz/20eY6/aIsSojSkNshBnlWTscMzMPjam7QyENkQC8pzMIYwq89jvPVDq+MBM+JysvnTwDuzv/vCr/zbH/57C9MzrZcjjs2joBQEn+7zPitRPgiBMMDbvZTgtbUJoX16u72RjuhgPOgAs5i4mrC7uK6Rvw28FI4pPWbywOUKo8DTPzCSEv87QQFcJwkRIBb0vI0Tunv4s7aAJ5RYLwEBrhvDQf7IuAnsQVYyMIrhNv8RarImu5Y3ZDJLKShoiibo0rdScyjxgrYVZEHtMjCGKrMaXK+q4S4qqjcexD2LYqU4m7GiK0I4FDP5qsMugi48zC+W2zGW80MDdC2ay8NNHLdIE4jzEy6NO8PgWsQzdDOMETZ+mcTFyw224pG3Qhxj0cRcpJrOs7lDqxx/2j9RrJ+LqCgzjB0qUkXLiqmLmcCFiMVn9Bd+wKmMqJ9p2p0Q1MVsTLXVmjFXNLo3ekWoaRhl8p+2ECuNU8bMU8MInMAMJMJYdK/KmToTQyhOGi8dC0VtNJBOPEAXZB4dCkbC8Z7zSz/nOET1a4hXjDVoPEQk+yuVez79GCMSDCNE0Uf/t5C9C8wbpmLEq6NGvaAdbRq2wzjFdLQYSKGW6GBI8Iu1VrQsUJMgYqmmFnsWGOKNKOyz4LGLPuKrK+EYYiuw4fC94UvJGgunltxBdSSrD/swaByuA3MzaomUgck3JazHe3waJ1QOfEwQ7ItCryxBnoy329BA51DAu6ifmCogLcya4aqck0y/7Vo3o0M0unw/ZItKYbsHUaNKYsFKusCvLsQL5YEQPnschgiasDOISpm/D/OmB6RGXpkWV5RKmisw0FNHkkTABLuxI8tLsKOptuDL56uLTLKfwPRIU8s+PqsaL4OjSBwxjPEju6hFCaE5UGwtgKQSqIQvWXTLzwTG/5UQtTxTK79gIVD6nYCEwq8UyQR5lMGYqG6cw5JzjoFQzpO6QbW8zfcrqiPiTbmMHYSzS+5ky+08SwRptqLJt6qsROOUskPJL648lOPjRgMSz7KcKfhxp7PrGe30p7tUtdLZpu+US39RvG+kqDUDzkAcQZMKtbyLyNFboVJLKE3kvAw5OITbQMNYo/08OwShMTWsQG3LGgKDtd8Ez0NL0FKiTMv8k0lKIZToy6ibUfsaRQpNsfipuuEwqrJKoDhsTMcMqBOLpxyyGG1DPAH9CF9kUn/8OlecTTUCTQNKq+YolAxSFRglsQeN0OhbkheST2bZKwxtpR+FTajDmP3UIv/8WBSZUqOPy5BUW0YdKs9qCafbrKlVA0UrlBAlORcYnSST2jvSXKGqTBJF2VEx5cW/uk/8nJSB2DOxaIuPE6CIqihTGtADStA16sUjIiU+ykggLCqsqwdANdVAHSgapdHRo0pmOTODWc5d7L4Da1TqnJQODS80axoVLJ5Twp8CMbSoNLRX8ybo6KNSZKNve07gaYhARVV0Gai+Uc8HLc0EeVWm2UW5c01rAVLq5A8urMEMelXks6ERLBxLNSXEO6qdA7TSQVbEgihQLUZJitEY/bRVjbpRM1SFudbhGJpQ1cjn6VZb1Qd74DXxUVKi6k5PfUAEaRyZM57HpEjB8J//uVqs2JtXhEDViNTXfFUrL7RWqPm7bSxAA9Iobj1TNDW7PnHQCdomARW4WLXUnStXagS0qwookLShiqHXjd3XJPzYoIW8fmUIor1FddrG2fM+fTjZ26hV/NQ5d5oNantZAgzQ3eC6q7VZdxOauWgh6hI/FNLSlKMvj81Fo5XP4cFCVcqHtgWs6dxQd62HPinSbMUrGGtOQUvYl602JW20ulgWknIcGGOIjS0JiETLaH1PErxS6stKd0OtzouJtqVct33bgS3LfQgoaNW+GnK81Fw1XLTUQcwtd3ox+jxLk4jQ3fAIE5sy1LvSm3Qawvu4iarcpk2gpzXCCYEfRglA/zaK3UUZlG5yEGGqoIlJzaNhG4xgr1r7I2L9CE873Bkts43wSxQbHBU7WqoKOG09Ksq1LDNN2cw1nZ0UNMcbpVJ6FHfqlQEELYc1vfx4GWIMJ1tTOo5LiBgFB+klzurNiOulh3kAL4wQYHPlHdqVMZNtWqfVXSPsGJ1DX+3bWR71OqTaT0jKVZ6jncEYlHTZEXtwswo6C4Kj1/3lX4713wntCwFOjgJ+tsMZPAHzw35cKrh14JL7lwj+3UqdQikqno6gOB11lOYMC8oypZxtOkwt3P1VFXw1254bqMUS3ioLXAVB4NoFswXOXczdwH9gvvzMW5JlV6xdsx/mCCGRvv9o2TXiGd6r1V9mgodBZQiDiuKsiqRoSaeq66/qmlW2tRDxvWGO8WLmk80wDl2ZXQ4uU45Iy8d7bIuRoKbZparohVF5iNF9Pa78OLHRGUYeaQgB1tH2ReA+ZlrLdVouvmF+oqn/s9uMpZq9dVeJoVidtTXda5ZE/bnbQQmP1FL21CKr3ORRNCg8Bqmo0TrJBTOmDV8NDeTdLbu8rdm7GONS/FwftqHA051+rVs069mNNeHj+uWoy7Wg7Yhh/uRijgitQ11CU6Wl+tFmFmTmA5agYeWZBUu7vbWzoBD3s7YhDRziIJ+BgRmNTaE3/mbioOOyNSiZJGZjPmbvpWHAemf/ePaHQf4wetYmdsJlMS6pv4gIg0BQNvZQg+WVxxPB86oP+5ASU0WhQ0kuelQuZAFlQnlo701mdzZTim5MtqBnADxWcSQtky6UkcsNVxNhJGZf4ABct3CZd+gbkgJUsU2QzjoopxFgdBZl6irALP7jLR5fByYM60weCDGijX4wWx6SYJVNnHU4wBk3tL6POXEa5mBpgjZoA7EvnXrdrI7crfZjic5pnca7sOXanQXdsy5aZB1W/dyi5FjCj3CZlaBrb45qZkkmTuYiF1YIUE5nrb7CWQVfwBbPrw5SY6Ih5SnrheEN35FMPkJWZQlGTNpPk44k+pnsbr5rCC1bEjuo/4vI483G6ort607ErtBmYPElbbxLZMiNua7NpiJ5Qj0qry7MlRW6P8dGKAx+iI31tO52C7aypAEO7om4aoTgbL7eusRc21LG3dwd7UC2JVIV3IabGME4tUHJRPHyOZMq0qou3nMb0nOz6+7+U3jII6CN0Ev6qKtm8Aa/aoi4aoo5b3VWOiz2ssrF6dH+aoboIRj0LzaaZEfRz2gSI8hkEKa+nZgG8AB/J3o41QL/NHc4OXzLDwe38Qd/iAbfY63GwuLG8K5GOK8+04RoMn7Ih4binwESaymhi9oWGhO/D8iz7h4zTQ+9iBfP0niQ8RnHN4K6cQaHcDCPYRm28O673YwFPu6FA+QjpE5l+9xTw1sdhtyKnS6H4ItS3NFt3qJR5CIrr8UhxXJP2/Iur8QvL2YxH/Pj63EzP/MMd2933GkM6dBbjpAu3Lz7jjiNEEyUABBe6+2j6TVACvR7I3T7M3TfgLkyx0KYuF1HF/IQs1UMYdb4vCsdu/SzYPE/n+2EiGyAtpNPD9c/p4eAAAAh+QQFCgDgACwAAAAA3ACrAAAI/wDZCRxIkN27g/HkKZRHbyE9evUi2rOHz969ivcy3svHseO+j+BCigzpj5+9du7SpTvHkqXKlyvPkWvJkly5ceVmsgRHjmfPkSPHCRUnDqjRo0iTKjVKtCk4oktDChUalOpScj9/Ji3I9eA7ePESLlT4MGK9iRMvWtTY0SNIpPzuzWtHF6ZKunjtvqyJtSXWkFqNTnUatbBhpVBFJlY61arUqVcDK+Va0Cs8sGPJlj2LVq3GjW0/7lsa1968uXjxTkRdN11elTT5ShY8bvHh27ht205K1XFjx0b/Fuaqjl1xdussh838ECJnjBg/h36blF++z6ez2+OY0fTpdvO8t//ei7X8uKSEcavPDbQoU5GNqxaenVSd/ePHBa5L/vWyWIfOcWZRdGx5ZBg/+3TEFmj8WMfdZ/eslhps5dkUH3xDradhVEW5xyGG4Ph2XoiRAUXfffh15dU7Yf23mYAEshVSPkj5Y6M/IzWIYD6i7dNgP+Do2NaQcn3XzkoV3nThhkw22V56IY74GIlRzSYZigXlZ5Bl/gEo0UTg2APOPSFlZFQ//dyoppoh6ehmg9W9+eBJR8pU4W9GhePknkd5GNWFkEF2VXAjoWiofQSt2KVmEY0kJmlprikpjoaxmaODEc4VE1+/UVWUnhqCyueThy05InBJWSncoYcmetBl8Hj/KVFhPvKD5qS4KvXPrryu2Sammm5aITmNNSUqbseOqlhTUAKFqpSCakgOq60KxGWsDpn1qEhkjuTRj7iGixSv5O5qaYPXobaXX1gNtltUoCarLFQdvssYlVKq9xO1hrra31gBgsktmW595Ga44oJT7sIL3xikdazBFlu7tTWbVDjyKtveU/YKhhSqVRbKL5b6vQqPO2Npt623PL6pY6QI48rwzORSal2Er8FUk5IZPqUUxqP6qRjHQ/fpJ3Ai5quUcNOOfN9A+/WH8kIqrwzOty7bGjPCNHf9z6/XyZVaa3ZaWFvReWY8L8fMCk20s1E+ZtV5Skfl9NMlS+1Q1UBx/1Srrf28eevW4Xo9s0g3m+ZdxEgSe7bPQmMMtMZP1us22lNSGfepuN2NqLX9nbz3aWgZ1fKPgbuMJuAwE26j4QzjiGnYmaKWkp09AyX57pRvzCxSQsd3aqAgK+V5fiaLThbfff+detasA+76jbA3bDO6c2ZXJ8Vp7z65hh0y5dTviGGoNN1RFo/U8QOFPrVC2ZFu9Yx/Q581mq3HXL31lJYkZFsZ2Z6SRkIU76mtSYSpF/AwBzf4pK9uR2EfcmCVmfhp5ygcsZ8Gf8SP6fljfw0Dx5pclo+TpIN7bRMH7zTmpwTSq0+06VRvorUVgvBLP4sChwXlNz+gvEk0G7RVB/+nB8KFkQRXN5sHkm4SJWZ9L2iVS2HbGCM8GdJwKQKh1gQxI48dhqR0SeHRaEYDjtEEEVwe/KC5QGgUGx0RQffYHk+KtZh4vQc9LbScFPfIGytW8YqTYRVyviIWpAhsQ2ccYhoLRzOl2CgudZGN4y5HQHe5jV6/Ix/bpEhAnx2FbqZa0mRCYhws7Ud02UlKDw+0wect8oOS8lpU+DGmYPGFiejRiUxyF5LEuHAxU+wl+SgpQ9o4a0TrqCHU1qG8eShllYWh5cNa+UrCles2dJIYsQjoHnGUwzVHQtLjftkxzAWTip36GARF8o6RFCQ5l4HfaXqHuCDmr5oy41VIvnb/FHOVpJaRtJAex3EO8NjybHu02FI02Uv1QAuQR1kHQU6JrS46s0kdIc3LBNcgfOqPn7saV6+kOZJdVowo5EhHeExTJ4QmlJILLWdhkAZRoOxHP8kER0VTiVEazVJH/rufR3O1z6SU65EJ0hTFxjET8GhEidsUJh8P0813KdSBUbFWUpK5n6PIDyndwiCRfGoUMv7Knh593hANE7uSxLFxTW2HRdJ1wqomdKEw9CSpmGQteIREHiPxa0jaaRgzZaQtLFNQgUxXRjhNc4P4dBNbFUazklwnnK4JD2jkUteXXvVDzZJpYYqzlHbCw7QiuahRNiIdss5oSLBFrEgMJs0z/w7Og5JtI6VEAtKuWfYk8wCNgqDqWSgxVJjiY+BnPwaO4iTHMPFIrWqB8pmriZVIEBJuRnlUxrNqMHAeTN2lOurGkXzNcP4IXIJiew93EOulRsPksi7JtuTOFDLOJexhnEm6L5ppJGE1HXaze9jYHiWRt0WiNDtyMIcVtXqPdNNwT3jSu0rVqi/M67IuvJSp2Oe5SIludFOrQ3DUI0yd+a+3rvsgAhcotmQFYiLJO8IFtwWoDqYshG8kpEwdiRzFvXA589jNvS5XKiHJL24edRYUp0UjY/KpbEUCWxe3Fsav9Vv97Lk6G9+YxuXVMex4bB2W/ri4UzXaAp0kFCXvF/8t24LzWlQc5aQUyMpXhi2Vp7Pl3AoYti/zFW/H/MgStua9aD7yHY98TsFETUNiWhmc8WFYbkWFO7TrToTmDCHaceRqMG7ZpWHsshyL2bcl2YfYxAlfRW9ymMNEDz1LJ+daB5hbrhUrhCxiazwH2MAt61FiYUzbH5mX0OgSm0lT+GqYKpBo5Gw2PY0iZxQ7udoYnNFSWtydWvM6xZz+739DTW5iuylNp66s/y5L4aF4FrTj86WHYj3tL8JZJI+KNBj3tGtv+zvcnS53pgscW+fhCMKBS1c7zsGzNHcSeEF+ym8yrKyLHtKQtN72Yfr9744/2dfVHZOLQwOudM/Mspz/NWmFj6sbIqN54r7U655OHBUwCUxMdLbuijN6lM/UeocW7Hh2l0Lg6zDYViY/OcQW7jh3oxninNQrUay4YSbRHN9hMqSjrk2RbGtbz9ouk0bkDPQd1oOHtS4MwAvko0F77ZFvbbrTE93sNDOrMeY5j6uXjO2lPIrSt/7zWMnKce3RZS7zsGjZ961KSQPcb44dc5nFaUm6Y5KczxamUPK+TmXd3OMTwQfgc57lqxVYuwC2t3jo4o7Wu4P1dFF8/J6Z9i9WZPSQ72DSa+aPy6p85UFu9Mb6mPd6q1Jb86MIhK57+iEpxXauj370qTZPr8av9vYuUEd3XzNInrDhiWY2/0z/xNTiG7/x1KZI6EePFAC29vmtX8dL5E//6StkJBe9/r+zz5ZaHfztN8N0dBR+LSdaG0N143d+jiJnokd6WWZ0p0ddYTUX7iB/6IAO6YCB88dMJ+MO0lV2K1VtHwca/sd9/4ByAjR3wZeAHOIh6VRvfVdzcLZ8fYNpAscdIoESKnGB6MASF5gO+8GBIQGC8SMg+fZxuWeChWYPjTOAd3Vc59ccexKDMjiCUFaD5PYRRJKDFhgb58CDQNh6KUOE9+ZkbEdLaqRu3oc7KghrUGh8UigSDyGHfLceVqgR+iB4Q9IjfqMgQ5gSPRgb5uCDQBgSU0OEnEFzckaCaJiGJ//XeybEhpUnb/WlgHLYHHNID0ChiUxShqpkZfrwa8TWI6SIg+AgD4BIE+VgDoOogSIxhhZkFit1bQU2Gq8DgKv2e8C3V5bYi/YWFSD3aaFGigYjGjyng4F4Dqw4iISYU+8DdBFxQShWi9LkiCeXLimxVCvXiyzYixdnZ1bGc3xGjD+0XiHRDl3IEqzYEuigDl0lhpkhe6fRZGKXhLdYWQG4RHQkc77Yj02SXfqwh8RIjlnzEaFoiF24juyIHCIBj9RXhPuWezhijbFTZtszif7Yi43Cb3ioDwGpZQMpY/ejXvtwkOBQgRnohT+YUycJi9kBIxtxNbWCbhR5VJalVJP/9Ib+2I1NEmfQRHQeOY5u0iPQgz9dpmrdgpI8yI4X6IzPGHQzyIhaI0LoFThy4Q4qt3dIsULrMXX0oYA/iRQe+ZEgiSAiWZRGuTol+V9KeYE++IXpEBKCtUOLaCanQ5OSx27LZoC6AzSSg0AEFXgZWRgZEZTjeJYjmZZosl4RgpA76JbnEJcjIXveZpcz6UY12TAWeUI5+TMGZEBNwlTpcA8kNZgiIXqiB2AAqV0DaT+KmZZmyR2P0pY9eIHs8IrzYIQxIpVTmZk2qZcCdTmfCZpMIg6iOQ/54FimeZqoCQ4NSGBkCZJEiZaviT8NooXd4Uy0eYHqIBJfMnohd5fU/4NshqaPfTmcT6QeTcFUBbUdrLOcQIGa8hmOBTOdifma6fU82JkpJyl/6aAOthkSAvJiGXVuDrNjSydOivGZQWOcKdUOySkpSxGHo3JI8nmhz1l09VlsqmOUNjI4aWKdO3IdpjESEqUOQNhFT4ZlBupGCAqcgZGefGKcBYWcWqMmQFJvRpgUGIqhIyeQiMk6Hoow1pkg3TZP+1GIK7URrflYvrI//qBqmiIT5QBFdiWa9tBRg7OJmEg533gUPTqf0AmkiImfhKOWmTabKBMmTGqftPQmbAKlm4kVuDSjHENQTqVItyJC8Il1zhmmGQqQhilGQSqk+OM6aJoPobga8v/TplnzWNLzf7CTcJEYnHuyngWVnOCCJklBobMWZ0txoXg2lkIpOIoZXtephbSTFqfjMpBacr7Zffm4l8XplSoVoWr1piBRbJjIiZ4XliOBmp8BntVVmNHZmi9zqlyzJvqpqv0HPa+6ffdYWZR6kVrJFKIpV5qaqqDGpAN3D2bFpb4qoH0aYPdAqtLppsl6qDIjKbk6ornnqkWpJugVF5piDogGPg8qXKoaZZkGDqFYEWiBD33aJOiqqPoQkh3KrrEES5PSrIX6pkUpQuOpdPkwF7t0rb2UUshJjmDFLRNxdZfoq3NYsEpxsOgakn2WlmnUZRsUrefWOvgYd+7Wgg7/6hpzRYpHIRpjsi0EexTjarLAOJZEa5gJq7DnZqgJFjMua5Zv8liqKmpo5Jv9UEIKulAElRPtwJrUoRRqsTI/K7JCu3FFW7YpW58x67IMy7SpumUPE7UG8jcVe1TeF1VXcSRbSzt5SJiUVhG56Z0LMba4Yaxjea5mG50CyWW3srQ3kjrFNkbGqFjTEanTai4XuxI30UJShafhgZq1BnhAkYeblm8XBViBK7i38RmhaLiHO6hAiiA/lKxKi6MQSyNVNnRMSrmxE0cMVzHQFiLmoBIq2ihm0RAKcRaeaw/RaEFD+IqtZ2JmEb0biboD42uti7jpyocrO6T5qSP9qlgu/yZyR6u75cIPUKWCT1EO7sC8pygPLdIi43p28YiKC+EOYIEU0iu26gGsGmJYIMe6ZZtd2VuqpiqixjgjPid05/oRDFsu+9AO+FphEpcO73OKYXEZCNEi+Ku822K6hzG9Jga9+otxvfOzYve//1swBYes0QOvJwx6A+uRDAwzNZMPFDZ1mweEl6FTYBEPXoG/8Sl6oagPAhsRxhsSLFkYZmEY2MckYppdxIrCAnyDhIqY/dqzZPeSufmdQpywt0UuJiGZIVEOkWm/B3EYEGEUlCbDJRmwygtYAnpi0uulVGgYGBoSoxeoICesUwy+2rXCpUgjo6u8ZSfHyIcPR/vF5v9ivucAGOfATGdcGAlRsiYGtmVrFPKQv9GLuhdavXrsa/MpsHNWuL5GpvuJFkZMD6cBML0qEYhsMDJ7gvnQDjYRmclxm4fBEHacESaMYpq8xNNWxzwqn3isEXy8xxkqeqH3v1F8rukqyCH7EPPrvu9bFhTBxvdUtcpoy7isMZoYeqWDmr/snb8cvZ6oeozHdZ8LqD3Ky+38yS4mylbmbU/cpgbpZPUgzQoBK/7xvmEBERTxyvtwT/7AhMcBDu3zDt28IfUAx2CKD+Mcx+X8Jd/YxOrMgOzsoxeR0cycYtkFegHHEaIbzcYrDxgcNSsCv8gr0Pe0D/JwoiKxJStyG83/McLNCSYRrclAQdH8i28dl9FAzc5WBqgQIsoDq9EF5pFkErL5vBCnJVGUodL10IBeHKIheg8v3c0J/cNAERabqC1/KrBr7JFjInoTPdFxXMnpl85OFtRu/db1zNG8TM8XqnxsQdZFfBoNEQ+nRRnW8s8AzdKwaQ8p0Z0xTUoI3dUjBg7xsBmT1sVHS4zjfNbT+6UWvX5wndlBbcxhGtDJS9dGTazOGbKJZ7x8rdD58TkI4RzXzMBDidUsKRBHgcsZzNiO3ZyQHdlpOdnlnH5rbdmYrdlhutFvzdmdvX4w/NhXSNoMsdd9XUrQLdONDRGIPL58SNi3adilVc3U3Zx4/4zIIZHInOoPvK3TIyEgPh0Vwk3UwwrXxt2jk+ZtPO1vP8vUmOi+73Ci/aLQqz3V2GyQi+rQ9rHd8NvdveycYTVGg0PZcxzHwqwU693ORR3hgDqwtYbW6I3PxasQfA0PpdQvWxIW/j3DAM6fh+HPZeHd+JaaAFvVacLg5VzH64zbbi3F7nzMFG7UTK28+et3TL3h1OzhgmQQIv7KRmmkEeLQk0Hk3E3dYkJzmiiyVW0jMG7I5kyFM87iNW7j8UzhctbbScHT0qvP9ODDAwHiLDLiRx428+AOCx0SF2gU7IDimCjH520R47vgVZ6/l91x3w3UXN7l6/3l5m0UVd6rYf9xEFmEN2lu5PhjpKbhDgM+4OBwgeYQ5+z0vnDcpd7Z2mu75z3ubWvdycUd6FAc4YS+yUex5+DQq2We6Kj9NI3u4pQa6YYCFDx4FF4dEl3qyuC6tCIM6o3ib0BB36Vu6u096HCm6jtd5SLs6g/RIrFeHLOuD2mpavaQ1feR67iODkYx3a0sEVOeY8K+ycT+22Di3sj+3pqddUyNv86eyq3cHNKu0H9ND0IMmyXU5tkNoDzI7XCu3bze6nWOvNa+uM3e28AswhjH1sGq2UNdzwQG1Hi81mE+0QFCvPkc7vJOzSnt37TeD1Lq5klmH/9+8p2aiQY/0PgTEpAb0RIt0SP/zHUQnuPsHfHsHJ+0tkpjDu3ljonvO+ssb5RwNA+KLtsmb/InL9tAC/JDDyQA7pGbDMLQ68vMfhRfGsQ2j9SCftz6lrxKsfHQ7uqgDvQq7eiwqQ/ZLliExSrcedAjEeVoz6ltTMzALLJX9+NUX+xhufUSjvNh6u6YnfVxPPY+H+yUDfRlTt0h/+gRUubuhNAfTjJnPMn4fvCPXkZEXBHMvvAiq/cz/4s17/cSf+oZHdaeG/Zib/g1XfbQ7umHWqQQ/eq7jtBDnsGNXQ9VjSAtvqgNHhV7/0VaN8yk38w33oCAqvXKfPH5LO+GX+6aXN1D/6Fq+fgc7sNyXhks8s/4/8Dyo0G0G/37O23oWpd8o0/6XZ/8p6n1qt/zYw/9qi7EMxwpRRohZ7fXPtxOK6JfCM0iAEGvHr59/frt2wcOH757DRXaAxdR4sSI9SjWs0hRI0WIGyMuBBlyoUJ8EkWaJMmwoUiWJz1SLPkS40yM9GzexGmR5k6ePU3qQ2iwnz9/Qvntu2fPXs14EeO9exfvKdR3EuMNBGoQITh9+JRO7PhSrMavZZV+3QjxLEhwSkembBlXbsixLMdK5IlTr8CefTFutIgvq1DC/Y7e81qTnjypjaVSpVpvsFauXZeGHZvxrsezaMFG7Lywc9jQLueydfkS9WZwfffebO2XJt6KM/8lAuVX2CjSxIodP37HDqrAewWFRtynz3I9eoDF/q29M21nsqPtiT7bFrT17Krf3v3OlqxHv6/5ytaomaLyfbl1G86HeKlieo0hv6NHMOhBicmVP9RINIrmIbCi2HiajrrtMFsQre62u8u6BLl7MCaJPJtINvps0vC5AyMCyrj39onPq/luagwcqOKxRx/dErpNn+roGrDA1i6yrToF28KwwY4eHE2s7Hr0scfrOGMwuvJg84s19UJ8T6sSlZoJxcby2++4yijaqrKGvrzHQxzVuzBIISlEM0mwPGNQQtZ4TPIsDf/q602NQhSRsKOmnK9KDgXL0yDkPEqoUIQQ+k//pvSg05FIjiR0k8czP2vw0QenS3BOnWbLUMyJ2MuSMISSonInDqEkDJx+XkpVVd08VRJJ1tKE88KXiFTTzjXXLFXTGxfNDCZAQxUqOVL7nGmhyQTdKMqInNX1OU5vTbNN7aLFltcy5ZwTnOaAvYvR65TD88XkektWv1dZTdWfbHVFdjNaH5X03WjTnNMmezcCidxDCztquesAfU8iZpGTUdWIiCLKI3f3vZDOSeelFOJssessX33tVQ+khvDMM+CuGEJVy4kEXRVE5GC0GK8clSQtV4x+VOvSlt9dq+ZeTTXvW0UvwlEkUENFtOSDWUPM4JtdJm9T9TQTt+alITbx/zrrXOvZ53Bdpmnghe4ZOtBAU9a1q9sKoojhiAicR6N5yAwXvQmn3ne0qpHlOevmtCbvwK69VnZoaJ/dKDkQWVbZK4UGm+hhcNhue6LIx7Qtx2npxrxRmvH2U299+W56JsD7FXxdst9N6qPBHJcI8skzm+1pRjnLvGWzMsba841h77ql0gtjLVEQEwYH8Y7ANo6ifyB/k1PZ4a4dc+pw70n33V86r3ehyyWsKLJNXo8isBPGU6GIPm5vKMdtlJx9yl++8eno6ca3eutB1yh70UUaP0uKmE3ZqvwjFnKFLUb/4YfaKCKP1slEOqGbX+Yww6283G8z+hudYEAFQOBthP94HvlYAZOnqkMlpyAKjNYDHfirCFrsUhCxn/W85RGfaa9fGoSSwcAHQvF5kD3tIgoHUWinym1tdi3EmbVi6LkZYi97gCug8HR4sNMRkFyVkRFQiieUIT6LYaxr3uWOyDUk0o9zG+qZRPDHtXpA8Yr/O46o3jQ+rpQwUF2UyBd1JTGgORB6ZYTX1ZZkHiJiJCSg0kjB7hKm9SRsbHkEBxj3pZPY9HGFgLQXd2SDk4jsLYzpChzLtrKq773LX92L5LvkscqIMBBHnYKagTApPUHmbo3SOpDQ+tOlALpqIl3azH+Mg0ckjnGWS6PQkpgDm07eckwD0wjiFPYsyvxSmoT/+tdQjsm0bdJyNJvU3x5zaaGzNauK0dKSoCS5sAgaE1zdnFUtfSUtSuboLYLhikdahc3/JZJ161wYQDEJP3jK65uagp5PoBaWkpCTVXcBJim717CCpvCP2cqV7eTZpEX5BCUfweY1N3MoVzGrYcTk58oqaqeMRi+ZHcoQTwbG0I84dJd2glEJ9xlQXYnUI6xc2kXjGbMIokluMW3jWsRjEpv+Els63eGbfDoWVwYVW9VqqUaN2sbLFcktdGloU615TpUWrz/2uiYwZ9m2twkVSdzRTlbtVRKsyglDSlXqUklylxDdSa1mTeRK3/W6ew0pSHLFKETiQqEA2WU1b4qi/8rKWUaxCvatOrPZ1E7DWGHJxV4flCxryMqlugjIsklEU0uiBRK7hSRSp9GrR0ArEYfcpYOAHe1kvYPY016WO6rVFWtL49rQ1HQun00YI7eow5ORjXhTLWvtXFnVMrIpTar9Dngw9lXirgUuwI1WAYcXUqd6cCOMFG/xPkhOSupqurO0bmqPq93tZrC1p8FWwmKiQd0WblCLHN4bJ8LejLh1ItSlLhLjSyH80vduGTSNZy1WEimyx4eAbeR4/yPgm63Sw+BAMFBdWFe43reyHhGJibE738wB6iVSHEsWlcuvl3j4wyBuJYJxDGJWilicXiUxmuzUEhWfpMHR89dsZ/8bINXB2Hwvccg9bAzUHutYIh/28eOctK0gY3XILCkyWL+GmNS86cT8cvJ4N6OspIHFY7UNsD6mfOMbt9LOWE5w8zbX5T3vyMFygTBqNEjmfkWQw7T9svkYFVssKmfOB/ZxiBmY5eZxOciWziyKYeuV4waO0IymWnbVfDGxjiQ8UXz0lSmt6jzv0SJCttSC/azpTcMWHCHUx/jwudcWK4tfZz6TqM+H6inneNI1RuaQrkUvZn9ZuIFmCa65ArbxVXjA6WHhakGdlr4NeCUBEvCcbWznn0ovrnODk6O8091a9y8hyql2FsknwZp+VFje9aNk/hpnibjDHfEo9pXJDWn/Wi77MzHj7YLqC23+IdI/h87nk7HVVOic2UJHCldfq3ZroMgoJvAA+aQj3Woer/qq00sQauV7GnfnRmQbjvi7LNTUpdDGuIBRbMYRpbjDJcRE4AA5PJqyY1X/tM51Q7mOElutTbfcMEVrNLBZExPh1ZybDhR2evj7cxwqZCb+Bru/iU5VHk9SdGYZz9KZDtv+8aOkDy+g1DV9J9gBRnTNGwl0vNaWv4AdxGAf90ZCbPaX9VnlawfzwFr+dnlDnKUwWdxGmtNGm1Ke52ORireMCTfAy8Md2DL5J8dopkAGebFeC5HbGR/vJc9V4vUqrdybSFCbt6Xzn49W6J3U1RGb/57IqEeI20WV68iSes27lgmNOpo/7GmGQbh3L8lFb+DS+z7x/eJlsYif3tVOfVil5fWYxlLDv0ATHJ/3POilv3vaI73Lp8c+jIZfbZlXtr0Euw2tAcRCdx6YQ5YXtvXrLZbiM+6Ktr6KpCBCinq7GHv7NQSErnuqjUrKORrSPADUCIAbQIgpwOFSiS/BjYDyh8MApHFpvfRgkIzgLrFgEhPcQDPqQAMEEwsLqKdrM2y7mcDIuopxDh4RNq0hv9gauhfcjPIDMj4LCVwDJu85iBvslCLko7FgELkjEz+bPOZQI5jAjMwjQii8lhj0QJXwF5YRlRnrLdhgJtDItvjpv7MufBe9A8MwDKF8iCihMJuBiqlK451fwTg35JikisPhAkF9yAc6JMOnO0HmC67K8qS7ID8cnEAtVDc/5J1AvC8QLEQ6VD1X4Yf4yCjqkwnE0ou42RpLosRCOjtLVCpMLMT2KCnDyDXecqZuU8ROaqYirL0nfKdThMJUVEXFa4hMpENqMgh+iEXWmEVaxJ5masSJ0Jr+A0Ve5J2Z+cWv+hJhlD+jOMZtaor/65z8ucJowZ+AAAAh+QQFCgDgACwAAAAA3ACrAAAI/wDVgRtIsKDBg/XA2RuIj+A9cPfySZS4j59Ff/36+fNX8B9BfuD2TcxX0aJJkyPz8ct37569ee3auUt3kCA5cgbFiQsXbqC4mkCDCh1KtKjRo0iTKlzYcGDElCRNYtTIkWPNficvbty6MStKli9j0gR3DhxOszdz7uSptK3bt3DjErVHt2lLqFHBWczI1arBvhv/CR78D3BXixJdxhx4rizam2fB6eTZU67ly5gzG6RrD1/LluBG7hu9T+9evxsPAibMmjBgxCxlpkvXuHbjtAUpa97Nu/fRzp8fii5pGiQ4q1z/9i0cuDVrrojviaVdmzZugpN9a9+uvW5w0ScHgv+kmrymYa7OW3NlCU727PfWr3OfT/+tPHkEOdO9KzFk+IL9HHWeX+k9589K98wD03sxtUMdZJHVJ+GEB8EDzn33JVQPZw89RdF/4hl3mWDgeFSicwciGFZMCjo4223gjEOhbzr9NCE74LzzDjw8uoOhPPOAoyCH/FFUUlZEBXiUiUENtlV0LK4IX3zjyJhUZTNmGdQ66+jIIzw/AinkPER6SNKRFh21F2aCQccSmZ/B1KCL1smok5Z4wsWllzyGGeSQ+xVppIhCEWoaOBmxydyBUCXYYoOzkWOnUVjmaSk4XfIYz48KdkpmoIKeSZRxXvGDVWZtHnZSYo526uA5kv7/JKtkl9ZaEzs79slpp/rZ810+A/Vn0Gg1lWrSQEpalip0sLH02UszSTqOrDXaai1BmW56n6ef6vddQcAWRBpQxvbm5GsmjTaRdHVWWeWd19qKKzzaAulpr75+Fi5B+5IkrFEijpdsXAU+mVU+87wo7bvx3hgUO+voei+++d4VVEpBpVlfwa8h/Co55bhLYaUNFxQxmPYCim9wD4HL70hFkVqcoSMW6Fo/b358k8gl43nytrxSzPLFMCcFIlx+dWSzkwiKBStk78Lbc2Y6BpUr0N32+l3LQv0L8MxybUVQ0kC5xqg9Tt8mrdRTb5ct0BQD5xR7Xe8L1LgGIakX0oYN/2U2ggs+yLB2JDf8M9ycKXRQRHKRRiy54dFs1IBVkT3Qc4A7LelQlOmmVOHxnrxp0Jw1VRPXbaVUWkEBIyn5UCl6JXaT5/IjEruwxkjrQe6uBTrnbQ9EL9begtYh16ifHhxE/IIr6kHGanwUVsamRvvf+aCdzs5sE2RdjTa6Ff61KKdcfIcQgVYUy8s3L1qx0Xs11EnqSlWVUAbyk2C7BZEzVjvnmFb3kDLAWtWLdBVzymecQpQFKlBfeBHJcEgVP5MMjHUWkaBELDg7/DEtNnUaSDnO0Y6BOEiA40tKAS+FoYmV6YGhCooDWYaXGg4HTdGDX7Mmcizr+e2DMMkdWf9KOJCEofAt1ZpRPOIRlJQhMH3qg6LXDGK3grDvVzZUHQ4rGCDqrQQqHOygB7uSDwCShSYtm0cAV3iUFEpoiUwsCH6EVA9ubShxzFvcW4JTsbtAMItGGk0Fs6LB0HyIH33zGxmJaEUjsjF48ojjQH5ExzoiEI+8cQmorhiRUEVQkBWE2UiyAhiiFAZnp0uHAIPXRAxNco7gqIcsX6KyhXBHk2XipJkACUqvFNKQozxJKfFnOae0gxxJPMrvKETJC8EylrKMZkIGYsv5cKiPusQiICmCsfQBc1CnESNSpLPGR4IDS2xRIW/ogSF2yoMeBZFlLOc5zQmtTGuazOYubdj/vpeBx37FNMoxVymUynSOhT+iBz2CNBB5GqSe9nxJ3CZ6Pk6y6ooOiWAYAbaSYN1je9MqaOc8l6dmLpQgDrUVvrjFUop5Rp98xOc+QRmggBaLPQsJoJU4d1BLvROeQkKpNEtGS5Ya9ZLYjGncaPjPmh5FWCANKU+tpVCFIiSatUpeER81p3ZgzYUUDWsfWQIeqjx1f+cImTnP2TaGDnVqcpKJO+ZK15h8NWtiXeoVP2RWo8QGVlLNzUGWeamTNlSaEL0WTOjK2MbetaV51U9DfnUkHzYwYbEaLH3Wysq3LJaxXIKHY514VG5JNG4wjIgg+yrQtO50QuBzY2cvI9d1/8wGHbPhEpfmGibSHnWW+CJIQzxjyIqwligA3NyMYpvM2WJmrulAh3Sni9t0hJa3fuIWUDSUWIeEJk02pSJmXytb7vSuvM7160HcYVt02KYx0rVuptwh2hYydCjz6O5VzkqbKlGIbSLjbHqPMhP3nsMcCIZvfOVLV1f+xjJ+Se6k6nMn/+YkM9rtLG3MUY4OlyPB54jvdd3hlmoOy1ThLQhm1QpbnViYIASFi1FtJco8EsS9HPbwhxNc3YiR+Cj3xQzaAJulWb3WJzZCr1BYql9MuiWKfi3aFN2rYw/zOLc+LoqCNIM7kOUpfLhJspK1rN+DONkgpjsdZhiKjhxX+f/DIe6xaLWsGY+ZxVbicNeRd1PmBg5FHy7zLDjS4eY3myPEubUQhVYSZDwPTsBv6fPioFwTQDcvLgcO2TiqfGgRz8h2D6HNQMhbZPD5hCiNRoqkgULpmlTRswXm8KbLQZBO43YdmXndXzrqoDsjeczcqRawi1ifVgPl1XBJ65sLog5cZybFx9E1noeNJ61yp9AfZox0MSWhA9n4INR+C0mnZmI1z+eZOS5InK1LIbtFiHDnTKdQfhLYAV/GJeD4cVAcM5b6IGjQjumNbno6FBd3FtmWuV1Y2Buv14WbUmwhbEHGt+drWRsz6nKJguShaMYM5Zld2834Hp4ZWY3j3SX/szRvbKfwjeubMQGX43xAwq6JX0oc5GjHxe0NF2K1hJb5thXN6v3fPJ8j1Ty3DKF+Pg95vBwcAtES10BWcd6M3MUkvMfqkr6de+DjJRciyDuEovKVu7vqIkfyyUmoEmlzPU9lf7vNXZzze0iuqnLfjQSPwri85+Tk6dC526/a3Wmm1O/Qs50+Wma6IAcp7vNpjHby7L/QaMbwq5Z7RliObKfjSdS6KzngdR6U8GYe8UUJkPSsZZ22UEst42C7xqxHHowMBasl2znqiyJr18PLxeUI/EMwkqaMeBErxl/97pdvxYKEDDtKoTwJg2y7DDouWGdaE/OdO3ighBA7zQVK/zjEMcJ2lDtcjIMy8vTxuO3n6YLHRnhRhDj3oPCE/OlA+p/jqUBouv//MEYU90d+/jMPF2cqyjcQ+qBydAGADkgQ9BcU72IOw4I34mIQgLYQLTFZDdWAD5gn3fcWKHcQ50Ab9jASC+g4WwcO7LeCRcQUafaBcRGCWhJCKTR+O8Uy+LCD97CA+pAPPug4XtcZC5FfMniEZDGCa9dv+oFY9fBSXLODFKMhBNFxSMh8Y3Fk5lBC+RVNeHcfKNUZTeFOzXSFbuGCs2VGdrITMuJKYCgUG/J18dQpP0JfPGKG6sVzEUIO6KAUwOWBpkMXssROmwIPY4eHU3N6BsEkHQYOFP8YaRsiXD7IEFJYD/RgiLqFiKw2YIVhD20GDjjiFkClEMOVgu3XUOz0JZoIF/IXF1aFFILBDwnjihrSgDs4WZP4UJa4ig1TVa9oSqHBSKGIFFblUGJITbeIZrfHi0oER3gHjMehe0QxikPhgUahiMxoFOV2EDuiI844OQOBEdJoEJIEDvQQD9Q4igoFUceYjb0BeUqxRANBjebBFf3ASEgBR0JhD0+oQLeYjDWBje64G/HwDvIoFHyxEf1wD0/HjTlSjuWojJXmgws4kNuxjdhSE2N3iElifP2AD1ZoNRFZE7jYgqVxQfDXUBZpGRg5EOvADlFnFDuoch7ZD/oAckD/cZD8dxD4YGmkYXwruRsmNo4wGZO3J4YVGRKkoQ/TZJQEgSsGOZI7SE3C1TItaHyWFZRuIZBVuA7q4JQ5SQ+yNJOA5jj6gA8jeRBp+YQxCIWmyBdaGWlwYYhFOV1BgY7rOJMDMRoLiJbDeCsGSZJTWRB1EZcsyZUa6ZVfqQ7bZhDsAJV52ZMm2Zfw8JcaOZLrKGnwaJhzgZgFMYo88g5F+ZV9yGy4skSRWZZ9WQ/xEIqMORCPGHVwhI7zaI5AwX4pyZlwqBlLJJqj+ZoDsZhQiY5PyH4suHj4UA/y4GxAoQ44AkdvqBTQxowxqDi80ZuiuZiM2YfaeZpi2ZOrc5b2/3COROGcUSlJ9CgUWQkXLWlvU/mPaXZmvKkjv6mdwkmc4FkaZ6mcFmKXNfGVp/mZKEUQuKkaiMKSiAefWYKdj2mf3blExdl+9jBHr7ltjRmcz3mQQJWeBlGTaKgU7clz1SkhkVSQ9OmgAGqQERoUX1kQpVmaAxGVBAFP09STd3N9cRGiAzaiE3IfcHSiDsoO8bCilxGRWhcUPmhsSaGjulkThMigDmqQ9ACeNVGQj2mZMgkge4lmANmkC9qbRQmTj4mOVFqlV4qlMFoTJpYRFuilhLld9HGOVnqmQjqlxkkQNjkQrXmmAmGfYoeBB5GUCkGFbgqnccqgV0qmLYin+//wEPLgmziCoi0amO/Eo0n5Vm66jbuoFO9EjFX1o95op+3XD/tgafTJpw5am1O6gl6ngIt3WJ6ppkwKoiFqjdZ0VUnRW78IFGL5mbOJmvmJp6QKaHNKp1jaEJA3hOkzmNsVq2Z4eOa4qwehq0Thhb44mxG6dcYHaJF0qhwpdvGwpgOTnPVkq01qS06YWAoVJtMaJtJKj/Ckjr6Yl4uKLBlhaSX6rTGKjvZQdvDHjwqSWNDaNvIJF7fYnujqhAaxrmVIELoar/O4oREbr/NaVdkqrHlaEBE5pA3xoWhGS2IZh4LorA5ojQrbSr2VsgdBsek4oxXbGXeKKNvaRFN6EG3/yqV1AZ+ziocemK4fl7JAq6oU66QVy5YraHylyqP9ODa2V6q56KpJ6nUbKKgr2bNYxZUSW7EburW86oQzqa3bWp0w26HWA2gUqYJ8SZEpSLL/V02456zP6IvRKrcr67Vfi7FJi2aQlyg1gaOlIUirc7M8u40766lyy6GIa7dlKrNs2hQw67EHAZRaeqO3h1jbZ65UqRkVW5vTqLj+irTg8FIx26EEAbYemSSVi3sAqB+ZQbfR6qnQFE08GHeSK7gAoiSlujpYKU5J4bNti7mWUozSdIubSbpAcbqT6JF9sZXpyrbkVrhJwaFHkZnRJIY26hY1mSheV5bKixxx4bxt/yG9vgG98+GLiGW9o5sUo0GqpAoRx4ibWMm0kEgh4ssb5Msd5lu9SJm+RfG3aFsaUugrjFt766lqE/KM1cq297sd+TtLxFuvx5ubLJi7fBm6ibMPu8u7zlW/29fAcUiWp3i8fzuROGtLCbkVTDJgHLx7RVu9D1wRk8u4IYGBans6SIksy0sQncJK8Lqyeae11PvBknmK2Ut2lva0LHiLPUgsKMwknbLCWSKvLju30spzQGyxDiyZ/NtFW1e8QeG0alsagaFiJbO1rmtV8/rDVxyyY6nFR8u3Z3i7pJq7KYmT17K5r+uyVZxeaxzEZBmziYK7RnG2kIt8cgG+0ZvGtv/5mQgcxXDBsFc8vFpsvOqrghI8vfWLyJhMt/DayDOijkZBsQ/rwfsLeZDbt0qJwSlZwNPZWXiMJ3ssFED7U0GcxUjMG4ZhNoj3yp9cVdFpELCEH7PswW0smUmxvRMsswWRNGJDOQWswor8yfexru3qhm+Yslisv3qJFAv4GSlYesfhQ5XjvbZXE9PsytHMyL0xr9PMTnr6q+7ax9nMltvMzUG4vkBROVfBt5Jrb/IatwsLxdGLIb9a0AZ90HiptS5MlkrxOGwKf+cRwyqsFCzryfuoowxbogi90QbdzqT8wJjRzOehJIIMzVIcy0AMFOVWsDMaJhz90gVNy/MM0nz/E87hXBUaQRX9vJd446i9KM8onc5mlh+sy6tk6KMwndSb0sLFTLVJEdFyXJPiYpZtc8W2KdBb+VCoeNQardQcLdPUi75vAdUHKsf/S9VTc7hpDLG8IbBe2FteDdNgzcadURD8Ozlb0UU7LbP/S5Hf9tNoHM1YXa3zFJCDeNSbEtcvPdfVC6jgWNYDLNVGTLU8ait2TMUKfbJFobpCVbEurdgJxU4KldC1bEuVHRR77aGXzHWX3ce+u9lufdi++NlefdRrLE2Yu8Wke7q4i7bF+48DBku/6NoKO7BChamxa4nsTNswDdRsPEsM0ZG87ZEWaJIhXBBdOlsOlseY/dzN/4vc8XS14S3bvgy0HO3c3l1NzLrP1G2vbHqKpnjKTTGiC3xu0Tnc8/rdrz3e4A1Nno3NHp3Rc53ZA4qkj3OSkr2X7w15JsnTFVwUp81M8ZzfPiuwCWy5QYHeGi6W6/jc/selhPy3HuqCxOLU3+zbXqzJlhHMEx7LQdFnzZvAGw7U3w0UyBriW6eCZZeULbF4D/G0uXvL9GSJkVjfmcHioe3iqsaP+m3cyS3PTkjhV8vZQaHF92yWaE2gx+mDVg613RyfTO7dKu4W1zzhl3FHIxvjCPHkUt7kFS6QFYnjauvUWv7Ak8h4wN2sVD4jSN5OSo4UvVLjLy5NYu7mb+XkRv9MoC2YlHMOj/9IkVoFkNX5dSxtFPoIF2A4ypnRhAJp6IKeUoYXF0Go5UihxV6XZqjONa8aupQeL6M45kux57vp6Z8eiTauFHRO2JR46hJZaTxc4EI2sr0Lq7R+6Cru1xE+saP4j/zIpYFq15YRkpexZUIJvLpe7MWN6MIVuhB+loC23hm+jtjdgPWU5317ykehipixUPqXowvsUNj+3UbOk/CZ3ditzgFZ7waRPKs+l3e47tSuGe8O6vFO7KUumNsO3OCeucrOk93M6pIYd8me7h2n7jI3SRRi7Zt93NguVJfR7MIl6dPr8KWKOpPcG//+JdJ+2dxR6aoW7xCl7ST/adgC25KSlp74wJf87rQLLxcpDw7/fvERlRkwf9xHUdmyve7ymPNJO99M36jWOO8FkfIW77AzovFtUfSwasBGva5sbPRH8Y19WYkwu5r5MfFFQfVBjydYn/UFn9xH0V1p9qTvhFgWLRRyykTv6cIbWE1SbxBqL+1XP+ZFj+GXIad1T+h/vrI6Od6CaG7LxxkEb+yc7eZTiHlUKOtJEYPKDVxJn8jUaK2FrZIMtHwYTt6FTvnNGzf6pfkHz4/MyuyEfu+3965XPaMd6H6nj/owf76oxd+jP+i7yep0Tq7YHcBrDuwC+pmwXjKHZ60WG7C9z/q6yF1smxAzea99WeW3/wittp6TKl3Xuxfz5K/cvij9MJ+zTUh4jeysKTis9t6BlA6tU7mN38il5r4bL9eQbX1YAAFO4MB6BekdRHhw3sKCDR0+dGgP30R89uwVHAiuYUJ6Ag+CQ5gRpEiS4PDpQ4mSIsF6GltCxCixYsl4NTt2HEhxokV7JX3+BCrQnTt5QY0GxfiT41J6DGE+rSfx3j2KFkUa5Djw5sesHnF+bGlSZ1WBYcOChChQos+a8UqeFAvO6lG6PocWrZu3rFKmS51u5FiPXkGLE1FS3XkVJFfGi5e2zRgvodmoFpNqvZlxcNKeQHGKrNpZ72jSo89q7pt6surBhe+lRExS8EF58WPkyfuauuZIzCHLOvzs2aHG0iJFF0eenGBJ1s1ZV8b3WmVi1Lfbut3KmmTC3rwFQnar2eXlkqcVK0ef/iVz5+2XQpeubyd5etavO27O/jN3cG3f1XznP8ySMu+38eTiibyMAgIAIfkEBQoA4AAsAAAAANwAqwAACP8AwQmEJ6/gvIP2Eiq0d69hw3wQI0YUSJGiRIgPL06syLGjv48gP/bjN5Jkv5D+/qH0xy/fvXbpzpEjV26cuI44c+rcWTGcz3ACf/oE9zOoUKHgxCldKpBpUp3jokqdOpUjPHcGESbEp9ChQ40QOd4T6NUrWI0V9/Fby89jSHBs4/JbqTIlS34vYcqkafMmz7+AexYlCpTi4KNDky5dzNhpR6qQq1K8mrXeQntcGX51ubli2c9lz17cR1ru2pE615aei/Kfa9csXc7Ty9dm4Ns7jxoVPBQoUqKKgzdl/PQxVXBRkUtFPhmrPK2XE4J22HG69XuiR5tm26/i2ooQ1bL/Bvn6dex7s9PNjOoYt3vCg3H2LmwU6OLiShW3pzhOeXLIAo3DzjrvEJTVPNF1BRpO1zWYXXjibXfaWhKBEx5b5JVnXkv20FZTX++FyBF9ghHWE3D55adfYzlF5uI661yF1UEIQXfZZwxel6CDokmoWoURiXfSRxpumE+HMZHDnl8iNtlRYryRmCKLKhp3XGQwynggjQhGh2OO0yWo4HVnkRbhjxjlI5BEp2Wo4Ud4ISnTkk7WCR+UhgW14p7EMcmRZP5FRaCWBW1po3RegQmaQlweiuh02ZkpUVngYJcPhm6Wd156c/ppp3u6PWmip8E1VmVF/S0X6DiDuuNqoYU2/9rlQtRVh9GiCck6q5iPmiWadRZeSFKmG3LYTqefiqgbib75dKpwppKKan8BIteqq9jCKis4tDbE4K246ioro1426JVmlAbJHbGwsfSSerYle1tRvgE3Yr0VOXYTiztBdq07Mr5aEDjzdGQPT5SGK+7CNF6GT0P4RJxZgl16m5aQRBbpWkvzwBuvvPMCR2J9iXk6JXE8UYscPCy3jO2rTprrkD0M19wor7mK+6iaq52ksUr95NNxp/veV+fIJkJZGLN4nhqtcFDzN1XLLmObrLc60kxjO1zPUyhWXIdt89gN7yyQWj7/7C5MtZFzDrIgJ43Yk/TaBy1T0T47LdUsv//83sGKWsfobGG/bLg7XBtK9rjdYifQkGq3RNs56XANr7RH1z1yYrqpyGSKKxrdIt+k5xTrQQRze3BCYsl8T66FuxpwOlm+DOvtz+F++s1bPbSPQClFLjRMXadHDuZ2zodnqEMpFY5TeeOt90CkU82Rq+DszmV0nrn++kHtyOMqjDCmYz7tMBqu+/raz2OZghCRJJDw6CE62/FN4ltis5zfOV9Tz+NI9FDWkepZjyKH01bZLkOWSiUqWJM6F/jcsY50oONt50CHBtVBvhgFTGDqWx+N6kFC6eRDPP4Ah9piwxn0qAd5+esfvfy3NAGCrmgDbI8BW3Y922lvRzgaS7D/LBXBhmiNgjE5hzmW+LYNDihLH/xaAm/HO0sNS4Uag1NE0NMO/IGMaUtTntJGlsMcWsWAFfmgc7b0vsYlSogbgeCkXEIzd6TDHOXIYx6ZqEF0qAN9MXLOy6q2xh8yJH4fwWKR4LQPOnYRhu/ZHGImiTSK9GmAT+HXZA64yUIqsGDleqBFOhJHcJCGju5ABx71qEcmZhAdtKOM7K5CSIEZSjMnZM38FnmeDnlRJ5U0DNPgQ0NKiip0ZTzZfgRSIHic0ZOGXB26asUTNXXkd0fSyzlYyUo+wjJgpJvi7tB1qSFV5E3n6aLK/oI0MfIvSsa0V05wGD1kduQdA3mmCEd4/yNRVtM7HNkHeuy4Sm62MoOBZJkHa5mtceJSlxwxD0sE2jFy5CRU8twNMTdKMvpgdJ6a7FPoABNOW2qvjZjx51+sCZe0ZHMd28zjVLoJyw6Sr6QmLRt20JZInGwKJuWgGyXDSFQ8jYiYStMTSKlkMkgW0IC4491WHkZNCFpoJ20hpT3kcUeZznSPfnwi+ZrJt4Y+Rys7XUsKAQOTpghzqPyLJ900eiKeVBKHliSgTnZIGd0d5H2qUylLK5QWCZFlHqnEI1VauUF1sEOsC1Xj6UyYS3O6BS/GAxFcOQfXi7YTMGHUST15wte+sW9X/5SjKc20mtP047XdqdQ81oEOr/9GhbF9dKxYqebDsyIqfhDliEiGdznGDPWtk/RsXOnTH08d15KZHA5uSts3aPp2IYCRCGtbaxLYooZb8oDph25bDle+Eh27lWxWegfcnl72XUoylbP6Vx8aAlNk+C2OfD7aEdHt1ZngoG7L/OoowO1Eu2aKi3cX/DvEdpW85TUHBp0IRZOetWJWzGpOtNihOfWlMfTdLDuNatfD8ESvmxQwb0/7V2kyJLuslcuCvZvV2ca0mxKeMHpb1T745XInIMFskqSymN8UNbnInWtg5HriALMsxSo27T7/ilJ85GQ0CVbwgkHy2rYgSZVLDPPbcqxBdhTIOQs021+CTNzafNj/ectDslBNVF92djSYec1PlEubvSm3GLs4QXCWXetdLvujH78jmB37iEElkpmDBnKfQgRi5ffACbNsU9KbxbHZud2rnb0RZp5KxFHRKmXPO4xHQVQd1UaVUCGVBo+gz9Td165kJL+rYwUZLeYyvwMrrAPMsNxLES5zjDZL4nSn+UvXY9ZZkiRrspNRTTpW+5lLVQ50kLhL6JVwuZECQSzA1qEOVV4wg2Z2B4IEoo9268OU8DblukLyD+H+dMhLWfZvlLzfi9Y1Sjs5dfWgzLd4xKNlBtcdPRa+cFm9WjPaPuF2uTOkW8OWHwINt/jIdz52XKVgq92uWmI8bHrbuyVc//QYnPW97xARddSfPjEPA0zw6h2cZQnHHcMb7uo2UkrWEid5d73NZUQ3UojgqMdBCrKOGYFDH6XhdpZtjZLLugTZNmH5DJeMZCYfdSechPK0b0529u2cHg5Hafc4sm2hb9nbXd5Hu6mJukpJ3Ee0NonJK8Jhti1J3/7LDZ2VF21P1wnA1gOwQNi3Pnp88uHBrlQDLdL21haa6IdWjcixJiyTxGXiMgaJvf1B0WPFd+XHNbzgkXIYj8rZ2Tl5MvU4ibs+Nx5WaKcH5COvE40MeuhEnzFJMK5dvDdyIkF3LbHBocV3Ea3Td5IPMKFfzJZH/y/ONLj247F4eeCkULb3fv+hGH5hlBq4mrMmdMUrfugZ41romj/lRdYEodPwHXixQRJf8g14Ujdb6/FUL173F+CnE7fTZwKxcz1nGarTO3+REb9Hce63YHinESp1VWqhE7FhPKcHgKoHT0Z2ZxjlTvHBE95XEeKnE44HfvJwdrtDQuYnHYCREUEHf1pmGl3GFvLHGZJnMTzRFitxbHuRdR6YXP1XfR5IESd4G2dHDxWxcN2XPeDghFOIdiMEg4AFaw9IETQ4ayIncqZxfDyYE4B2D+32O3qXQuk0ZERYhKy3XB01eG5IYhxRgFLYEVBYhXkYfu1zheanOjqRGZLnQA8CIV8oF2Logx2BbZYRMe7/tg9UBzzHFhM1gXpuGHj+BoKvh4kGyII54YRU2IknKC5YuCMcEWyARhabUYg1iHHyV1UU4TW3s3Al9DBQN2zM5y5D04FzODd4tl/U91aBEYpPyHD1cHZ/UTOQ14CwFjE4Q2neQ0SstUVIp4Ti13i654hQx35r83y92HLW129HWCe0iIUUQUI8oStYuIzR4Yw4czARUxZUBRqjQY3nBys3h3Pb14KN2G4lBycV1Rff2CwxJGJ09h4Ml4DryBHoyBP1IBDrCIPvOJGTBg5UNTHT9BkW+DrWCDAs8w4gGZIhaXC6hxm3yI38cCwCOYfXJ32g8oF1spAi8pAQGZESSZH2//A+f1gpGNlPvmKP1viR7/BYREmUI7lwJgmJ3JgP6bCSAHhnn3JkoRU3TZKTNGmTSrd7OKmFAoGTXQgxBiYP8ACS7KBbZXmWRkmSSUl1IjEPSnKJcvOLkWRfcpksgPUXrJMQWHmTW8k9zIgzm6EPRgQ4YvkO61CW6pCYiqmYj/UOBkdC+LCN7MeUbah190KVvJFRmBkieYmVadaXDPSXYuIVgvk6BjaWh5mYjbWYiWlm8YCUkamUITEP5aBslrmZsEeHuIkT58ebC6GTWgmagDYrBTaPpkmTATaUqrmarOmar7mWFUeZllmXu1mdeNmVvVkRCRKcwpkzBCNVPqmXaf+EmH1UnrmVmI4ZD/XgiEp5EvvQDrX5lNapVJc5n07SnTipdHVnkw4DlkpXEcqpmOZ5no71DiUZm553D+cwDvJpn/PkoPeJn++on3XXc+3IFQ05EENJngPqR4zpmP1IGiNxD015m3FDnRxxDnWyhJspoRMakSDHiHypEMdIhQcXoMs5oIrpmLAJdaRBovEJeCjqWSHiF+TQDtVognzIorvpotGBheISizqjl3locGSJmDlanq3Jo+vpo4J5OeMIoePgNkj6HRDqHjgzoxQJg+ICK9Z4YSM0Dwt3gla6oYtZnubQWGaWjV5qD+6wTbZpkPYpDlFxpPagFj1lcGeKnL7/ySvrSKN7iZVzynhLaBAHMjDgsH0h+Vg5mqce2pqvGZmIpg8dVomBGoybOQ7nwDX3wFNrxX1vWntMSpXmGKkRqZe2ioWTSqlr1H21l6maeqVlaZ7lBqr0IKqIBl9OiapUOabpcKhxwRHa56t2yIKUqjvhl5Dhlqu2iqu5uqv46JEGpKhK6JFOtn3xIJKcSqzGiqykV1Gm2n9DChiEuqrzcA/dhRPTeoAryq840YRW6IfcapMAezv5uGfUMxDoWqdkyZqLaaCiKhIkag6nZ4mb6HJ/sqqXwh0CoWEUQa6AcYKYyj5RyBNNqIzc+lcFi4/UJpTUs7DoiqOsaaD2oA8V/5eSRHOqF+skzjoPGxuGp9RIpOEeInuNJGuyCXh2KJurKtuEBtuyIelM+giz2iezO0oPNWtO/kCivEhJy/QehEoOlbNTOwgu4NIQIEu010oR2kqMOCGLpMi0TeuCLCtgIimSCEe1McupH4q1NptILOEO+8d/z4NiYCu2SHpCEtdCnyGYmXEQ0/oeBTiruAewbstwcKuOkdoolvu0dnu3IJm3equpfFugumezscV89rBNUzFa+oEbYmsPimsmIXd8pFGa7TYxjEqAdXit42e5lrs47rOOrua0Bqt9BgS6UUs1oxuzG5qW9fC3aaEe45VshvsXqpoO6ka2LKUTpJpSEv/DFYExMLNIt9gIvCcrvAxTozuHO3rbMsobuszbvMFalCBqs8I1DzJhW5vmVBShJOWwqkR0QhXxbj44tF25bpSGD7vbEdZaviv7u9+qgOq7MOxLfsdLtUKpvAU3uulZtVf6mO82PxaRJG5mvW7VLzHxrI07wg7UEC4sRFwhpwVDQpiqhNTKeMWIvjwMoxUctxdcECu4avSbrhw8tfT7wVb6nCMcPB1reidsXH8hDuTgKl2iu414kVTVbhYpTUo3qbIniuvDEeh7weW4lz8ssLqKwUMsD0VsxKArulSrxDDrt+AAOfXWDyQaU1RRZP1COe1AI8a4ggl3rJlBvDV5jKv/NnNiXHtta7kDm7KaO8Hk18ZvDLpvvMSje6x3nDauYSF/GsVFhmerWigLe7ePCYNuzDJfAyszh0+duKR2uMNNGMlYyZBXObCdS8RJjMqZfMro+pB/GzyfnA+mV72mghNU3HQbLKxmdpRrLMTixzfM9A5r+6ufCMkLyK06Ycu77MZFjMnBKs70q3tPh8fFfMx9bLjlxQ7gsKlFGc8j+ZpJl6EV0cAwgoLYSq1/AbC23MC4XM+RHMGX7MsgTM7Na87DrCnGvL+tm8xN4TZmGc8U3ZjpuYTvE4+5GzGM6s7fN7lu2s9nF8mAwagDbby87MEG/ct17IQRS8wqAQ5sg8wQ/11e6QAOE13R8pyefUaFEmOGcue4DzmrvfvARI2HI90oM/nPa2y+BS2SzgvVcLzJlLbQ5iE01EtkTwMO5uCwOs2pFk3HtIgZC7zRWGjUlarDTIiM7xGREPmkkorB+Ni88VvXIPnGFBGZrKEp+2APD6bVjUEtn7qYX22Ud619xlhCDemtCaHDar2o5oidvxnX4GrKKm3XyovXSafXGQMbv3PMNL0U41BeGeSwjtWaWAoOhn3Y+1jJDXmTjv2rR73W2lrSkb2dlC3XKQ2zmJ3ZeM2ne70hzjcT/DtTnqqYON2cya0Oqr3ajqnELbhzu9vY+yzLKkjGbM22PbyXE7mX7f/rvpfd2yPJ2no7hV0KiTBNegMVExRb3KPtTcxJEcyN3BQt1cSYk40c0tWNh9i9c/0NybmappS9PnQt3lBNxzCrkLGJx3CScuazF+O1R2L2Nsu9mAJB3/YLyzgRMRzhbg1BsvvN37QN4Nzqrd/KeAVu4FKdrsDMfXyK3sFzaBRlRw++v6ykYzrGnMzd3AJhvwIBqznxbj7KWr4b4tlc29rNw7rH1ANO4L2s4uKtqC9ecUBzJHbUaEpEE+VADjl2XlhenhXO3DvNo7Rozh3ho7BV5Don0v5Ny0qe2EzOvuwT3lBu4LB63v/IMUnUaBRLE0t0bozWaB3qRGP+miRU5pD/GY8UoZRj/Ngm2+Zu/ua1rMty7uRzXOdQrqjr2aowrkW72OV9LmEahOOCPuhhleFcmnRJN9bxCNSJpuaz/ITazeaSDrwnvbIJd+m9Xdhhjcmb3appOBJYneUzsURcjuV8juUC0aGoHdYkCZHSndGu3g+wvoTEuIfDWOu/G+1mXOuTmutRbde87ty+bhlAXWsUlUQzUexdnkEYFGYSFmam/qm9TpJ0e6ANIaLVDsHYnrTAq4cRfK3eTtC6rrzjrtOZDZGxiTa4hh60Rexc3uWMpkE41u5f7qGN+cwfHN2OV5Ku/rE5V+1N+N8A6+8o7bsDb+nj7MwHX9gJv9lnyFrf/3Pljjbhr9RoBgXv8N5EeursIQ+FZN0RIS/y2W3yJQ/w5rvvHF/Zc37Q6tryB+/bvz7kcvc6MHFub+M25xbv8G5QXk/a52WW8wyy2fh0Qm9t1c6H/Y70cv3NSq/0Ts/yUO/yBg2N7jZ3uobs5yXqXR9hXy/hYb/akZuANZto0or2sC7LTPrNbq87iP/2cw3Hcj/3X1330CiPB7Fo58Wcga7zS/T3nkroGj/4Zc8RRgf5Ruuvkd7TAe/42of6uw3PlD/uK5624fswM7xxHBFWE52lfUQReFRQXK2lYu+YDBmZF+NulGp7b4rDsZqCH125TG/Z24dzKI72KT77vF77QP++wLdPM4WiUDDi0TYVz8jNEZ+/ROCgRMSv8TxtkVC36EF9DxEzxs0ffs6fwzdc1NvuuwARTyA8ePHkHTxoUJ5AhggZPnz4TiI7ihUtXsR4UaJEiPTAfQSJT+RIe/bqyXOXUiVBgiDhvVuXkZ06kDXBmQOJTqdOdeoqcoxn8+O+ffru4TN5EiG4gzabIoT6UZ5QpkupVkVID+pWrgwJKnSY8KFDiBA3ysy4Ue3ajQ+pjsR3tGQ9reAIuttKT+/HeBMp+qRIFR04nTnNmUPXEzBHjyCJFtUnMqlHq1NBWsYalSnVrVKjcgUdmqzohQ3FlhWoFi1Fv2zXov5YryZckib/G3/ES6/ebt6yF76r2LPiVcI7jStmt1EevqGQ9en7aNsq1ss1QUvl3Fk7ae7dT0NFzdD1+Nd92Za9Cvfe+qNUdffuDY5e6pnCAxOvuRP5O4GywRE1qj2Q6GoKv8swc+qqqbxjsMGHChIIvPDMI8+1Cd0ibqTnIoOrJt7skaykpOSbr6/6LDLQpsWigw7Ae0piLsXqEswuNM8axDG0eCA0basLKWwLSP5+FAg/DTcciSoQaUtKNr3os+++/K6iCZx3wIFOKKR4A8ceGRGsijjR8MuxTLCg0go0IteEyEi4NjQqRnDkDIlJLp80Ebn6QKrSOMII8+lKffa5SjoZDz0w/8zO3MvsukbR1CvHSHVkk003RYKTQ5tKig5GkXbTyyM8gbtIsY96Mu4c/ULap5//hsoSHKUKFBPRRjO7DaTG0pQ01Ekb/DVUsipFLVT86nnzHjhFCqlOD+kylkTxSLWoJ3BQRQexnT7CZ1BCAQTJKJDsmWfB7JzC7LSyntKsJl+5+8hXeXN9NC8S5xXWRyJ3FZVeLY/MtEOb6LwKT/MyUgxbnmTVpx9X/ysKS5CUFddWvljCOGOWHj0QzFuvw1eo0PAlueSSLa4T04Bp21RWoYKKt8SzEE6YJpqWa/XhobCMleIN73EWvx01JrogrjoW+bO8SE46q35NPtlkW/3jFv/g546Cy8tN6XTLLGpXu6+eQXd2TChvH3NuQ/yKLvrMAqfrmLR5xdSsZFCj1RVqm/a6Cj5kNfQZ6yTf4gsc8byOCezkuI2VbPz6QTtyQoljm+gb2aU17qUQmmce3vBuukBfO+9c1rvlvTdkofx99kPaAs+aatanDVI1jYbk76PnakKbd4cdzvl34X9fu3IeYc68Xc25Iv1zX9HFSlTZuIzt896gzpVqRJdUT3DJtJ/PpoiAa8t2i3IPd3LeiQp3qOHfHx4eqjL+yHJ0N4f7cnn0nn51XQ+il9/gIy+/mU57KKNNAuFywAghaFo/Acr4igSOexBFZ/jhUOPA4SqH1YT/ePUrmks0dj/8scs6+1MdiUy3QnfxLV6tEyC0nka93aBsYApkWd4mZLjxsWZIDHmPf4jCD/yoD0tIwRT7iNNBmxiPfidUmgn3AkDsFeyFqTugAf2mF/9wkYY1tJjAUja4mkzII14j3w/lUQ977C54xHFOTSIjorhYEFFOxJj+lmeZ6ezleR6ylRe1F8MYwtBlKXIdDpnFLPdEZIJlUQsQkaVBOGbKJkdx3dgOhceNQc9G1ImZCm0ISBZOj5AFrB71ZLQb7omRYP7joXlgdiEudutQkGHPelqkuxd9qII20Vkn7cJJ+ZHQUasD3SgPCcNTxkeLYFylpxRpIFEdboLy/4nHfEI1SU2mCEnd091H5MKbbu2DiELJ4whrQrQGXk6Z79RiKpsJn1JCEz+txOEyhTYthuSNdSlKW4iWBDSeZQkpdPQWE0G4sSeKMGMRgiI8JTogMM6zhlzKYqEUmTWh8WV8QMnV2S5YyQDhUFm6U1uIVJYzhxazoQvNo0EiOlGaUvSU+sSpRhX4HJIYCI0RhFm3BiW8jzzsW2i7mvdIMhKCwkmcR1lPXIYqQnS2pIks2RFEkTajmipznjmVEQ6/iRTi/LSfdUroB5sjuaslSTLRYWT6HrPWDbVqfi3tJMayGrrMdXWUFr2oKomDT5XxlKxX+WiQqvYcySmxsXBS6v9s4ro+4j2MH2h7mDBhWrlrQnFRfvXqTeU5WAX6DEn7/GhQGdtYJb4KQJDFmg2H5w9/gESt6SQmhGp0NNAiCprNlGdGq5bATPFUa+ILCmy6pCzWznVnr02qgIhDSdv2g7bXpe1HauuSdea2s5jjbW8ReUDAClayImFPcQcVmTLGcpZnndPZmutY6P4stogaKXave9fNVs4ufDEhacS7Sqr5B7gpepN6l3Xc8PBQVkmcr3PlCB2nUrAmx3XM8Iiz3+Lh0S7JDTB4NzNgA5m3oqhEcGEV/FaPNriNq41wayU2Y4u9b7sy+p1LPVxMEC9oUfkjcd+y+Ft6pljF6j0sSNr/FFTmxrh34aqwrYh3Yw9e8GH94IfDclvMYR7Tr38Ur3kNpJ6rLWtLVIFZSGDsZBmrbXdd5aDwLou2LS/UM0HGcyptleA4xU4ogywsmyWMUoCyT6FL7ODvmrvlJ/Y1z70V85jRa9ieUqWiAINucxlrkygL5TFEvQqW+ZHlDUKusRBjNJcfveoiH4qpHPpUbP7F59Vm6rEadCp1/zNbKq+vtaeG2D4sZ7xVF/uZriYzh0AlynhpSKgKhlPk3jxhXXvQ2kIxNWtfBWWjPJGYPgaysd/Z6nvu9FN0CaWuJg1tBacNgyirrKnr+pg3l3RwVsW38dwGbnFLNNJaIuxIlu2e/7+xG7ZSfS3jlJnobNN7xQoU0TBdilerDnPffOy3V8H6lo3ahnW6OTK7F0mx2dAYv4q+dYByySQRjegq3n6ogDMu3hht9FP/BLnBV3bQyU6WKocuqrSjbV+lCnQuwm1pd7FaL0fPHJFhtbnAiVNwkY9VYGQM9QclXN9cU3jltRGRPeenajQbs6v/rCnSx4heiP/zbyreKazFiONSQ2zTdre3VI3Ucoq+/I4FUTJYahreYsNIlz/z897e/uyNUhrrujMiBqE6NsgoUNI2cZJ8Jgqzr3RWmZ/s6r+7ZPjikgTd7tpN1G2OKPZFjH19NrNYx+suj9lwaBb3/Cgr0/QBe/+Jjk2u/PcsHXDVv9Kb0H71Rs1G0HEJtvY2fGjubbj754vX90uCcZ/n8ufFF9/4kl0Sp4uruwTOaYw1ISjWwRemd+aV7PCkfr/toUtpf2/I3q+0TWPIyGWdFjrlHxieGi4Y4ZZnsQ6L0TFhqjhxQ516mAeLQbomQ7k5yqjuS6DwM755whQKsjy3apIbYg77c6apAyOJGLt1+i+JG6Ygc5oqUrs/M5DVEp6iSDLDWbsLJMHGMDD44J6iu7rJ2CZyWiR7IKCWmTsruRKQSMIFVDWGIrs0myhIwR7d6CrGyjJFm6PAu0GfY6bT20Fpcjbla5JQEYhtCjsCQSEqPC+muof/8fiId2BCpVtB8QKNP8IX2XhAcMjDUWqyKwQe9pIKmVrD76MnsWuWOfG+6KgegxGkz6EiQ+QWn2GLmliL+pHDBfSrOnShO9TDj9jDUfIWP4QcQHSwqbkejxi4Sxkc0xM7GSpD7FE7OFmHWaTFmlgH13A6z8AbTiQdz+G+ETSbUJxBUvQ8QjSleRG9cQm/AsS8QdK8qNk485sYkaDFagQHWsRF7vI7W4kiBYki0UmdbWpGYOS0IRJFGryzQ5GhXEG7X0SW2MAwasIXKES6ePyIasTHatyIWUTBbUSUbtwtkDmZLhSuPjxHffAS3rO007Ghu8Eo/OAbe/KVMpQjbuEU/2lExJLIx43Ex37kr3/UjKbjDr2JF0KiitUaNT/cB4JSyF9MJpdRu3UUJOLIFZPwpzbBksi7oaSwRo7sSG38SDK5DPgSSfBqQaa5l0K6JJQcNYe5LJaEQBlqSDREIerxI125sJhpDFmKB9n4P1nzkt0BlXroSZ/8yfcDSroZymsqStHQG19RSvTTh3wwxyt8yql8SczTktjAk/0Ru2zCSkahHcBURNPhHlm7RrO0xVoEoc2LB5XACx9LGqZLQ6iBxEtSFro0p6b8Q3tEJNSxtPTQoTKEphJBlFFhjBNDscQ0y3VgTde8xqCUEYyBTHeoDnuhTCqywyB8QQqay8fgTP+nXEkInEj40ssUcaG9sRiZ4Q9jYRqt8Ih8FArYTEzKkR+0FBmJg4faNCbKGMloucPefA7N3MzhGc6pIUMM4b6+AZGpS07kbLGO4Irb0A3ptAl+rE7KQZke6avt+E6+CU9vygfyDE7gYb5DKU7jNECYHBeV+b4AWr9FjM8JwYwass+rYEzZlBGBiMz88U+5AVC4TMZwIc/ynMEDlZEEpcgB0TO8gTC565IrkrXTG8cz8pqxSDfWzM9Rws596tD+/Ea3DFHe7M3MBM4CvcvT1KayuI2xRMpyGkW3ypu+e88pbbFIIsxlsocLjU2qMEHr/AoDcbQxXZqBzJt6HL2JGc//uhTFJD2WmEnDbAIzfknP22AOS0Imf9K8FEkNtbBBodDIn9xRkKDOl3spbgSTkUkT0Oy7waKjuDg8zUxJ8zzPqfOnp6nS9HyIvehNZGpH5DIcPyUcsrTGe8RPQj1VA8HEzxuZo2zGe3rUXJpLSUXSiDlOT2XHTawi+YgPNhK7FMJKvOknIIFCzCvV15xO1yzUKHw+EAVPXbnMTonV9BrQupQzW13QjGLHdJvT50FG5wFQ9/K8ueksBeWiASlVxYRN12RCLgO8QzGX21TUOYVW4Wo5EAERWa3WzWxTokDRV1XOPc3T98RUkoGvPh2SvQGzwJylqgDNU23NVGWbObSY/7cRUkZtVCW5V/TSpQGt1km91lihUcREmXYskU01GNopDzlNHStS2Eh52IjFRopTpy+hlf9cWJDoHHttOUjtWI/l135VH6nMUZpyEjZhi+T4IT9Kzm3FVTSRWXxUCycCSWCZG6HY2ULpWX1Fm5T02jkjFHKBlv0J1ndKMzBC2kn0KKZtSGGxwajVx42g2qr1Doy1lWldD6AN2q+dM+ggl0mhz817GUhqMErkizodJWEpErjFRrklNrrF2So9lGmd1X3lW68Fl79d1KIdJXpsL/QoVvGxwZOVXGYT3XRj3FmEQ05C1Lp1zlGiXI+ly8vF3MnR3KbgFYk6K+3hSulrrwwWO1x6YdrkQo8ZCQgAIfkEBQoA4AAsAAAAANwAqwAACP8A3QkER7CgPHnzEiYsyLChw4cF79lTqNCexXsYM2rMx7Fjx338QnbcmA8kP4f/Uv7zlw9iOIgOxcmESbOmzZs4c0KEN5DhwYMU5+m0OTFhO4oWkybViNGjU45MM3IMya8fypX57BFMd46guHAva8oUN7Ss2bNlebprKNDdT4QVLaIlaHFeu7tHEyrdG5WkRr5Np4Z8uNIfv3t203kFKxYc2bmQI8+Fx7Og2rZugSLFyRFiUbx3487bq7TvXr2l730c7M8fw5SG891rV/Ar44djJeve3ZAcON81KQsX+BbuwpstC3ZkaBR0Xr1B45IuGjR1030g+/Vz/Xolv3y0wY3/c3y74WPe6Hn7JgfcIbx3wi8T/4laK/KnGAnexewudPT/AAJ4UWDYhcRdd9+lp+CCMLHXHkPrRBjhOxRShtlboylV01NO3QOOXQKlI2I66/TnX4AAnlifPVKVxM+BBcF2EkS5MWijguuAI6GEFqolT2bGyUUThyXtA5WH+4mIDjrp8DdfcVAe5Fx1A6oGEkTeydbQOOWMc96NYI4X2Y7rVDicW20ZN9p9RWKH3UgegtOOO+mgc46IO/Ik34VvCYSXmhkuVZJOXN1Jzpdg2igmZBHqWGZ8/IFDHEU2eeSmm1Tx82achS454og87gkklP8JGuM/NuF1aKKJLjpXozq6/8cQcUNxVGCmuFJlJDidLnnOr0uiww47eaYZJYZIsUhQayk9FBs4ErXjW1isPhRWedU+BCtMlYEjT0HHPWSpSbmGpJ12IoFjp53nlFOOOcAGS+I6PBX35KiaXbSsP806ZNhJsx0K1rXUZqvoUNu6Z2FxFTnUma23lnsuuq31c487TJ5jjrscmwOvpxEC6aSx9K0JDkjMoupvbNLaBtZYMhVsMFrj1MyQzZLFVy+yH2bY0LiaRmzuua0VbRhi4LTLcccfM1niQSOTDJdyVfGrUkOtfdfywOHAPPDMktWMs6uTxUfQWt56+61Q4Nin3LiYZqqd0Ub3s89s5oi9tLsfk/+ImaRR/9RQdlarzFBs85wzzsBefw02ZDijBw9BlJ3dUMkQwS000XQXbXfiXerd8TlOdwtpQWg7jHLhhoPjTz+ypUOOlzDHjO3jZ5Gd80OTG8TwkIOTO3TnRR/mzsZic9mx0ztSblNTVbN+uGztcEX7WFzbiChvYoqtW+8Q8amZyTYJX9V2xL8OXjp5y6S8u6SrQyZRLFoZ/dUFHZ3YoS5nv2CNC0qe7hQ0spK5LU4QEd7c0ne0dqAjdDVbHjrUoQ5i5cghqMEHPgJjIOkt6zv7s93Ltseb2pFQN94zC/hu8pMCwsUi+KjJYM6XvsLAzh7uaFcEOUa6YE3wggipBwz/mbIa9KlEZa2h3jlmZ8LHOBE9JrxRCi8XJYIcJCctbAuk8qURmFBFO65jIOLYtzeP/aqH6LCiEAPjlFsZ8YhhBKHsaua+6+EuW8eihx6/hcUf8cdCQGIbtBDokMGAMYzMKtpK7DYbroBjdL8yx5LY4S0W6aNNQctk9FKGxJDMZokCBOAdE1Ucb+mxHqisBz1UecWaHIthQpLhSWaEyMJ57m7zwJg5knZGYKmjkvpQYD/OJzej4S82jdTY7K7HNZn970vOtFE81HaQVabymtekySuBUhqczAh9DLRbPnLZvMvZI5jnmxi6JMasfY1Rdl0Sof9GCY5o8iYeP7EmNpOC/02HbPOFSSEIIW3SOdh47jtMIY1q0jkxXRnpUoPJ377G2Q5QeqmZ9mRIRukJGXmcEpXT4adPXikdgebHYTAR4+vUuU6IqtOhT4EId1g2R9ph9HY2egljNkrKIKYypLGkJrKSZdKBPuVK+VNp+tbZ0KAZCU4/KxA4Xac1UMqzmQQhWEGoxVOY6DSrOAXbFa/4U3toUINBFaqArBOVNmKHIQvs3HbmxtKGPjUqBbFOSRZIEPDosH831WpYI5PRru6mlb6TR1nNio+AFoQeChlqoOTSF9moBmiz/OIwy4Uru1pWIg0R0D3QuR2C8KOiFw1swXZq2N20NjJvseK3YksQIf/C8Kxu61lQ1LSUvlSWQ5d66FODa5JzIRS0zElIlOhh1nsQzrSoBSxGt+o4jh72lfT4Fj0eYlvGnpUgKJqsb8d72c6Ao0PAJZeRTkqRPlEmHpQ5yBr1URWGVFRgqh3la+fyFj1CNiH+3S5NvPvdgtQjOns5K0Y2eA/cNrhKXSQvgULyJvAqt4WUoZCG3xEPa+IjmFYBB6rsMUfp7te6/I2SQurRswETuCH2SKV0lNLYszK4sSFlMF0Ac53gtmQiP8nwO4ZF5GFxWI9mBbFESzxdFOPRwAdOCDZZDJPmnnTHdaESXzaIY6BqqG16JW7b5nEQ+L5jHeygoJoryA4Od7j/Hh/eR4hdJ6nFNdnJM9Pjivc5YA1eOa8WibKWb9tlLzs2rxtxk0AnQg8zr0MdPlxzm+Px5g+XliCoOod08Qw2PfdsymY5aaADZOhSf3mQVhJoY+shD/iuw4dLkjSFKi1n7qykHamdJ6fTM7nKQUQo2SyLBiMCZupQBKSksTFaTZ3WQdblR++AdawlzY4Om1XOMUqaiXe9O97dKCkbBAdujb3iZCv7tsze4CUxkuUfPRrSS5IkrCvY4TjPWU52xiq307LCFWaruw1ZdXT26eeMLJvZVmZ3jFnd6iFTUNoem2C1mQvilc4j33fetwr9najcVjnQUx7igguN8PrhGJWQ/224w33osXdJ/B30sPfnMK5vjdPE17LiaLPlAvLujpufUw45UFWZXUpTaFhqRofHIl5BmCcZO/IoR35tHpze4fyOuZ1sDAmydTAv9jSCDtA1A71wohc9HkdHOqSXPkF1HBnO+rhH1E08WKqDQ2fxwacrEasgFh8b3AwZ9TywSZHs/lMzqBw8mYtDaaMf/eGRnjjc8SEP/AbW7rzDu1kEvKCBuy23YV/8K/+Irz4JBL6Nb7yG0wzvtrdZjx/Ghzssf1PMK0xnVqTm4/478FQ6RM8XhhJ88U784r839dMkyOPX7PZ4UPli5pCuy2x/e3+XMs+8j+x/MCj64hj/+8JBfv/yH6J2ClabxVaxh+KuWne7X/3qtNWJf2miR5pEB1DzqH9yu/8TSoO/+OI3fjCRZm1GEPpQWvLQPtuWLU00E0MhHM5zdULFdzARYPoHEfMHE4cnOKGVf4zXeMIBH98nfg5BggVBSeJ2gK0hKUy0aQwSRbVTGyfELb7Waxw3gROYgeBggb5XW1QGZQ8xWxvIR/tneGUGghkGfgHIEMjXaGj3Do+FD3KmEvnAZLq2Gw3oRDOoE5p3g0E4Vh5Vf6vEXT/oEGXoT6QSHWYIDkTXf6knZBsmguFnggTRhKoHhTAnhf2gEv4wD3mTa+0nFu6ThaLEIO8FDgJoE2HoX6DGhkH/94NnOBSDx1171GrIB4dxaCbwsISIKH5OaHT1NoVXkw7xVHOCCDNiIw7XAzO2Z4E7+FE96Ijd5XFogUpmWInih4mZWCEBmHyeGGCUBmf7wDr+IC2AaE+qmDxRNEoQaCMs5nuf54woh4uXmHq7CB+9OE2pZ4EBJoys8w/30D4Z5xjjQA6hw4p4tomJ6GQ2phOpFGBuCILWuIvZSGmd2GHdSHTeeET/wA+kGDO1UzMOYo5egmfUIoGcpmwKhldraHbx6H/zSI/Id4/3iI8fdUoVd0T+cA86NJAe2SUGaR5beBPN5mRRVomWmI3XWI/jR2n5aE0gxo//sA85FEns8Rvu/1KQHIWM5ZgTLEYaVPeORohPKimR2VgQFqlPMFlr/NgPiQMvDvIbdIRiBeM+5HAO7jBQDmFo1IeSLLmSvdiJj8WIKIdKzrUd/NiHS3RGBLlrI1SO6TAP+wCEZRiLtbUg/WQjKSmAd3iNbpZ6iMgQPHhNZ/mNaskepVhdO6mK5JAO7eBcDFGXj8iG1SJILESEkuGXs1aHGMiN1lSYaQk6C0hPYFGO5yCX1IcTUGIjFFKCD+GZwoiWGnkPsuORBSFAyhiDC9I1cPmYtJSaOKGDYOKLNcGIlmaYtDmQySMeuElHq+haYCUO5RCXyfGb9LSawFmH6/h7q3ScMpkP7YI9tf9XLbzZmFpZENZZLVVEgam5nb8Hd7J5RKdlhaboEFdYFl3DmI5JSHN5XgyRD/rwOGAIJcKZnRh4TvGpEgh1X8dYXZeXEzqlU6p4J49JkuAQd411ndXEeQZanOf0Iml5N+xWPVaFPWB1eYrpVfUUDuNwDhV6E/sQoBd6nh1qd6sEmnxIYr9iInaRNIvBfo7TWuXpojT6ENgRoLRYo3imYRARm6zTD7NnjuVwlSPCS1FJdycaTbwpnXFZpAkELV1XEGGanYSWpOgxLOBQZGqKptylh5wEpS2YjAJEEIhJEIsSpPVkn+HgGy6aE6PlEBkKhGgRYLhDYGY6FERmfmpKEGv/uqhNepxWYxgVVQ50xzUzoTzLZBOl2SSWaRNbF3cMMaaRQahgY2MlqRNDVn7U1qiN+qj0ZUSGISdzpFq1V47sMUVbJZ3moBg2waEYdCPsqRtHKByYeRb2WBBpl6jMx2asWmQ0AXe1Vjzz0CTWU6mXt0NTuaLlgDb5VxPjZ4s9FX+8gYnwUKxl4XjJ2qxq1qxsSn/QCk6f8ymzSqsPypw2s6tCxZkP4Z7Amq+SEyEWxGHFeoSUJq5M+ISpyq4E2K5p6qyd+VEylzUtkTjsYSg0R6/6Jp1doZ2Nd3f0VxNlt12o17FmYbD85WqsRy961xDDF35VVJGrp7BEVhZkKUQa/wRi56IlE8E+V2lVGBtYGtsQrYl2E8myEPGpGLpw8qAz+GSu2sSBkLFH74FmxAIfHvWK/Zd3yPeQ6CqzZwGL3qUPOGs3WpFLRkEnymRTP8s4D/IQGla0gfkQjFUQYrtq9cC0uaeaULt5KPkeGlaumDmsf0uUjUewEZmwrToUPBi2YusmjEQnIfIpIUKQ1opR5bCxNjFrLlmgW2kfwzaqhLqIZeF9eTeglqiL6li4e4l81/i1+XhWYhu7wXUx7iIiNrmrDNqgQHu55+qKghmZlIlF2qSDnKuIjPdefJe1qKuOrbS6YokWLVmzcHazjRtcYqsVpHi5kcRDtmuO4qla4/8gSWbReL76hTrhtGNVvKP7FgV7tSPVsn77tu3LR1d0rPxqE0mZjzarbsFEXHULOOwDL7+CmDVzJzipthglE+/SU3r7hcVxgcDaasanukTotDmxuZ4JtrDbvxMTo+zGK0xSKBqzNDLRmAWRmM3EJbtEEKRTEGrmumVoTSwEEctVvgpihCmpM9cXtRk8mPtLvdjRwRKxtLziMVwhIhvjLreqqxvbFd8rnQ0BLGUBhXFLE6LaR8sVrh9IwZLRw7AJUhvsuNoRo/bgQLuavfBiRjrEJVK6NFfpFWMxpff0iltpgNeVNmAyhBacE14Mi4+4wf0rZ4yUSw/0LuugOOGrNFz/QanJuDReUg6/wZx8YxNpxBC/BBEcZoZCFBHVixYPzCqH57qv6MWPmEo2Vr2CTMa61CXlgA7wIHXiAC+1G55jwcbxNB4DvMBlUcluu50gJW4x1L8lO1tWZMNavMfFKb1Tpk+PSGDVO8b7gA9CscZcsg7p8BW6yje0/DLKIza+watmwcv7Wr4yLG6jFUzrO1Y7eJnIfBbtXBOlHM9/fMocjB0Sscq13JjR1zXvQqlXSamWqopLs0uXXBBLVxCYyxDivK9BKGAiNxSCY7I0LNGPI88WfU3K9sxk/C3Ig80ysasAzaLuorEh/ZZLQxDBQhBltMLCekrmLKNKehYXfdHg/0bPl3LPD3SMLYoO+aY8E8pEXBO+BJHEBA1pJ9wxu3FKcfZWYkVPMz1laGVbCgnEbkJ5ZITAvGknLuPT4SuOpeku4JDEYD1BSqfSJ/1ILK0ufbRKllRfAgo2T71PZTfVynbOl6IPOKR0jAxY0vlAQe29UAxBAw3JjwTJ8lbWD8E3KzxBNLGySGZvQfmaTRqJDRHXY0djdO1nsusmiEFG32up8IJxPg3FYb10u5TWDHG58eYQZRRrEFGwr/iuoDwXlB1sln3bMERomb3ZHmwP8PBXnz0wXY1x0snKuwTOCV0QS6Lc8Ibarc3YyAoObhbb59SfWizTkWnRZXfb8Zxgmf/9YbJbt6uM1ZYbnlyj2r/iKDVR0ASRdBpj1kzjeoyqudaGTgRxbwwihNgJz+Aqi9r91CH1dZg91bEb3vYgD2TEyPSqq7TDxpW83B57Ey+cdLw80PFTQWn6tsJYEHZj3Xn8skMx00AnzyVX01N9zo1bt9N8jpXLogKsMcCCgg3hX/AFEZf8Sy/8EE1DQfOdhx5+MjD94fvtjiQ+HUGHcOdG1wVevdcrD+uwMY2jWroqP+pAOqTDDjcYY04IGZF2yZN2Tg0htg8W4XqJzHZZ2SLuZbMIVDj23Qq25KisDyymDlAOpIzDxPLzaMFCL+aKDyiHdusN4RDRdk3HYegXqoP/tGp354WHBRPBRobaXeJs7ubgDeezCw4Pt9d0V9wfc0GUs7IwtnB6dKwwIW0LjelsBpPgYDcBGqgFdscGcRMg1d/ZXeSSPunfveTEVdWvFkkmZKnv0kNt9s50IYujTsWlvtymrqjT1J8djqTgeqiw7ui2Rdn+XcpITnLoRmBKXuCX8uzYUQ96HU8NCD+lg5lXHHhjaXQ4YequFw9SyBAxCqpq420QHayyhe9sCHKT3d3ZPh3LRuneHsTnEqON9eQ5uYpxLG98fpdimu6vSbIN6xDsrdbBMnHxzhBi/rk/srcXTOrJR+yT/azYnu2myu3fjeLB1cFWjTx0ZEKXuw7V/xSJ1l6Bn0jFR0fxDRFr0yTMYY5qMYbHxtqMsa6BJE/rR7/m5qbblG5jI6fyYjwx+uAO56jwymMO8DB4Zy7KDjFkadrePI7SblcPMjrGEBG7DcaFCBmEtfjoOGFoMdT0mW1wdi3ILBWr0YeKESRJ5fpTWz++mIyCrHfj7BBzzn4udKvxRyq2O7H2fQeJf+9iXib3c48RA19XFYMPPL3wwlIiWj+Z0Hu/Xt+u1QbmcGX2DrHrjM8QRH8j/e32JAmUJk75CpkR3l5X6GMxmx++7OAW1rTdsP+7bmPM0U0TyO58Y3r4J6NoHN7hl4I72ZSXObEXWIbytK/ZcSe7uD9XU/8fP+/gFvknzxhIZTWPlMr32t8K3j+e+oJ83+o0Sv30jEhPP4414HGf2cBc+2Ku/dt/NwABDt5AeO7mzauXsJ49ewoVgoMYMSI9iRUtRnwX7x1EduwugtO3b59FkRD13dP3UeVKli0/OqwHDqbLiAzBMbSZEx++iDt9/gQKFOVJfUX39UOaVGlKcPKcOoXJEGbCj/FUWr0aD2vGiv1WIhWpbyfKkTRVwsNq1iVVqmpr1sRZMehcumPvoRwaUunefvvsvVx4s21Mllotpq1Kj6LLshGT7ruHjyE+o24jDrSslnDmmzbf9qwb2m7eonr5JhXrOaJDmZvNIjZLmSk4rxf/G0MUGbbzQnuVOf9u6dry385x5Yqme7f08qOn+6YGfjXz7dormedO2TChvXu3owMX/h0u8YvIRytfbrT5Y+w8xVc0DF/87XvgUILLvS+lQ8re37sN7z+LeDLPJ+XQSy+kffh5rLTIBJToHQkrUgyienbCDTh86jNpOYgasqc/2iAk8b0QC8QQrwSvaxBDlupZLDONNrpoNreKkihE+yJKDxzJJiMLKbWekkexCkuEECfzDlzxutxcXClAtTLKCDa1+lpJR/d4DImpn8jiZ8injIwRSQiXLIq0BMMqbUvLyqQpvulaglKi/JhKz7+VxjTSTCSRsy/NJlfkkDM4/TTJ/yU3I8pvPfz003MlMo9EVEBAh1Jz0LssIs8lKw+DSLbfbKyotJaU8idVf2irjiV5IJr00EqjQ3PQBB+USKEfO53PUgxxNEtVVV0isshYZy0xtLsybbLQ1aZqi7MLHbNNw0UlatWiYYkt9lhks8SJV5WURfC6BCvSDlrLrJKVpEjxa2kybJX6r1gi+/xWpXDFHTe5ZZ1k01S4oKX0u2whOphRgUGSy0dSIdo2X4nRNW4l9/z9Vz3sPKxpqkknaheceEIesat34WWYR4tKa2zVryae9aGL+HXxy2WHajRgiSSDyVtw8LWInmuxdZemnG/LD2alAZOS5i0NvFk99hb2Uf8qhT6WiB4YF+Oa364qOtnOkhgNe2mlZ/rtPI2V0rknq7G2aDCvGbOspNqEVEnIhM0ukbW0N8xYJL70A7bjhOA+Tkqz3n34a21ty43vmGXmbDSWm0u1wcIF27rgrH0c+r/NgUu6WsnfQ5vTuUMF/HLM/ekHdsKd1Q5fKz3n7GRSGzeaapPKPt2s1Clmya7LkRIW9ucqOrzM20k22nTIP8JbpYUdDL7SfVeH+vjYk1/ecNwpVJzRiiK7lijOsDT/o/tAcjZ7P7dnKWMFGfxeWKRsvFol6Iv3yXF41xLgyc9sFSsPT9CTn6QkT3mzqZ3/LGQZLy2KJ7zzSlLMMpsCGnD/YhuKiP1yg7/8qSp8FoJRiQYYOpXoh1rHcY+mVkIQD5IIalG7HAmRB77bNERWFPlfdApIlJSMjXV1YliPLiIhJloEMzXMzHnKpSCR6NCB7EPhD8sXm8U9amVj+chPatSmlTQRIk+EouqKcyLQAe5meclHPvLDDyvysGNBTNvKVKYwjklELKEDykXiV0YapVFf+wrKGxEUxznW0Y6rweN/gPKwlOBJLQEMo5uiZUi1hEso9oNjzuiIqitiMYVnylFrpoJEa4XKlR864k5UA451rMOQlJvZiT7JLEY2ci8OzJwLf/Yq+URRk35T5UIok8DyJBM0GMLQ4Tb5IUzS0pby/5MZLnOkS5vZTx9x7OUIR7nD5P3jH7Kbzas2UshKbad4quuckRKyKBg5RWs9AQ1L0MhJJXXzX+AEZyMdWc5U8cM78JjQJX1UORbiM25G0srIfmhP11wMH7WEyDpoxM7gDe9DiJTiPQAaziqOs4TAhB2oONqvWT1tVxOJ6PjIREiIJNSDyKTYZG54s5HKsaR0xB9KH1nMTEIzjKuLDjLpoZXxteaVO+Pks9Q1Hp26UTk9FScJhQpMfoilIsREYiCj+JvN4LSpMjkqK2sYlXDBRTI7LQ0jewnUgaIUHJnrh1fRSsw2BuWIblHrdhoat2m+ZGY3GWwa9/XMG8aVpD8l5/9WU3XXB7rnlE+FUgAl8x1pOpUmOIVVROURE91w7qYP0SZV/7LLcgVUoKSU7GRZ5ZcEirGvskRqvywbq9Qy7yeu0UqVYlI4heT2I3yFEGt6WxyMtdanrz1pbPFKWxjaNiizNKxc/ugexciDqYUt6tZ+FlGmEpYwo7vMPkWGXAGhDbz9ZO1QANooukZWWOZM1TmFhTB+5AO7c7ktbo1p26Uy9Z4fKdNOmheRGWUkRmgbGkGeSJB4sDc685BqWQPkSX8ua6QC1SowzXlO/fqjxP3o6j3EFZo2NmTAstyMPWODD8LMdKkSKq/PnChheJwRLUR6D4ZRGK33VnWnHnbtT8f/KV2UolivUH0lXYxbVKkAxmLR/JmNyTuyphRrxzzuMYOfEhGnZEbIGVZueOCrSPTMV8mj3Cp+HegYyOg2n7/dYpaKu5OTEEitzMsa2rZcYSIRmh5gRrTICA0RCzdlJWeOyEEQkrqYbGd7R86YmxdEVwYJtcRzpkmdgJKuwvo5XnwOi1hVIpzUwWbL6ZWwE8ncaEa/itaQxrCkp8K87VWVzfJNMqfty+QZ35nUy6UnyDajF8JVM8ssoUjPKmLGCsOahvDBSplVQmuIQBrN2lysr9ns2HAKO7rSZaiPoJVnkGV5niC5UzUvu5q4JRNO61T0asC8J21fhNurnqpqO4Pp/0UGu77njq0xQ7VudmdZnhfaUpv+HJz+IeYd7OCKu2moXrcgLkoB/2hcxK3Ionz4zQ1kcsRmTKBjW/omNCHTu10J44ZfpHPxYWKVgBbriLjjuP8+CNCszDzXXJrg5H6usEOccstczGqrdOi6QRZzswCxTCGLKUS2vPNrg8MdPv+qq+QR9EgSPadGJnnJNX3wpSf8fHRym4s9msxdwypWB57Is7VOXq5hXaIUwlrXvw72Wf87a2UHF4dD+k2svhmowxaqRQY5oJ9gV7B4BrnDbWz1i2zdUzM9PKXQWJCvW6TMhrcMeNcIX6tetfGb5vSS3e7HyR9njZyqmXaeNUEaM/+YvBIxjJW48qmL9Ck8h0uvjwfvZWLaGrn9Pmu9i7561r9R7Ul2/OMRnjyG7opXvNqslCC+ReKDA8eZqXSlZe3jgXzdXs+3l6QRMkHhxaTX3Fw847EP+9ibFPK/oZ/W0KmdaagLcbHoKD/h+TKtaL/367f3kz8hk7SP24z7w7/WAzbX8qn+i70GOqmPOMBDaivWuy168y3kS4xBAxUIkTAGLAgHhEGniMBuOwgKtEAjw7Tr66UN5MCD2wuIeaHguD2ju650aTd78x8y4bIVfJOzoLB4GAhCi0EIlD/N4A0LnIu0Mzke7EHtqx6icajswsK6CEGty7CQ8RysE5nigxVrCvmIFoTCH5tCKpzA+ru/H8lC69O/Hcy+/qMXluAVDZOJOxw1JemfNcQKh4AeIMo76VCLiKoIOIzCOaTDGrRDImyuNnMzLuxCEnKJTmELtsJEnrG0q6EIqzAMRYyQ0MMXRhSZQpKTR0yLgAAAIfkEBQoA4AAsAAAAANwAqwAACP8Awa0bSJAgPHAIE85LyLAhuHz59vGbSLGiRX77Mma8yLGfv48g/f0b+U8kyZMjHSY86W9iPnvt0pEjN66mOIQ3VSbMKa5nTp1AcfrsCc6n0KFGayodh1BpU4YzZ4KLSrWqVIQFsx5suDAownzgJHIcq3Hj2IseQ6o1ifKkTpYt882LOdOm151Hf951aHQn0aJI9S4dPBiq1cNVE64TmHWvV41nLZalWDbi2bRr2bYlqbJty3sxz9XVe5coacd+GQ4FvLro05oJCYNjmhAxuam3qU5tuJXrPHuoHz4EG1ZsZMoaISqHHNE4xX6YM2cGypKf3NA0/3pFGlw1Tr43TYf//1t4NtPyCG3nxn17qjuGvRXO+22PPkJ7wO9CdH4cY0blAAa4HFrRSQcSdSR91g5d45ymU2vdAfbgeN+FZ5555xEGm2G27caeO+/pNN+I8+GHX0InmnhiQhAl1B9yAt4jIICQEagWdP7giJA/nY0U11wyNRjUTw5GqJJ2fhGVoYawbVibek/OJI884MgD4pRTkqiliSrVV2JQL060D4D3yFhmmTM2x19/CX3kEEv5gCYabeBxZyRedSL5nWsYYqjhbByux15VU1ZZZZZaJjqfQ8CNuKJX/Y0J0ZmUyphmRPmEORFC/BzIUHWgycQXaxDuJd5qf9nZEIUZxvank4Oq/0cOlrTKo6iiDm3J5V3HSRpnmfid+aulAZZlbGUtgkORpwih5M9L6TTV4HiBBacnqUma5p1PS7kqbZOwyhpVrbcmCs6iDCmqIjiUEqcTWZICG2ylxF5q71eZTuTmpwnycw846ZxTjk1GlXrnqtpaiHBR3Tq1pJ+B2lYuuudSTLF8JKpoT6XJglnRf2VmbGK79qZZJruWSpQWvwm+RFd2BV978Kh9EbkarEw6BVV6iE28UKHpdpXrrfOiCSCkH/8634LtiCwsmfTSi5DR+a7cLErWwSQTTbBVu+fM2vHEZ199uiqbk3RGGVWitWKZEK1AEb3x08Lt9RF0GEFU34Iguv/TdIlRB37P3OAUnXKnPF4N6jwBkzNwXtTOrJrB2Cp5oZ9o69yQVVq2DfShbsed6MjCotYPOCBB1w9G98zlTjqwg7igo4ZTqjGKJKuc+GY/Nj6wnWRLLtTCpN60IZ2yeetQVZ17jlCtXi1Ku+HuopZZ1u28DnvsGGvsfX4ozo2mRPtu9o91QHIdWPCSlwp8TuUl33C4a5PoOZUMAY2/iAiJLP6d13MZ7M4hountyjeks8zuzIe+dsxpfTKLkNeoFbOdpA1z30IPz2ZFjw5C71CGcsj+Cqgrwh0MJD76DOPOwUKHtKN/tBMaxugzNwUqzlnoC1LN2Ac21rhmgg1x2Nn/kJc8D+kkdFQa4dBIyKV/zcwzObqHO1qIENgNbUTnCprTykQ+cJivJPuQk5C447WDUbB4qWFIzjSXQc19ToQjVKJvcNU/jTnxYOZriT22Bw4qitBicgtWpjzyxbg48DbrW5XwsqUqlcyviOfBHFOc97zgTGxowWIXHjfTD7lY0Y8McQeWfKYifNyji4WEVnsmV0bURBCCozLbGnGmQeH5LF2jNOGd8oi+1zUEdgO5ks9ouLGInC6PnwlS8RLpHTzhBYLQTFVQZvlINtpymG/L5f+MhEx/MQ4h5mAhOtRBEFHOx1bqIp3KvMg767SDJpCbICyHt0zgYesukGwYBhep/xISKSR/iFLRHSOUx37swx7vCScLz4EOdKQjmLZCZwmNhkrP+MuB04rmPB1TxmsVSZbg+lM25QhQkkpOeiUaGUP4oay9FLKTKzSHTBnq0HXAQ5SIEpkpx8eP07GzOvlwYDk0ulFXimMpH3UmXqjJJEoGBYv8VNcT87gPcExRpuFsaOxwKlH84GOnxFrWDf8B0yDZhGDRNOM4RsOn7QhFpGsEXQfnSld6iA6qB6uHXvX6m51WzyGJ65FnHhKamYozHfC4qa0y6ZD9bGqsehQqYZgJNm6hdUjrY2ph5FHXue71syTEa4Q+K9A7TkR1PfrpF5UVqoVm9aHmBN/RwvIWOP8xjmtKSWtl35pURh5Vs0uhx17B8dniGlevDamHlvJ6u4RsRHX7Qt1HvtiWhyA0YAtFRzC7YiyLqO50gWWnguY0GMryM5ZHIqMaiUiY45L2ewd0CHL3Aj5GqcQs3y0QdZ3Frnm8rqHqSAc71uGOeZxSLPlNS3RSkqCDTtFxuTXveUtDQYOhRynu3St8TTTc4XYnvl7ZD35xpJb9JohHrWvHQB5KYCpBpKcFkk5KxMsPhJIXrZSbsMwU1so2DibDet1wivLjvQk3djKn1a+JffSVwdWXpzE20A1rfEgc55if1SpYGtk3xHEAuR7rYpSQw2zk5ZgFxko2cY44JSYkR1n/xivxUVDJ22MdM3JsFLonSDH0ZfiGb8xkPu899CFi40B3uktOYY5Wl+A3SyfOCbqHDht53lYG7zSUE6J7E+LeA9b3z/b46lcfVTjhFdrQJA6Jmg3E6tThjaWog3RLMHplI9dJqUkKYpNm4+F6cDrDfhazqEVNaq+A2CGEPlZFUr2W/bba1d+tiLJ8qtpnvZPSts5TrdsKKD57mCGgPe7tPh3qYY8axF91CLHrG2pK6UMfxzozmpld4pI8+26qk0xGwpJk1J2EH+/MaLaBQkZsAwXDvkZIr4+rcDAXOSHmjviw1Q0OfEytTKMunFfB+jQ1yZtA9DaQvUPyal/NKCML/z7fPARWs4GDx7cRbOsFG55whhPX4RuWuM4tDnGdYNzcZ+J4yjyuqSTP20Cri5fU2rUPEo+EHyvPaMyNvENoIuxa8234zUF784Z4b+c6Z4ioVRI4UZ+MIaeOt9rjneS1JH1STvaqxr0K76azxV/p+N3UdUxUsVWYh7+Wb9a9PnewA/0eE7+L4AY6nOWcvGTF6undciSmSX1v6+2GNyHlLJNtV1rPR0kNBDu49YQTFyimZwj4Nm74nR6eXfqYmkNOFjWGdBzylwrrvCkTJy/NQ7i+piuY8QFvRJckqDBz+dcmVHBYkn7rdyIykcfO89abUvZnerfPl84xe5GMXjSaN//een/O0MUjHoUKtT5w1DJ3kCPP2QZ8PHky+roW1yuDn/vqv9d62qNMara3eLdXMgIoIwiWb2MyOPMgD+cXD+DwDu/QgMQVak23eTmSD5PWW7slNqzEQ0jRWak3Ybtiff9SgP9XgMRCNSZTgI4FYwlYH1PigOwwg+wAgeAgXF+leSHhTecwLQOnJ32HJENhfyE4cKy3cyiYhIJDaMrxbk6oD0nYHD2VN4OjV1SiDgCmDuzwgMKlfhWIgPbQg3tXWajyd5e2GnSlfIxCgkrYhlHzhE7YhpaBEVBYhfTggFjYUOPEDvHQQfVAfBoBHRkhRe+ngWb0PkWFRs+ndWqIEOf/Vkpgp4Tv1oZw6IYGmBGTiA/2UA/0IA/vkIcAxod9+Idw+G4vIYaLVEHbYTNJNVcIYVeLCG7fxk/opnOUOImVYnb0UodKCFamWIf4MVzvwA5YqA7GWIPAV27Dhnh5N4YU1h2p4lEJ4Yo3eIN2JXgddn+oUWzFZniWSCnLKIDmpjHE9lX0EozIdYfDaIxaCIGjaFz2IA/NKDzhYFRCyG0O0VnWuBcd9mn8ZH3m2IYSRy/jCGgbh3iauInpyIDxMINaWIPnN1e1Ag+dhxrhcJEYiZHpRTZ1Fhx+eHrb2Ig6YXEkyXMNwXFIGHQJ+T3vNWbDRVfxMIwQeX4MCA8Q+A7w/7AOAWMOMwcOGfmTGnl1p0JUzaSGCimSQZFuJ7lzyjhsLPllQeY92ahXdxiTESlcnrgOxEiM52AOjwOUQGkqQdhIrRiLSImUR8iU5aYi7tVZwMd1nEZzVFmVOKgP+CAPOZmHXVkOPhmW0DiWy7QnEUSNZymSwEGO6/aI6GhcdNU2aYh6jFmXGYEP9bAOxogOXtkgGUmGY2lpX2OWhYmWkKiYGnNcdVUoWEKYOtGWpNh0+3CXxIiZQ2WImBWE9cSRyxea/zh2xvZ16/aUn6WPInSNkHlcgKg6+6APe0RA4lCPMMeR7NN80Nlj2rFW0aKbEXJ4EQcU/PebwDmXjylC+P9nnMeJN8m5R+bwnJ25nhJmPHyZDvbwV9h5F0InjiOZkE65YcUlnCphUnKpV8Omech5nuvAk5ZlZRKWLT4UmA8yG+SQDu1AHOFVmP5YcQNZJnHobrj4cyYpdmrJlnvllnfyln8YoF+YdINoVpPVkbUJIQqDEM75oO0Qn4kTXfN5n2ZXijqaoQgJkKSpkOCpmt3hhwBqovmVHLelIQkqlqZCDucwD5myI4G1cHA5lVC5LpfniNV3oYPGi9m3oXXoo965mCEKmh75lkaKGa8mF1NUDm56o9fZKau5afM1i14HaEDhjQjZpTuaoWK6klJpmsTpFbFIosoooCKBb70kGnz/qZurtCPSJXjFuWn611zFpn9i+qXiKKb62ZZCmo+LaKiihqj2Nn42BmEEo5uLdjfKUhHGBZKlB4+V+nCgNpqZ2qN/KnFClmHhqROPaajlFntpMXKr8xIPNjBWpoav1mZVVVVhERH5F246YZDSB1+5eq2Gt6ueWle+moYkOnzHaRKKaqyMGmGehxqP2qp5AxbuEhG2Z6ecRq3y6psR15TYCpAuua29yhDc+q3BCg6bVxKm2qZIZXAu56y0hX+16mnzipj3+rD1qq2Rya0qQbHGlYN2d2IXaGPIKnWJ2KCQwhCng1oIoX0fdpgNm3MQu7L5+XVAup/86YogGKvDp4Nw/2FQcvI4HptWmGZE91UcKIdayVlxROuEvYmyKauyY2qvhqdu1+pVUDtqguqWVEukNNuaAbuDc4YhpPGxReFHZsYQmFiyzZqcJosiKlFzSbu2SZt4CaGSf7qWTjm1VWuN+micOpgZBsU4HYtGbWUwjXpxlaJ9Zxt7DXEy6GhX2qhweMq2jttcbwu3K0u3ncVZsHi3nPhZ4aq3NfZgEVZPuTmtHIZcwMGhXRKMIeRrVvq41HofkDur3amLgvO0E+uWI6SPRKh+qQZdOBtTqBoz7tMeXdGJlgs31Ui0xDWo/NqJz9NnrDtmrjuvOIqC1leaZUq8+7q81wiCXhhtGME6rv8zQOZQF5+LExiZEy/0NnbFkOBwfq+opZqYdcpVfs8jD877vBsWvfLqdVxadtlqvZx4mm8UFG4JoAIqiJJSHwO0UKIRFciKKgxjVUpEJQ3ovl0yeyT5Nv8Jj/ibv7ArZGLGtNgKnBR7F31ItaBVdwg8KSs0E+VwGB17M+WADu4ADxbsgA6Bw8mFbAmLjZ3WwR38wWmZqwAcpGbaEA3omETqa4BoLJMiWdPCVI1KYDUckxEYkzqhw6r3tiaLsL/GdRoGxIGmvyC8sDhnIkRcxPwJFBVsuUQYZMRXd5g4ie4nlIFRE+XAUOCQWFZ8k+/wgBactkEmdo74L9oHHFaquhP/mLQhfGwGWak/rLQFGahGfMQJUcER2YBLbMDvNse82A7p2ZyruFbn8FA2aZN/nBA3icnYqHCO2HMdusEc7MFzFyF4Cmr3S8bwBWS2m8WYfJXCN3wV18lm66XAMVSbeXAzzBh+/IB/7I4OWMH8mn+wCmaCDJWzbCTjRsv6i80JN2SUzKslDEcMecIgWKIWSsw8ChMvVA4/CRTlYA7oAA40OIN+/Me/DMxrvCJehXFfbHritpi0qst3+sgFTaYZFpe6zMuWfMm/fM4AWsjEXMyIhx/rUFPvl8wqQUDsqA4O8cwR2L6YbH+cNnGmBIc0F3jFNbpnzI2vK8QvPatQuZpF/8yYjjHSEK2MfKoRG+ol69CVpZwdGt1tCdHR9IwQW+jM+IzT71vLJUvMxeFT8MrBYTzGRwu9B43Qi4uNIGpzjlG1b9mUTpicPG2XmriA8vDT6dlHQv3O4LDWDMGO9EyDCGGDgKzJnrWWhOwQ1DanNmfNFRrTDavLWl2EstjSLys5bwyusDfRZWGX+JHWOulH5NucF3kT4eQQ7FjPSN3ZIq3PTKyUr8zX4wlkVj3QMP2446mfwtNpASrHxwKFmpjW4rSXPMOX3BIU4yTXRr2FV4zXwmWhmghxjMePCU1kp+vIrEvGd4HYVm0k4jZ2jm0svFgfizFTsukQ4xDPcI0aHv/t0Xct0oxrcZuIIrFs3MddauGT3ITtuNwZvbDbc62tYSY93WWtIv51nXmsogmR2X3UEA1FQP+tEuCNehVXoQwBb6UNbJea3GL8vMLNT+A6cWP92GargFaSWAXKl3ksMEoRz0CNECyUnnrIwAIu4RtTdz0Fr7IMWqcNwg+essq3nU9I1nOMcfGoPbDllXzJQgPzpiK+UH1EQAyMDuK0F+7LWdxZnh/B4lfbkiDWuDE+msE2cDS+ozheH6/TlTLlUJnppDwO4uCkUGP+1lglzwKux0Xt0O275IjKI05+v1EOvYCGr7ZakEh55TuakAv4XzzuleaQDjzJFOHEl2Te313/CU4MceYK1VBFndS+ijsoty9xDmQ3d2ztPWZpDL9gJ5LmBg46eiabaCU6aeR/TkDyfBtuqocD3hAyBQ7zzOMOgVV63I6+SrrER2Jf3NxyeemLqXptK6ZOK3HIC3EleV45mG6V+HObOA8Umehv7abj8OpvXesJMc8IUeCzLlOBC07Z9ZCpjBAO+JEUWIHJRc3jiXlwCeN3fq1LuZ282bQHk4NPHYfxO79WEjBvyuE/PuKBDiJYERxGnujZlV27fZPijn5deMCO4eQ7/M/yyrL3mm3KDup26YTxiyUgkg6yuSFuuuoDUb9WssfxQeAAju3XnoXgvtR9uDFN53KpB+VC/ybx2Erxov1ucQzZU+IO7zDZPL7deXzt5JRY06hchs0Q9byF2h7XHQ3u4IYPLz97Ep62dC7CD2uhxh52tpZ4GG+Os+0Olimb0r7d8iz07CBKxLlxd2HX4ADexljUTb+FSY1+9vCFBj4zhu3cWCp3nD7x786bNn/Ssdf1X2WFYT/o3dJQNpUQfEgPj0J9JmnX4c7437302g6RXeisBhUU6H70D59cVV9fKxvhgkspLmfIhIvzhT8l8MAOsvmi56CFaQvLJTncdS2BDkGMax8P5dnXFyw5AG16+5v1NS/cZyK4moTsAcmnsceh9VCTrs/jDoI/oWZ7fT9spifNOrH0SP9cDyea4IOj0KuJGgwejNws3O4Ovyi4SIJvtJl4bvUQDwPh+h+flBbHeF2P/pRpV6z8gAABDhw7geDUHTxoUN07evb09etXUCI4ffjsTSxYT6JGjBjrfQQZsp49kvY4Siw5Ed9Kli1dvsRXkOU9mjVp6tNnUydOnh0x8gSqj2JFix/pyXvHjp06dOZ8CmQp9OdLe/hA0gMXT+vWd0kFKk2YkF28evr2QYxYcF9BnvdWpnz6FCQ4kSIvdrxYsmpMmH37FrQZNKjOuE8FC35bj57WpE3PmUOHDqVLcCt7ylxJNyRGrfQWx+uqlKBo0fTwnUWb9uc+1kEL+6wbe+REkgL/9e6F6ld3ZoE0hx4+/LojUNbF11Y0Kg/eOnboHkdeJ09iy8q8+17UuBnc561cwYUeze5dPHuoVUMEt3YfT+PtC8uGbxfj7ZK8q+fezVJiYNfA2eIULr3iBGSNonrkkSee5ZqLjJ116IKpOv0kdEmx7K7KqjsNQfuqK7LMQm8i9NpLrcSJPMNqu/hE0gyku8CBCyXbXsSPQr9yuyenmgT7DzigChuwIPT0qWc55tRZBx54pMNvN5kkNIkjFjfsTiCtMjTtIdUwKrFLEyVCUSB6VozvxRgLuqu26fKjDpwd+QNQIh9de2qtjiLSxx54wIIHwpianNClizJjKUoVr1os/8N4FK3SM3xADLBEfyaldNK4xiRTtjTVlBFNldikLkecRBU1zv9+M1WgywJUC58EO4NqTcpe8pOvkFDEFUXGJlp0zEfNkwgtcFSTSiB/wKm00ksz/UigkPI6E6/KMAM1s1JL/bFYVemUU6r1WN0HnxS3s00lCqnNaCWRctU1zKy+67WeX7/0EiKhcLLT2GSPfQrTTJ09CcZo5/u02p3mnIjHhIvVNq5+8i3szwkrS+kkRNldFMtc5TULNYcFQutbN82SKNlxwfRsRY9cFJhTT2EEdFYbV7qp5jlXTZjVwvpp+Kk/0SyJRc+2Y9fdgjzbC19hdYZI5KpI7ifZo4ueK/+2ieQLWmCUatvrL79szunmVHWOi99JH84N3ftkymvdcYvGdb6OvzQMXyEfXu/niSjFaOP4rmYxa66hJZw+NdukOUdSxe6Z7KcofVhbyj7F7ta4iYY7bo6BdTxYvHMCDOKO/IYP4LlmvG1G1AedfNqvFR+V8QDHLvvsyHGeLtaYDL0Yq8vJxZVjSOntnECc/rxnH376Df7vqwvXS/XUB455Jp2w9XG4hhvvyB+IvP981Z/1rlDKuH+X0jLztiweo/YAtBvzqVFUmTbD78ffp9fdogmfmlBVWLe2pTPwNW09uFubhCjGO8Wcb2jOsgyIQtQ+ID0MLfyAmAN/Fxf8dTD/eqtzGeLYdD3fBEdV4PJSaxBon4yYDmBFw9zmPEZBqeTIfev7XgEjkivMjUk4Hswfp1JHG1n9BTDX888AT+iwEqmQe7DJiEYyl5GqrE9nogMgznC4L0pdLmXNeg8QPQi0aFnkRWxyEwmTOBS2+EQ9ODzgE6EoJhjST3hncZx6KLLH3xzQOJLa1z/88Q9CPnAjYJTLR8SYPxDSyFy6gQoJ77GtHymRjzdsjwo718CixWNo8poX+4YlotQI5I2UvFO9pCYQQhJyI1HUzspGskjDSasj+oFkZSS5RjkOKJOtiRWresfDWD1klCBDD/tSYxwTSoQ1OeQiv0b3RVi+Rk2b/6IlNh1pLmrBRJI3CeATC2TK98kRMx7J3LgkOKwujTIiBvxlJvuIzGgWRJonsiOLCrPNbG7zluesnv++CU5uiTNf5XyNxE4kRRj+rF4hSiY8CRTPX0ZklcI5mb8QWc0Z2YWRtbQlrQI6UIJWMi5rUU2QzPlKutDFXUbbZkTfKdOQFeiZN82klywlnNS87YtGKRNJLjTLKOmTPi0r46wMdrCCastb7DRgei6ZwPfw0HciuhtU2QmyrA6oaSFTZYju+bG+/dRC8MmayjhSy5QcbmYz0w0STRine6USbyJLW7kSCVRDZhWZUF0aV6WqFhx2iYus2hKTmgfUf1ntdI08av99IlQtgcKJR3RlYnEkJ7GNFswqdMHN3WQK2HciE2/kLCxa9pVHlFGtgdpxHiyflc3M3IayJb0ZAJ8yoqnmzlktAklMjucTUdZrqzUN0mnNs1oK9pBdnDxddAO2Ms30s1B6uS32ENZGn5ytQCu1WLM4Qrut2rWUM7VpsLgaNb4ZSzhYjBOC0mnWWL4HjNZ9C3ZvyzjydkSQ3vuuMDdK3glySVgplSdg9TXWzrWFJgiCcOb0GaDH4teMkl0qfwN0LAADs1Mc4WHA8GUcZI7TwOUlkIBMG9jiMax/LIFwhJ2bT51pJ3pAvC6GQWXZNZLzcR2WHD572MKJ/vGudZqInVL/y+IbvqZh+okxk2I8YxZN2HRgJGoQ9UtZXAZmcTtqmIm727QgR9FZRiNsTidqGFNK1bjgKtZB34jFjiBIINJxrWxa1FKfdBCpXRvfUmsGu9ilis57S88TrYbJcVKUe8XxkladKeYeoRbSd+1vQZgEDjxfrn7ZuRoZxcjll/A4WytFtMj0ZrowDcrSFGUmG9my5GS6z6TcTXMmHazXOne6h8z6LV5oSSu+wNUlXhYVJTtGwERPp3J1qUquYQ1MOl3aRAVeGHkz3SO36A3CErGz78S9mdIB136L9JqxW+LlOh36pNqqHP1aqrdpM9NHokMpkOyU7G4xrHGk4k2UwS0P/zSzVLaLdpaF26Ru693kpO6uU7HMyMkH/qlj9XYi/OTUOQ/7BIF5dbBv7mznkYNJlgdfUT9J4pfQrtpNHj9lVqXJ4DanjeInu+TF8XWZsV1mkveRo1n87eQ1TWtkASz56PbKLEWqPD9XdA84lofigvyj6mo5ZwM9LjtZEwXVcfl6n39S6LAvnelZHnZ+dezyh4+TH8srpXutDg5XcjcxOO/RdgdoHYpEqLc5s+90Qz2te4FT05sm29ldRFtQgV3JmXx7amhO97pTLmAnE9tUCBWoqLCdVX/S+uxAt0ROI/5Sn6wLyj0KRNug8TVzNs7b+aHaye8tIpNMDLn6zV/hBv/UMpXZdlxa4k80zZI3QuGfcEhORxoDDJZFna3CvXnEfpOYNbKfvWrJlhOWhF7Z2bsXZeEXdvsISvBUfFScFKqPKEs56UPes3h/S1Tgoh3Hm4/QJP+3rX3kIx9BUp7s0z6mWY9u874sAg4j8otbIxuqOD+o6JhUSb/2u7P3M5qqAbUWCZrVQzffE6iXkxOKkj3J84m5k4i5i5xuuwisSD+k4wm/K7ZzYaOyYyGqIDKZeAhKo4h9aD+S+7apqSbxWr3666duajiRw5b/I7H0GMEBvKdWqjy6EywVfBLd2j3qIJRgGruyu48bCbYkox2zoMA7OwqCI6b4G6rFu4voWyT/mei2I9S/E7q4IBnBY7InVoJCKKS8gjmjuvkNpeI77Tkez5uP3dgmrHjAgWs/FJEvdnGhoII2xqMZhSIMTBII2ZM6JsPDPOREE2yStOE5Uwk/L9y6F4wJKUlE/BtEi2iRFLEjgim9KJsvjUq90jmJMUKddZuIn+M3gcgHcsLES/weezoWq+vEVqI8T8QlFrKk/8ClT6mbVSS+6mAdZlSXdaGjxzKdHpxFPUtDK/uzo8rFmQAXU8K+18jDZNRDVio64LMk2mkdWYlGBUybu1g4GBkJq8AQ1LMYzeDG+RomIayyc2OrNBGpK8K+t8MIaVrHPURGuhsrvniU4bgliYTG//QjvU8JCvyzDonUG5NIDHLzIYP7R7g5lJujRXLjM5gJxw8CNP/pnGBExyg0xij0rIlks5gpuszINPXRrIogikBJoIl7i/zqrOcpSUdUvdgyCelhpFIjm7WQSf+aCFfqRP0BRFmryHuMIC28JQm6naAsv1XLC5jQRoxwlUU0SReqv9LhmpZ0JINsuKf4xTSbugDxxBOcO0KSJlLkObRcuEATDrA8oHsUtjNqibM0HXvIFQSZh3mAIXB4zLb8xpGYJbg8k7bCiJ/DCP+rS7LJy6fIw526kYLaSt3Jq39KMg9jRrTkteE7ShWZH89wTMhUynnwRmhTJMx0mSEKEM8Ujv/am8n/wg+xtDj1U6AiysLyu8FK46Nl1B/iEyps1AzQakx5eMzIxE2mixLosa2tiRbO7Ez/c5/mwohWIk3duAyPvEmJUaiDtBHzBJxZSr3ZLMPsdMR5oEy0ajo/A0+XAcGMdCOIKx7i9ECM7Lu38hqOjMfW8zy8s6XFLJSm04/GfMzt3JjHLLeDY73/dCTxDBACrbqGLMF72g2GYThSs4/6Mrm+GrxgcpHhWzkoi7ILtVEbBTYPLcgPMkwQ/cXPxAiFLBt1PMaSobmOLDYAgaRlxEJSlE/pCglBAbRYhLAbtVIymY9Rm5x4/DmpANIgvcu4yMurRJb2gphARCUVVc7/CTW5S5kj1WPTGE3LGLNSG91PPePNLXPSl4uTH+2IACxQm6wUPBHPGmyjXDLCNdXHRJSllIEN6FMkVvSJ9qtTHD07bbof94TP3vgNcADOFJM6IV3IndqwQS3AIlobBhWht9Ia/Cgq6iqdcSG3y5yLaRw5OrVTidjOctNGHHOdZ9xMVPlUOpxKIxXOvRlU1UxNTfXCewyY3JOl+pm/IFzJuBC4G43W+uQg/PE74fDMuiSxc+weUi3T7koWPEkbZm1PdT2XFzmJa9wo+rIaCDUzRp2Ia81V/bwybd1WkEpOnSHPNRPXUeWwhURWS+kHDOI+Jp2Yt2JA/RAqwLyVqYkN1EBrSo84mmotDHy9UIHQ1zu1V8gKIUKkS3AdkIE92PYiRr7hm4RdnjdkWHmsDm7BjOmcLnjlJHKBtpcIWbLh2MmcT4TrV/oQTLIJ2HAtVtq7qAVTFu9ZHqG4MCQlHwViwNywWUTC2TBJkbrgWflURDvD1qDlVyrS0foAKIA12QJBWahqLwaLJu/h1BuLT3ncSGssiljKWjABteCqEArCu5/92KWMzdkQte9MTVY52pNNWvYiV2M9LE/9uZH1GeECioalxu5ETMshmhbi28QkmzOUiIAAACH5BAUKAOAALAAAAADcAKsAAAj/AMEJHEgQHLuDCNUpRHhw3Tt47uTNs0fxnsWLF/Np3FhwYD9/IP316ycQZMeTKAX+A7dy5cl/MP/547fxnr1589q1c5eu57lz5sgJHVpunNFx4MSJO6q0qVOlR6NKnRpV4NGUHcllxcq1I8ODCtV9dfgunkSK9jCq3cjx5MeQI0v6Aze3K1aXLF/GnEkzn82bOdv1TPfz3FChRa9CNfq0MdXHkKvancx1Hcp16xiGFcuQrNmJFdVmZJsP5VuQI0eGXF2XMkG8KWGC5Edbo83AOn0WNkyOadKljBs7jUwcqVRwSJG7nnxOIDvLKd8lDPv1edmzaO8JXEtaY0F+p0Wm/2ZNHiRsvTFj3pXNt+9t3IMJ8zYqcPE44cOLU7XKf7l/guxwJR1Y1I11HU7g2DOQaN21NRB4qUUoUnkUopeeeuvJhJp7t+kk2GCGRWUffvnpd9xxyvX3H1cHESQPQfDAgxk7mxVonVkvJrigdts16N13EY4XHoUVXmgkTBmyV5tf9+DkYW4hUkViUybu119yK1KG0EnxxBPjjDVy1hBEOeqIko8/PgihkKqpRiSFRxqZYUi00WQRYE7yFGVijNWHX5XEpajicloJhRJC8HRklpfvZMaZjc+RWaaC4PB4UnfglEbQmv2sSZubb5IXp5woXShSnbZhBOVhiZFYH6CQ8f+X3FVZoqSQQ/EM9OKujGq2EEMPyVOmQJRWalFHG+1zEqcQ1uksP6GuNuqRsaW3IT/7sNWkYD+xel9Tv4nzKqwnnkSroAVp5dpCZeUKjrC8fjmdmJHCI2xXmg6Ur2mpgffsv9GaN+2F1Vo7m7NMfuiTUMH9WZy4kQ2Kbq0FsdtlrjjqGs+A1TUU7LBYNaisW/3+azK0oQ5MbammslZbk4ERxvC3wj0McawEzYolVuoOZKitnJUFjrsnNZpZdQ7BQzRlPo78nbOdnvxpyiqTaqGRB9uWk8y93UeuuEkxdTN9VpGN3LldDSVQzwNRJ/TSBcHTaMdJgxxypt1lm88+tIH/07dAnko99ZsyVZ1ewaPy5Vdg84noNXHgKibuzWVfpbNdhrJdEDroLHRxSjFyjBBmwTLd9N778O13nQSNJHidAftjOJIsT5u1Tdx2LbbNIyqVVNln00of2ltp3lHnQXeZEqMzjp60u/Pg23TqJwsUFzhRvw5e7LKrnGSct+eu++OPNUaQU8EHT7zZkxm/GTvvTPaOdJjVnyjRCNpFWup8/4s99qkBnPYGF7CBcaVqWcsJb7oGnPKBqyC+G1usUDSQndnlffPrCD1QMr8Oxi8loTnWmTRCvWcFMEgkWd0ACUi1ldVOZbPxi/h457vf1adygZLYfziHvABpUCAbhJHc/z4YIxBiJGQkLOGnTviW7KlwgNwb1fcGNhMZ8oQcfHJgDW+IQ/24xnhrIwcPF3KSDQYxbjFKlDsg0hFKiaYg+UpW/+qEwtV0Ki4r3B73une4FyLQTvYQDBajMj6age186jPRf9yHwYLQw4woURrc2pgWHlnEQQQpjRKXGCG6wAU1TxSchKKIIT/CEFsyTMcgyzEzsXHxfOSy4IreB7+lPRIcZyxIl+xWkBCOJk2Z3Bu2QhmkT4IylCscEpFoZ8o/8uMe7VhgK+lzSHNFzEoU68z8lDaQW+ZyOWjBB3dIA8ckCpCO4yHP9fL4r1FWyJMmUYmGBPZHaEpTKlu0Jqx0SP+86HiQYgOJ3kDQYg9xrkUfCEVoOZMlTHSmkEIkcR07ncWXd8KzNfNkDQz3cQ+uDdKQT+mI8KqEElkC1DX1IGg4RXOPhCbUUqURGdTiMiHWxEWizuJfHoc0EPJcVFRU5IcChyIi4egTUBM7KUrKBC9eplSlBRWNS19qqUzdI28OTWd54Jk9/uktiXOUGkHmwpqfapSK+Qhk46ZSorNJMFDsK0hcAdrUggiUWAlSqUFZylKCaOeXqIMaAM0aT5yiEk2pC+XqNqVHk0RrYHaKZiHFRiW0FUepmG3jQFfKV2OppSMYYcsmIfQmwB2sLw0SyL740RGxniw8tsvHPGSWRcf/TKWCl81sZtEyEHz4dq999WxVt8OgwJpQmavh6pLIiTd9iTasJkMmHUMS2xnGMrdd6aduCVLQgf72u3wVYaVOwtIkHhe5Ibnocpn010uiqaHRFSV1wSfb3LXKPpAjm2SM4xrtZqlYKfktOHwbXvGipLjmPS6R5MIXvV1EuOMU7bO+KrI5zhdrz8zd17hYTeCJdLuazWtvBXwSAhe4K+WVI9Q4udXVvExHOAFNJQH73vdamJ6meuZso2SiDtvwx7idjEm58l0SF+S3FsGHXTq75AhDd4kL9uSCAOOhwMQ4NDXmSNMGBz6azFZ3S8EvW/P5OzLPtaR2KTJwDVwQNpeY/yBqLjJWEGzcrFo0k4HciTv0XGWcVDLL3rENaabbZXtONmJ+2uLk3jpkQTWaIiYusG8HrGaKxdnNxA0tWM+r1XjCMZA8iY87Rq0TPwO2wIDtH46t9UxVwqpEiswuQepRj7wWdM18VTKl5VyrSQsk0g/e0Th1et70pmQfgYyPstOx53aYOlWodu9GaMNHrOXD1deVymGwe7mOPLWgUVWLPo5oKSULWNeZPSJonZwll2QYROdQ9qj3bOoCz1jTqqZvOw4dy6F0i984Gwitax1OYCc5yUbeNYh/Pdx1SxscTpsMqfLBrd38ZDDrILWffXmRcHOHbx850kzmweNsE5IcC/8D+PCGN3BaExTJuL4Huhc+4CxhRB9dGZIU97HjnwTFHOfgXE8y7uz8EevlHg8t31Ytm46q/LpCiXfJLXcS3tpaQZCOc5xpvpyqXgTnKCGttKaVKfGRwxxoD3pPNH7Xq78cwnsLubWxXSUxW46QhRlfUo8OVXxkXeu+/XvNuY7iNmMFymM3oD1UyUqhpF3tzHZ2L6GanYyAvNqy4YdkxzFNyBi1mvkhqmQoWSy9ap3yCpo54efMFWKDyjyYpxbPVYlFVpYD6GrPuEAmwnfKh5basffH4p9eVPTVbKSPIT1FNntrwIdz+QBePVcaPhDXI9dwlUpHUMrB/XIAJffuAMf/xnuv0tFsb+7Ep+wDE11Z7DJ/+UcGvK5VKn3y6k8gXl0TnLA/W3N0P+3o0BMCUXTwh3qeJUxytxf7EE11V1lgs2jhEmvvRymmd3pQVX/LgXM/kn/ppHOzkyDa93+4lw7gkHHu4Gfklx2VkizQYiT8MHwN+EAh1UW3VUHchXo4yFs5iIGuEVMc2GmJVzXZt0C4Bw5DFxGgMYH3Nm0JKBsUN3UNo37oA0GjB0Hrhxw5mIVXJ2IDZWs8mBJgl3+ccn2zMxfRhHa41xxDBxFX1nvkphHU5oL34A6ip34NM4MV1EAmdYVKmIUEtYXRx3df2HpiWExnNTsrcYaPFx/rwIbj/8dZPYKAOOYPskV7rWQ+HEZmHbF+Uxg8fviHzIcVF9gVvLZwXkU9hnhhiNgPO5aG6RCA6WCCBJgSLKhHe5FhC1R8mvhKiXY+hySDZfOJ8MddlKSErpFwuqUPqGN9ryc7sYdWgvF4PBSLoyYRoLFmzwV8rDZ8hcSHvsh+vhhB4SKORiGMBohXXjiMlKFr30VzyiiGLFYeiPgPLygfhQGLsggaNAZfKJNjX4ZPu9hh3jglk3MU5uiHbneM8Sd/BDZu40V9KdFSmzZT+1eGc2iPQneEzpYW+wNdqhgTQnUOrcIVPpYSxqeHUXGQWnh0uxZ4/8GQLfVGriGRp+hQQIWI/v8we4XRE/g4ahNRi5xykyDJgHfojZNxklARPOegkjmoepgFeC01buqWgWBVQkD4jEEFTYMRgAGIGfR2SSCHXkz3DxTXG5hIGT4mjrIyDufwF0xJeb62XTOHZAj1WX6FaX7lUssYj0FoOKfSJMrmlXvGkZdHOBhGckVZksvxQEZxDu2QD8L3loH3ck75hXbpddRnEQlVZ2L3kWVIEzcxaiaocSu4dIZ5JK1WFIppklixGOTgmJAJEipZaZSGgTMXbW0GkcT1jkr0evO4F1UEM3xWZYSJMsvUZfuGFGm5ibsYNkaBcvNgnLIpjGYCZ7xmbnFJeOGVm9NHk70JW7+ZeX7/gScxVm/50FjyWF29AVCclw7tcA8tyB6RiYNEpmZ/J39cx2R4OV6exZv9A4TheSp+4VkEpR1wiJ7pSV90SCu/uJrI8ZrzkA/IhY5YZ3WUBmktGWf3qXUlVpm1ElwEMVUx+XWb5k6eiUAzkViYgjfA10Ii53TBgRLiKA7l4J7w6VOTp47E4pIM6WscWp/ZSXgiKpWaiVB7qX+HOI/iQRJ14jRzJJZ9mWMwCozj2J4R2qLJdYP0513o5qFE1qHs6KXu6FJRWaQJVYjNOJYoaj1Pw0KPpW/mAFLDgXL2IJ3GJopWR4HFAnhp9qODOBBTFaguVZNImqCIeBI1BaUVaSo8/3cORcV5sMlJnQI4q3OKI0OfWBGk1vlrpfinHSGooKoPhGqiSSqE8pRReySUe9EPHZUYKPee59mkMfVcqXNwDVehgXhkQKqpnkpcAhGqgroPCIWmV6mmLgSce1QyjfWihJEO9hCr/vI3rHUSUul3emqhOtJ3YrqpvXpgPAKswDqqqaiqVrMXqFoedyRfq0aJV9VOERUkqaNQIER53Zqf2gGu4GqpWUWqajpW0aKsTUqo2mgqTkQy06oPkwZ2Dkmv2Kql9Uox+BqxZ7pJOJU9UCpl/gpR2YMtFCZH/xl81wOoBKEsCeV3CYJu37aSufqwKyKxLquv2BKz7tpEKRQk1v9DqjjVsRW2D2/RMpNKrZ+FdfXwSPSwktXJsiFqSbr5qS7btJb6tE/WN9XDaTlbE1elLco4rKpBsB06irryIvSno0hbEAoFdhnYtGgLtWrbP+ekPUGSU9DGUme6tdbSDxFnDy03D/UQY/UAL0CUoyuLtGVqtkvLtGj7smsLtfinuDUZIXCba+L0W6LKs5Not2arcA1nRgTXhTyoqe24bi8lr/5xuE2bDxOrtt5xiuTUkUuUUxgBl5KbOj0bEyMhrGYqojLnd7XWoba5rYYbqIVLraQ7vJPLP8yFKZoiU62LSh03ES6nV1o7u+KhsKcbr+Omu7xbf8HmcOImqPuJFcT/O7xedbxs4VyIBV3ZcicxtkEtR2u+Jaq2iBrCGqz8U60mG3/S116ZyVf4erbhS7zMNVWAGqpAybFMchNl4k0p9b6o+BGpcb3yWpkJ1RG8qltfJ5WZVmDhG6Lg8L/AenOBqhGbSb2i28FUpZfuRT3Gext280j1ILmTGyHCOnNZVykJW8KcunoxWZdlqpkX7MFAjLY/rJema6QherkQdsE3V5W1ig99OyzxQA8D15CWOlwuR15ueZ+D95KdaizjRqZFOqJRGcRkXJfeq8FTtS8NF20kuozZMm54Sw/y8EFAJMUvjA+ne706Kk6CWoFGNmml+McwucOhy8MgXMZkPMZg/xxegupX3BttfkFCL6W7fZsrPoRLRfu+wzq/CAvDmyy7/uLHcemnPapmPozIqIyvikxVaIzDWMzGUmXIlBxEdAwOd4zH3qvJsmuIotylW7eQnotkhJzKxAy8H7ydd8lmsAzLaEFr9AA3UuzJLuVrxbvLIdHLDEnB7cjIw1zM3vzFoXpiyWwprLzMMsdS1qq7z+xIzafJCIVuOHwa2IyfwBxzX7fK3yy+XgXEa2yX5czGv3VraqFmzvzMuWLHRVaXOWy2I/MWekV/2Yyd4BXL+ey0iXuKQUy2RCpCkOt3AV3KCPddFFHQmuu+zdcVPPsRD/2H2cypE30REu3OFY24F/+9wQNsyOI10CItjKUceENb0u5bwb96ef+w0lYXpltnyhhhYsg4xDMdrtYLxEf8z3cZ0EzZ0781tJgsELSmWQoiqm4CE0a9x5UW0xmcuyMGuk/twRjdvzc9wQ4JYZMJVSmLej39zk5MtHYMYOEE1rNb1EgHitb5uRmKa767m2td0R381kgM01ZNUO2LtwNn1/I3zU780y5c1+Iku+RhtNrso7QZYHOW04ec2E1rwhOMEkhsLDsN2e372s9L2Q0ZqL7107acUk/FwOHRh4KNEnLWxW/2obcLzl6c2KjNweA7yY/t2rD92jjoyft8vT/tcguMx5RrbCPh2dnr0kLdW0r/ZZcLQrzi5tSB+qurDYYiutzM3dzNbXpR+bTvDNvWfRoRNb/aPWJYjYwg9r3CxsZgHKq1ArytPdJPxd6wLdkFV737TMmTrQ+7DXG2m8VaqI6q19IgFtoUnKG/xt3C7Nb/ccZF5toEbuCTra2b7Dr7nGQI7uA0C+F6/JYnPdj6DWe6BdwbnsOZGmkA7r+gmrvqjbcjTuJ13XwnnhrGq8cL3EkujuQwXsN+OrZgCpX4nNqje8wDTnlCDrsttcsyHK9uiQ8pTRJRHddDfpCA/MtQnuEyruON3LJW/uM1LHDtXYFF7rjxms5hDnFEuti8zdMxTdi+feEunanaTNECnCWq/yzS1kqZJ+HclMnHMUzfnVKrWx5AtYqhxNjkZ27juorfcqnmr8zDbY7oPc7Dir7oVYe3t91yFbjl1owaRp7SsK7nCHvFvYWrs/nn3X3jLQlQhz19PIzarszji6zc9okVuxvZj17n6oRCi9voff6Jm87dkwHoXCzcUcnYhkutGr3Iw3297Mi5LFkQJQ5uRB7psGVT1Vd1O7rokumlXRpg1r4cu94Vh27e5y2qyd3jpT2i8u6llPl3zO6MBgPhHUGygaqDKvmlHD7K836Mv/7h580V4ArTUkUxAX/uXA57poISPAu1Td5d/17WoJ7mIusab45kLwm4WVdwuLzxnlkQyv+CQkES8rsK2ttt8lXO7z5uUFw8lxmv8WEehIVF86kY2wt/82JKYvU+tjjnUsIOvEmWZiN/5i6fzro89BfmadgD62/SvtGeq04pyO0I2n+s8/IKqlGf3r8O12se4veZde+t9RoyTyhRVuTecmFf7Q5f9kjd9N369IPqVbSeyx76reD89G/f2js92zC/VSnRGnmv7DvYp/h9bpg/41BOv/yz9ulN8TiX7TUnf9g8xonFYD6VQibcUyhx4PddmzR++UmtcGk+XIFK+J5P21vcn+LW8Pb56OA17BhL8cju6JWPv70u+5iv4Swbl+QMrrk/VdgpbBtdpj3ay4AacR4RQIT/PjKSz9Ws3tteSH4V/va8rvPeCv0fDPujb1Cmnt9eS2lU7h/BO3BcgasTqM20//DoH38AcU+gPoIFCwoEB+4ewYQKGzbEBw4fvoEE703EmFGjRnsdJWZcqG/fvocl+53sV/JhxJL+GtaDGbNkR5o0G9a0pzJixoQsWaoEGlToUKJFe26cKFDpPYdGj1IMqU8gUqoYc37MWHCkypMNtwIliTAhv4T+/sWUKdRmQo8rJwJ9C1fnT6d1ncaViLUqz7o7qV7cq5Ftx40ER5Is+VUfuK9gGzc8i7be0LXgcF69OjfoT752PRflvPMy4b1un9LVmzQw3ok0C4t8iLJfY4Ym/xOe9HeSH8mUD9OqzXz5M1yMw42rZOq29WjmbedyPr2aNUekWm+jHMmwdsLDKP19B49S5eSSMZtnNl68ZOePx4dnbC7ZPPr10gNjdl3VIOKRJw/vq227fboC77t/DiywvPJgOs89rOp7yy+8HATtqfPkm6yeyqKzDynLcKoqKsQY++8wlbrrB7wDjYJpQQ2Zo1A9iDqTkUKifILvPJsYrKzDqnqyBx/SqDLIpP5KjK2l75yS7yUehYtxQg5rtHEoHDlqbqYefRQstdWK5A4c2WYzkbHeCjTLpZJWdLLF324azUYqqaryM6pgvJFLvvQE08wxySSJtyp/k4w+/D60E/+1H9mrU6iN4rxLTz4N2k7MP/27bSg1jcOQPMs+rMmzOXlST8pGN7vTuRu9pFSfLiUtcrHYLu0tqE2LQms8yeCkzyjUeqqvvWBPtTKwYveKqiBS9UxWqD/LUvNWYovqdbO+TJ3WWi83EnbGwCpq1dsO+wyqVmgbAu9cZy01171qVwLW152yJYqpKxcN9q9WwwVHqg7BlZXehnojq85qM2NUYPeS25bbYTdKdl9ZKdVP4oKMW1LaaVsEbkOFTy2utHnz1WjfhMjVDjCALSZ3YHRtBUdjYjkOKiec2Pq4UQlFhrA6k/sN+OSJWbYYqK7aTfez2sRyNziPKlM1Zwftew7/YolPVkk7SoXWrl+gvS63VpnrCvq4tJ7+dLCbpNa5wxm9jBjlAC++uKGt7Ur6Y0899Y1jjxGFk20Kl5rqR4i2jbtSogXnirvHcOWbb6IgDZztX8kmHDA6D1cNqqK53rrPsrF+aEQHU3qWKHro4djNuuLMknHPFiO8tNOWYnkouoPeLmCRyiSqq1OblElymrW8OfmoZS9KqtoN1wt3fomqO+ugS3w8qAHbdS+i1nMFhzzJgYIRT+aDGsjuzG3P6yKlrqaw7ECzF6q/kgI2nX4F2xQ//ITGf4j5QLW88z1ELBZ53ube4r6VVYpxwkvMQ+TnFeqVDXz8A1/sAvi3Aq7k/33OW4rtWEK46bmnT6Yrl/6AtpjR2WV19GjT/4q3q5e8S3CXc9TOJJUQpiTubnb54cVMhELGaM96WHNgC1XywtUlhIkwdFOTOrieuhROUl3iIdGUeMSvBaVlEeQP8ITiwPsB5YkwhCE4XhjF8F1wiom6Irdot7jm1W1oYFthdr5Cv98BiDhl9CIendhENZ7xf21soxvfmMMpxZElLKSj7n4oSEohCXha+93bQCMkiDAsfS8cpCFZZzyFBalOOnQkT4b2MyB2ESgsxF6ZVvnFvJANjwR5oTzOmMaXBCUtb5piKlfDsBVOcoyCrEsY/9O1FcYLKJ6ikgSBtcVCOvF4NP/rn+tABkdh/mUhdmPle3CYmOyYjHbjhFeo0nacNI4yhof03/FOKc5uhoh3tOxXdiRZy7LJKlCKA1NcEpaXDHlKH7WiZkkIKcNe7g2e2UInquoZIgmGs5hKnBg/7ejPx9zNL87UiT0yJEEikm6JC/WlQ/1Hr4gSZ6J/qejufobRMWqNRCV9kGc6AsBsqXSRVXspSOxWzFv6jpmO0mj1vnK5CMWrpQ9lHE95BVF4NSyVcbuoYQ5zR1cC61VCO9H+7sKiqK60ZhwkFirridWNOi6jYFVONCm5qm7VVVbjtCG9pDpAqQUVJD6cpT57d9focBGcZGRkLTVJRbNqi202IWD/2/yaFDsSVSsAAmjVnEKQp8IraE/dK/Paklc5TZaymOQXYjKrWWn+8Vqa6axvbCRPaq0zrVZ9aVSyOj2bgjSnVvItcE/TLWxBVWChVVjIJBUk+1SEMVotYVeZ+lQcmqs2oanqU54pvtaZclBvXI2OajLMkNy0nFzt6lGOI6X/PNdXjQTOT4k1pFSJl7nIEmKJEOvApspldmBbTIRwuJo8FVe+dB0vUuwLom8Zhl1kIiNi5Ysjr/blwMcZjVUWfJnAOPjBsxkd3W5bl9Au68KnMtQAN6yjDsPmT5gd6lvnq5PG1naxJzYYzlS8Yhbb08VjAlAPv5kz2jrpIUycjHfv+YvjGY+WxwvG749lA6DYNqp1iEwkbTUkpJwYWMf/iyyT1/bkJ+N3Ky9OqF7Hh9zGogdhQCqymGu2YzL3GCkhOXOKsJNmUUX0eLxkklmD8ymPsITNclZJne18Z+tciso6cwoaAe2ZJx3SZkHaqTYRbRRFn8ebIvrwSSSsrQG7UI0U+o3NFCvDOG+azp1m8GsuG+p+SOW1q3YQFAP9mb1NZtKbZo58YJ2frOyH1rW+yJyfJlf3/Joy9UDjUEjZRpT+NMyZ7tR8YC1rBzva1sB5EbOrzGryeE/a5HG2rhpS7QNHNtvZ3nbJwORoptUs3HIdN1RHKpRWfyYgAAAh+QQFCgDgACwAAAAA3ACrAAAI/wDBCYRHsCC8gQYTEpTHUJ7Ah+DsSZxIsSJFfPjuadS3r+M+fgJBPuRHsqTJkvlS7kvJsqXKkyT79QPnr2bNf//84bTJsyfJlfPapTMHEVy4okXFKV3KlClSgUuTNhX3cJzAcVizat36tKhBhAoLNmxYtGK9s2ctVsx4T5++fB5DghQJDubJlS7zsvT40SQ4mT0DC+ZJMt89oeQgHu0KderUp02lRi66tXJWxowLxoMXr3PnsfNCl51YL7RptGonbnzLt6/d1/zwttRIO+U9l65JPhzMu2c/fofTJcYM0bFjpJGpgjP+1LJlgcMJEucsL97Y66aRTjTNPTTa0mfnqf/W2LIj7PP8ZtNeT7483NwPZco/GTinzfTtzg0n3th4VMiQPYaUcwRiJR1m18lDz4ILMpSdQPOA092EFJ42EVu34WYeeiaxdE9F7NW2l11y2dVPTzjtlJ5wVvHn32TIKafccgIOWKBlnT3kEDhk8dgQgwuW1t1DFRY5YVrjiajShhzGZptF4knE3l5MliQXXrmdqFOKOQHHoosvKsWYjDH+Z+ONW/XY1Vj0zPMdhUQaaeR3FE2pYZO/GfZhd/aEVmd75fEFUXkl8cSlP/3c82VXYfJX3KP+nYnmOPJwt2alp705JIRyFkmnRRjm5dF5vzl5j5xJ6qXXQ6Pyo+VNKfr/k0865bRYla3HOQppf8xJemOmREooYXeoCTlhnJ0e+V09aq2nYW4lySffPnsG1c612LZjmpSA6iUiRH1pyWVOipJzGThYPZSrrgFGWtWtaC5bD6cRcheem31WWFSy9srbrLOBQhvTTCOdiq07CCeMrZ/2KOlhiO2B45pNh85KjrnpFlcjuzNCRePGlMVLEbPgFAvevcwWuS+/3snL7EUQsyRxldFC5E96QSWss8La+ulsiA3bWVdMsO6UD2IXZ/yxU+wmxeu66EKEZmrBDjtsp13x6/LL/2ZYXok1F+UPtdcmnM7Z6fDsM3upjZfS0PwUnVM+85ytXznqgsyomE9P/wZjyC1a1rZEVSfLmNYutw3wXhCZJNNT/RjWjjtoV57OOgj3HOV2FXL79tBy3xycfvtBjRnfYcpo5q1RX7XV4MLWe7WRhye79eCLfz5SXcQBNw/C6Zwj/DnonI05wtzlWyS3GYYUOs75kYN33xxT9ZiYUa1+VetSa9W2QPYISa9pDYXmYNZybo1kahh6vU/TjedjTzvroGPO/cOjjfnCqDIvc9zj+kd65qefvPFNV9lLTt6Wxp/AZcUs4RNNBC11tfKJJkK1q5D6uJYaO8EFfimqy+jMUQ78Ca94l8tcp5LUPJpsKVaSKyADq5e6XukqKy9bFrDgZD5MYQZxG2Qfbf/04T4Q4kQgdAteOZZoQuKhDWGYMhLMbgOSF8ZqH3UbDtMcVUPUzbBp46DdWYTFqfGVEX222yAHJdI+r+XDiEcEh/yUuEQmDg+Fx4vi8ur0QSviJFH56Q8Cu3jAdr2rOeOQFw9jJ5rZURAiGASiGtfCnrfozlHjCsk93HGOOtrxhJfLox732LC3+fFmQkGX9saklHCEo4as3CL3HqLDYzGykWbMYBrVuD57tLEtMnOUPwQSQDnmx5OfREfxRAmazgWtj+Pykio7RhxCylJjeqMlWvo1xpI5ElkYROMu1ecm1LCxkl/jD8UymQ95dBKZJlxmwppJIbe5yoqyasc0aWj/w7+VaZXg5KY9BDKvTJVGVyxrmcu8Q6wLfYgtgVKn3LjEj7ohs4R3TKE7xqK5CTHvI36s6DloxM9e+ROb2NNly4izNYjMqyvbnNMGjzTFbgkKKYBZZwBl5Q4SejKel4PHRuUxVCmWkiT4nNUsuYi6A1LzY4/y2DUL17JwlqybRfmOrnjJ1XpSUkmteV9IcqrTAO7jmPAE5TqEOtRR8umZ9wRHivihT1tVM4FMo2bplsPXMjmqnLjMqjbH+FKWcpWXFOpl0ETEkbjIhawT5dJZ3/nTE6pjHWstqlFvA9IX+mMe5xjHUyXzH3dB52L76asBR8uuwkZkIjB1rUu5Gr55/6mRlL5cj1vCOhL5GCqAR7THUH5qDsuu4x1tJWWGQCrXuaVjkMlp1DjIITxzsRJ+MMVuVtV31fVF5LbOZB4wl+RYV0EWuH/cJGXtqMzLvsOCHnVbPuK6k3ugy64Bgqr1Uocu6lpXu7QE8FZ5CT7YfnemuF2NW8gr1oGhCLjDzI9PpVdcZQZVs+LZnOfgUihi0hVjsbTmFqebNL8KmDGyxcxhCzs4sxgrvuJ1C2vK+5tX+fFQ/BDucNmLDswKFVMgAtjEbnIzcGAMv0uLVFO9OCOlgenETUNLdzf4kIGORi0vJtbL2ifj1ggEspGNFTiE0sn7VXiZmANybm065GHS5P+NocVvmFy5mKLUmaTaLSSUB+taKXOVPy2eoEe53GUaPxi9M6mb8MzsxAtXio1F4XC0bPzmdoB4tY6hc9P0PCaPDXhZT5HXbKXMZ1ITJ9DOrORub/qXQwO3H++rGzqG50TMQlE89n1KoWw8zCLvKsmt1HT1wJRSFKvR2LE19ZRT3BWKgA8fFrnX5gjNYJEgtaw7hXVwlNlezGbWTwJxjdh4LZCaHK2TfWMKne98upNimtPL/rPLDFtYrMKPcAUONEaGuOD3tIpov0V0RNyxDuN5m62PDrd5tVRuwbgQPwX0z7o1LeK97fepK9ZqvJk9atty7dQGjoh2Wkxtf/MFJL7/DfO4ZtKnBEXRyh+BbMN70nCSHEaGU5m4K0UMo4uv0uMErnd3BezsZls531du276HuCSTd2RoNkZvrNLjqPnekyczxzpPfnPzxDRF56/keReRknFlt9bsEKlI2kfuy0DXtC2WpNK/Aa7yqYdVNm+0Oq/dHBgXEgbi5fj6xMXOnJNm/MSgBjSgoe32c+r2LZCvtuN4LfXAlOonGwJz1m3id5+c+2M6J7xTWLtdgm68pfCjk9FhqxZAK53QMo6908O19xvbxybSuryDae53acVtMPjxeuiPM3bSb7fs9u54qL37lBaD/PVL53fs+x3WSSOqN7jPvfbJ/XDzzoU+hLkH/zlaKQ5hM9WG9Ea+ds159Cpb+egDZb123M8+jERf1dP3smtSjv2tb5/7unceW3cPIxVsxKYcYGd+n8ZdiMd8ZfFa8icQ+KAramF/9gcx+DdjJ7dwgPF/HigTu1cTcPMTb4MbVscTR5NaxJGACZh6VLZnDrh2VPMQE4gZ9QdtFvhLGaiBH8EkudckJyEtiAI3siFHehFz9wFaGoMUR8GCTnh2qAdlMUh/31ODEPiA0JeD96dqcMdgd1d9QMiBQyMbGFgb11YTBIhkD+FKRuGEbCgQCqhiUbhnrjc49ucoA6WFeniBZRgisccXR/iFXzhpIbESEGN/vpQRbnF1skIrK/84cXbWgsZ3enR4b9CHhxK4h1rYhxAjY+AQd6oSikdoJXWBF+uBOxxxIjhxViqoGDrHhGy4bo4yh5VoiReCXZq4h5yIgeCAgbbhQS4BLroRbob4IX1yVQ3VMPugigJkaWrYhppmfrIIh/DWcRxXi83GHxhRFHfYFbn4jXy4i+LYh734FB6hJ9zRIArSEGeBD/rAjBX1X2vohk34hk1YjXyGjfqoXeAIjuPYi+OoEbpyjhqRLw0BRVAkD2dxG6p4M/NAFPM4ja8IiTs3iUN3jfuYkdzYjxwZjuwBDjlIjk/BZh1hGAaZEO9AEPGwIMoIj/YAkdAobPQoSMeHVRipkXX/eGIdmYsXsofx15NbmGsAGTMmpyctBw/v4G3rwA7v8A6dQQ++xBH3YWmuSJHRuG6Gp3HehJNV1jQhB2A7mYMVqIesB5QhIhCcuBe/2HJKyQ5uyZROSQ/1kBHLKBMWA4dgF5NtKFVLAST0sGwBhpNTaIOtx49heYNiCSoeSRuZuImLU5D1IA/w4G1vCZdxySyN1RH2EFoRKY3stl/T5ZeiZnq1eDtF93xqB5aH+XpVuJgaMYGJmYgA85rhI5mYVZmWqSBzCXdE5IgxCYl4mTfTlQ73IJqJt5XatI/tp11stI0iR4NW6I0caYeM15p7mG9fVRu0eRbykJS46ZZNuZJz/8kW9uAOw8GC87gU5XAO7TBfy4d2XAlggTYa2giOjVedFwFtjYmIhON2GMJ4pUFU7/CdcCmeXGOewQmN6SkQ55AO8/BGxgaf8YmJbGcR9FmfPOmf+NmcvgSdp+mfBUka81Ad8dCUuHmZ37EOMPkUR6EU43AOEdJhyZZ8E7p6jQeBqYlvxGGfqcFBGKGYiaijFUpyIzOiJGqilRmXQKKiz2gU4rCe7WAPdEEwKlajjNF4M4idX6mldpiIsUka66OJWLosYKpYtRWgRzqgbqkO6uCUniEPTMoo5PBcHEalMyEfNUqjhImlhYmHfEqWLhamX9o227Q1WlZLDNEZSMoObP/apk3ZlOvAmcUxnPcgVn+he6zGlTdpo3y6pVc6MomjmBsqEZ/idm5CIS6Xqm4VGvSQqJ4xoGyapG6JDtMjEFBqdSZRkl5DREKpcZvqgvO2p4Rqpsv5qaQaqo2HrD26Ta2qqs76rGOhqI9amWxKqw+RDvYAoU7yi8YokMZIULQoYKNJgVQIqmvkqc1XpmQ6pqYZbeHRrC6nM0S1M/MErQ3yqtSqDsoEDxHyQZihJ2snWBKKXXpKoTh6rOyXmumKnf7SqeqDZWjBIKkaFhTLGZ/hcn5JDyW6purAlHNpSXFhqRBBRNFZalZKdAibsM9pdAxbqnx6WCkrsS5XsTT7pmz/EiTMUg8aG567uWCt0VhIAW0kU5NaebJRpqyEebCduqxlJ7MJQrM1ax03mxaI2I7u6BYj+4cjlxZAp1UDa7QzGm9+urSBhnw6q44JshlQqxCeIbUKgrO55Rb3oIe82JXaZKTHBrYuGG9Cmq5k22Jm67TXobZraxBt+yNyySwYEXtze6Zb9qPHirAQYo3jqrefBq4JW6xK+7fu2rRoO7iFmxCHyxBwq4geoQ/4wJ1EpWaRyRDyyhA+MhCgVrCWi2xem7nLqaGjOjhme7bwGq2eEboqabNvmxbgsg+oW5sIAw8MQbtecSD5WLuzyEtZurlrAbnJGrif2xBtK7wWe7HF/1tYloq8tUlUzNu8qgeSa4Kcv4qNQ6t8ZDdv62qhSSeqL6u9v8u9neG9beu2CzKyTycQqNu6mmEdifu4EJFrzOa8+vi+CzhJxFqu17u7Zeu5qbq/odu/P1IUq7aMEnMPkbm8YqGbVNuNLhW/J/syM2q2tdWn1uulZIt8gqu/hPuoNvyo3wu+tBSV+rBw76MPIewOBvEjaCG0igs+sZWnQxe/vcu1H+e3nAuxGTfDwJvBxAuuDZOK0vI+9jCvhssmEZu4WIzC8RmsTRxEX/mTJIe9bifD2wu6hTu6ClIyPFyX0hIRXqwZziqXOErGmnrGZRfFMMyuU/zGcAy1cvyXEf9xtXWJe++TxyrpEGpyFmJcal4rrseJuYAMs4LMmoHqxvn7tq66Gf1byjYbJCDJyDYGa+DQqqI7yfRnhXl7VYCJuZa8yWfcyTfYuaCcIEBCoqYczKTLxyC5W6sca5I5xMOcuLKZf7MchbjcxI6rrLp8EVKMv9fhl8AczBpcvBJozFvnO9WhzG8bJM35h/vwzMFqjUwczdX8zimLv7+bsdvMzZ+Bs9+cir7xyDlMuoSVuBe4amfczl0bzS4Lz4K8yb9cHeV8tqNsz+H7EOC8dbHWzcSssyW8ER0x0ERr0AfdxggNuAqtjgYcJE5rzyuJzxJtx7gHHOBQyrpJUAyiuGz/4RYZO7tUVtAezbX3S80Oe67X3Ltom7F+idIz7VpanFNcxyMw/b8C4c9yGbc3fbsMeHpUzcJAPaxoPM2TJNK4LLNEvdDBDCT2ltRbrA8DZcqkyyM+EtVt0RFhTWovxV3qR7kNu7RovNMerY5h7bQLAr4NjdR16SqY9yEPobajyyPM7I7L6A997dS37E2+Oq40Sr14rdeYPbt8TdQ6MswYW8kCfHKna9jBO7xvirOM/TiPrciUe8uVK4fze9kr1teZrUabXR0MAhGI+9mylZmONbkCQbgajNrvSDDZ7JcROtevTXYqpqN/O9uhXM5kvdWfXKpbY8j0LN03C9kSvWpo/ykRI5oj8QAOpv2UAN3D8eHLQJJ+Bc0f7XulOc1V29u/RK0+28h67Xrd8HrKq73BXdEWCWw+k5mSGMwZFlu8jF0U6p3bcsjOLFWJmWzVYZy/ptyqU/0dsFnd7KffDw3YGOvfI5nAfSLES2mZKUkQbqog9pCKSJGqDE7QKzahlV1vy/K5wfuo9G2cDxvPayQvNo7SpczdSCGUBfk769Cob4nDnkEP7kilCv7ZyG1vsjXL7iu2ru27aNu9OD7cF544Fgy8QL7krD3kIj6iS1mtHQueBG4d9cAR4dbiUK7jRWvl2SWFTbzQo4yUNjzWck6mX07DYZ7SY/4QAknoI37k6P/QqLFaoPEwl+8jVkKJES4e16IWrukn4YBM1IB+wzdc4Uc90ona4UD+tkNORIYeGgTXXoresWulIPggsoxHg5Ne35W+zguI6UId1oBeopy+5zl+wJnerIHe1COJtd+N6vWT6KresfDQjuMLPsbrIwve5X5m680H29Hc3/Xc69wu5jgb7KKO0i9N6kjhib0IbSNKOe217O/Q5gEsMVhrD82qyHHe54S13PNnshxNS9q+7dzO6d7+7Xcu7MN+2oP+icZ+7oeeDomurw3PDkwusgJs6q1LFtNu7zq9qUeX2VfV76Ucnr5eoiLfttN9xiRd8Pc86FerD4QObeabDorOlFD/meASX44CEd2IS+s4rdwMfOVfvdon//FuatQln+sEP+zlzMGx990hPJne1u6vHsA/zPIS/ZqdffFFP7BCt8KbvGxAL7MoT/JZb/RpC9MkSuqDXmhMb75JybwrXpeMQfVwLsk5T+0PrsnRjutlN2Vf/8s2O+xjP/C6Dsyc3cpK71gf0vQE8bEd8ThPYe5PjvWf/rXc1X7RzGd9v9B4vo7RuswCb7Ydn/l9XRRvjfipK5nuIJel3/jm6Nsz0xGzbu/srdwd3buDJfq4T9uh6rm4b/itnPau/4l7UimMbMcEc1Pv/mUyEft97t4RXvuHh7m5P/1jz8uJ5zKBj+XrLeQI/89qc2t/vo2n3f10d5x71/EQuh9qTGzJtKz36kP9JQ//d33NdAyBE85dY1/uHSxWhdb4ALGv38B+4AyC05dQ3z6BAw8elBcx4kF6FS1erPdQo8Z6HQ92BJnRI7iQJU2evJhS5Up6IVm+tHjS3kyaNUvOBEeT5EmT4Cry3JiQ4VCNDAkOHLoPXEGE+PDdW9hQo0Sq8mBm3Jh15M6QXEXyBAsS5sqOMUu2FJuynkqT9jrWhOv2bVaSXL16DEtXaNKNR/vxFXgQH018Cx1CrBpxrFasHx+GRanW5VjJkC1fflsvLty3OO09zmtZb1S+ff8mZWhQKbjBb+8ZRZx48caRXf8/nrxblvLVsxgx/w65eXPnz58PygVuO+tepYE3MlQIVajq45rtFXYOLrFEehot3lZusHHur+J3806ePqxw9jo3xgXp/jZdg/gQgjN6eLm+e/37KzwooZxqem0giegzqLvvxAuPQbu82omk89BTr8KbNqsPJ4OMo2swDBHsUKH8CNLLKROdkk4fhPZREZ+3nmIoMe9Wougi2iCsqyQJJ2TJQh+Di+shDkFk7Tq4iNzIPoSi8os61RIa7EQTFVIxtQxR1EdG+hb0qTvQxgMPq954ZOtHyCJEcsDr0mSTzcKYIzFAKu/xUMqnllQxqITu0ZIuLlUSr8aMUuqSzLHMzKv/rjYXZRTBKZmT6sk9TZzpRNbuwZOogwqyUruJEKyoRhsfMrRU3xDFrVFVV9WIStKsVGpOD3NSkrWnqBwRQXk2qoqlQk0FtjJUdWSVUQ0bdXWvh2Ldk846D8LUIFdz1XUqqnwt9ddgzRqW2GLbDJLNZJUNECH/KF2zXEiz03XXh3oFVNttgdWx228XPfZYEMeljz87K7VPQPzyW4ouf/yJ7VNPuSM0QS+3nPc7smqz915V9d0X19XkNNfZE6+71bAmNUL4YP12PdBaq2ACNeJQJxazYouNXVRjPefkz9+QF2pTP4NSXhhoh1/aKKXtrjW0W7BmJtK4IdMUuN9xBRaR/136mGLqXaQtAtpoxUIlleujt2ZZWKUb1Ei+Nmt9T9U8H3obT35Va2jkh7Luh593fx67b4Z9/bsi2SjT9uxUs1IbxKeLBVDam6e2ueCsDfLrKLpZPZpLioLue2hAYTYc7Q3BTdLE+k4nsvHl5K4atcDiJPG0uoti1O+vvbY9cBpBD32rtI9bm+2HnII66v2SdT32yQ9yfWP84mYzd+nHXoz33unC+L3i2BYedYshT8pyy5eFjjRJoZ+KV3ezmp763Q9Fq3cda/L+2/4MinbVtwVsbkTYJT9M+ZLln2pZq1rtg1ep1iK/ntDPVkwrl9vkxLOhVK4gJCpNxwj4wNqtj/9vseFc+xQYPwZ65EjdgyC00Hc8acEpdsxDjZM0iMJFVeWDKEvYp6SXNBKWUE3ZS2GA3oQgFVFNWRhsHouM95D+0HAj8YCIynSosBwikIcl7MqR9NcmfRSmPv+5j+Na16mBkdFVBKSS49r2kHhAMYppQmDnyDSPedSjjljMiBbp48RGmY41rbrPuloFoPKdyz/JIhI8FAkPg7RRO9GL49Hk9aeY0NGSePxhh+rDx9Wp8W2Wss+dyNe/DOZMKHva5KNcRZ9FLhIcrnQkYugSSfedx46WvKMPHZikVMINfXmKWhoFE8opFSWJG+uiUxRCvD/aamp0UaRBWsnIV8IjHlT/ZB8tt1M9n5AEl7hkYCb3yMx9tbBZGySmrYo5StTEzWPDHKadhrcRakrTldVs4zXbpc0Els2b36RjOHeZFT+OpojR8c8G1Wkn/tFtbsMjXkTtNFGQCeZprTzIIttowxDyU3e+Eg9AAyo/cXaInGo0J0LlmUopgexWvjzn/TTiFMIAbKXxYds9q0nNaV6TKlrzKD0+eqhbXpKBT9ue6eR5p4Q2NZQPnCi6arLOtzmLg0ICi6UG9RPr0GSa9nSlRvvEN20K9Xa2LKpRe7c4Wj11qVGFqx/h4iG5ACx/9yFmQW/TEm7hRDdCRUtNpslInmLUkRwlKy3NurIJdeSbJURq/1slGlfKRmlDMwESZq2zzpla6ksK8k2ETiXYaO4Uo68Ex2E9mrmhUgaP8QFeUj2b18qia0M8mauU5qlbxyiqcLpJEJA8dM/BRpO41lSkT4EWx8UqkCdm89GQNLRSJUU1t5nMalxRRymQBKpo7/sJ/TBb3NNmtJXx0Gg+lctPl1kvupfl0ETjKVU9MggsLoVrM023Fd8laJLhfQ+YHlJa8qK3p+v9qQjbu5sKFadSuz0pfcP1JZ5QND4VHZ1bwONbrCwoJfZh0XwyqhHCknewCGbv5xZ8Kq5exmnpYilE6coevFhGviaplYaA8t1G5pMeAcuTXMxrXsJWc6emTW7nmP/r4RX7hluQeXFnQUnT9iCHPDjmrW7mUh379oRUPVZvRt7WXbB+tbhIPi+K3bVkLzX5JZiJsowXSmXO1Gs+MQMJb80TE7YubXMHaeM7BP2wrT7MxORFc5pXy1ge+Q2tlolzPPU7Y5ugrcZY1quo8MKgJ/d3I4J+RzzAdpFDl9rUMpqeqIDVN9euZ6DzpTQzkYOZCL3opO9S0HdbjCYEqRe0FjF1sMmLaumpmmyUYTVR7/tgk9L5wbPWcnJcOp9TUbi7I5GYf7uZ2o0KzsDCBneSJ4Ky9iVocBdRrLJxC2MIS9g+yOlRaG5yWc0oScDkQZPEHgZo9ao33CUOdr+hiMD/ji76rPFeNtzmK5wuI7wt1hYPyFYYphyFrWEaCbS/wT1gU3+bmgY3eKvXQxePMXzWDvfWnmsscQRduzyFHlVWQN3GcBPZxDTXaMFBHkl1t4Wt+JNwpdfyZqB0d1Qv4lnLXf6yX4NN5qHGubDtmej0pnfgO18t11AuOiY6myZj0nenJ+M5rl5HdbQZz6hBSiqBe9zUZRZ2PnUukbZjPYGMPtXD6UMnB2t2MoSCbsMA35GVgmg3NUqQr+lRc6ofWu5jy2eaN2r3ax28xRdCEN/hkxYVi51ohQrJUzdN9v/GfFQqAbWgS43af+ezb263OuXPnXfYgkjzmQH7objSWPuO/zrxbd+dqvfNldS/499xb3u41Wx396aOTpBprJi4KfxRQ7HtbVz7xXdSkeIbHx7dL/4iQX3z4xd3+cznHV1Qcw9o577n/x360LrZZnoIHMw+RqtK1rF//u8f/P9PvfJDPvWSPbzrNPUbCv5oP857NIszC4f5M4dxI267Puw7D3npvwzUwP4DQAEEN9eTvTJJOXbaB/bDs7+KPt9RC7azPrmjwArst4uLl18Dhw20wQ0MPw8sNRAsQAOUiaxICgU0CXrBtooQtZ+giFiCwSXEPyYDlH7TQHaQwimkwhsEwAD0QB4sQBHkuiC8BxQMFtvoDgscPn5jwgosvfrrt9Titv8MpMI3rEIcvELVE0At7EHa27IVKSPocJGhWzAJ9LEnasElFESBa7rrayQ4fMN1mEJGZIcbXIc5pMPWm7wQNCs8HI9XScA+XInWOrz7K0MzjEHtQ0MYfMF4UMQqbMRGtEFJ9D5KPL9FExxGa4taqRIvlItOtDwe6bFQG74JVLy1azuMuz9H6rdUREYpbEVXHL/js8OQ40KcChBSYhETnMVaMpQYJEYlJMN4AbMXZCP7O8VkTEY5ZMZXVL5K3Dn3SpdbxMW1yB3K6Mb6U0Pswzi5C0ZvLEZuXEMK7DFyLMcMfIdI9L85LL9nlMVofBHHcR2+Wyx5OL+xMETs8zV+Y0MPM2SZcJw5NnSjNQTGeAgIACH5BAUKAOAALAAAAADcAKsAAAj/AMEJHEiwoEFw9OgRlCdQnsOHDhNKlCeR3ryL4OrVs3eQIL+OBPOJvEey5D1wJzv2AymQHz9//jzmm5fuHLlx4XLqzClunE+DO4MKHUo050BxSJEeVMqyqUF4UAvC6xiRKsSrEBUqnOeU5UeD+/KVtEeWZNOvIF3yWymT5rlxSIX29DluYDhwRfPqNXo0qbilXbvCiwdOXryoAgkX1MoSq2OHCANLDin2Htl5ZDl23PcV7cDOLg/ys5fuZlKdSOn6/Lu3dVGCf5kalD25sUGGtR9jrc17YGV7FzGTNZhv3z5woYmLzIdcoL9/MGPSNB033FzVrF1r3wnb79K/vW8z/3zYsDDvq+7c4R6Iez1IzeHBiQQenCtLkcqX4wf3/B/0mPeUBpdfqq0mznYIWieQUkl9B158wWmUUT3suReYQ+ll6E5BkEEWH0j9wCSQWPS1M4+JBt2jH3MhmbRfiP3510+ANw14nYEJJohXbH492NeHE2ok5JAYWWVeelOlB447UE2lm4VAEhTdiMC1006GVrZDkIr6FWQSSSzCGKM/AdpUoIEH5qjjggxGeVBmAmXGkT0SWvUQk1OBAw+eTfbZp5JuGhRdTODsc8+VGmo4kD1fbplZSS29BJN/0B1qUznlYJemmjry6BRt4cHZFERI9qmnn6g2CWigA4k5JT/3nP+YYTrrrCqcSYvKWVakkvonYjs1kUNOpgNyaixfLDUYJXy3FYZhqalGi+qq8XH2WT+uRtcPrFeuk8634ApkonC7glPfRYyOyNmkvqJkZWnkVHcsp7GB5B2rC2EFranSpqoheYExVxxnnWGb7T8tHepOOuic4zA66bAX3HDmnkuxfPmsNeZHsdYE17zG+uigyEC2x1CiiU7br6qJeuhUSizyKlC2zw20jz0Lm1OOOeacg05B6Gp2bpECqehSjNB9RJppIG+XrMieSiYPV48NtOGSKKOMdal8TpuePOqBDXBtahEkJqX+IXePO+dgimnPBKUX3EJzb1ncS2j7w08+7bz/tWnTRAmErL0k3zuqbkcuuXXWGS6eYb8Z3vk1lE4RXFBMhIJDKTgzuqOz2zsLBHGt41pon91Ho/0PrKXJC/hQghfE14O0Q90VeRAJpKjjiebr+J7RMh62y4Gizfnan7ttDjg+0zo55QQxejfSMbXD9OuB4yX7Xcr6CN73bNrpWGFa8w4oqVp3/afwxLtpvHx9g44p86PXOjz0ZRUXItr89P0x9rALD4+iBpJ/OWZDWeMdh3ZHkPUJL3IQOV142LU5fsyjbfJr3rf2dD/KMcpo1ANHOooFQO50pU19UZZTHKgeBCJwcXG7GrUi58J9CY9lBpTgBDW3uRnNg23K61n9/wzYPnBIb11oy4eAXIc9gtyFcD1SIWxAApV3vMNPD1wVEZ+lpC5qCIsQBBv7iNab6GyOP9u6BwZ35rBzfGsdUOmgQaSXOv9Y0G9/AxlenmiX7cXOO4azF0HWQciVrS+GV0OkeqzGvid9cXL1uRhBjHOcg1AQYS1pR/J69jBaXVGO0QOTxijVP+rk0TV7DOBBgiK7KJKsILQh5DquCA8rQk6LXyvIv3LjHsm1zCET20wlL3dJ5yhxkw+rHzx2kysu9Qo6SrTRKfeyvcE5MYBBceVsBggeWXrzm7O0JQdzWcDGsepkv5waZopWkIERE2kDIVM6QMczn6FDHYSsmhE/OP+9SX0Ej0zsEex00pXXZLNHsASHK5ECzoYW0mtjM0++rhIoMUZuYsyaZEHYMhBM8mdtaywH/dCBDjiqE6Mf5BLBXMU8NMVlmqhcpV5gOUCFdgehDm2otMLGoSchroiHgyC6wpM254yGbZ/jJElrJY9HgUk/BFuLmP5JLIGuqSOo5J5Co5jCHuUUnIZUTIV8+qTzPG+oIBmmQYpqTGCdg2fLE2Kt0EUSfQxMLWrZ1lRpZCNOye6a2uGm9xbqTSsa1rCypGW/4sFYxmJFIWMlK/RA8hAdnqUgZ/zModIBV3D0DJ/q5GdUpQoTbA3KH3wDKExLCLuFssmVhT2sFQtryCb/NTYeWZmoZJmJL5CwdWY3c0fD4lrSsNGVMwY7rXL1Bo74SZO1yMrLQhcq2+oiVrG1HcxtI9rT3U62twL5LX+4xTARwvGi9rgbzZYLk71Np68ltAs1ZUNd69o3u326LW5zd5DKehdfanWKP/phqHYAcx4HnoeKkMte9hYNWNfLEWAJmkrtvWZH2gSHfe+LX6jo9zGQBVp9dgteyfjjOPnQh4q/pN4GN1gghmodE1uDVQs7zbUa3nB1O+zh7eomxAShEJ3qQQ8SRynAgTHYttRiHJesV7ks/czSZjxToNyFXoD8i453zGP9+tgxkKVQQTSSEJ8GikUrNa1yO8re5LpY/0Qs2RZN/hfTPsq3U7TR8pZl22UvfxnMQmLWkIrsGDL25h4qHlhUlbxc/rz5xb4RCSWTgxy+xUs7Vr6yhEGy5x2Lc7F+9vP4EhJoUQlESPOox9BWXZ84SRIliE60oinZZLzaGjn8qLWT1aytr4RlRcuxHHKms1oKZ/pYB+k0nz8trVCHGsSkntCrJZTq4BA6wavWiFO/9FQV64PW4A43rRWNVyWHZkVcWtG64BcvKht7wk6rcLKVbdhaYjdazn42mCsyoejBB9XBwQqryVUWbpvE27IG9opGJOlJS/XclTEJox6VsZWMBo8XriaCukLvejMb3/n+8I8rUicjxqkjqv++SGUHnmpdFZzb+jj4crytcIF5ZC2+/g1w6BPJ4vjGHZfO+J03DpSCdNyWH09VyL0M7YpIpNSTYXmEXG7wqlvdRV3CtW8so3KLfg0z9xhmKd19bBoXXSg57ri9w7p0pkuWHkIKkqsDk3KWywkfV7eMPfDB97xjXa0jAQ6T3kHIestjI5VE2Dzarcqhm92JqQzK0ZMO8raL3KdOf3rcJ6ORgd+973znu8szE3q/L7iSvwaOPOCxDnaogx2wn+Xh8aEP/iDMejDVnuAwzRKhTP7ezba8qDGfec2fPDBS15XoR6/80lsG7ySRk0opSSIEv4Md93w9O2YJd9rDSIQ4uTD/NSXj+8lnV/j5Jn7xh6TtrvC861NnvvxDT/+S4EP6YKK+Pu6P4HWo4///B3vx0H3IIWdB5zQmFBhPpBOTdxiDsTLo52xkVXykxn6S8X4jhlLyR3r0B3r3pytYF3h0Ig+tpw4kFYDvQIACMQ/mUGwzxUeTwYAdp18QGIESOHJOR2SZt3lOsWoRJCfapnx714F4t3yjB32Idg/3pxEk6Hon+HopuHenhg7htyYwCBLGJoOH1VjVZYNe6HZPQoFiCHeqVnLvoWrAVFkb+HlEuIYppYQfWGTwAHsAKIBwNxDzhGwad4WQ14Vf+IfpN4FjuIMV2H4sMYIIpoYX84FuSCes/7YR6aKEmUFk8mBFsOd67PAOA4iH5eCCeSFTCbg9fsiFhgWIf/gQjrVvgyiGFihmb4KGavgmQxZoAJeI2BY0rkYWlMhYhnWJmjgQ7NCJxvJXuweDFBYOppiMX/gQq0iGQjIRFFFkZWYRqdYRqldZG1EQjhhwI+ZT8feMEMGFvqgYweiJ2dMUxqh74KCM7BiBzDiI7EdmxUcRCTYk8GGLF5GNiwKLj8E4AqeD15YV8XB9magY6tCCRGdlRQd5A9GODol+0ciK8TiGAodgLTeCEcQVk2iLXrcvqCJyPaZd0UhkAwl77wAO2IeQVyVfTsFHyPiQMLl0ETmGg0aB3lVo3f/IRY9jb8qmdBVYZCWZkuUwjAsZO1gVk0iZfqv4jOtHiY4EQR0UcOjjJ7PlUIc1Sw/lYYVIku9wkJniV6vEkFcWeUlZlkzXjPKYg/KYFTd5UhzpDozVJ4jVUHOZWLZFEdq2hPTADjpjjp9YTbsXeTthloTpWM24fs4IjU5HVhZ5EQHpEHFZRVUJTldZeIqFW2TILPKADsIIlqAIbzlRmIUZEe+4lIlJcmlZZjgZIaoJmZFZS7VklbREePWmlWSIDwKhYvjgOX6Jdr3HF0UhmoS5b1dBgfF4nJ1nbRGREANREeEombL1VZYJm4MREXXybcaBD/O0KadhHfKCUL3neKj/IQ7CaZbEmRVNiZzsVx+Zp1uG4YD2JZ3hREupCGTGQWDMoVrTxVXhWRRJUZ5leZ6liZrIOWZ1B5DM2RCuGZc61nqXuH3fVJsiaZ/7gC3HMU8uFUUGZU168Z8ACogL+mdsuZzOSXJdUXeptpjh2FjQSZCH9aAw6osSiltbglwEJkKZ4ko0hiCpQQ7n8KEg+p6XV5w7aIGSgaLOiRX6NVuxJ1sxGqN85mEDQXsVaqG7aQ7PlVXbIQ7lcA4mkg9AeopCKqIDyoMGQXveBoci1nWtqRu8SHjbV11P+qB2iRgZsXffpmRX2onuNi89QQ7pcA9qEab65l3bpZjOaIYH0YEd/9F1jkGmldhpc5pYtjQQ9YB3eWowyENC2MOlXtoSBkOow0dWjYWe/HZqrMKRSiqib/p7iTVme4doVQoTx4FxgPOn6cAVeRWqQLpbbaqKCSqLrnhqwyoQQLaCqnoVDqhdzUkRpDh5hLQYG4GmFRodFjRCvdmhnpoOmoEttsYPYbqqj/WYptoUs9h5JKei9FicbupjxpoQz7qkOtYR3UetYtI5nUkv4wCoJqIiMIYx+wGmvaqs+2WqRHqsBxGPyTqTCVpkzoJg5IqK7gpZ9MCitSSvG3YQpIap9zkox4Glp2FV0jUOXgofMRM9A3EP4fp2xhlkBqGDNymGu+WuzVmxGP9rXWKlsXCHp5nqsSyIKWdCZ3IhDvyKMcZBGVW3soJYpHUyrL/qXTbZlu0DlLelYzlrEBsba7MaHR9LFzqaTfvqRloCsMWhbrQWc3yXlKtaqiyLmnL3rlI7rvPIsI95bf0lpJpotSyxsd62tbTqWVU4FKnRE14KdnVlVyKxYojWcPuAtnTikAcbtaZKkxTStM0qtap5mGPYGGP6rPOKtZfat9VaWrWnM0K7E+LQM4AKa2WBqd8WcyTRd7EmiXRis+wYuXM7ucYXJJW7GE+LuZqbg01BtX62ZRo7rXVlo9hyEpeyGtlUDukgN3EyJHdahLiZsuBQe65WD5Cru5k3oKf/Ghi/+xijSrc5uJUVuLcIQWhe1mmgSxYcazA3wzzD4rWpsTPFVTd0l2qdZ6ntKLeDiKpNgaCkua6uSb4WK3JLWbnF2hXw6mxyaligi7wEExZ9U79oQrK0AjyTIxDrMBCFFGS+NDxwebu425S9EbESy7Zj2qKaeKjSKIYZwRsPXLVO+qRWtBA7y7HGgTOm61KASpeEJ0sQOkt5cmoOsSd34sKlaIPvaL7G18CWSllPkm+zaV9guIMzXBu2a8O9OKeZqMOQGGsxB2FASxfl4KNv5KB0ysaxB0cXsmHuCMUEKsWc265L58IyuoUKLBH9prMI28VebIlgfJLsscN1ZRkY/4rGPgoxJEUrl1iHc5rDBvpqcgyRdLyVdkzFzEiwbceTBPmgLipbt+XHDdymHOK5byrKOMwhkOi6scKZacKl5oAOdKh9mPh6AYjDimUhUjgQVmt5JBqslkq9tyNZLOxsPRbKYJyJpDyAZEgQNexY0jyQzPyiMtrKzZmXs2sP6wCy1jEO+AuAuHzLt1zOzkyfDGGGmqFj2hVyBUzMkgGNCDGzqdi5FjsYhDyn6HyJjJW+xvpsDcnMe7zHBB3GxRyraToPsswTaVzL2bfLrkfOkmzQ1cmMkCgk7iyTHiLPwwuNcZvMftYkXxzJu9zPJqmJdxjQOIsb9LDPorzPJS2jef+CyGlqD/LQNkkhzuQA0RFN0UANo1EKwxFhXbbVYyxswO0Tj1gbt3gcalUEFQ4a1M38wiu9jqHMx8AM0yl9zTdsRYqRlypmHPrAETrtE28jRE8Y1BId04elXR52wEbtYUhdsAc7Znvr1E890jz5oBVd1f+MxAf9wi59wyZpzZgYxjncxKem0JSkDzTxw2+TTOjg0xTdzOlsS2xLhkU21/m12e8avj31vXrtyfnWophdyJjJ0gRt1cZq2AVZklDIWAVB23FCrY+9mTyjPD6j1g1D2X8NpfVG2xE5iVxmW7Y9tZEhPqWNwHkMylyd2nZIEEHph5C1ykItjrH9HvFroSf/8dtw1dsk9Vbj3Ub2FNys/MLWiA/H3VgfjbDO0tw+JXx6LN2ZvYmvjcWrjRDW/MVg3aq31RF8l6neDQ6VzUlvVU9tVN7mbU8RDaUFmbDTymVs6ywgAd/yTar0rccH7dYqLc2XHGIVG8H5BhJ4d5/yi5ucieBwlVT1VMsLTlJrLdTOnLOaZw9DrRhVQRUSRb4Z/qgip8zQTW+2PdD5JuKe+98D6GUJi6dVKr/efOAJLj878zY78+Ixfk+83F07+5FiBd8TpaBK+uNry7ZL14CKwXf8nX7NKshNXBGB/bLTSuAEVnvrcOC7TeV6fuUK/oSsHOHGCpl4idziwbC9NB5k/96W92x5F2vFhmxEoVcY8KwQANm+ru0UGjHgKN649gAPeJ7ne77nff7g2W3XqXg4T8xdiV7af8gSl6rm6xhyYeacoebRlpqZrnuf+4CbXhnqvk5PPCPjbZ3SAn3H+rTq8v2FAxzp1C3opSzNEuFnYF7Mryy6jTsPQvnr2q48wj7sSv7sxk6wyJ7hhRpqjVGv1+u7VEsR0ry+0g4S7DeEZKxiHFHZ237v+DvjHv7Ccc4SgTju8FzFo+reDozu+LDJQAnm0f7Pts67eQl99Ech9o7v297tbf3M0NwUQm7Xid52e81bXTGA08p3OnjhDb++0x5k9kiEHyjxb2XlFC/qFv+/740Fd1IqEO98W3XdY+Ne5hyNOOrbELcZeqmZ8kAyJCw/ZAJxfSYo43ge8/Kj1uTc1f99eNwbkqD2mkOq4SYM9OKbgxFPZghaYkEyhB1IZINE0U7f4my/7T1Ty1NP9RmvD69Zg5EJhsj8v17/9U8X9uznxyUmJEnfwH4N1E5f2SSVPKJO3nE/jpD+bR2m8zkvtXjv85UP8gVPamZfuzV58h8CiWYfekrPaees9k6f4Hme+uT909pnRQyBnfsQ+Ql8zzcZpGb2XfRagWFfiE4HXq/chmjvu3XC9EBNzjLO9qj/9mu9y78I+7Ev+3EJqSuq92UVHoW4+4MGkL0Fv6L/L/pkJvx1MpBTb/hrr+DB7vRxf0UK8dinIpee/c6TD+QwiXnx4YybL/bHafS9wfKix5QAAU4gvXoCDcZ7x07dQoYM0T2EaO7cRIoTITZk9y4ePXwGBeKDF/LdSJIl34UMGU8lPJUq5b2EKa/lTJozY950eVPnTY89ff4kWK+ePXxF7QkNKlRpwZ9NnfYsGjWqPapLmYIT2lOlwoYNIX79WvHiQnbxhHY0eA9fPZQm3aJkGS+ly3g6a97Fm7flS48w6dF7GhirUKJTrVoVnNin1KlVCRdV6pMeQq5dvYI9Z04iWHRk49nruQ+c2npuTcONO7duXbt6Xevl2/MvYMU//5UWxuf4cNbatRkbpRo86lVwtMHJpFzZsjrMmi2iO9dZHTt49fR53LdPn1p7pt/CvStzJ/LXr3f2lPe3t1OqjXdHXp/4N3CDwz3eTajcMmf+083a0ye77PQhcLvcvCMJNdXMi0kuBR8Eb6/xjIuvqeAuhM8g3ip86refOqLqPvzY0a+r/i5a5zODRAOnwHtejArBkR7MS0GcIMQxrpx04lCwC0PskcOoepsMv/xKXIgzjOSx5x6B9umnnwHV+k3GkxQsD68cIbSJpyADA+1LMdFSrMgRSVzOxIemY2cdefC5Dpwoo8zuI8busZJLubJsaUvUHIyLr9jEJLTQ2igUEf8hjWYaiURH0VxuzRQ5WhEcAQe87sXtXsyTxj35BNRPllBSyVBTffvyL788+ksl7x6FNVayMmLSJ9EuvVSgAjvFsaY/V0otpS1bOrVY+YZ0ijiDZptNJWZbddW0WGFNiCS5arUU12x1JTDX7HjtdSZP+xRVR2PPXazAAnvasCDenjWTpnjdmpbaRQkiqkVc9+GHHwF7ChDKKMEBV08tdQzVT2LRZbhFbgn0aCkNs2IWVEVJqtdaZ+shc19c/f0p4Cit9A5LPkkV1x13EG64YXUDjlMgpg571shFayqJxGpHaumvodASkE6Ps2VRn9yAhJLk08q9C2W9Wma4QFxjHmz/t5ppcgtnjDXeiKCi4swuyn6FrpPqou856qzrlP6uXIQdLA/qc6We2smqJ4bXZq5bMm3jfFcM2mMWm9IuN6Q4Zrtkt399Wu5T8bmH7ktjtrqeinGOlmfXfA4TOykFHxwtyJ18OTd6Xpon8aUXdzovxx+X/HPtZLYKXjNv1ryku2Z7jMwnLRVa9sHBmQ/yl9Gu5yXV22Y97lRfr6/bsIWOs/a8scbaJEXr8tn3nuYkW0CIif9RuNELNFye5U1ifcHGnZLnKfWg90j6ObWr3nZosdfI2qw3+hl2WAQlgYUPf3EKzlCGYr6iRI5AyFtfSZj2vt7Ezynzo59BRCa+/NlO/2+6qwlBCDc84eXKI0fTTe8a6EADRTBBosJLBuUmPQ6i5Xp56dtMRNgis5lQMMAp34Xu9DIXro5xNRETomToEwdial0DuRoOtde1HerrX//yTflQyMCo0A0c6wAjGF2Yo7sUSolL9AgLn6ihG0rRWhgEXJ2wmBgqaXEqQ1QXi8IoRpLBY0ZXIiNNFDMon1gQjYFZIzjSZrkovkYj8mBKwIimrafA6DcJ5NjoRvciNQZIIP3YIx9Hsg4ZwXBhhTLkIZ1it4kppZHlmV+APvckH66SSozBUGFYaCsWjayIwzolKlXZm6UQ5JV48dlVRNaPOA7vKQbCZQKFMz6DDExOc/9SUCnDVapTpXKYPbGb3XznyqvFC5lVbOYAE3MdF93ykrqEGPjkOSfVBTKY34yaQJzEyqpdLkvdG+Ec18lOdXGSk1HRVDznKc8E9VEgejoIPhlmPIfF7Cht1OFsZMI779lqPS8DaUghBraFgg8uDvUIasARj5Vysy/elCiHOGkbRpozoz5jFmES48xnihSkTilgSftRz54c0aUxNZUD+cnG/Z3zMIVBpEB7qi4NrjFoQhUePUsiEG1CyFAsRepiDNqTtDVLL8mUykcEcx2ehgxGkaufAKeHVY+NxCN2JRjBEKTSQoH1JzA5ZEc2SVZympVvewlKRxXjyZBpUCpUEyD/VsG3Iun55B0GuaxejQiPsJ5LsDP1yCKPqcNMQtZURmtgXGkZ1HnyY5b1Gx9eMZvZ2UoQLoTy61Pit9sMki6RVaupTXvWPTgRaqRLdRhsiSZUj1HtRZqlrV57wjzOiumeTeEt9CDHQ2rSLrjC3VgmC/XA1AKMavYjIOgm113oRpck07Wtqa77V0LKDU6TE0iYCtvU4XKsWAhVbaWWW0IO+rQnoVzHbANz287CLmDi4ydS+OssgPZmUz/03bo8OVd/7Yuq+lTjcw2C4ATf9Sl8/WpMjddcvJ3OqRVCVocyPMm5EviAaqlPQo93DxJ/scSY5ep7wcFgQsVFog0M2NgG/8TUlyBzQ75Ja29uBbrtdKugRbHT10LKYxKHUbqZNU2RQ/JQlhwZTrKck78op6pzxmc+ilGvE7F8ZtQWT8vHq5ejECzbpqAkpdV1ip+HPGZ80plfrhXbmm8nL2X1RrEa9GiBf1ofyEkFqsXbp1ryTKIue7k27UvJN4lCN/CBbDAuBiEAoRcgqlb5w5S2M5Y/tOk2dfrHgQZ1hIaJ5Owg+n4ya/LF7nXGGT7QSSu8Tkd/xBg79YTW9drjXbvqttweZ4lEaSK/5Mmi5PGtWs46F2Ka8sAsM9s2+cWNIiUmkGdPK5QjnrZX/+zX+joOnkneNrCjlRGNoJNQ74EKVERnbv+s+HswUC346QzS7li927LUVZBPQi2QetuX173ON1aQ06h7refJycqQQdK9mBjLbDaSkZiqkAMOhsPK4T9hX44kXuZD4iZyVwWfaI6ycY0ROzGNjljIyy3Yj1xIMj7xa1KW5ZGWQxuMMI+vYiaewfZI5eaH3rbRLMfzfgPd4zIL+pPT+mh2gd2wR3VK0xvuafi+8M+4rra9cfO1m/fL10IrOHl6FjFjKQuFZRqIiDQXd2er/VFsd8plAT3owNSFflxk4aHvTidFupi0fA+S132SFaEfvTjGYakgn2L4wz89MYtPDOFP1eiqI5mGY8u5zs30Ejh+XH4YfFZgvmv74vT/nllIn4lkfEZ6PZt+wahXJeeZYj4dJxn2ad4H2iyfHkRpHii4//1TvpvMqzCFNoBRYvDBetmucYz4nDb+iRtMGCFyUnJ2lyc/8mt5nwXp5IFXDCNjAsdlze/7WlmY9wIgfTi/Wrs19fumdlm283mwXnu+X9s57vG5xMg+j9s6xIIj//M5RuEzrCDA81uP6Dokq7AjNboU+Jsn4tk66rM+zcu9xOgck9O7jWAV/msKb8OYjPgIEAxBfLqNBWTABrS7yWOm0bCH07k/DlEVG/wQ7+EvDgk+zdIZjWA6tWuwn2M/IUK2BsS6u0ujI5zAQ6E9n7O+g2Cp7wvDwIsXgbgY/36jQnZrtyskpiycu4TKh17DuH5ANDlZEeSpDetDQiUyCu1riqBgQqA4pcyxFp8gETnskR9cQIPShzuUPBSck2vSpxgEOcEIRApBuM1zF6zAjbRJG5p6Cr/CwQ50xMxToCDaJAeixCG8O39gpiI0QsHoPMmgPgrJkAnUMqlwJXYpQzMUNhFcxfggQSCUxNcbwn7wh2ekRT4sOihqCt7TxSQUvjNSmwEZDqTgxMkAvpXaqmN8xKVQxmWkxEqMEmiMxiI0Gk00xcTYxQviP845s8KBDG/8xsDID3IsR0hsD7VAx1h8PnaMRg06Ct2zxkKqQNloFdk4i1/MR8v5CdW7QbmCaUR/REZzXDaD0pR8SMeCZMdaRMgyzEUlbBaHVArDoEjFsMjZYgeN3MgFikSDAsmQ9DWDnKxMHMaFPBTwCwzue7I0fEmZZEU6tDmbBMkTJMIU5Em5OcTa4JuKFL+iNEqFfKqatMOlFJAHdMr6OELoScMbzBwgI0arvEqsTEYGcj8CuUmmlCzHSh6xZJWIcorM4TeYQ8u0VEuAtLrme8uubMo0g7R5gKmGocENCb27bJRHMUZjDIyAAAAh+QQFCgDgACwAAAAA3ACrAAAI/wDBCRQor6BBeALXrRvIsCFDexAj3ptIsWLFfPn28dvIr59HjwL9ORy50aO/kyhT+vvHsqXLfycFYpw5z925cuNy5hQXrudIcOF49vT5s6G4o+LGIT1atKlTp+SeNiw4b568gQqlDowYEZ/FrxMx7hvLsWM/keDQOi1b8qxKlS9bxhTIT6a9dOR07hz6M6hQok6XJhWsteG4woh/yrNakOFCcAifcu0KEaxFsRo5fnSrtijbz5xRxpWLkmG+u+Rw7uXr0O9QwEUFK12a2Onh2k6r6sYNrurk3/Ya4vNKcWZmzaFV9nP4mW3ylXHflr57jlzeoz2FMsz+F/bIpTuR8v8eT343bt+TGwYHt54h8XszwR0vKb10w+Zs37qsPz1ddXKCaQcUd6+F0xR4s4lH3oJFvQNPPPEwZB5i8/SGXkQNVWVhUxPJNN9zKd23T0YjYlYWiPz1V12C2BXoooEHIpUggzQWBc+DVyWmYYW62bPjbubppqFWxrWF4n0zJSnWiSmmtF8+7ZzDYosvPhWggjVmyZA77uT40FNCCuljmELmGGZiMzH51khJwpfkcSY1+ZI/+eCVYHYv8hTYUeGJo6VhDt1G40T4QFQUmYhWZZBDXuKWEXIhFpXPZY9CelI/zp00Z53XCdXdUH7G2CdTDJJqG432fDVccMHxWM+rieb/2Oif8m0ETmg/9YMRexK5mdlmmDan6X732Indp0HFmBSLtDY70nsWrQrRq9TWc2aFzjaUT0P2/bTPPez1mOqSbW00VpHDylVsp59i6RCfo2Yrr0CW3VMoV2TO2xRZdQ3UWUsCfbteOwTPM24+5Zao5EbpwgROlKodS9i7Ms6ob43tdTVcRfdGZK2QFzdFIkNnMcSSv5PO087DBLdjMHzHlXgRwh1Bx5JI86RjDk6e0mZUxaaGTCtwv4U5q9BPcTYQwP7wk4/K4LiTzjruuDxuZpPe0ytGDO/Hjz3t4HWlngMhGDTSRQla2DzWCsRVPfZ8PCFDkUWGdma3lizaySHt/wM2OOkEnk7VL2s0otYGV7Zkuk33ls6ULZbNp7toP5UThW7HDSu2c2tlt7NkLRfS3nyn1c89YYNzDjpTV52qRpOOubVGDePMLlKAwXt25c7+yJhUn0N24/CIHe3Ur/6S/g/JqKcj0OqDt/N67DwmXlzNLwEOOWB67c67vsZ7vqCX2HqLt0ChZR/S0+mUUw7gVLtM0ZhiKt61XO0AKBhRy872/f+JcYdAgiev890KLqWjy13MYQ7AtS5ViAOZb8KCvZbkQ0o6OZZAMghA3qgtS1wqijxudDfNpMVJCUwLP9rBQOitQ3oQUdlihsQeCtoMJu1QDbO610HcfBCEhYGQEP/jMTwSgsMg4XOIPbzyk46MrlsN6QcLywE9wilqhuWrIXz4cUPVjeowOuHNa7bDGsSE6ntFNOJTuMRGd6SxS0hEYlMqAy5wbIshHHmipHRmjnOcY3BcMsjcFEc7ucwDg/ACY1/KWJQXjbEwZ2yKXvSipeFFKB6NcYo8uAShIgoxjpmcI3GaqMcu3uqQDFRd4KiGxY81ZIvpWmFeJikoGFnJewKp0p9o+UPypJE3ObrRJ+PYEAFmqIZPQeDy6JIzBjZwlfKgR1fsRZKzWNBOtMSOVgJExgINKDAevNyffkmeYRKTIZs0Jm6W07CB9IM6LQSHOtYhD7jdQx/4xEgduXX/s3VNMnLb7N8ZvfnI2PQQeMIcYvFAGcqBbDIyXcqiU/bGEH/sI2fnaCE66DkPr+hjLCA1YFocJksdUsmWt4zkQeeVRjXiZlEjcSMbF9OepiAQj/dwBzqcCTh3vOyjcAIJSfLXJ0ciTaUr/UlLh5hExcB0JOmkylpO2M71zWMdGfUjOKj2MpolhyQ5m+VJvakvyiVVqS0V5qze9iqoNpUqbGtKnE7oEndCyT/oyCvr3HaPfYCIOacx1lJ02UOk/i+tCYVQoyZTj5dqxYmiWxrfLAo2qQluHfBwR3D8isJlMgd1N7kTYbNl2LM6xZLDBEdjM1dTWvVLqAIBmL/68a0r/9LUHhk54A1TOJDAdsqopjUtER9ERIPQgx5tZQ97kuususRpt3zjx7nwqY8i0bWuDVmeSPgBWv2N1lmlDa5UkHhceijRY62VaGJA01nZujNYdemXZPl2srfUZV1j9Y6WzCre8To0muVF7mpZW6OQfih9+2mSMm+WoodJCVn6/ZPP+puYOJr3vG9LDHVHNBCQGglFCg6xWVJSF7FB+GK4pLAmj1jeAbtHWlxRbVHeU11teRhYJsExjht8KdC4pcSiJauKxVtecCB3xjBuLYfoBY58GtjD88EPfdYEDvk+mWEWzR/uhCzcCPUQQiJssYvnSKMnm/nKU46UHWUyEwqepf8uD/5uUr08ZC8lF27kUfJIqLstJfnZRCPu1qToFcHXuaVYSpHzkBetWj0XxlBFoS4+v/Jn4/wqJcuJnY8IQtO+roROjzsxo0et2jEPpEMLmsikLUJobSnJr5zJtI+4BI93QKaenoZJPgCk6IPSmdQ/cXSqK1KYN2nkx+C4xzzgoRB2sAMy0vT0SXIIXGBbGzHCfiWxieRns2Aq2ctmhzrGDY54IPejZ7kHOap97XY7pVBaoUix2/wmjuxjIPWAh7ifbe566MMj+0CHqN1N8PHQsDD3XHVxnsyQesjjHbaGRz3/fe9x9LrgGB8IPpTrkKrALdvJTrjCi0OifejDKfH/8Pc+5FEOdmf82o31eFMGTJUYC2Tj4CjUcKC183sRR9LqwceA6YEPfcyj5Rd/eXBNLSGmY4ggjWaIvYCzc6ItEVp17PmAU1UPpLtI6WAPNqS30h5p4bk31ELUxyFCnI4NRx9CF0g97kEPr3M57HjnVUMGbHYNHZcxoCTTx631qiXiM+7KtXtB805wpst45q8KMD2uwlC4gvKIr/Io3LFi8a8zHuOOF4h6916PAINSgJUvSDy6hNxUAXXj8jCHyz9P+6K09biUHwhCMJn6grT+niDFBzwUH+F3CSTFtYe5jI/L6YbwnvcWLjzwAQ4O4qNUcvxN/supZWTzPhUyTPV9/4ALX3RY01b23GHK2MKby+tr/9rllcevBxJ+AB+XWhs7dtNCLRtwZH8gugQYxfd+poV78ucQQwR945d5XgFr/tAP83AdSmExjlSBFkiAo/Z8dMZUimVcYmZ4nBUTD5ZfF9gX4+F+GMgQzFcjRSYQHShELviC0Ede5IduKHEP5wBhs1cji5eCcld6zHVzw7EV4xFHGyiDDCVgIGhN/1AnkPMX+nJ3yVctQYhzDHF4bjMekudlAKaBSViDnMUS/OAOYjUx2ZIn2mde98d9GtcQ+mAvQ5iFodcUkueBk9d7LeZRJsESEIhIZkgrjpQUjCd5CzhghxeHvBFgI4F7hGiA8v83g+IHN+XnFjdjDzl4JYDoInxCDn8Udo24gg5BXTRyYZpkh3f4iKB0f0uYLjg4cAxSgUlBDukwD/ABdp8YdD23KiEjR/GnepB4FcjlUSEIMO2DiQtigbGYDiuTR9qXi1W3iCHTi6knYJNIiSfjDuaQGu6TQXwhha2RJ3xiDivDNR+hdJInd1eXi5rDG0GIGHUIYHa4d6vYRWSYQYO1g+0XiDlxDsuIHLAVdpLojNMyh85CLZ94jgMRjNO3N6CWGrPhFzrofsiYjBWSR58Bf7bHgOq4jpVTLQepiPhmeOjGGf8AgTuljczSSBYYFOPAiT4FLobDJvcGbKGHfz03kAT/mSVW2HBCV2Qf2WJLlHBjoTTycJLlMEsWMxKwKA6y2A4dYmmn9kpDFoRMR35ax4ZCg4jo2JMq+JOtp3n65w8L5D7bOCrekSfjQEWz6CaVtmZthmqLVpPkpzk56Sw75xAf5xAraG6Tx3tfuTEjyQ+HpEMJwiKByCflgA4CBEGVVnIGBocrdYuPh29UWJl1SR4XVi0vlpDRlDkoB2aYpIRB+VHSVSw7Y49XkiecWA6zCEGqlhFKAh/VFVJvqDWXqS+SiZeWqZlP0VRSoYYtKIQC0Zfmtly9+UlKKIwbsS03YVLG6CKsKXpggU8md08VQZ3VuSqk2EGECHm72Y7oVBi2/0aH3Xd/bXhECahaF+ZszsYo8gdgAQlUtFUsPNM/TwgqaSmLPsVY1RKUhKJzIrdPBbidpPedkQeKjKIV7fkTCQghoBh3EAJxEMcQzjZuz9YQkhefQ0lb4GAOicYdl7NlQzEO5xA1EeWRcRRR/Nlw1magvJkY4+kQF9oQEvoODWpeeVmj7DChA1Gh6jCjtsaXqvh2I0lb7lAO+RVJr8GUrQNHBhGhEroQmSVgryJHxhVXzSJ+CIoYLnp7tTF/UsGeNQpxYFZqjaWjF0oP83ehoLmGbEedm6EP64CkOth+SVEO5rBKN8JGaZQV6MSboEQ8MVgjWqqGtdGl5RSjhcGeYv86oVR6YWNabo+IgObGl9Qymg74gPRJgnY6Dg30GAwhoVv1GIoqqVToVvQHpoUxeZxmf7jRpbfJoLzBqOw5nPVQKKQoqpKqpmXqghmqoc+1HMWYXwMSi/K0oANRqgKhrLt6qekIb6k6Pr5ZGLCqlwTKoKoqFe9Aq/wWjKWXrDwqpJPqq2sYkAv5aSVWnxAmiAIxbj8KDs+GrONFpQFZdPgUreTRUFw6YLBqalsKVRGKGxJaq+V2q1w5qOSKexsoZjsnlJSYZaElokv6Pu3qrrQ6EjE6nrsXTc56dff6Ukejr1rRr1hprdeKTkPErE4RqeUWjD15Yb0qpOXlZeOXjtj/yYQi0T7uo4NJ0UDtKk/uaqEr62WK1XBjt5NaQUzAeE5SQbIvepCKgZ4KtaxjqqvgCoO+enXMdYAEsYYtyLA7R50VBIEeuhoukpY+C7RBa6Hk5hC2FqO9iqEcu1BMe4pNa6aFh5NUiJDl2Z0i1KCAO7WpirVGZrAH231d+6iNaJP2GoIx8TgEcrbuwxBru7bcOqMMsYGQwWm8R7eX968/cWeX+p1FAbpN4YuBC7iZC4M0a7jfWp7DWa4Hapkea4MnASXm8BdjJQ6T60d6pVeV+6PcioBT0ShcOxK9+qQzeESI651tVa20grqpm57lplDAmY6vG5yy+502W6Tp2h1U/3KnqmMOeUW+v4sOlnux1GoojgeDRgh9Tct9Lmag8mJhXpmQX0uNOwee3Ue6Ztpz2Lmc8+Ch4Fsx7sNA6JBR5nu+lcuoGBu36Hh1zie4qOq8lom3vGm6mBm7Gty8fYu/Gnmw27mbHKlxRApUJ5czdLqkiEmxzpRRCYzAvgu8Fqq+q2ueP3h101sju4nB/JslCHqypQuKYLsqq0Wg9NqfNRW2QPUtOkWn7UKxAuFMVPzCfnTF5hu0Dhyq/XZ7NrnDzUK/FwOcwYmhF1bG/1t1jWVqSvx0L7ZhJgc4N7G7aekUVJxVqwPDeVXDtRqug3eHXzm92UoelUmZP9wsaPzBiv8sHDfpeP2pczvZcyK3cTq1U0/YSyPhs3c8wxbLqHArYCvYevYgyDQixmfFtyAZks7oyJfacyYMwB0CDwqcUeqaE1JcGy3EycJLsOBgo704walLyKZ8yuNnyIbsjMMhl2OGzLVJEKF1wGQZzZM7Hrm8x7u8o4N7vJQ6yImBqGf1vC/Kv896l4jBzG8Ie+gAxWlJls4kzdGMGwiMvjVstWizxj1sWj/syMiMtO9mzhtHD+tAwEjBzlnFQO580O9cFFk8zxNqo4zSwTx8qvjMvzW5z1KxcftcdP/8DnO8FAecx6tDxQiN0D+x0Lvc0FirWBDtFKkMcyVLmaGb0fzMyDL/fUTssFMRw7t9tMfyrA7nq8BV3M7u3BA71dPxWqNHOLc+2HAvCtMjwXYy7cYvts/BQQ/v4NM4TdDo29NrK8/oAA7nW9Q7tTNSTJbPU7FHbbVChMNLzdRs7HQyjcznidG5SH/rIG57zA7p8LvBy8fuSiN/Da/AzLEg95tCPGovXWrPEtc558pIRn9X/aOdzJ5aLKYbuK2YSx5tS6MqfXa9CY0e3G6JjWQZLYTkfFrrgNXoe7m0qqwEmdlaoQ4NsaMSam7B8VG9mSMr2JltHdcWba3yd9V6Rb4/itnscNfHbUmkGKvk4cnmVo2lKCv429u+bdo7SUTIXaHlm8XO5iCJ//WoiMHLiCHb7dqo8bBZ0jWTyAu/9kvdjI28N/3C7bzAP7oOvjzVoQucMqrZk+0g5gVSH+ues2J/rDovIvs9vu3YnKlvzXnQ5NvdEsfbdX2epZbI40HDFkqm5oXCp6uvTFu/0zovkLzPcGevWEgPzIbXpzlJ7rM67PAgbN3YrkzOBhmmUsHAFltPmwXgHT7gRxTiNALkzfIbJC5pQPcOY02WGaQTVPTiR/bYdX2gh02hThHWRh0PG4duPC5CH440Ux4yZZeLIoedcZzOTE5LeIoOEvfkpI3R+BZ/DGLl8swOWB4wBpaFbiVHvPPlvCPJkrah+0APO5NI64yn6gAPyP/F5hh22maqppmLG3JuocH4EyenlcULQHyONs4ocuZHW7Hn0WmJDp3LXO04eHnrMQbJqxT8E7Ld1TxtofJghWNxhbVp6adsWmLusJtxUel8pw9+Fas1h4UHq8eluiOhxZVrzeyAayTzShMeXCut6ZLssCjRD/ogD9pN253rFE5benuZsg0x2bSqxe8Q6ydHMpFl2nDpVJeHm4w2ktUuTw9u3wnVmcs8Ei4KktTbo4x6za1d7reaK6d2TwIR4Oze5W2tavgUrPDKQPNU7lrqEDo3mRUOyi0dg4QLr6xN22TKsUUXMAA36wPx5yLf4wjvg2OeqbQlfPZtf6PNWi72k9v/3KuYDXEcT6b9RqQdZhYg1RBmFt2Vx4J+e1BaqfAbFifLYQ+Tl8RkNsQwy5dSEQ9InYBfafA3Rlsl32HAAvQMJfR820NFn/JD+YD3tr2H/IPOp4IuGNp6Cbgcy4DnTjJ+dWNDKfI41+lc3+4b3Ihgr+BNRvIbSltKn8Rnv7dGtvaU6uirS/XlJZK4HUU8f2YhxR5ZDmt5f/LuqL3RLuJ+T+Yh9RH6QJdw09Rs5ZHMt50EKqSDu9ZDGvcOgfXelt6Sv1xLJB/qffBdj5mZjpec3/lNPBZk/oOMu1o1ZZmnL6SVWhSA+5VNVhS7PvdYb3KAP5NNzeVBv2I/sft9zsxC/2lgQMcrrWzrhvz1RLveN3qropg3OqZjAF6bRt/zPanjl78omJ/9DMLchVHk8hnyAa63AFHPHj584AweRHiQ3kJ64BqCi5cQ3Lt47yzGw7iwHkF9CPt9BBlS5D6SJPV1lHjy5EF79eQ9lHhQ3kyaNA3ajCmRYU6ePOv1BAqU4FB89+6dLAnSJMJ6TZ3+DIoQJk+KGK3Go7cRpcF9BkV+/VjSpL57UQ3iazkVodWaNmeCk5cw7k2dZoNCtZuX6NCjSPfxU7pvK7inhfMCrZpRI8eYYMGOPVkWnD3Kk+3l1IevaU62bWvGnAv3cF68o4PuLdpXH0l+/Eqi3EzYqezDav/BsZt4EWvWjZI9OnY8NiZl4pT5qkbLOaLnzz1DmwZaGjrPvUb7in0t8alB24ctsrNIcTG+wQeBhwSHfSXP4gMJGlW5XiLz59NNS7efcyi46qpXvyZLspZ+mg0/0zDSTSuE9gmuK65ISikq4qrzC0KJ4qEvPw031I8g/oiCr0LBwLHOoJZkmy2/qzLaKL3fROInIQsNKg+hyxIqCLWiKowJoww5BJJDHVOLT6yOjLLRMOh0UyyrgdJj8CtwlIIOreL68+8/By/EkLkgv4TOvSFDFPFI3yYrECjbMIIoscUOWk3KKb3a0i6irkwNnPh4BOpHMP9kr70h3wtRPRITooz/QOlsW8igirBacaGCDkpKpCk/Sq+fqI4sai88jxqrTkA57E7D9iYck0xDczIwp0YdZSjWFikVa6QHuxIVyhpJRHIoVEFNCKxR/4xttFPF1FHVvwBzzcaDinWVO4emktVDrm4lCb2ostNTIqP6Wy1YYYclN69jByXzv5CaNfHZVrl7NaZ63qTVRSixM0u49AZTKUukzAOu3LxK3fDcMff86yN//OlnyxsJ07CpSfUsicZ7sasT11wX5HfPcMUNWGCzdgLTYNTIzIe1hVdmd9IT85vYr4/11BJjbDemNCGVGjtPW5GDIvlLk0EMMWWVV2b4oImh0wihIi0UTCWMKxbL/65/X+zZ0p+3zmno1PoyGrB+kNZUTysNgtYhnnab1eKV9oTz6am95a8sjyXKuuFay+Z65JJPJbrQZRVGmsZ7KoM4qIgYKs3juzuK7Lq5vU1XPq/y1hvfvoGO11SvrQObNcCQXthwtJoiOCHG43bccYMkI6/mXVmP70HMA1tw85hIDtq0y47F8ziVwhabdDjvOX3ekQWisXXnLX4d7oP6Cirb2zPXXc1XezcWeOMCV60kscc2Xs/DB2QUKNdrZ/+kpbulu/ooA6s0LM2zh8uzWPdPHSjArcRSfIhHuPKRJXmqi0hPXEc7x73PLhpjkPXsN7XJKa1vOKEJ//YXJkGhJf+AUhMfSEhXun3kA3kD0ssCndZAa3XIctgaCQUh8x/IDcaBQYHHQXJ4kM5kCIMz0aBa3tW14B3HOnIbHAELl54Tpk1eKVmf45C3n7NYMHY7m1pIZDhDu+0JeR8azQ7BAQ8xdulHzOFe0JyYkBT9z4hHrNmyijdCf3CliUNUG5zOQpSdSZEoH9IRCGWYOcHARz2RsZYX/5gXMupQjAjxUv4yyL1pwWSNTHHK0EBXNLG0Znx0rOO+DtiT7qCGP4DM0R6X9kePbRFAU7xifL7loR158UxRaaRBcgma5uivc/DqHxsz2cE3Ds9ocvwkKA33stHsRSJDwhEVOSLI10Qtagb/PIssB+Uxo4THm96UCBnFOU5etsUuKTLLUzSpLGSKBGn/KJ8JE2WaQUHzMEhxXr8mNZTM6EhM/jHKOMn4zXAKVJzlbM5N6oNJPCZONi3RJMJY45h3lm8f52toFVFZT2eOhpubPMoUT+lPX50soAIlaEIEOsZH5iQuz3lLT9JWrMJ4D1npEt/4lLgyeBYwUcE8pSrv9DDSlAYq01zPyTwEOFRx1KBPhWoOd9mnw0inMDUF3gexo1PyjfAfX/VHTw0iz4y2cEgPI05UYhObm2p0owRh5rO+N9S0RtWuB50qT2I6nas2xab/hGPNWiNCUIYVrGJlYlyZEpN6MrSqaBvU/0hRSVSGIktJd70rS6Oy0NH01a/eI1RgO5nMwvIUnnZUbE84+jB0PvGZb20hQnzlUJ0IJHnKmxZm7arZzd7Hs+o0GUj1kY9jJnGnhT3tvlJLnXreaDus8mtsYUtFtBWnVQnkjVNehRHdRvUwnE3IPMSb3d8O042bNKbodFradyZXMGl5joH+6E+ItVaYTxqOjoQJFDZx5ykki0d3nzoa8IJDvAeeB3nLm9VOoXe4xFUvYUH51Z6ujCuZmVf/IjsUo17yqPsUpkAQdzqzJFAq+4uIiQV8UCAheLzlBe6V3APSo0BYvXOkIzwpbFEMb69DzYWKkrrW0f0KJMjzyqhO6P+xG7V0l0MzcbGLFfzbDhJHuDZGJo5JR+Edk02UGc5jNJ3pKbwk+TI5oi4b2Rir0ViFzSptqV73KmfmRDnKC2YwjbHsyZDkmMtcXuJFNYNHaXoqxBLi46QW8hLbKOqSimPbYXxEH89Iss52djGeiannPQ9Wwu39M1hDacdBv4u6qLHqo8VMHmvRA4irexYl7fKStulypQGGhxkpvetJunohmD6wpptK43sQ95h87vOWQ/1ViVx0QAaaq1CtlGr8pCi602w1W95cyW2jzUDh8a8+MBtgd/Ca10FkHLCFjSU4Gjun61X2sv/R7MOtUVCqJI6BZvrsh/Kzn9y5Su9SZ1//g4ATK+LWrbnPje6sqJvKwaPxSTrt6Z3Km8IxqTd+7o3veWrHqL66jDo7Gismk9KxMfnOOxxSD92WW+G7RrfD1x1a6xjb5hH+NHIv7i0UIupKSoPrcuV1p74ORLEZJhjjkEzwg7wDPNy5K7lfDvP9AVu8wkbW14p283bmvLA9qbdEEoWqD1nXTvupNop+4h534Ufpz82JyhESdXi4fOporLrVsc5u1XDdk/Bmb/kQEnamjH2uVuq5WeCq77YjNejabcjbUffLntDd7nf3JUOsPo+HF9HBEnd3148beJ5TW8TIynerrqp2J0b+IQOhIdEnv/L/Ur7ydpU65vGueb0XVN2NWu+735Hd1cAvcfAnOrJ56epEz7rL9mrLCkfG4qvJywryQJW75XW/+1/3/qrrDKzNiefp4gs+IWF3tPJBnvi2r14h1NKOe+JDlOpbv9t1QUhAAAAh+QQFCgDgACwAAAAA3ACrAAAI/wDZgQPHriA7dQgTChwITt68evUGzhsI7x27dRgxwnPnzqE9ewxDigSXr6TJffwYphTpr6VLfyNjyhT575/Mee3apUt3zhy5cuOCBhVHlKjIogPFjSvKFOnMpkqHjmMotKrVoCLJad2qFRxXciMXGjyYEOHCgQ4jgrOnFhy8jO80cvQ4M6bJfPvArRz5sq9fmHVl2hSZ7x64nO3c7ez5U2jTo0aJLoVqtC5Ux1OpCgV3FWvIr6C3hh1rsKy6ggwdgqv3kS1FcO/evV23seNEmflwl8wbE+bf337B1Rw+k3hLhvfuzcOpk6fWzeAqM6RMXVxgykOtU+XcGTrD0OBFkv82rZDdu5AP134MCa99+7nLRSZPnvtu4MDAfw+vWXw/4cL2MLfYc5mNVB1UllU32UDddTcSeBCSQ1ppphV0nkitgTQQR+68J49qA62XHDjz3VVSSLzdx1B++vEX037EqcRPYcvlNCBWTiV1oHQyHbggg1M1WNWDEYI2YUHkWQjPSK2FxOFc8oTU2nxUmngSSnupuCKLL8HoJYwhuTQjjQI29qOOO/a442PaCRlkgd8V+dWRZJVVUHtRSrleQx9y+CGGH+FDJX1W4rUPSilqOZBvXLb05aMh/dMSP2PeE6BOWgGlnXbROcbUU2tSptmbDg4kZ2h0lmbQOrLFkydDGqL/JQ9HTGYoaJWF3nVoooou2qhLj/rH0qRjXuocOQtaF1V2OUY3XajUaRYSVkNOdaqRBWWk7baybfSqTN+GmOFHgxKa6277mIRfb7+CA1iwgzFUk5gzKpdYOo0plVRVn6oJLXVBTksttV5dy9Wq2samMKvu/amiavOMi8+t5d5zbq4zHcdXo1v6EyxN805akr34CskjZP8quBmp1Y5j8MHZsqpwbO7V7HBgDi0XsT0UU1xuYeZijB9gw/rVDz/9JN1PmF2CGelwxPKjnDvnmMlvsyinjJ13Qr681VgJz9wtPB+GO67OOmdY8do/3zUfYfdpbPTRSVNadNMxDgSjmPnM/0O11VJxaqDW0Y7qptdabStzt2N3dLO4yY0ruT1sV245chaHlKWvHb9E6ed2D0TpX8Lqvbc//OxzD6ad+Uu4Uzy6KRTi5HBLMzzxuAclhpbfgw+5vQdvWEyUk3gi6B3rbTTooetFaT9+5S3c6ajb8zeyQw7++mPOGt414mKPPVDuZX8LfIkmCd97hoGNa25ez7vEdF9HIy866KSDDPWk9uxEIJzP2h73BCe7oNCuPRRZUkNk9S3WnM9iFwOa+iI3rrpMjnIniZ/8FrWfltTvULkZCF5AB72XJM9L/tiHPVjnmZAIUFQjKaDLENcr9QQqaIZKl4kmeEHJ1UpyJcIS0v/khzeXHE1dJNnN5/7iLvmhUIU88U4AX3gyIMmOKy00VXhUNBG1oe9KINwh23ooOQcS74JBFGIJm+iuDrZEhwzJINJKaEK8dbBvJdMeFQXHKRkaUIozDA3a5EGPQi4HIhCRGMUi6DYqkbE1EEGbzsz4Q579bpGGGh2jfIPCMWFOiXM04edKiMJ8YMqFkxFgdDalLIH50Spa7ErByFFIRNryIRec2KAYKUFLkfEhOpOIJB8CkR/+zougnGMTj/Ol1IVwLYQa5aTAocY27g2PP+FOKgW3yn5105uDe2WpOCNLcNTSlojs4cR8Zi706cORj4wPOII5z2EeEiSxQiOhDoX/NHAsrS9f6geA3AfK+iURS4665jyc46kqug5BARSnkLSZmXOiU3IT45lGJ0hBYaItQJKsZ0wkmchK8ux9zevL9K5pqduEiD7I05Um97aPhVaNWeCczhQLJxmJti4m4/gQPQ5py0faypLrZOcxP+JSew4zMPdsknoEpUtzUbOfSQPol1JoqYHkBDn5oFRerKSXhEKtplGcCje/eR9RLcunVwFX+Qg5SaOS8VZLZapLb4I2qM6TfbECR1VHFMLnKU2rncwHSBLTjvhY7FAiBFpJRuclgbJOp1NMEJt6CtcGaWauH0LbRe0aTy31Faq4ZItUQ4K+kWQVsU+8lDsaGzGS/2AOfSgxq6Sk1o5zBAkpMAQumgDWWRmCtnzETCdpe1gPetbwPsHcWUh0OZNQqvRRqJuaO9JWLuAdD3odlFrJ1Jqm4fqouMY97ofQmUimFtWuiJTnc7mY3Lbcx7BsZOZWpTbMB06JPrm9Zm+zt0fOotdN6i0bexfM4PayBZ31LeZ86xJJWPGsLoYNTrC4qrPGTkmv3i0rjMSLvWRR8cAt60yChUqPBkOYqC528Uj3OmELywQlDPnnBle6t34YBjE782XaKJc58EKNHwPOzlUA9j+koDhgVrTKiglpyAhHcpgxzrJ9PVpjhgx1Z4Ed2rsCqtjD5ATMTA0QuUZozXndY/+8DWLyVp7sRwauuJB4znOecybaLA+kwSOR74RDG2QUie5uY74jSJ6EZvc9diVQM+VNW3deLKKYKa3DypTLpudO04PKQ61Hpxe8mogAWiQ0fu5cpRuYpa1IXkeeZ2LgQ+SKKXHM/shHOijKr29iuqdz9mlULpPpoG66fJ5Otp7NqWX2hqS56BG0lspmm4gJKo69Ig5/E0Mbh+BDH+DWoRxdLRyJ+JZl2yQ2sH26035159gJVra8W6xlG4+kLdK+z6qDPLwaDoa/HNoI5cK9K+ZFSnRJ1uaaliK7f7kQolKG93HnrexmqwWfW/4zhSU8E0JHbETUDMyX/Nk3d2Rku8n/UWPSioZwM3EHok1puNYe3seqSDzeFNezxR0I2NWKBJH3rstHNWQovbwaWCMveTrWkY7tUo6friYaQFGXZCgDzMBLVqVMqhKPeIyv665KMJ+QnXOdk1omF1RPl0US2rUwpOAatONwBOq3nWCEI0+POtL3Ps/x1vyVe4xJzbv+da+PHbSHZ3HZ8czge7elgq055tpnog+4W1fukqK7yU8esbD6am/7kzR0AP9Cwfs6KIQHB9i9PuXFV/zsiloPPgQbWKCv/R4ER8lhYbsfgDPaHmEl5YZh8ubn8NpNVDSQr6OyesOrPuxzdX3OnR37yCd19s+tIGtJVHmVR2+/JHIv/7lW4jF47fbN5yjH8a1S4LVmjSjNT416pU9x6tcQo+tEe5gtrEjud3+UdIR5IbMX+qBEn2d+eiFp2PNWOEU413Eg8ScriQdq9Pd6iEQPE6ZISdUrGngrBZhJobR7uuVG/qA0fGF+MaKAnVF6mgU78Pd144NzFThvF1hIXRYo18eBU7VO8/GBUKc0QMh7JEhE5YeCNtESkgYUDbU9D1gdXtd80AdaM1h/ENFpNYZUSIV9WoKDg4V7OSREABiARYhCWjWGW+UoSJhk0FJj5RV2bBd9U0iD6IRnk7eD16eFgXGHyeGDu8JPJBSAkuIxv2KGIfMX4lUODtcroRISj9MQcf/oeuxFh5PXgRuYh4LFg7hXgH24iXMkgoModyxiSsiyhoryKZHhLNLRiBT4iHJoS5IoiTXGGnc4ixMTE0lVLuAGbuDQfXAHhL74i54oiIVINxk2KW+WboVTijwCO4HBimUXiRZldhxXfRemh/NRizLRhbjHEPqwi7woRH7IPOL4WglFL+KoSSnUDqO4JtpjXsvYPfdRgaJGbzWYbFomjdO4hdaHibg3KPnHWhUzEMOTi9+4ieHYh9IELB4kVkpUcAs5D+t4IHqkLNyDWSoyfRbVYJ62czKWfbbCj3tIJZXojyTSbz34jV9okAhpXYFYP1aScnQkNb7FjjQnkRbpfl7/RoUcuZP1dn+UOCi56DvJwU6+4zM+k4v7QJDdl5IrOUSeUy9AtA/QkzSqk37ImIwuxFY9UhfPyJNe2ZP3kUuYqJTvVC7Xd1LHNFhkmYu5won80BdQGSDpVHlUOSP2kH6bVZFHkZWoqJUzMX1fGZinpiJiSZSZCG7+mFE4CER7iJiH+YG6YpCXB5UOUUv20H2VVxjuYA5LIXh66ZnLd5E6KZik2XgzwXP4hFTXyI9kqZiB0iSpaZhKaSJ9mEFrlDrK8SFdVw/fFpT2IA++VYc1KRN5NhAYWZrIiU4UViu0eH2PCW6uuVoR8UDPCZlfuBu7oTm4aQ/00HUtdpYLhYgJ/6IlEDUS0pec6KmcpZZxxjSLsDkxZFmUx8QaauFAFEOWkVkoIbE0zjSU3dliGlUPH7IOQOGZLhgZ0iFc8QiY6ZmeGkeYXHiW+WRJzzkf7NNe2ogrFyNC4Hgo0ClqFzgr8JAOiHgyDpdTzcigDZqcD/pn+SguSGVSWeiBZek7H+FgJ1U5+VCWbhNZKpmUH1qFubMO6FCi/VId74eTGGhOe6Z49rii6NmiDGF7bpeH0dmc/jg5tyg8t7WjJIGZQPo7opY77IAOo7h8TJiin+akGwmlLCqcA7FOdiWh+Leld7haeDUiz+mh+CCgb8ETmtJ+FhkSGHieboqcsWdDGrIncf8anctVmEmVdvwXeSdJcPrwm39qDkpYYGiak/R3qKTJgYzKqNNFe/sop4+aSxliX6hpK42JmfjgN0ynqUrYgIs4XPtCDudgnPIIqjzZoi86qfsnEpF6qo6aqpPDccoFWPDJi+/kN4pBqyu4iBXpMunQDiE0g75qcb3yeKQqWCNxp8YqrsgKScq6rB+Ze6oTINFaDrV6NTyFIOJQDufQDhbzlrz6qds6mPO1ZR0YoYrZnMX6XqRlSy6Ko+n6jS3VrlmXMp2iq+lwDxoUJavYlftqsBNGpYrKPrUIsGkpsNiIrvB1rqPFhep6qX6Tfu86GVdZOOSQDhj0lkTDafqKnOP/AnuxSKV31ZyNCrLFWrDrKWEM9pG414f6EKt/k3UtexkvK7H9NBI0a6g2u6rqqSgZd7Wt+pE+u7U5aFSmZnsNRrSHcjRJOTVW2VNFsbSSoRXu4LRb8oYVq6KCWUZVGxisqrEHu7Ncu7ezl1eTc7D1ObTWdw9SWTfryjrqRmwv2w7A1zxZ8jnmOZrJSbc1tGXsWbJayrd3eIk5CKOSGhNhi1R0OZXpohwlgx0xt7jA90x1kZ2E2orp+bn3wZ6A8qia27f/qIXYuLEPhrGOR2qiK5VGtK74siPWArOsqxLYRhi8Aru/+mwI63MMgYdSMhPuSVq3y7nTG6fgGiI793Ps/4WDRUtH/ZAu/RORlTEO9HqtABYTdkNuIaGLjui8fla3Byus0iu9+leu4+qz2tu9GQW93CrA+Bdu5MsP79RbRuoy7sq+ELQrMYGQ8FuSaCG5HRm0tKsnPjRf/EuJW/u/uCt5gAuWgLseNzS6L1G+lgJn5OAOL7WjShkT32iLUWuBF8zB2peBHdy/ewuuSUWyzUbADmSf44uGJajCf1MOL+sRFSMo4daN3AjBMVHDTxpja/etsKIix8q/t7uBd/iVBKxalIrCguhBKkQ16NB0qxGja/FebxOnmTg8u0vFbWrFcNorIbzDWpu9nLtOgtu7vjulyiWLJ1y45Te8K9R0Of/DYIWEbJb0bKshLr9zePJGwsJJveF6iXpcp13cx36sXBnltzcKvuialgYshqijQjjBZ8uhZ2XzfIQkizgzV/k6anYcuD4Jm/fxs5vssT3sya7JmyDrGgKMo5fUm2M7lXWznYN0XGAHywCqmI26f6/MpHV8y8Eqo/pLPLzcy12MjQI7o7RYewsGErfYfUCYOiDUUssxV1AoD10nVMZcF9VcyTYoyG2RzaBLRmHZy+o0zqAcKNP7zf+Izxc1VXuYzGLloUIGWlDondI4o4cpf3lCcXabweDLPjbUPrzrz/uISH16wwS9uyNMsLpEcGS7K4gZIA790PE8avv4qnZGx7D/WLklzXO57NFaCsiuqHPAelFby6hZJr4Ep84wbKPzoJsu/dAVy3O5m4lwuGxdFmPDaovdPKP+3NPzaIOFuqRMetOJJLDF3Hg4GG7qDKQ2yhbyUBE0s3q449JNHdaTLIv4ENU1/VwyhtHEyrdZXY8j8czWXKikPF2oSsouVsiIwtAZldSzET65s9QU+NUY2BYA+ptkd9d4bZr6LKyouseizL897dXjExIRKBKiPdCYHNi2LMzILJXq/E6/w9jrQBpis9Tx0Mgshs9Tatk1PHn2J6XarNMjq9fPB4Uxcdp/2YrNmszlC6RMZXJHMjO2fduKZ1+7W9dkZ045q7Ffq8/C/w3aaoGBzscQseHSxf1cFi3MmcjcHnqpAfIWZDEh4VPeq7em9Di92zgQ3VjRUt2tgQy6+/vdyLplq1d4D33e44PcxLmRf2ZJpwyEYeqns20W0S3dq0dI8kzMdE2QqWGFlYuzkBzcAv5IVJp6hDfdxZ16ilLFFPrgSuOhmGoRFELhY6EwYAfPNCvMUypYHF7B/W3Yv2vHAT7iBSthnzbeDLHUKY7eeQZ0co3Svuih9QDdY2EnNW7hYfdptUTSdJ3f81ucoBuYP9TRRE5GxG3aVgjmWgJocr3eQUiVSVkP8IAk5GHl5kHfF854uwsRJw3FbHraGTnAQ17mQNsrycarX/+95qRG18tduFH+TvKwDgiBDpSODnVO4TZ+402ef/WZVPGm2vRoyfdG6Mb6SMSZ3J421RgrzlAO4esKD5Ue67JO6eVhHmDnygCq1W1BsXbNeII+E6RemBssE+EduR6uxaktVeLc2lGuOnVdpueADuYw7eZwDtZ+7bGO6bd+zek0MTLY5NyawVkb7FiYw0GH0VVIb4qS2pfYs3eorn3YUvCgDtduDgwx7dE+7bJuFnhuj+fk4N/u6zvpeOSOf8NO7Bf939a78MCcVPDOp7Ja6T0x7SFB7ZRuDpXO7/X9egA/f6vN3RxZ8Ipk7ptN7L9ti8hOiwSZlED6Tr8527IeE9X/TunWnvG2futxS2/rpA8BH+hzW+Zk7rd1ePJ7ze6orfJIGZ8COtsqEu3oMBAYb+mn8Q4bv5Gi2/OhTppAb0PXq9FhCewKv721iMkgu5ZreQ+ixtY1dhp3vu0w/W1SifVZL7QhT+Rc7555lcUMf0ZVffSV6LNmv5aTPBDnERsMcRaBoe2arnNwnzTfbs0GS/c7Z/d3P86rhcXbi3Ypf7uBb/bUKzYEMRDqIPoygelUH8+3XUh5pzQyiOilBtbNtskavCeeXaydu/cT9s2dH/h9St7zfSGiP/oiQeN47p2X6egznd2Iru4YXPc7POa1D7KWWGPX1/nvvvuO+cOiRvjA/68www8OCRH8V37j9TC6jCiFgB7mXin7Gsy7fN337T5f1Y/99E+Q8plRYxoPhg/6C1HnAAFO3UB2Bdm9excvHj18+/r1AxcxojyK8uhdpCcR40WJEut9BBlS5Mh69kyeRJlSpUpwK13awxdT5syYHW3exJkTHE18+nz+BBo0qEShP2l+pKcwHkKmCA0OhKquozqDBxPSK6nv4c2KFjFq3GiT5NixL82yjHg2JU+TNHW+tYkvIs+YRe0WjVh0pr2QScHFA5dwaeB3T6FOhVowYT1897Rutdk1bMSNGTOCI5tZpNqzHTmjpMtzp1y4OGXOpXsXKDi7rPXG5Ns3KWCFCP8JF5RINWJVgwjr6XP4EKJEufYkf7W5UfNykJ9TtnTuMrTb0TVP6xTNU/X2n66Dyowt+6/gpu9usgNn2GC838GH27QH7jjH5BiZM4+e/+z0mqap3+SvLu4G9Kmxe+7pCZ/w+lKKNsB0ooqdCA9ir6fgwIFMonsmusgr5Cqz777M9HMOvgBJe2umFPkjkLv+iINtpIsaBMy8nNCrajHgtnpPJ688BBFEEUckkTMTAyxNxZxoQlCmFotqUrSO9goposFsq5GpwNLLER7GHhOuR32IGlO+DoNEc0iyVNqsyPg8OzHJ6wBkcjTHnjSKPzpjqjIiG/1MSLClBjsInnjs2RH/IkV7zMunfR79Mcic1MTPTelOnBM7uV6cciafvMOzQCTFihGkv24SlEal5PnSIQxfvWmfMiOC9EwQJ6VUTUvbwpTTJeda0slPQwUKU48+WvCjvx6USFWlLmrVPZ32kYha4SyiSFKcctXV0l4z/VVTme4E6lE8+VsQs7Gs7IhZsErqydHhGKVVIuHs7acrIOnDlVuRIlI2Lf1GhUvJ0lAbd0zgHjX3U9cELFbBZEcCS8jL2r0pq4UPtunCjvS9VSd/KVZXIhIJjgtGcN+K8kDHwHlUOFl/OjA0fWQii6PLggwYnIt9ZmwnR6nlOKcMfe5w358zHrnPnk/Wc0+6OHa5/+oNYxaOn9VEpelmBTFDGunJKqbM1HqmdPhoeu01LS+Pk1Za5KaVPdtUgfNDWeXQ4LK66jHd86cfrbvj2muDzw4rKeQo27kerJCNryGibTqaag3BhDvkbeeum6TOVsobYYR9xWkoUIPzJ/B+VosT7I52ZnxxpD+KaUOY1a78rX34gW+uHeHWV55+NVM31/g+M9Y/0gzWyacDHXYbddVlfRhdgG/1q2KdMavrdliLvmnhR3GCSR/g9R2e2+LLgu6l6lqX+r+caL6z0YUfSl1w50en603ELZOd2B4HE9bgC3w5Idf4PJMWfJyvK+kT0bE0czyzvC90/GPeTcj1PIX9BP9wgZvZ6EzCmIk5biMLsUzF4EU5DK3tgB1ZDbDS4sC3ZKZ466MbDstSQV4lL34r6wgHY+hB98gsT3yiG0nGBsCfvWlWLczdC4NYGhrWcF1m89fnYNKrYEkJgeQiHBGLODN9RAkfZquM2OqzuHixUIrgcAyK4vI879QneBOBIEnWp8MJ8nCLXPwh6YIIRvsxLGYMc54ZFUQ3NF1mIX/hiBOppcDvvcWFBROi+MByx80tRyxEUsu3RPkfOQKofrSSlSENSbO9SEwkH/JZfYJ2wAw9xJAvLBfWHoKRB+ZxXRLcYShHOUzisOxlrFHlKoGiyLYki18aIVVH7oWTMM3Llm//7A4yi4i0Xk6Kj31yXR+FOUxRUs1hqpQZGRUJm1LZzUoBrMvkbtKjaoaJkgwjCpnKtM9ZAQ4c/gBeDb9ZtxtWaj/k9KE5y8QwfthzZq2M0Ul6FrbtcW+ha+PRvIiWTnnCEHoxrNbuwpS61FUxYwOl2HL4Mk6Eyu+AZTznoxqaTq4pCDz/Agl9wlLKaUozVh1VJcxghs8gErGa/mghSUtKj4pMpCKVId4n2zTCgbW0lLjMJkNpasYS/mtb3cNnFFvINnlOjpKoDJ+8MpQ6iZCUm9nSqQCj2pGR7KqH5HxjRDI51GTKSpE4zUgOe1dAod4Oo/W8Zr1COlQY2k+t//wn/1JxwkulQdWGUm2OXa2aVzgGZZLKLONf3Qktd3IPRQokmsfwda+eFhatihWq+DYKEbZG9iaZQxPALovZuhappZzN5GcblkiahAcrIQIJioZWVthOS3dE7Yghw7RauASvkY8jSyc959s/lvONYNxYPhPJzJx+5XE56ahr2RYr9kZ3fB1l7XQ5hr7r/tKXkDtZd7/1Xc9Cd0xWK255lzaaauHkrAaMrnvfOzTG0sqatJVsaVIXPJApp0pD+qZdX7I38BWFoUQ5kAjPiJQAyvDA7L0oPR06OYXdssEjvUmEfXTHp0KVt16dKDA1DLqpgS+4u+MH7/IS4uosKI0DRmZpqP+1UGmNtV7vDel7rdXaF1JYPhQRoAAvA06xaLckzyFfdFxaNPDKNCJINVfNbirgZzY2vfNrsWoLDF1UppbKRWMYRCj8wOuWuMteNtmbbpKfneTVMWVu6JnBwQ+/NqklsvFzgg82LAZHma+6EyueIbXn+Rx5wLLLsW57Fmr4hJKzcCyzSBXdj33kQ83rY2Kbn1hgWufFJuRy7GulKd1Mc8xRnAY2kDiG3VO3rzPfdZlnE31mELoaQY8OWFjOlk9auxirHnSvk4vNlWADm4oWPhZn1fLC2iX7J/mQ6Xvy1+ooGVdxsaQ2X/s664MlsM4x27YG4Xjlbu+Z38IrzbRLltf/cR+w3BzMB7pFqm4M8cPV7ZzRz+RiuvbCpTsCwhqtLxmRjdu6dD7pN/qaqsa3tPmN7hNY0Zhkbp8ofKZtbfjD5ULixTmxg/Mrzc1dk+eOG/jNHrVJUEL+wJGnMScmlyLKyT0TluvD5Udbt8xjg5FHAqsxNAsfYW390Xh1ULauquRbwgvn5apy6E0duUQ8NFkkJ30lb1w5GJ/OKKQy+tlTH9vlvBZ0ige9Jvt0TQEV2HPfnVjvX2fY2bGck33l+24VXLqBMrncl3ek7mUstE1QGPRc01t5/RFWIh0FPgE1z2FPBLnifWR0uJB60C5pnxQP7mGZNlTGkN1Wcnync8+L/+uqyyMN9Dg28Y/DNJsfO3tkPsZ6K2ZXXSe5W7ElD0ZVBlmsQqYrv4JGuGd3kZQHKz3OUxau6hKd01xZ/kbgOo953FiP+HW8Xv1W9tr3OmP8is/Wut+232ewU6OZtQ0BqbiQn95DvsWbr/TjpYtgP6a5D+iLv/lTOEMKMuwrGndSrr3DDt/blNOwDgIDvHw6pQXyj6JBwIMBOKfyEPZjQQc0qAhkuWSqwEy7PVHzOw2UPQJTkuu4Kr1iOtuRIdfxCEHyCBVMQRRUO31hwSV0P/uCwR8DskS7M5hjlH/xFCKcks8bHRgBFuHjwh6clJUhLU4CH+EJniVsQbrSo/jTif+mm0AL7LV/CBymiRwvyjwAEcIt/MD3KRMwRJHl4YuW8BXSqiEyREFOQ8MGVMPSYsMv6i8g4zj7k0NWI58OBKIgbImBE8TpGL875EIGkpiTOKPbwoo8PBZDLA1gS8Q0nAevasQ2DIo39Cncw4l1875LHLRB48SU4TACgw6bwhmBY5xpE8biQcXy27NVZMJXpJpUg0SbqMGOmMR9AEICFKQe/Job2sQ/3BStU8Mteh8Kihy+WCRBQwqwAJrq4KSQS0KQWUZmPKCmo8Dpqi2dmMbeIyVs9JWAMQm9AUMbzMUiNLYRm7afgZauUz3waT94lCIofMbhiEaJ+IeJBCHPy0f/fezHcBPEYnISKRJGYgRGQZssxki8blI7hkRJnHDG3QGfiaRIVps1lyJC2BDJnuFGACy5wQrD6yjGdyJJw0vJoCQ7p6PAICsal7zHI+k//4CJjzwbAsrCf0RHU5ydkFCSnvTJnhDKrcw5p0u4omQ4e0TKivQMcLTGEoSOQBPJQgO+HmwLxykt5Hqfg1mIWeLKuwyfryxKCywNl0QqVqvGTdyTPYGckjCZgvHELSqQ2BDI5yMgXGwWhTiv6sJLeNRLM1u0A/JLENq/tiC/KRmhL/sy6JOj4jCZbiw8rim0Bfmjk7oerEQ65avMV8wHeZMIvuxLiiTLQAMflChMlVied51YSyXZEXkqJXghQuRqs9j8mNl0zoPRzYo0zYzkGN+EQLoaNKeEifIBSroCItJyRWiizOeMv9o8tbFct5tJud4EGOqUKjXssrOJl59TSlLMmVNBQvLUT2ncTDSblbU8GP9xT7HYzs5xSsaYT/ocQkHCrvCMiIAAACH5BAUKAOAALAAAAADcAKsAAAj/AMMJDCdO3LhyCM2hQ6euoTp2ECNCfPcOnEWLDh2ygwdP3rx68uLBW7eOncaJ8VJ6rGfvnst7+WLKnJlvn0V+Fy3249cvp7+cQC/+G0q0qNGh/pL648fv3rx2UNu5S5fuHLlxWMlp3ap13FWsWIGGDSqWrNmzaIMOJGgQYTmFDE9KnEgxZ8aGG+OtpCcP3ruScimq/NjyJc3D+5gqVpz27D9wRyMTVeqvX7579uZphjrValauW71+HXuR9NlxjVOrBre24MGECzPOjUixNjiTd/Pu7esXIl7ag1m+hHl4ZuLFjJn2BEf5Z2PJ0JMylfnyaTrQ5KxiB4s6p2my31eL/885sGBbhOfQgcs9uzZF37nf6aU3jx5fkSXbBy/ssjhN5AD2I2A/lKkGXXSVKRaTU+1Uld05EGoXGljeddeYheNlaFF555mjkF0PzcaOe+/AJ5t84NBXTz33vTeXfCoJZ5h/Mu1jI4BM6SQgc0mZ1SNzQB1YFGUK5mNPg+dQRRWEoJlGYWoYajieQAYd5OFC6tklIokl4nZiPOBotuKKIY3U3jsdzWMPf8TRaONxOOYIznLN1WmRUkEJ6c8/RPJz2ZFRKckkV6hR+KSUiKZlnlvpZQnUbxJxaaJG8IA5Dzj1YLoiX37lRxs87nikJn+X0RjTm3HixBOddbbqXE5CDv8pnZ+YPQWVoIOOFqVquyaKVkEJKaSOWSad6d6keKHpEVCb9tVlpGmOOlx/pp4KJ3IXLXenq63CGiufSe20z5+24rpVOYf6mq6vFmFVDjlw3SWXscfKO2JH9IxpkT1khvQsO+soq9mabM5Y3Lg1pYoWt3Za9C1Ssy7IYINVDbpuhhaS1muGbsEVl70ijiipl3itU6k88qx40Zic1kaSwKMWbDBNCCccp2oMA+nww0pNd9nEgpKDbniIbowobFjKG2LI7sVTG8nJdiRPvvZctCZIZfpFEaiiEgzOtNSaeu1iQb0KVM4/7hxruD7XequDCBmNMbtAvZWe0reFTBuXFIH/LN/UVO+75jzyuMPR4e6EGnPVFrn0ddjG2XgqgGRpa/ZFDOOptp4RG2krkl3JfdrFdFtk98dL6x0p3yXaq2zKLFmdGcqJc5S44l6b5ea4Y5Od7baX+5S5UDwvNV2tT3V2lYbclU7WW7HNqzpdTb9nr8nzscQ4OPwSXvjtoXq0fVr5gGPc5DdnS2C3ZXMbZPFtZ3br8swTXbo5d0s/vci1pZRSl7LB3tS0l5PZ0e52KGuM44ByKmulCic6Wh/7yIKnAm2Oc8aT2FM8Uz/RJapRstnfmfz3v2eVTFn0WRNQNOO9xKFMHgo0DANr9EA5zUlArjqL2SwIGfi1bR4O8iB4/5xHlkZFD1Ii7B8JOXKse+GLMGTx3gsTmJbhyGSGN6ohBJXjvrQ0TCnf6pmf8gFEzwiRiGnBkhrxkjq9kYiE/qvU/0i4krNoxiMou1QVrTiTi1jrTYAMZI6UI8HmNAaHEuQRGA9EpH04JYhnRKNZ1PgxEa5OMHDMpF5Qli89akiFOeEjTXJSrRrZCByLyWFaFoNDRS4SQQki43XsJ8nUxCZ6ltzb1g4HxyluMo+NURNa1gQ2/8ywlNZCJU9yFsHl4KgndVqbdPLRjnOgq5ZSOiISp/ey2hxOjnSc4gvN4jWCjU92VVug+Yx5TGTWRJmFBFdSHjOnGzozTq3CYFNmGf9JbF7klvoLWcC8yZFwipOKVASKORfKUILhY1qkHGU7p2UqcBwnnvOsk4C2iM9o6okf8zgH6fx5Ftm0UUQD9WYvD3pQshATbDAlGEzbVBygzPSm1LKoYjLXp5vwY1wAyueeJLOUaqLLPOJITVIlKcKBdhNNaCroL1k6xZwQZk0PxalWIXfFmITycS5pCT7GStasuiSrV7wWTxN0kxrlAzncikxSqOmZpZI0LaojyVOj+k3/UbWlF7mqPcxaKhpptaZkOStWy8pYslLUfGptjjzFiMrD6JQpDDtKU9wh0jMWpJYC3SsveflXqlp1oaI8H01uqg99SPQyj2uobBc7Vor/1gROhRzqZCpjEYQZbKeZnQw/7DHLX5nHn6HdJTj9WlrAFhC1XA3kmyR205mo8x74mK12GSvKLObWKAUaF0RtRqCdKEaCQxpuZ/uJRoDp9b0EZa5zpTTYmZkSkNbd6nAEt1DtbXewjpUh+nBImaP0SLwyXWdizBtU3fKJH+2gH0mNBpH3dhOc4nRegF3i2sgFMr9bHev2zDmmMc02u+YUscFwK1nw/sSRmWEhtRRTM+AOKR/pmDA4RlphC28NTLXEBzhqW8z74jcfrdWqOQW3shI7eUXaNed+B/xdA5vPKSxUE3ESU7OYYNbB/rhHjsfxWXDY9a55c++F4YFGKWO3/7qIkUlr9QE2s+ZuZTl5spOj7NCXrNNmqyqwgf0kv3ZcqiXWOsyXiwLSc+wYqWi+SET0ujXnpXjD+jXMnGFKVqtxjywqs4ieS/xfs95DwSxu8ZDMV+iB0fRnMlk0Uuhq5uPetTuTXnOiGMrdTPuarEtGi75EPWr/8prIfnYgF1UtXM8ZOkyIps6MFqxbf+CYHLU+c1BAAw4JZ2jS3vQVS/yLbF87DqcirtpCU5OpPBfb2LQFG2SzGOhXFsUil2EhtHGaMAJNxh6OPg12CBWW5gXlO7lGE7vgXW50Mxas+7WIkNH47oY2XB/zTrW9753vLLNJpjP291Coie3RgSZCX/+pkMYQDm42L5x7i8VuY8/KWKyeOicTlzg2K75QTLc24+eVbA+Jgm8sX0rLYXWzl6sN8HKghTufIbjKoY6hiIAjYI2BYVpMTNvGNtahD0eUZsaTqXdDuc8vaW35ALmqQhKPnkWPMfdewtAZ6xbCJTcL1aOuq0JRfccWsjrW06L1rfOXzz0v6533tZp6XKrdZNczr9OudrYTUtCQCYojPY6ZuvdnHyK3do71vvfS7x3wUSKJRepCRMS7nteMzxDkQe3uUfd8OB2+rXfjCXefOHvshXFzf/gxTz5FmPSmTz6GokSRwbf59dDPubDPUuLGlJ3n9cV9jZRZ7x71HnNGgsr/qMCqdFlD2OlTV/7p0/Keivhz9kxGPIoBXFaztBv+Ta6+uzV1fbOf3axzpg+ndHl48n13Qkbip2Wx9VIJs0jX1i7qp3zaFhTu5347p26h5npe11hBwS/DFhRPZn+S54ElJiYxx2GthSoQpDkGyBwIaGgvBXGfR3xDFWbpEIEROIGR1hjqJn8otoHpNj76xyz68oH9538swhf5oj0A6Fr0tiOHdA9S4Q5ahmTlQzNftieNNjQ4CHWQtoP0FWVBCITrRoT4V2y1Z3b28UL0MSpZNWcqOCCNAVJTqGXS9YTFt0+h04VY8YVgOB65o4E194OLl4ZIaIbFZh98kUcx81Ad/6aCq+JF+zAPLmSHx8F9WTgZUqgdXWhrf0g3XTd/YAeEQXhO/IeE1YeKjreIK+GG9+CEkOgYfkSJuAMTC+ZKrzRXDaIVXJh8nmhmOZFUOviJLkV/wHZppFiKoJR/qniKZ0cw2sMyrIgy2sNhupcWj0FPnnM7VQh6riRXetiLpueH5EiMqwF9oXiMZWiI/seMsjUmd/RChOGIlYcWQ5ETjvQ9uFM+mMNIdNV3XqiDtiaM5qgad7aOgrOBpgiCqjhsXNdQ3LMiUpQyNveK76Q+0HRvSPE1hFOJ9lA+y/FR//h3FzGBSCWMw1iQu0aGHbiQDXl4soNOjlcfS1iRrwgUBP82T2rDWwbkam+VkYxkbdU0Gkr1iyqJRqR4kAvpjP63lArVPRL5ESyRVZXjdkOHFP1gEwVkizhRfAgiS1dxkgRZkn54lP70daCEVVvXlE75lFdDavVlFgNSgAaWlUnWOG81J17JSFtIZscFaWVWFmaJlIq3ZMEmgsXGUOcoW9IHFG23cbslLgOYiWFEV37pGgNpGgYxmISJTj0XFI3ZUPBWiAr1ac/1mWcxl5AJMUqxUR61NiTnl32ofpzpT4wpZNmFm6HpZDinmMWobgUEc/R3FgS4mpMVXLEyXPw0m8lXmzsHeVCGD+NGmsQGf+1mjNQJc6A5VqlxXq1knMcpaLL/snH+MInrRZvOKUkqU2JjlSn8Qn2h5mnnpHguRTesVGVylVlxhRR6qHzZkZ7q6Z4euDJtiX/ikV1EFIv2tFZr9ZjFN1dAVHLcUQ5Jcg8QBKDOEzvE2JYa8keoMiCItD4gOiDd1xwNllGOFGEH4RXn0A5vlTYYSjcGqhofqJKvmHse2jtatEyUwWA/dRwmSlfp0A4wQYMwGqPmuISidpTjhWSVd4c+9UA5yWBYmJNjZKQ8hKSIAp0iWHvVaZZEJoMBCEj4eIeQWBkEUiRVulZaKm7xySyY8onqlBr1N1MBiHHthBgXRaJjlHRbJnLheaRtOn1xeoqlU6MHGnZ02mnc/3kRE8dhpORHu0NIGyVenccfoNcqUDiowvam+0d91tdkhZpnaeF1b0ZzjSlx3NmoMXRu9nVb9yku5NJn+sCjUMgYnAqnnzijDOmoqaqqpsaoG5gaEAVWerp7lfon0DhYgGZRlpqrwsmhnopmerYajkWKQyZie+RnEOcfT2heCOaBKiSA06WsuYqQR4mKi4qtx1iqEGVbx3peTLEPdDY4MpJ7dNZ557qMg9mQvAqsQJitCDpMZbVAqeVh9DavrTV/VHkRdKelvike/7ql7cil1up1ApsWiSdk03KnZroYNqGVb5ZYAwutsVeQo8aUiIKaijqqx4ZpNwqHZhqyOYFx1/+FXdlpssSYsiEIijh3Vr8Jdipkaih4p+RKFqdkEfmadPqms7UZgj3LLvPJqqcJkTB7p2jxJjWrWFHptCoJnVDLmz4LFI2ac3wGczDbGKhyERiXXY4HQ4XntelqdhsaZdEKYEuJpxcRSL0qt0+LhuaojMZ2t+c0WGLqR3dIZ1blt2YJuMSojCSoQugqcdnXseR6hzfHuChbnf13lO+of6RpcaaWgolLc5qLstVaSxN7eCS4Z4z3ZLdZW6TLdvSar796uu8HqqjblMIJu9vFYWb6c3OKu0+7loiqq8ZLt707gow5u2RKvJortrTHbodIYrYnuq9opjsLvTA3e6sLatP/GnntSLjW+4wpBrwzq7Uyyr1Pebdiy687OL7k2197hnbkKiB3aEPixr5VW74qA40qu6S7xpCOi46Td7mgV6lvsqn7y7+sC41jIopHuJ7f+8CHybkpiykGPIrZm8Ag+qMJfKgOPL+LhbdvmbrsRsJCOL6jKYhjlYJtV16SycAjvGsndoxQ5rhdGqfbxYwltoSh1sJ8VrACGMPhgr83UsOgiIxe578UHL7UN1i5k3P+ly/VyS+v51gpmJOtmZVkAWRKDIhMTIbvliHG2JLvRg8YbL4vW1aky8VHvLYXAcZhfLHJWHOpW8FkS7WeOWpqnJg3rMX3q6lZGcJzXMeqccdk/3yEQYbD1Yp9Gytzs5tbcSyHh4zIaIGxiixiegyCdgxsj+y7QlywN2ojcDyiOOQ/mFyq2KqdAKutsjeErIzHqci8sfuKMWvKqDyiPQImKQEOdLzKiqqbA8uYOUvAUTvLoKyK2yXI5BrDuywgcATMq4xzmjxkp0m2HIrMQ/ivTeyQgNzM9PjM0TyiwVzN29lpHWiaZCux8msW3/zE4XzLMkupu/xT6LyuoDliFJuEivjPf5zJtDzB85xi9DemyPrBSZvPZ1F/2sw42yzATQbQFP3P0xrP8szMWLVYCL1gqKy+v8zQ6dzQjbeexFbRmmTRZ8eEiqd/SAjBDEePbPfRSf+rD6os0u1M0iUdxEmoSZmkiDwnjQBtdjANdqU80yNqIxiXZDeN0wE6bPliHz6d0kPtx//sw74buRyNwLqswFq5aU7tpryJhv881VNd0UuI1hZR0TxHVm/swSR6SjJ3o2GdKGVsqACtSfIBI1SN1ms4NYCjxhRteyxNutA8IKdEZ25c1/2MwjlR1iTENz7t1z+tiBdR1XtW2Permmh6So7Usoy90xk80YoIR2901iitEvNx1Wut0vWrxV1dSEhsUY9zu6FtfXTrZJBt1nDk175t2SmSIkDtu7K72bmFv85622KNhrpd1lLN278d3Zft2qTm1m98yr2lldmtt8qN27n//cOUrRJThNZCDdDTrcbCTd3Rad0CCKKGZBbq292IyZRI6Nvi5NdWbR9mMdgm5nVwyMvrU085MaLyrbv+Wt7Rrd6euilnoeD+fd2W/BPlbMk5EdLdfeDNzd/8fdeiit5YDZczJ7MUPuATHhQWrtz3h+HSyCJPBsQc7t2w++Aivhw9oS32xMU2XuCfyo4q3oyizZ4b2NE1Xk/agnHunaU6jmcf3uOHGMtPFuRjipM6ARRGztlJ3qlM/s6ECr5PLuNymeONA6k3dOWkuuRw2bpjrbylCr+IGMGNxd3j4dZkjrxr/JAwfeDK7LbHS8EApnNDhrW9tZj3oN23TUA7Tt9s/4zmtWx7jIe3QJjMcVoPwsrec0bbmkcWeEpMcC7S6mrmDJXZ/+u62rnJ6Wax8EzEgL63aUGv2DVk2Vvo4MvjiQ7q7im9vrrJKiTL1sxYRiuAaouP+do4m47TRtiQn05qXJfnyaiYkJeMvR7fNQvfbzLs+Qy2BE3rdn7nqdgYuD64uy7jRrvQNftzJH7P3AvF8JnmGn3saZ7ISbki6XbrUB6zAWgWHrvAnK05xIvuiAnOBA3BG7zOskPq6iywpJhkva55gAThcCyojHu8WO7vbAl9QTuKm2zwzo4Pvc7dNsHV+N7w+o67EJ/uRUjU2Y54FW/xwzpxUL7xqc62/13OzP8UvVmO6NcbyJOLc9naxopK7y7/8+Puse5NyaoUoxWc5QcuhqBNFhPH8y+81DD/8xtP6Nk97bHNoA7/t/xu80h/87HLx/DMug8e9C4PDlMv7YGU710UPOkJ6bLe5Fxvyyf2yRt4k/jorForXWaPp5Ue6GU64cPzO0jq2G9P+Gbu9XNPp6/M6xyftHy70NT+5aqJSEhe7n/o4cmLwimu5W1+5ifseolqqkhL9Xur3aQv7bw8QZJ/+Zgf8aHcuWrO5Vn9+aCv858GSnVP7myrtnqftTcO8pdDw34facCdIjPa9W5f+AVNvxedYsDq6lCfIXkv7pJ/5A0zJ/he+qcPhsf//5Ik7/qo+Lm6XpgsH+1/CNeqiTlm8/jTrpL6Lft4bobgn+0n34O2jvEOla27T1ILvcsAAU5gP4EFDe7bp08fQoQK9RmEGFHiRIoS6YGrJ7Hexo0YOX4EGRJkRZEb7Z08aRLlSnAoP0LEFzOmPZkxK94EhxDiQ5zgCPYDSnCi0JwNHR7Vd6/nUqYQ6T2FGvWix5JVX+K0mnUkxok1veJT2BQcPoEOwSFVuC9iULZBJRJkGFfhPboOZYqVKE8eXoNSpULkKFBr4JuDDQvOCPNrTZ5L9dkcS7fmvbBv27qFGFdzQrQKZ/IFXdEvxY6GOxY2fTji4poGG9+0ubjiZaD8/yQydCj3qMF7kEP/nvh0YuqMiUkS1yqRJmuyrpc2H3u3aEG1Bdtmrl60c9yc1AX6Bh4eb3KsyMlDXO5V/NnM/apnHwg0O1LcndNG5CxQ6Xr+TLNGPA0x8/4zqJ6TvuIPLe4qMiop+yjbTSKz+qNwqf+M84iqAc8T6ED1XquML7Swy6ygo8Cyb8KJXquwxeGs4krADVUrKL3WHAtNxbMe4gmp3lDszEUhQ9sqwxg13GrGkGpkjSnoACyuJXs6PFDHHTuDTDbFWlNvyCGLLLCgqmRU0jgbpeOLrJmy8tChuhxEK8smC8LHJZNu9NLFjaDSiMwkywywJS1x6hLKKD+aMv+msCRT1DWlbLLHJI6mNChSjui5E7w8Q/OrU9QAhZFKD/H8Dcz0DGLuq0gpXRJVSyc9dVPgOhWOT9JADVXUM/kLFLbo6nySyicvxXCsV02SlT9bbT0OVwJ1JdXCYglV07dqT6pUymAxumhaMXtNltOpKKr1KWdpXAlNFwsd67saW5LyKsDkPXK1cMW9ya9zB3t3VGmjxGtbQd19lzD0NAqU3XvzFU6ghsmlVap95cU22lu97cmmwDKitNJWURUYqsTc1HThiDzFKWKVJ2ay5GajIk2i5kYCN8wt63SqYXyMcvm3eOK5V2Wh9/3OYuU8Gm3cb4uFbk9zvTWOaTpZdfj/5+8Weqxn0ODh+meg9dpLSKHHpnXAotU9zlOlBaQo0r/mTQxTb3E+Emigx8pa4N+45ttrq10kO3CJnRaZQAR7qgflPmEqMHF69IrKuIdvnehutMPjO3O/xRa8c7JFSvRw0iImck+HRRZzcrHuFsxIcPgWKHPZZS9o9tl/Azv30wUH2/PBS/KQrt5Q4zYqr0uv2VfQYI7d9tsroh0e8XLv3XPq5fFdbuCnfPPHFx033uu1m92qplGf5PLik5l/XXqI3I+I6/gzX+/63Du3H3vBrToQnO7Tlorf4jG+6BSoW0tCiujqYb5hNS4wUxGgeJxXO9stJX/U80v1HndByAWu/yr9o0xC9vMiqAhQfEu5SOFGhhvRcaVj33JgRwYokM3hBXbNe57z4IcTDvZQKhfs3PbwoZS0JOViJYwgOFQHw04FZiH1uRzlyFSQvx0vNDrE4g0p0kMuYnCD1wuiEInIkBECKHx+U9xUAvgz4SQGSKVamuki8jfoUSSLWYRIF/Vovy9WT38eBF2VzkJG0TzFhGNT4hpn+LDYqCsjSmOfAwtSKyqyzo52vKMOBTg7E/5sj1zMnhgfEpcy5syQAvQdGk9XKZRozHGTjGTKbIjJTNbyjn77JB99F0ia7IeUEKNHJ0cTHJTBrCRnBMcAY8mwJUpkh++zZTQzGY9cetFzvEscYlH2wY99lLIvp6whs07mFCX2pZwRMyENlTmeROLkmQaRZjyxSM1qajCMIGmlUhjCTW9OspN3I+A3xSlQWnntHQf9J4C+GcN6BAQAIfkEBQoA4AAsAAAAANwAqwAACP8A0QkciE6dQYPsEoJbyLBhQ3n05tWrZ88evor25jmUJ28eRnv3Qooc6bCkw3woR6JcuQ8cv4X9/PlrKLOmzH44+/Hzh9PmzIX/ggr9V5PfvpX35rVLB26c03HiokqdarKq1atYszIkqE7gQYTstC7kSG8ixosZG85b6xHjyLf3tMKdy3Ifv7v8Ys70KRPcTZx48dpkOFSoTLwp7bU719Tp1MfixEqeLNmg168HFYqNx9Hsx4oaF7L9PFdkybioS6uuazcv3719iwYOXLNhYaKH+aFUyvQpZKmUS44LHhyzcXXgwlqFBy4eZ7KeQaKtuDDjZ5CqT6verpIl3p61XwP/nk27L7jbNo3m403ON2Ti8OODO/4VKzznnPN3plhx5Edw12FX2mkC3tOfW9yJhFJrrtW20E/muUTedzEBdRtud+Wj2DnktAcVVfKFOBl9Bzm0DkP4PcfRimXxp5o91ZEGF3UOBWjjR2jho2N3+zDoUIQMBcbgbD8RZlhR+8TFoWNUATeZUyJWZpxV71SJ34pkQdRiRfiEtBJS4Ph3nUj/MXTjmTd2lw9eWOWm3oJEOvigTBjyc89i5TD53pPDOdRnlA59xY5BVN7nHJZa0lOWRP15+eVKC5GJJoyisWXppZPi+FY+Pd6l1V1HfcmgXnLahGFc7f1G3FN/AlpVQrAq/xRrle8YeiiWLU6kK5eOPppPpAaiGRo4lxbbkUdttXVmlzza9alu+dwjamCkFkknhuAs+SGIkvX5VEOtuhprQuuUuw6t76SIKHS67mqRmr6GFOClDLWjVDv42nsvpvxlChecOTk0lIS+olTeYBYG5c+vS/4WWVbfLgQlQ+ECOu6551YJz8a3rqtou/02ShdKDX1W7EL25qtyvhxd6u6kO0oLME62DewPtNE6Si2RCROVz1Kp7olVxI2BW7GIF6PL3JUegwzymAOWnNHJKMvjjjtWY3311eu2vNZ1033G7IKt0WzkwC5FK6DBE971k2H8zJNOnlJNbNLErLLq6lXjov+rbtcQOf20srySVJ1alrbTUDtaZ70114DvF7KNzMrc6UsC3waO2o2ynSGcbp+ncNwNixPx6XjnbffeJcWaca0dA56r4BNZGqDUJa3l0OOO8x65PE/fWPk9+sBZ0oVpG6istAxOu5OFMy2WKuqqS6z66qwzxI65tNr6e+C0t2v7Z2aC5tA88jTENdaAP86+1Sy+nKZKl/djVVBpT/215b62ViRR4JBe3oxGtOyJJSG1qpWtYuexj4XPUseiyLCIZamrMC5r7YPcirbGrsmBLWZkY1NV/rEQO2GqVzmz3E6KhLJz5Elv1xuaARuyve4t0FCyU5QOd1gW4LHFaxOkIL3/TAK/962Lg1hCIkQkIj+xVS6Ed7GfSfCnG/3tDyn0W2FDfqYt03nretUr4FWGczS+vY5jKUpjDnm4Q/St6yGAI+KKwPG9OmLJg5pyVI/KJsWaCWVzymOLl+hilwqVkIse8qL1wAglvXWLMuTS2A03xrE6sjEiDymJHTfJya5FB0eVKx6n6tfHnuEvWpd6C4I4pcUS3smFjmQk9Wa4kEhqLEWURKOKIqeohWDSKnFkSCeHiSgmfpJLTxwlH2miuTDZTkwgAYnBrBW3dHiIetVrDPayZ0sr4SeXC4wcHdPny6t8b5xv/J0aOakoY4pNQWQrG+Zqgh5njkZeH1HJ8x6E/0hHapORtKTh9s74zVymcZfwISbg1qlQLDEqj73a43f+18yk6AtsBVpTkfpxD2v6U5bbDCg4MrZAXG5MROREZ0NX+r2INDFm+oipRPNyvKHM5E4XRWaXRKbRIM1DW98K6iwpJlJw3NI5lNwbR8bC0qZ+T3AQlenlMJc5hQEIX1+TzvBEYpcike6ajQyjGIu6EFtlL6VOTSsvHagrwoVylN/xix/7ohisFugi+qSqS9oB1i+CsUMdCqkBDXVWcqr1sCy65KLYwp+YWW5UQDIMsfLlkdW05jx++Rk5XtjIf7IKsIAlKziYwzpEqRSxTVWsDot1FniSUk6iW9g8uKaRuP+AQx8RbQlQMstXzlIshh06h3DJIVrKMBC1yF0jG+tRloisJTrJnCl4ahamrSnuJD0qCYQ0G1gyZpMhoO1QcRtSpYUcdJfJTS+i6AEO1eqwHs+FLv2mqheBbW4t7riuSahlnoVJz0O/FSw4Qita5/jtvOlTr4JT6pDl1o6JMQKHY+MZxfoSJm1MXYg+GpITnTjoZvZIB4faU7SmkFXA5jWwNw9alQVzUo1MNS1DFCu4CFskuvSNLE80BA53gKMeDmmQqUjoF36EmEMSKzEtvbWQd5QkjbQ6bzyw4uLvpTHDc2ywakEWYQBNWJkVRhhMkkSpkqxwyPgrMoxEfM1VsS7/RVZKF4s1WWU7whid47TKDnXFkOC1NrcVrhZQeHIU2zakqz5B20KSBDQUD9C7Y30zflpc59/ROcsMznRJPuaQdjkxJFKlr6AVdrMkhWQhazozmmmiG7kRVzgATbJVyhifKcux0nWEozAznWAGY+WYN2ZWTENNIQuTuh89gquQE22bw2hoMXcD4yKJY+vJVFuTp8W1OOmcSV9fBdg6cuyw91g/B+GGJxOqlpjnVJSOknib36WMk5VaZUXZEc8bwdKM2asVT58l3OIe91E6NV2/2EQnxVY3kF6zHo+W0Z/jbXGME2XvlbIx1zKGI8V3+Gt//9uxxBt2TMHsGnb/RScd/34NC1/TamtGPEqJ3SFLFXtY9nI8K0D+sRPD/RaRj5yUfulwXjqMcvBECDY3KUrDX/3yhJKFhzN3r5UZypFD8bC9YpEfwFUj8pm27etCnpOE+HszLjY9RPzWNTHdS4+pMw1LVmcjZUIG8B0NT9gCnypehjShowuJ7LpxeVUec/ZN27yX2d4k26GuUqpXnTNXx/rcP173cL9rJCOHVMFQTfI+3uxzJK+JZhfyMIYQvvDmpCPU7bj41a/I8fKIO8fTThnKVz7YwxNlwUjmkMsyBOGhgqdGD/NTcJSeW6gXi8xZ3/rlP/7tr4f8JUOEe4D/+/IKkpmvOM97h4znV2Tiqv9r7MQU0zsp+VpRaPP3rcP1Kuqg76e4iHQatgDxPDvcr0sJEa6bMJFG2R1VXNV2ba7Sdi3VfFKXKGmkWoCSKfRnEQViOP3DdxkSLPnEPEYRgGRFgNnTfmuFgM23gIs3dzkXIzBTf/eADxLmWPmnbFGkHnExNau0G+WHflFycbgCggzIb/SwgPFggO4lH6BUf2gCINgXFwVDHoUWSPZSIPbgDuZAazYoGTrkSxnnS0FoeFXYXu/nHDr0g0FYhRPRZ7/mgMBGKYWDhBMoJIkRQFkFGtIzhXvDbyyiZQxoh5eEH+/HQ9J3SUDmNB2HR57RVh5kgqeGQnXxJmqjEfpyL43/FnG0x4XeJiKRx35ZyIXuBYY7pIkg2C5WET6geDsmsSksQTY5kxZrwTjukA5RSEscKHlTeIc6CIY/yImt1y5VSHugGIo3Yoj/shKZd4qMeDVs5opyqGc7mIutR4teiIATsYO7uIv20ESUMxe6Jy+ztYoilifGVxJRcYwGhHiYKHdYmIk9qIedOI40Fo3siEfvNDKLaDXpgA6wZHyRoSrw8YoNIY42GIa9tHjN2InMpY7r2I7S6DRusVW9khTyiA7mQDfAITRacV4bYXPgiIWW+I+Ix3a22HpYp5FbZpAPVCzuBDXapzyreA4PuS34CF5YQZEPcXgXCZKzh4eXpCUE/8l2ksd2IqkrH0OSQDmNMiIzITFb87hZeoJ89fKScyZMMgmONLmP+6iDIFiOIdmOigWUJAk1KZEU7rAODvlCSqkWTyZl+hiVxxiJVXF4VNmWPBmNqqWVloJHoKY88riSddNZC5EOtlVKKQaThqeOF6l8blmYBSk4iyeX4yMjMZUURglLeTkO5UAO6dAOhlYVZsmBl5iWWliJhumMDvYxbamYo3GBjTk17gBLHzIOlGkvv4KZmamPgsmFgVlOxaWWO6mM4nh1n8lWf5hzPkmTnwlf8PVQjdKYwTJbLvRC5WAO7bAmTJmZyLiF/IiRtllUuGmRvemWwFkSz8iWquV+W/8mEc9lmqeZEatoDuZwDpU5D2tiSLApnWupWLUJi+MFkhipk1aJgATZnZ3GXOCpmwYYc4f5SaC2D6eJX/m1OfsHGD+CIrE5nRuplrt5dlvIZ/RJnQSZkwL6XjW2EAOJibTpgeJ5le7SJfqwR7iVgsACKkcxdlYxZfJpEnc4lTMWcWMIojmakXK3frNpnaDIoTxIoLcYPChKbo25OXv0JYvGELz3mpP2l84BTIlFFuC4o1jhkT86lS3iQN6JmDS3VE9HogQKVbyyYQyhW+CwpI8ykVPaHClCpVlipTboiXyWpT6aFXtWFWB6k2jlemWKkLxiFYCRbN3HlBAapbcGEXX/GBzVKR8l+GORiqcjOBkt8mNfCjLhGZPOF6iCepkB83vIRm4MYRqScWWJt17E8ajxMalU6JY22V5/iHO4SKZZ1qljOjsvQzzgQHRm06susaavKWHBcWWst6rkCB+u+qptuWkztqzfBqAV1zWqN6Ce6nF9aXQ8YT9+uRBoYVzVtknwUYmyep/N5ZFbuG/lxF7QehU2p34eipAquKbauq2eclsrGoM0Ep3hemlXaKkM2K6ss2ddqqXsh6WO2l6Kt3ieNq/7kBMH10cpWH/w5aZvSkf+qm/ImqxkxYPnKq0iyp9op7CJQqTN52kaVkjVYjYp+BnFiVYxCpi7prHjOjuF/8eu3ymtVCmwVJir6MpDfFaCKaqyNcGyRFicGRafdzazWRYfZTGFtfqZaEeOlbpnyzq0Q0d02RUSdVcR8MURV6O06pJvNDuYAMtcAKqzVCkfGVqpIjqKQ6uyOWEUugVqyBkseUZaDpGZ27Y3PEtLXaqzI9qsy8WqttmsUlkjR0puD+uiaCoSIteyD6a3eytlwTSJhMlpf0tLwTl9eXhea9sQOSeykxFyjMu4aLp1IxFu1UG5cMq3fQuwQJt8nduhX3iOsRmQNZqbNYqbWGG6p4ugtkU5AOetlJu719a0vuuu9ElWWCmTn4u8mQmCMaeudgi3wYugaPpjJNkvKqiCx/8boQM7ocubPbuYi1eRu1EmvbR4js/HNDfHfo3aEMSTvbjVZ/AFGlk1HTqiQMg7sLR5dkE6n7SHuzIKZegiZ+yLvOk6cQlGe8CrosNmaDjyZ29hQyVlaxd7g4abqQjbqg6GpcKpka97UAm8vgvMvr0WTKUatxJ8v1LDc8PWexh8ZXFagFrGp4AoImprszyqWOd1wkKcLkKcwmMrpkgMEQzRJQ+LE0h6mSaIHSLnEJJUUok6tdZ7naJLO4DCsVzKkSY8xGJ8wiqGwmbZa4mXdvXbYSoKxUZIEbm3vUalQAv0lx0YrQNMieT6w9GLwGP8x4C8YleSZ12jximqtQhaEl7/C8eYJ8dVPKUajMM3upa7WIB7LKRsZJaBvMl/fMRYNr9rLHSJLDVTA8d4R8VlxWKyybbzucNkyMO9i4CxyclkHMhjO5/0e8haC8NG6LVsdXkbRlNNVsIbDMBaiLZ3yjo9nK4gOMu0bMS3rMWnoctz2yNoWsoACjxmsSMbBp9O1pS6Fo6i6YnmG8shyL4obMbQ7IWSEco5oaLVEV/PuM0yJXZl9brNQWnmtFRaIaCzyrlt25aTts4EfSiScaS+OqrxDFX4MLQP0hAnZcMNcSv7jLk2uaebC8K82aOy/KYaXNDsG4ntqiOh1iNOrFsZITgkrVtAMlo3jM/mBbN5FmOU/0pjmBpQgquf5Bt5IE3Q5VsSDe3CSFodtMPEJeGXMsoQHFPCsaunm6nMOpzMvxmiy9jT0PzTDhFyXae9ZqLSKWpmampecFpWEf0327a8bmu+Fy2a2pl2VOvWIsiAIa2fYoF3Pre909iwcrxoXL0xgoxUZQ191JooBNy8BjSpu1mTO8m70kzX7MfHBnvQ3mo4API0Dd172suio2UlJaxLg0y2YqquVTlDiN2ZPBjA40ijI6uDkwzUdZcVeU3PcmzNEzuNZfXXsHtO+Um6ai2hi02d8WuJ9rmxjm0VlReIunLZaWrN+qAjeU3Wnh2bcfTAqf3FWwaJG3m4HhvcqI3VXv9s2jxbecVb2J5xmdo7wRcRoqMFTtHNUDTtlNx9i+a7o4ltnR67n4iHoTVt2PGBe1w73vu4LnA82/lqW+ldguyNRsTMGTPdtNXawJjsoSEyqXZa39UNi36YzPvN38QRbMQzsTqyqCtiEWgqRcK7I2Fy4AluUCnW4qmagxCep1xGq5XMsZHn1tmZdT2Z0Tft3yAu4m1XD8q93M2NEVKz4knV4gb94gQ6yTJOzpkqqbXrtp5Zjq264xq+xYIq3vMa4LhCEXvdxmXSuiu+t3L6gbtdpDP+n1P9naxNrnuqrFj+wQjpvc792g12R2XG1088HQ5R5lJKGQ1UhRu31txtEm7/ztpoG4mXPBlz7sEvc3vWt2mBUxIIeunnjVvOveeAXsKCXqLstXGjHa3bid8d3G9YzqfBJpQPOOmJy+c0w9x3vWEr2uWd/tJiMei9JOq8zafbWdwkaJAdt8gneucXcRFW0cRmk+kC16R/nuBPls8MTmUay3G8rpOn/mOFSdVPHRwiSeORmtxdaxEm4cJ9JOv1fBWdjiLSbtFMS07WvsfA3mmFScCtPeF5LB9c3uX4KtS6JcF7xGG/Ct3g9NEIVrYO7DER/pYluOam/t1aiNqu4vA83BB1F8GMS+RxG6zqDk5SGg8Z3DF0Zq24gskLL44UH9n2LlI8Hh9anb3ZxdcC/6dXVcHeHx/y6AVHJF+H/ui2KQ+0rjydEm+2VbG45KYTe4RsfO5zYV3zCa6olYte7GTyv57hFE+jG4nMLW9A+2rceTeqTdwpTS+8kNurftlHKw71E33wx2rYVa/yWH946k303hrUJv3ObBzzDtGYPAcT3bre7K32iQp7vLSh1v3207fhWG2Ddp/0CX3S/87nJ84lt/WwwKrUT1/Mf872K2xaJW+fiL/4wf2baYmbJG7uj3/SDDFsQb1htJ3eMHLIDpL2mg/RBY9Qx9rdiM+n+AvhWW6hybrSd5/671yqzELSMdWkzQ37lT9dSF77mG9QuH9vuv/2NLrmOAucv4+dm//Iid4qcMSf90ss3iG3+stv5LosE0h+Uk7P+Uwe2nR68qy9aRkN5UW1zOeIeP4e/go9/gCBT+BAfPf06QOXMKG+ewMV7usXEd5EihXhKcSY0OLEePHkfZQHDuRIkiI/0kOZUuVKeuBYvlyZMSG9evUS2qyZs+bNnDJ9/gTqsx7LeCmLKtS3D2JEfhGdPo2odJ9CgvjsVTUIlCG+heAgbqwY7ydYeB1HmiSZFiRLlzDduv1J0ya4uXR3BsWbFy/KjkVjLlQKtZ9UqFL3IUxYVXFBvRi/ki07FqzZjx7VfkR7OeTblpxV/tzZ82Zj0qVn9vVb96DhwoZdH8448KriezL/l/azrRQc5Mg+yVKWZ/lsQs0lR75s+zm5cpl3M9Y1HR2cQH0CFdKL984vxqSBBb+WelAmwav3Glr/6dRnxN1gg/Le3ZH42ZDFNceEOZOtUOgz6/aXrjmq8DnIIZc6ammh1QLzbjDwDhJvPKwQ+2kpcPzBULKN8IIsPrEysy9E/JDTj7nnEsSIpgCjIzBChYZCsTvwZlQKQqAWw4u9vMjSSMPfPgQJxBDV+iy/Ek18EUAUVyStRfRkgpBGGvXC8aEVefSNN4oyGrLL4/5iEkAmm+SKq+nKLChKKQ2LrsDpakvIQtMk2tBHLTHyUi0hTwJzTD9NE8ggCAeCcEHw4pTK/zQK08NNL8HqHKu9Dnvc00s8v0TyT03xarFQT9V0zc9FGc3LKX4Mg9Q3STe8aMs89eSSz0xJS2lTKhX89FPd2PRp1KB8ja7RqFzDUqZWtXT11ZJkkrXWS4Ey0la6fqIuV2uBgk0rcICVTkeFcAPPIo2QdS8j4YLsEq8gUWrsJdGk7Y8ga3PFy9OpkEKIW8dydCpRRMF7J2Bxd1v1TnOXTTcozFy6bq+VdJLWJzQ7nddXYAs97N45geq3Rn8P+zTgd8jdCLUPMTo3pPlUvsy0PjNiCeKIJdy2YsQojHBRjWvWN9iOa0wK3/MCFdlgg2MtrtJlg3orxYffnTkxM20eFf9nfW1UsOagGl3PK69AFnShxYomeVKkW1Z6ab32Ww4lmcPkFN95uVOQoIzyxdrijLjG1rCDzDMPIavsIbxwsgsmV2H7REo7yDFjhjpAMTEyE1dPg1KMu62yKtXbjO71G0LArSu8ntJFRn1kZBGnyGT5Ul4YqOGk82xJuKeNTXMXkTKQcgOt671Cz//VGOOpRDfPTMJ1sin1gFnfEqOLCpYPnOrPVtxxk2jlbNPJodyd9+DBGdoecAi/O/xvv9aNfQXDhhLOM5lv3nlJVy143Il+OvlS7dUlTmk8EzXKlWZ8ZxKI+a4CGJDVK0q6a0jgOGUP+tXDeQLbX+KC0j//xW7/U53pHgFZhECJOWRqENnZT/7GGKEN7VdboSD9Lqi6O+0vI9FLyPU6qBAP+qSHPqmdCF+kFQplbkB2487OUrithQytclJ7kgqTNzid0CN1ONQgRt7hE9TwTyyu8+EPY6WclwmRU4shj+kWuKLqjA+JvXJi6XJiRdRtZIYi+8nzrAfGPX7IdX/0IQDl4SySJMhZZvQdGgVSQQBFkTuEWuEbqVSV5VXxjpfEY0XAgUf+5fB6fwQkngQZu0IeqWl5+V5syFM4VlYxJYwUkxO5gpDyFQ5zlaxJK3VCuNStw5e/vOAm9ag6YeoRZRzcjTvcERZQ+tEyMGOXS+pjn9od8k8J/0QfLpn3tNHIzEVGnI42bTmeGL7tfBn5ZTrTGUxibnIiw5SJDvt4sma6rod6EhE9guMXuGiKlXJkJNuo9UQoJkab9OOPNX2iToY2FBy/vCEnzYXMelb0nsoaJHZAKdAxwRJGMDFnIikXQwUe9KO248lHMWI+dDbUpb4EivNsmEOgVLSeHVRWM8sYpoC+xTl5QU9PcEK/Ms5FoTJ56UtjesHpWe+Y+7PpTVcGEtSESKezis7y7FKTaqoIOpUTUzn/Q9SdhjQhtkyqQzGyjrX60n5bvKFFompRqtqzOH1Jy04lFhRbztFID2NaaKaF0K3ipG3SMV1C1AkOdjS2sep0rP9C2MrWhwJTpnEtW1SJA0p0jcRkecWq1KbD175yFS7RZNorBSRU3GFEpQxbUTodO1vaskOyD1WsOu1XTMhgkJkVVQhwM/PZQob2TKNFrk+0qdG+oLYxJ23JUHnySpssybRtkVj47qKP2na3tpKFaWXX6dZLvvOKvJkrH3lYmWbOroSMIehzIGYUkzn3RjfJDwhfC622yNNJZ43hQrw74MaCd7IvZQcmmYre9HaRWfVU2RkN0hDQVJC5JmtMUOn7Rdj2UyYqcfB/xZoYAg8YneJlaGMVjMmSpVddEAZqmtzUHLJ2RDuAROmAXoSSfXIQOTmmC4j7Atd6gPVdJfYuTNP/6kvHrmPFM2xxg5E5UXsCVVB/E5BcPjrkUM4ElTzuCxA1akgxG2WPZ8bdX5DcXSWn9bHkfbKWbizlKXuRSp6SX0q1TN+AqZc00N0gguIi0OsZErVr/m5u2wzZNz/Zt2SZs5RJI09qrYYhebYwX2wcab389Losrel2yswcIOsnIYh+bEspKxPaMpTFYKFhWYRb5+A6uEmCauD5KLhjIWenz2H+cpKc08ZB89eUgb4eqtmx5Iy0WrflRZZNaRo1GWeLitPdcOpsvLY+USyl17HvYTtsSHnCVSHKTqeiIYpbxs7W1dCOtlRp7adqI+badsm2tjeZlyJRbkGCK+fLOJoi/9SgrtmoVuqp3Z3UVzf1R10WYr0NGhqV7BN12eH2hQ/ZovYt0rQm6sxzRqOfTRtzJugOr3jPvfCXNnym+UPkjXBNlQAHua4XN3etaw1KVWLNKh/fKbtQSt9islrZb141eJ3dUEwCZTIbJGCaOo7Lig+5z3gRrmttUjl8AB0/4D5qfzUKlKMj/SeJZrpEd1QuO8+M4/f6uV81vel5zzPMpU7ohrvIT4ehiNLtPvq6jT5bdQPTjHVn0tsnzlVp9lhkdfczt0kuVZhFJ0FlX3bKD074tmo+QC+POVUsDXC599jX2sF6fYXerj7OkGkBwrzgNx9ZVfsJ9KGfzugTyHh9Ojv+1/H8ok5h69TmAj9gs1U78E0zl9h7fuWc7/yfmor7xESpjTHsjOmTv3PKc5/DtT5+ggucFx3iPSMBAQAh+QQFCgDgACwAAAAA3ACrAAAI/wDjyRs4z569ewjvGVzIsKFDcBDBzZs4L2LEevYsQqzHsSNHgxAzauTHr5+/kyhToiQJMd++fCRjmvSnUePJiPzuzUt3jty4nz/FCRUXrqhRo0OF1gRnFOLRpxqHghM3NWrSpRF/ZgXKdelAehMNJhyr0KFZkBApzhuIVSNGjx9FiqzZr65Kf//y/jvJsmU+lzH5tYV4F1y+nT25Jn16NKlSjU2ZMj4aUSpVqhYdD9bKtfM4r/IoiiWb8CxDihHVDpQ3GBzcjnNB4sNncV/JkjNP6tXrr6/hv399E16qG2W+e+3S+QzquLnzx04nSw9XGTP0y5qxet7ulV69gvbwkf8m61DtRIur07PFShG2vY/gQKL9bZukXd278/LdFxE4TN809VMTXnvdlE87iY3z3ILNRTedg9RVVl1mV7W2XWc1eWSQeAjpM15D5tWk3ogjquVeRyGl6Bdg9qWUH2++JfSXbRAFFlhEu9F0mHIKMuijUtMFCRFmVVVXoYUXAuWWhqPdM5uT+JyGGlaruWPllVaSSNA8TNZT01z3ALePbbkR+KJ+/PBXFkLB2Zjmm4Lht1daPP7oo2RBCjmkdQ22Bk6SSlr0mmkGfTflUlfKgyU8jDbqqHpgeTQYh2yyWFduZ+rXW0ij/RfTSzP2Zeam8yRmJ4N5pronn0dqByh3cJn/F5ZBqnnl6K244uoOiRy19mSllpZp5ov+8BdfWGHWl6Z/LIKD0l6C7eTTqc7hmap0q/I5FXRLvXqhdx3JKitrXrkTz7m5pvtolqt9GRFDlIYZqkwuZtpbPscWxKZtoB4nL0zOEnhTctNSu9i1QrJqmVTbEvmnt57RI3GJa6mHFbrqZtyoO/Dsmp5GcjlEqT4uKVtSvWfem+9E//5FGsAmFUjTPXUajPC1RBq8FcRcadmunxo7eu7QuCqqJcgZiSyePiSPqex9cuansj1qtVyaWME5q2lOPAal2HM3p5pztQ0z/DDPWvnMGrlLBX3r0HDHDY9AIy7lXkOUzjhmYGWm/9wPvlS3wzKbCDFUaZxbg+POOeUkOVTYYS+YbYVocxX3rn6CA4/mbjca9+eMCgTOem1xefdBCZFc8tPCDrsXfxMJPg/hZRkeJuJogtO1ZwdDjvNzk19VOVC4Zg5R50J/TnToohsv0UQYLTSy3vVdijKMErUjO+q1N3R7wLnv/rVQvosdjuRlOzf8OIw6zznyySsfj+fnup8Wl3inro/TZELtOrTZ0x541uS9rOHHHwdK0PiIUj5VGekxdqpc+1ozwePBb27yWx7z7HeRWYWHQ0xbnUz6liN+4Et720OdQ+R1MrzcC0HkKEfjmEO+Bj4oQnvaVvCaM7wK2i9d8sPg0P/AkcF4cDAthoLehvS3v7216Fk5+ps92uGO7ZGHewZcSQLJsZweMdCGQVKKwaTymZokaXNHtEgR4cY8IxYRIkN0npdMtCEQNs2JLYxaXgQ0RQE2iSxiipMWYTjDHoExjNgZo8M0ckY0ppGIa1RjRN74SEG5Z3r8o5ceoaUT0QDLP05jSUpMCEOg9O6QjWFV+n5UpJ2VkXiOrOQk6wfJttSPkhyE3t1+Ja9Q5lGPmwocsvTmpl++UIE+OiRTGKZIs1lEKxaU5WCMCDSNuPGRpmPSB2VEzCf+zx8C0gkK9VUy3NyHMFqUlimTCcaxNXOR0oznLSNSPFkOKjwfHNkdn3b/Pb4cS4Dk/E+ZtCYzUvakcQtC5fl2OMbWvOOhsYynLTU3v5q8Q6LalB4v76E6XxpzVPyZIkE6JUiagINYCERO1xzzlObkSWHUSuND3+FDifrpojZdUlzquFGO7nOEwpJZOGm1kGQJyKQnTVlvVFqwLxYloZNJZEyl6aicqpGaEHkoOHC6Va3GM6OzCWtYU7c6X1qvXicR0G+IWZNMFVR3BUtlKmvImGbGs6pWhSMcsdrVvF5kp2IV61iYxjT+hdJ/AlOJRW7iLIi4dZTgaEdTH4cUykqnoVTdXESlSctJRsSrft3I6TQ61sEStolORGxhFovUpErtLoIppWXPN9u6/zLIr5s1Hl8ryVW/fmSnPO3paUNo1ku1rrXg4MdNaDKsu6QEIjSL61PpGtVVtkqaoA2t/XprVbAGtqdkpZ7J6lKSpTwRnc69TU2iq6DpnpK2dpKoOLL7yN1qV5p3g8h3x6M/MRl2TEvBY24CtpKYWARg0K3Ze90LPG6lz3lCiWMa5Xdf/O7yu4FFSLw4+hfVAWcp87KPSdDZD5L8BbqHS24+7KEc51DmTlbJTmus09kJ47LCR0SRfjEcWOndA8UoZhqIA8k3dJoYX88j56cORA4Xs3IpZHOehI+oPBxb2DVe0giGFxKR0iYEHD/GCrPGq9YS/yUjAMUacJDTZJbCOP/GUa4JPM/FXRvb18o5zrJrLMLjKC2FNmEeDLNmBBjjqvVYiSrI0lwm2Se3BX2tlFBN6Hxn98ENz191i2tEEliJDjrEBt6HQtZyJX0RViHpKEd8jaRDyR3JbBGucX2HWGlMV1LP0J2NVceMR5K8ZNRG09dYEOTFoSzQupBGdiKvyVlZ2/q+Ys3pJ8XrNH1EqWIYcRKtUp2U7bxzYZoRozimLFFnl9t99LBpWCX6Ml7v49RRuttE3GGOYvPu2w2C9bhrzcHPPRvTuhZU5s4yHmYNV8PvoYiiGNejeytST2Pz66X/TfE9D8YsYQHPNvnbIaYBW1HrYLg4HGensE3a3H7/4jfKiajXivsW1+9aSBJlZRb+nvo7iuJJITtzqga6/KpWTveze2VJj0hMXBo3C6W6bI+cM1wxNHSxMn/uWarfl+hY7ojEji4uQqHOIjpxh8697VKFFsXqkFw52i0Ml61zneamoc2XxG6OnbPU7JFZey31rt22b30iYAlR9PBmEX28S+wxXKdTp26tCFGG4hnke3fdfnR5BH5K0RvM/kKC+GIvnvGSiQh1Rl/xyPdb8m3Z+le+sha1ZK6JgJOHyKmLd9Hn/exo93db3hG3h5r+kSjSM8ztRyJ6bMnyr3cavmSv6s/X3kFOwRPaVyNhZ/ee9zduDVyC22NcC13obVFb/3qMfx6soBZ2jHO+2S0ClcfndOvolhiFO7vGuLFc+8Dts1hhDv6ISMyacSN+PwN252d49NZeeOd+Ckh675dGlEdhV1V//LZjs5FP+leB7jMQAiGBnzOA0LU6hgcO6NB8LVV25cMUS4F7qEd5LKiBHDhwYlUowYd19ZV2cqMxpMNRY0Je+HKAJWdDohd9Qoh6g7F18cCC4DeBOgUX9zU08oAxGYM50NVElyJq7VB35KN+QCh97KeCRFiE8JdpRdhvd6Y8QSOFYLY/1vM3pUKCCYh7kcEYXziHR9R/e8VGOMg2t3Mf/cAfdfKGN0OHgugn6SZ0bGOGjDJTM8UopIMP+/+DGytxD4uDgIDoQIMYWnboV+lGOgC4RjmohmXyN+BwDpRYiXpyiai4FP83TfLDiWAGE8LSh6PYOKZoiamIblgRhnTIiQexD6rFDyxGi7V4irfoPJkIEcd4iY5IJnfRD+w1jJcFT8VYSclIhwdRaClRF5I4LdBoW9OYOatYiBpRiP1XjX61GqqHfNTENu+yjL/Uh5KIhVr4hkIBTd/YGv+3irVkREKnhHlFIufCGkbEjhsRHsliTn1oeOkgj7SHd8Y2DuSQDu1wj/gYhquIVbqHZyPibwS5Z0uzg3Xxa4iHUPPYTj9BDufQDvYgGBRZkeDgdm6Uff6YRk9YfxHBNgb/WVi+5iG6U3elSI/jcA7pMA9IxlgtOY66eIccOHHmaD/0sJR3tjSodRwZMYKGBIgjF5EiMVBHmXqr+BX1p4gzBYF6RXm2NDRimZbYdxHbVFhj4iEZQW9u6JAQKZGzAw6t05W5aBHGV5Pyk5bswA5qKZZFpI97JZaCOZidhRGOeH5johBw9ZOHJA7lIJQZwToIqZeqGIZgqTyIGZigGZqJOZhjaX9o+VCiGZhp2Vk5+V88qTuqZnZZKZFhVkw2opnkmJthmEEzlZq+GZrvoJqKeX2ACZqKyFeMqZOXwg88OYmT+RPmIJH2gGQs+RJjUlYnVox2qJvk6H8u+Dm9+Zvi/zmex0lnxamWNSYWj2hoogYOIRebvlOPEekORPlhERFmx7EiCHGU3Pl9bvedcBOe4zmgvul7p0ma5XmEMaeDhpaQ87AOPhkUv5OV7jCd/iFmhqE/+8mf3fmSlKcexEmgIiqaBkqcpHku/deaa9iHK7YO3DhyV1lXdSk4/9Iv4MAf//VuHjIWc/GNZomMLUh9ITqiI1qaEliiCtqOVJiNJhSZX1SPCEiZPhGRswMs1RaCOepxUcIhcuejx4iEE+OXB0qkImqkUDk0KbqMvsik+PKHJUgUQZkO6OAOKNZxTeRxP1aAOyp3H6SZHgqmqgeeikimwkmi2IemRiiBhhkehf8lLE06grX1VHUZGjEHLz71ZeBAWHwmdzrWkv0JpmJ6oAganKl5ouTmoYWZiYyqhiqRE7NYW5QplLtSEaIVpl9hgQFXgfOhl58KqH0ZqqM6qhnJQT+qZUs6E304Rek3W0G5Dh2zNiNyK/KwU1pHfgpXJRTpq74qpIIarIc6cdJkmPqlg764nCaEGCTJQCNnDoIJDzO1DvA6mPDwFW23GhVTJRxzj9qqrdx6plUGhhwhrqpYEx+5g8o3RSs1FOVgDuiQDvBKoIsoEODCHveqKHTqpfv6oen4lP76rzXhdvUALgHblGwpled3HDvhk8a2sOhAqGMpMTBnganhgajYq/z/aqtJ2LGnCqQw+xoh27M++xFPMlzWBhILma7kwLDooA5Mqw6B2bRQa5wQJbHiGlanthG0eosZy69fEYEvCIZbF7Riu31jdWqQqTg8EUMyNA4LK5RLC7Vw27RS63tfYY4hqCJau7Xb2pE2eITpBq5gC7JjO7b55FNF6yXvKUPlwEVtK6dvG7dy67TAiX2U5yV6ZpAI16OpqLe+6pJ16B1AO7g+i6sJEW/ppg4kybbmcA4NC7lRS54B+H9xERdRsquby7mA+rFul2daJ7pju1/a1ivs8HT1yLCSyw6ue7ziiaR007PGBxYMgbG4y4K6K7D457vbZxaM2WchCw7sUHeK/6sgLMu0oOm6vqm8CSqxoRGw68tl2jm9YFq9JLuE2Lu9tUtaPPYerGGVMKq458C6kEugkkuYO/sejOkkl2iW8Eu9NlW/sHGBGTYb3SuC9dZtbcu66JDBj4u8kUu+k2umJPuagrjA2ppToitzQgvBPZZu7DCCzbey5hDDMYwOGPy2Twu3hlqi86upg0jCnYtRohtW+AvBBpxl6MCQ/buwiivD/5vByZvDaOonHlJYF0N1NuvDSQl8oiUpHqHC+Vso5KIOszdyilvGZSzDq6vBG/zBcZOJ+BMvQkaEV4zF8+sn2OvF32XAQve94PvCZvzHfyzDGoy+Zpqk6KFoHeJTF/8zk5j4p3SMhMPHQT67xbiKx3oMES1sxj8ByJwcyBmstE7LvCj6sZa3ITt6tzZVx4H7yLtrvZL8GhLMEXicx0QXnEe8tp2cy5zMxEsrmMpjmCFbtwccaHzHykjooV9FdHXkGrMsxIUSEfB6ywily9S8y70syuAHuugoy9rFt/FnzK2syoMBH+CwbhQIwaJ1k/CwDsgrzTNUzfB8xsabmG1cuWFbD7SxeUfkiujxsd8MzvkozlgxeH/WFp02Se76DuysDhl8Dn28xIIcw/G8yzMsubEruEKbqb6odhIlznTsyOFsT/hsu+W8bgFX0hioOaTatA19xOAr0W2rtGr8yTD/Hc+CfM31fM/vIXflimmu7JXTy7P33KlphKta1qW5Ws5z8Q4MTcMyLENoPMMzrcZQO9VorMSAHNVOPJqUK7jhodEjhmdZXJFBzYJEXUkYRoHlvNaaezzI69BZLdVOzNKDnLxVTdM1rdVbzdXYR6+MeaOX4tM/nYu4y7MeetaPlNbmrF9YwdTubMYxjMF2/ZvJq8YOHdVy7cHBWZqWl2X6kJliLdBZbJjFCm1dahFzEW0asQ46V8ZAUQ5TjcP03Fmkmpp3TcP/O8O6bbweLJy85x1gbVzGgmNjTdZI6XKLjRWqDUct/NBsu8SP+7q8Z0u1Xb5wq8E3jd283dsG6iWg/9iHOirY8TTY2sVTBl3S6oy8Dx3I5yC3wsnRT3m+133EU03V7k3PXlKuIflu3cxBFrPKIC3QznPQBDsbhCV36/DYkA3Ks83IT1ndoTnf9W3fx/tQ8kAb+83f9+XNHa2PDJxTGUHgm3pwRJTJ7wzd7ACvzhqVyS3U8QDh1k3XE17XA8x7kYxjHD7efFm5ecV9BGu4TvNj73DLm+y/6OCs89qRW4aU8gfjNyzjMw6379DZNwoRHhJvyyxNA0iQ/PxIJQzi8HLSaw1mPlWu7fm9a/vcDOusHJ7WTA5HTh7jTDvjcy2Y9CAeEfGWCvEdsnzaj7TlGtHl6PExq/zhNuW+Y/+eYW4ZkoaHuo0D1S075W2BIl/dGmg5oLc9yNEtmF5SF7Vx5Tg3sRJFs3vZ0RXGZWIuWFTI6N4L1WueWxthPPJXiJeOvOJp1+T721l2aDeqpVRD6PFE6l4xGDn+b4i+qQb+3QmJD/LAtOvwfmb54is9npMdD/WApcN9cHsO7Fou6IFO7Lh4X6h+2mULkozu5/Eh5u6jZ08JkwJ66667DhcegvsdEdqecN6+4eCud+5bgYG16MZlbdDufw+ImiutvLYtt/BgD6hc71Y+xQdeuzdeYd4s7C437n5W0oRl7nUh8Ba2u317LoQKnHe+FIx+t3a6p+huZR1Z2lYX5nI3tI3/amge75TaGqCjKZiqOaAGOq20wR+8fvI8rKeorJFdKfOrXoU1b4zfB9Iv/vTxMLeDWqC+B7OOCBH6DWC18ZZx/F9+imdlu/H6fe5Mb5h/SWfGmZjvvZrgctI5qvV5bliHBvdfH1qKflrmzvVlD3/yV30s15ukSph9b/VCJvdV6DQPj/UNGhGeXvd+9e9E6zTg/W4rL78gv1f3Z4ODKvgPfPU3yj/suZzG0iGAvfiOr12QH/lXuvRAffmZP0tPj54ois8bDxENaq6SX2KyiNKGN/aNf/qPj/TDxfVMU/lZN7KuD+eeKT9tr4MWcfsZbliArV9ZbvuBDfx5FfbVpqOn/7Xy6fYaD3hyHOgdyf780H/4cVwbufbAm3f92C9RYoX3b8n9GmY3NnuEuwWen2P1nm/9ANFP4ECCAvcdBJcQ3D2FDfXhs1dPYj18+vb1a5hR40aOHT1+BBlSZEd8CvHhu6dPpcWDK1VyrEdP5kya9OLZjJczYbx3OXvm5AmUXj17FTMWREpw30twJ52eZJhQJcSJRO9dFDhS61auXb02hOry4FKV90pujEkTqFCc734CfRv0JkV9DTGCS5q0Zd2mTSEWDbvSbMSYVg/e/ZpY8eKtgVWOnfqx5lrKcN3GFUrUqN28SMHxBfvXHmCULqcS1mwRMWPWrVs7Nq3PbEaJCv/TzqTcM+5lyjKLptQ48HDnhFH7+h09+mlK0yeTn7ToWvr0r7Cbn014uybuyrnd5pRJcXNw4cP7jc341Clp9aVjy14Omvp8+hydMn+PPeF2/t3f8paHKPnwKmgfjRDayKynlGvvKbHGgmyl+iakMCEHTbtntoz4m6y73ObSjyMDR4JvPfYaxI8lxLKqsMX6LnTpJI043M67tcI7C8GGRiQxRhPDUtC9BxUayB9/WHQxSdZQytAlBTeiUa3vfGKLoo8g5JGj2D5bELAUTVNoRIGMJNNIJc9cjMkUQ9yQLf6mvHEoETOCEJwstZSwS+Xwu5MgcMoEFE1Bu4IqxSc5wsn/TbVuurG2Oe8ME6SyLFSPwYpAywvQMgflVKRCM0wpQzYb8vAmmmIydahRE0JvTpFiU28lAzEi6MgxAR2zU10/UhPUDD1KtLuZKKpHHlVXtbPOxN4TTNaEkDISWj93pVajXsticyZwghWWnqIKQ/YzLDViCdLPMpKwLjCP6oy4atG0x9r78ptxW+5K9TZccrFE6LFIFZIwQosGfLYgAtsViB8d3+103scg03BDmUrNDF2pCJYKy5dY+vfcuu6EFGGEFV6Y4fokGm0jx/iVraEaKZ4LYIzRfbilksnd2M6NREYSK6VaNbnCeFXm8yB+DGo5IXmWvtfD8IY+99VyeWRK/z6XAEaIZ4NZHY7foOmrqh6Sij7aoH2MkycnY2EeSmyvQAN6IYIHVFFrs+mE8OqNLvv6q4lSzoi0oglS+CGl41mabbeZGknfJhnfyDytx5WVLL37li655BI6EdTHyk54qbOMTdxpOaMOqSKneBWxVcnPk5zfvRb6TLAg+6Zp264mUkjzlFHkE/R+SI7KprQtA69tgC82rkGonLMvcizP00t22QU7C1R9GdZ2W0dBCpso309ksvKC+FE4quN94s1U+2R0Pv7QLuULIQh/Poxlxh9zctTN35WJy7bDu4aET2zhG99y1GQ+wqUPHOtj35ToAZL4tQdwJnnY1KYnnMoJrP8sj8OQX2SUne/tSltRIqBtDBi2BCowRUY73z7ywRAI8qR9bkuPCCuonvRc6iLWu99empS3D8anf6A6zgF3ZazccSh8BVzh+Cx1H8+VC30xnOED13KZy0yQJDusFAYfBESNlSgleymRc6zzuBGCo4TSQZw8PLK0B9aEiQN8IgkNKMXOVdGKwhueDNUXQd548X1gdA7UZBQb69HrNwNLIzgY9CXZYEuF9FmaHDuSyTvKpJOnWmEoxec79fiqg/u4IuEEeTgudpGC8hOhR0riQ8sxayrwS6MiZ3m1PAlQI/AAJjB/CY+PxENpnNwk02jyyfCIUo9/I2Up/ZgPCAEyYUn/O14rDcmr54imIzhsSFG2RLvyRaaHI4xXvBYoN+MUcJjBzAg8NxIPYAKFk3R8YCbzqcyZMLNtoVThKDXXHhDWzGjWHJ7hwEHInoxkNHmEiRsD6DZxluUhZ3HKSmapEQZ1c3XffCM4ginMeBJTITpZKGXuudKVRgmUokQZH5fjR4OiUnjR4kcWS8cbcHrkoWH7yAGrkh3n6fCWQW0Q5y4Y0JKOtKmkMuZaWDrVe7p0WDCNaQt79bh8ULOaN8Xp2fK5RWOGBKDfDChF5VdUj4gnkXrkCNQSMlK60jUjUVUbVfVq1avCVKafqmJXsYQ+sNpKrJwUCkg0N5FmhjQ7JDxn/4M8WhK52suQElkPDrcpyY7U1bPw0El39LpXvv5TlH/d6j26KtivFhZp4JhHJhF3uqAyFpSEgmVE/iexbYoPHykMp+be+VnQAiWlKh0tS0vb2NNqdav6WK1XbQrIMl0Ttsdb2lBhErbteEVs8IOIN90IXO7shDYx0cgoOULcYKL0uHhNrnKXi1UpSpOrrJ0u6DQVOjeuz7QgrUruxru7wCXHbcC17HtBMkGKVnau7DXpSd2bkfjykx4tpcc8NLzh5pLSV76K7lgIq19N+QN9BrJH2ozl2LQGuHsBTJ1CGts7FkPJuOAT6GggzN44IrMhFbbjPTc85Hl0+DkfBlWIRf9M2CKVeHj5kGQmaYsWA9ZkP5stIHtk3NeRbFYnNqlXdnxHlB1/9pg+1iSQlylkIms4ivVFcnSle1ASO5kfdbHHhVcM4PCdUHdtPdGVr9rW9EK1MmlNJMrKPFKgwMPH+6xwJzVc1RbvUaYfhu5qB8vkfpSYTOiDckwCVOMVwlgkKOOhZT85EhyWSsxq/EttFt3esj5azZ/U8IVvW+msRnOrSl5ynT2NvrqkBcG8vk2YZzQR9YhtYm7yioeIehoDS2TWxbWnRm4dJT5Ds76AVa2mv9pkT0drKZIsDIurvE0s84fZCxIbBLuHY0Nb5h2cOw3vrL3oymhS26Plj0aIHMrq+nrUlMCeLrnLfR4S/pPKfd4PoiSSuwMz6Hs3ApYXgVsZLhrTKQacdb85kly+DtzSzgW3uMetcE8zHDXqrnLEH35ssT0Uyxtadm2UuND32vA7lLqyQq6dk+L6m8IAt6rJEfjtmTZJ5XSuVbnN3ZSXz5y7kjFgeoXKuZ5Ohrlbh+pO2ueRodNTbSNHukuVzkLULjDTc4Y6y6srnKYAVesxx7mMs06b8bp1hC7uKwF7WtaUwmneXiw7aPH5b9Kqfchv1iqm384vTt+q5Qapu3ahuPc/C/qqApYYqjVKFcB/vTA3P2lDj/teeQQEACH5BAUKAOAALAAAAADcAKsAAAj/AOvNA0eQ4Dx74BAWXMgQXD2B8wYWlNiw4sJ79/Lt28evn7+PIEP+G+mvID9++VKqPEmwo8eQIBeOHAlun710586VGyeuZ7ifQHuKYyhuHM+GQJMCLRjOotOnUJ+SI7eQakN79iiCO4h1osSI8uRtXag16lOMKTn2Wwvz40ySLffly5iWJbiXbT8WfNvyXrt05IwKVSqUqOCFTZUqZWq2McFxjgtOrVoRq0KDlrNG3Aw2rLzNkaPiQ6vx5Fq8IN/SBIeStMp9LfPqlTmTYL525wLz9BlOXO+eDI0aZap4cejIkCNPnfwU32WDnDl7ni42KuexUO255miabWrV/0q2/86IkTRs1CEZqgZ3O7dg3kKHFhQ+nGDxpMfzK18uufLz6J1RRx1ZDEUHEYCVbXeSaTCB909LKZWn3T3a5cPaR2st2BI/4Pijmj/t6TbYb/KBQ19y9t3XlH5R0RfacswRZNVT0gkYVjzxwAOPU5s9VI89D80DkUBAPkSQQuXRtVF3Ijn44ElzUajZPBld6E8/C8K2kIdvgYjbTvGRWKKLxKnIYmP1NUYVf47ZSJ07Oe5Io48/YlWnj5nlaQ8+o4Gj5ILoObkaPxhp1k479mjUIZZQFqQllzN5ec5u8AFnonAMqfjTmWZh+uKMDIHakI3ulCpnQTqOSg+defoYkZ6ZEf9kHnfeuSXok3PNc+ihVFrYEZQW2kYQpHDhRulP8V2aZorFceoYiseJ2p9TYoUFTjzuWHTqqPI8VGSdsOZZUHkqlcZgk06ylms7pfLqK5Zy3VNQsLYW655PPWG6LLOKOYvmvo7FaNa2TxFckZCswgquZQntiZE+aXHXUYOCqpsVu+m4yxqU5SUUG7H+EOpOYEKdaGKmmvqrslMC+5tqY2Ftpqe34Tp8D8QaSezSd+myZw/GGSPqK0pzKaTdxvWGt9Wk+QoXGEFD+abpiis/+2LV+cWMp5100nmkza8tCShqFc/1VzpBJ2phhF15zN7EqvHTDslOiyi1mVjrB61yeUf/pXXXNBtZkGVJhi12rUnztY9faAdNl6wUNpQP3HzNbRSMYE7d9+Yscw4VPfT0uHWQ0HE14cMR04p44uHx83Pj7gidkp8ML1QayOCkMw6MImru+e/AQxUW6Ah7LThoWPE52sP66LOR6mSDF7I97sDeK0ZfP/c2PyDPwzvJd98X/PjkF0Tdql07JBBZpvNZXvPPL7gz6yO5fnbGp0tZ+7wcEcsPYDDaje/KR0DgeQZ9PiKI4BYikIUtD37xYxL9/kEooLWDKx2L1bwoRxOcmGMqPJka1QpIwooYTD/yAB3pwJVAh3iFK6NpnvPENj9ivaWC1jsI9pIkL/5xjy84AWH4/8RXwiJubngqdIjCSFc6rNyseTmTWPTWwzi0xW5Ca0PL41rikUiFKIQDNKIYFxKPa2XtgF0L1wIL8qP3RVGC9AuZX0oVu4OohD1yeeNJbFUSv/QuKfEp0Rgb4qnyveNaZYxMdQpCDxfiyTmZWaMSl2c4l0xRcT9r1wUfR8PTNMg2xqJUIAtjkREOsmAnJOB0GsnGrSmPT0BiYPKYp8fVOYg986Ajr9BSk4nJpiSsuYl7RBnITZ1yfIkMDY6SaZFFMmRre1JeLE1nMxlG0JMUixQu2VVHHcqLg+AxidkA854RGccppsybpfKGo8a0kyHLZIgzoZKwV+pJeUmCWCdXZ//DkuTjYhfE4OQmWJthoWQe5DTnOSuSGGMeZ29Qs9Q6o6KjVCKSmU9ZZiIN9k6CLNIz9KyTNEf6yuXdTI+WDFSkShKvzGSEIx2yIV+2FLL2ZK5ZT1nKyuSTrMZUtCIYdWdH49nMeYY0T/i8R0ndx7wZ7jN63wGm/DS0l1uuZlgf+WIx8cNQhy6kp47hKSkH9rJEBtUsOHpHPN4Bj44WVT80q2aSlipDCD7vedj85WyeckuafuSggLlpv1CWzpJBtCKBLMhYoxLPMrqVfEY1i0hNOtdX8rCuKZlhd9DzS6f0tSHiQQluwIdTp8SnkBYRJDhKtFi0nlWewYvsU7xl2ff/KbW276urU9Vymrxe6TSgRRdchmUSDs3rS7wZbEMMCzDEjjKxq12tahvy2IpM55gK/NFSn9g8HnrXdlGk4a/kZ5E9NikmG+KHxAjSD4IYa4g6XciJmvvViLZ2ou70G3bZqD4gRZOpMvRuxyqSurve1SnyIxt6WZPHcm2MQ+4oR/jAOt+iRGWUzj3Oaxci20GmsaQBriw+LZIPfWrkxHdkT7AI0kmezSZKhXIia9YCG3JIDcOFnO5yn7uyDe/XImn8Lz5CHOCSPkW3EOthsO74mrHlxWebidlB9OESuUk4kIcJDY9/PMYW/pe7+sDIaJTXsKgImC7lKhdMkRaS9v5T/1d0/Ix29vFXcEh4vkeBynPBumMdczlvgLNMUgdtz7PIyk9+QnOaU8xF1LQ3Iblch47cMeXT5EN3eMZvaifK0z8bEXCuLOkTxeycyliEXItOM0M4hKXTcOge85CHOyRNaXvoI0Peq3BrpYvfhXq6hOnLbleSx6e6jrnUDNlfol2TagcvhEOmsQuFYu2ObiFkLZfejSi9umV+eZWAPj5lPRrita+NWanlgSS527ZsGH/XKeLdiKyAFJZ64IPB7bjyVlULXW/H99fYDTSxmQpL7VVEwGdRdHjlvRAgraomW7FxmPrd7zDqh6gAdxaowbVUPrntLB43Mw8XrdsjjdsgTP/bs1jDZHFnmTXcGY/KxpEqzewYnEANd+KZwawPeTKNUuVkuea+ven8mtEp7axuzMGBwCDrSYFPUfYL/UO4AXN3Iz33qE50LXQiBg/miFw6QxqpQoEHOypSZ7okBwcryNm1IKMVzihFSHSx7xd0oFPfxltoFq5Fpu2ygiA/wgwOd+hkqy3fHD2Sife8Z9Tus9372kPDSqcA/mHcWRxCzXGsxHsO7wRpfOUhfxzJT75qT1+2835V+MPTPZ3AAz3TG181jSr903vnL9RRn5l7u30fa9GHO8bx+hKK/vjKtL3yl397ixz/+bRvzMafaaTTOyauvfc9uYDvj31EWIRGhL7/7ENTHeYzn7pPEf/zpW/97J48/dWy1mxdiNTte6S95oAvV4uo/tEfhzrm13zO13/RVxmv5BSSt3vWVR2y5X/9JWgv9RL7oDspE37idxwOuIDKxyLQVw/ocyQFAWJI1jwM5IEJNG7vR122dxxCsiczhBd2dh+aZh/gUHdVo34NkYEXZ3uilx94xyodV2xDNoIH+H/ysIHkxxWr10Xddw431m2I4Ws3iIMLoYN5AzrmN38JEYRcaGTZlR8BiHHN1IKrZyv90A7ElFw2GHtUKEaLt0zj1xyQFE0310opeCZmdVEC6FFCMmT9o02k5XUE1IOM5H9WSHoVwXcu93IaJTwH/+GHXVQbk+J5bBiHoYd8iChZ1acyjuVY73BIT/EZbaQRkUgT6EB8FVhA0FeIoHeImWiHCuhyBHF+8tSCEeg/61AOlPg7q3iJhPiKkYeCm5OFJTgawFeK4eE9+vdvg8hKbQiMIXVy7Qc8kJg0/mAP+ZeKzdiKvWhEZKZxiSg4iggVyOYvc+ZLXYKNy7iGvJh3ZHeB0BiNrSR9IWeO98BbIGMPKYc329h/v/aLkvVM+iFk5qgdL1gv/jAPubETAqRcwAMUBOh48QhknOKFnOIwTvVDI+F9AQRGpYU19xGRruh+d6h7LnRKZQdXhTZ2kUFb3EWKHlIS6VAODKlQ+weSxf8hDiKJgOVWkupjkoP0gwJpFitpPmQkhtQXTVf3Eu0VWNsmhSuTk8DhjvAYjqBGbu/nkxxYgI7ReNMnc99YEDjijLdHD/WmXTGkTyCxD3GnhlDpLDKYL77IihKJlVd5hZbILc7UfCK5foMDDuW4grPYTGU3S1DEfVeSO4H4kf4Sl0VRDufQDqzoi3VJfXc5hXnJLXrYGH35gz6CDw/heGulVj4WDym0KhhpTb7EDwopWA4JlzJ4ORmzYrNHl1aYeypDlSMJDiAllon0iaCIdGEYD17pI6MHnJ+YUaepXTcTP95ReJznlszIIprSE+SQMVXSIQB5iS1ketPYldspPPD/NJrvwA7myQ5mQZrLV3YeyEznyQ7BWRE/GE3wcy5Xcg/pYA6uOZ2hIUJFQQ7m4A73YF4fEZ7sqXemN0blt0yf+J7vGRXJSRDJOZY+glHoeZ5IV5jFthF5xZpbJ0Sv2Rh0Nw6QmQ4HMWMwEZ4L5J3f6YNcSS2LlFbl6aDmeSYqtHgVUaMWYZqFaZAcihrgYDlNIxiMWUp0Jw7XORBS1FtrUZmz93CxSJI9iZeumIGjSaM6qh/os3jxmX5mWZwu6DzeUSzReTdFkWVvWZ29QaKR2UPFNVUn4aRCGaUIepmKFxlXiqUs8g4ItIdVWJza9YKlWBIj05CAZCLAYRz+SaLm/4CdUBExsyOf7Ll2Xxl7eNqgeqoffGqca1URwPmn7EmfHIqQ+LmYi3Gmibop1Ymk+GM74+KmssJoOTipkgQ4nLObGYWpDsopqwKabwhUj+WZaHmQN3QT+raOULMbNZiTl3MO6aBithFFDHFHzAOroGqrJVhuXEaen9qlPmhvHuiASGiHtOWH3PcWbJly0jmdIyIYu5MxVKIkamZgd9VdD3MPGSisLApwyPmpGhdNHrijoWd5GImY2mR4HqmNSjEO52AOjbpsaPY8ukWv+xBmkMQnOkir06eVfYOrZDSL/eov9sYnHIt2Simm/oNQpkpEiiEO5ZAOVzRL+VRX7yOx6f/mHHViiB34gVI6kZQ3sqCZgiP5SMWGslwik+RQk68XFOVADufAm69iGR9WWdwlLw6Ds6EJquK3oi3qfK+oQspjnE5ql0IGP0wYMpZDH0v7EwwLDvDwNw9hI0fie2GZbCc3egRYsqSHlJ/DSmgZtNpKlO5jtiDRD/kQYYa1ji1rDuCgnnGiURYlT54RZdbSmT57lH76pJX3SuPYGMqjmjRmITP5hOsKSGwKDuvwiam7DgXBuppolm/iDhVFgJd4uQIbGpzbtQvxuYLXD5q3Dq6HLKWLLOPAuOmAoVkaGih4IJ4hu/Dgjy/asXYHtIB7HIMrqP2gDzehnzRZKSpSFIz/uzJ3iGxg4Q5tmJm2W3qcm2yOMYT1KRetR5NJe2UiVLxPy6t5RzP4FGZuCo/om77qW7fWa01YRz3owL3z23k5CZno4Cxk1zX7W7FZ578ALL4CfBxPdGCGR5McPBU0WR8T9p/n0MC/80CUuX4eW8EIWIRnYk3NUw+jmy9N68GQAcLIUg7hCzzYF65VqcJnQpCcUlcEAQ9l6htnOhwmI5cFoQ7q4C84YlSTayf+6MMVycIEUY//Bw+n+BuEMSY0SRDlAA45gQ5MXMZNnB+Om0hSFsX28IxUnB9Aqw++F4IsUg/woA5FTERKbA45McJm/Mdn3BifqFH+54EtiA84aIhv/0yPVswiQAIP7IAOYFK6y2ph4MDHI0zGgAzI6dmI/mGbPUzFNCMaLOxxcyx98bAOB6yfT3kfKMLH5oAOsqzJm8zEySucHaa1oCN/tbnIcphsRXvKcCwPkczBH2yTh7oQYzzLslzLtnzLmpiaJ3xAc1m76VtwCDFsgDnHDGPFwhyM8vAOksyQHNx1SbE3DuuwDduwzVzLGFp6NnPCsIt8Y+uDXGZkCkG3HoMQQhiCWAxk9SAPOrIOeFyTKkcYUZHOmVzGtPzM+jHHPUR7p+mXnJnCJGRwXnhvpky3zbNU22yRcbtW6jDCOmHQQTF3vWHMCc3HzNzOzxyhxxFmx4dEof98uQeoz1Y8at48dkcID6rMvRzcysJ7WsZc1F9sEenssC2tDvCZuZ5Rrm4yxQD8jTjNwsZG1fUYFj4dydx7IohHGCRq1GJd1HbGEEpdEGTc1GD3pWBrLefjxsDIbmQWch69EDL0z+bj0yPtsEH9HmCEzI851oI91hbB1GrdiXJadqPh1qtEe9Eb15cx11gdlsZGx0O8DuygDgdc1MS0WkN90i6Lw3yd1KQN1INN1gRhy44LkHQyhFEte/X8ivfkz5JN1Ve9zQ4RD1wN1HKHL8L72UJBk7AMyy1d3Ol82hy8EE182MQJ267Uc69debEdczWjQR9dj2Hpvh0dcpDcsB//3Nvw9VxGIdzsvNSaDcgtndRirZ85TBDwOchj6YyuJC/7ENUsKdvVLWgaXcoMMYRY53sCXdCi9B7MKsOiPcuazcy1zBBM3BDtLVTO6Jl7UhP94CZ0CYwnV90bjcXC7N/Bh8jludmD8VzMSt4u/cfvDd/lCTzxnUI/QuEVLreUieHZAysdd8WAyRBmS2PXstkK/Bu8BtY4rOAorlbWPD6Oa20wHuMCcuEYvjD3xIUMgXnHmL3zwA5drX9FYU6PqdSAbJ6DbNH+kuKk+XBiehoWzpJiPkhGo+E33hAZ3Fu8Oc4J28W8wagLrdrwXc96yynnWZ5q1S3gcGunsRFpXoWI/whNNYPdpZyWP3ol+gAPk7yqBh7Lz2yajGQWrAR2UEHC4MDUhg3m8YAQVS6xAgLbmLh0ip7NaVfXOQ5B3tFeuTi8gHTg7LAO64DpIHjFdauIONoYDezpBEHkZQzmfErhEhtm+vDWESl22Jd6OO7q/l3lGIK6EnakQ54ORk6Op7x2v64fxP7SanVvWGexysPstBtz2Md27Jbjrh7ntSLrqDg14hDLkpbLFfHNR8kiCt7Q7MCj5K4lOYfu9TzdnNLnMlen7DZwdMyF1oRNawEO7FDngOSy57AO1XYcsYR0jRHIaJ3gDc3UyXRgOR4RHtXYj/2kgKa7FPmTzz5wNy1qTf91jIXbXhP/hMSLwxef8XD1eI7hzH887lVeE1riHLGWQqee8v/rYeMWLl24XXX1o3hh85N8pjicDhgvsqH5jnGInk8B9KodD/ZG6DQm8EYva43d2MCWHxvPvvnO6x3Hc4Ja8/iwDqwc1ujwDrzc82Kbd8397VBhnmDPp/eWdRZhsdT2tkik9iTE8l+oRD9pEXQb9yMo9RhiE6osy1iP8fguc13DjYuHhQyR2WVcEO/pzvBQD1n3aAWBZEqVFW/N+E4RnmeC8Jb3k+0O9zF/vUhm+VeCD3fczJKm+C25RsbDdLe7EKSPpadfxoRv+DxOECGWbg53QLCLRLOvuQbvk9z/b/uyxDXWTdtBCGYUy6T7UA+qPMapW20jWYeFiPyRwfzy/++qzxCF/qr8ezO3ZQ/WL/sAAU7gQHrg6B1EOFChwnoLBdZryBCiQ4oLIdrDl9HeRnsOM34EmfGePpL7TJ402U+lSnDy1KFTp26dvHkTKyrseFOnTnY9ff4E+i7e0Hr49FVUSVIgyXsjSTKVF/VgVKkFKSLEmtAhRK5dvT7kutPiRY5lcyoMCQ5k06coV6rc1y+uWnjq2L2DJ++iWL59ewr8+U5wz3eEhQ6lB9Gown4L94Ez+XSpPpT6qE69bNVhVs5awXmdCBp0X7BmzXr8qPZjU6cn3658vLTeu3Xw/+LptUl6s+adPgffvXt46PDEGCULTIlSIcqTyJtnpirvYMXOnT93HShatESde8GZPrswo8DVbCmnfB1bIz3btxNH1L25YjyHgn/bF8q56MjYA+HCbW6g8wBkCbJ9oItKp+qm0+qrhrQbjTTvwBMvpJCcOi8u2GKrhx6q3OMNJ7BEK8iqEHUaCj/8ECsqo6eOYkwlfl6Da6l7wKEMtpUGQlCenRY0aLrrICQSPr68++60gSy0EEO35DLpO/byOyi3ih6MMMgST1RouOGEQ4weFymjKL19+OEHvRnVc27GtwTqUSAutVzQqrCK3G7IsChCkkLVmFztReYieygevN4zUv8srzwDZ7ibvISUxTH7849GKAfV8DF8MMIRvR0zY1ShOrEaC09TsRuRNEDXwjBDQr+Th7Z4UCUtqyC7XAhMQ71EqB7jyCzTUgD3cTWu2DaKKMe3QJ2TzlElOnU0U3VbNdC2mCOINngQTbQvIW8S7jDBeG1RKaSEfYvYF0tqbtMOE+t0JVAVdLbXbyOKNs8RaaW2WqMEjQxGKeGxDdH4qKNI110Rc3EgYytFN11iKzqPPHt6xUcglea9aUvrSgwt3yyz005VfwFWdyB76snMyoN3ipTcxcChkeaIJTZXLH3w8Wqxfpid0+M6QxaZX5JJTnSjivxtNWCVIcqq25frCy7/0sTwGYkxm/+7GcrjNkXLIZJ47lAxyqKTrt5RQx0SLD2J3Ck3qSmqljWAc4ZoHlunRtHQceOpsuGFGmNJrq0tPYmpGwUyzdoX3b1oJLQ5U7u6zWzCd9ru8FX5JozqNq+k41Z+l8Gb9tRtuKqvPm5wmh3a0cAoBXbILFZfvGfTlTfCZ/K1gVyoyoeQ3tdoRX1VeqHPV22V3ZxJf9dli0yfb6GF7bt6p8co5TtJjJbHuvmdNcLodxPr5BPL7TTfHLyOmG7eaZWRRZ1PrRgdSiD7iKMH8BbFagz3+pIx1DQJZeuyTFU8FB3zfQtaJXsbhHTTONAdsCmM40j91LIbyg3E/1F+49//HNKf7QXIZBQEVNNi0xjkoK0lDFybgrglrQjq62BraZIK5VcWDYLkM5XTzMKEeJDxuM5AzhHgQiQjsPHpjiMjyV15VFgRtFXRilRpyaiwU7+5Ia2LO1keRy7kJJPMKE2MQx6yPPIdm6APMZCCF1JGGCUTUkxAIEHWrxC4LgH2wx/+sOILrxg8OXVQegzZHOoOSRHwjJFdbloJP8CROyVtBWroM0iHAFclTnVqORQJUBKXMpmmhIR+4bsWHyn1R1YGUiHREWSC6HSlzfWFc31pZMbC15ozrcQfBXIiR9ACudJZLjuBIyCOdCNKOzKJdJ8ryQgXwspWuhJOsP98pQP5lMjuMdJ9jiwJJP34S0nu7HvJ815X9taxoggoZ8vhHjN1krt1MemdhyuQSqjpo1jyk0eBTFvwHHhIWi3yaJ4TY1rKcy1IUrMx+rhHJbWjTYEgZkkEXJdCihUlsYklNnuM4r+ApTFh/fJNFLmiFbXJpV5dSX0aTBVOcplD87hGnw6FDCXp58VLnog4idojyjDlMHkqkTJBzRDEImZSnaQUi5jhpyx7KqT3FA+CyvvO/DalESaxpqZl9CVOieVEKy3Kpz+dDFIng6mPAoujc0wrR6M5uK69hiJDcepTFyjI7FgkpjU0EnxyMljwdVUkdiNJPk7iJmr+MYDmRFb/iTLJFfxFTaNKCWpcK3MtAbYFMgCDXV0jZj0v5dVHsMQmfO5l1asKM6tlSaFXEasPxZaRsY19LFn3mpgOFpJtRs0ojtiVuDoC96gC66No0SXJLkEqr/2M6vDkBJ+X9lVPMj0LbGkq2xfV9kwNxe1ndctP4JEqrfcU7ouMqpyd7PFcyhWWSWJWWqdCV5Y/nK51syQ113rvc3/apeKe4t3vvqWxvxRvBmVpTC01ZDGtuyyEP8Iud1IsuEfEZ9eYIzHuEczDeTXfA0fmNrGU5aKH1SFK0HTTA+dWd1CTk7Po02C1uLejBRQbRC9oYQFpCL6XQuKlOuzh2zg1hqWyIYlL/4zO2wn1u+A9sD8+q9OVCfQg+cukO4+yuAEWcWkz056P4VtHV93Tw7Yx8pFjDNhuoa6/OpGiUNE057BGGRz8yAeVjXTl/uUvjksZD5gpsmMcebkiWZvjhjnsGra+Kr3qIsmZ4eGQlP7Orw/060QI676c5NDJdDZwlKWcU/IlykuFFM8GU7NGH6pmg6lOtE3j2+hBKTPCURTImRdSaTW71GVYei2nkwdOzj5ZnKL+I3Ly/GLSzniTdPOhvxSKwRpLptFmMhZzgurogdwod+QZCsHiMelXXhGTRzIoBhNKISk6JR8EnvOKWSxqgeCZkgZlEY6lnZYl/Wm4G5W11za6rv/QYZbLrvbgqXdtbgaj26C2I1/jZDuSd6s43nVGtpTTZE6D5ufECt23oXVZbFpvdpJlVtzBCR7oVYND3FimIgzXKSGYqjuhwQQfd2kLb3ljnJr/APo/Rj1W0p1oXJph0jCrBe2MqRJTxdoZec7zlJAqpHnfDnTCi7wTmZtXN8azue1uvkvWvLvii+35OA8c9KAj594davafAdzyuesyY1Ve40U7lTikQhRsIvU73cVnt4O78CaylE5vaVmqigjbiayym9ktHmpRsx3o9X77WQtoaPJYKN2IlDqkcde8ap3zfYBHYOENj8V/wsk63bHk3ByvO8izRfK2hXLl2T4QfnD/HO7WI4/SWT4/E+O3YxQ5yuMIKJKnpGarpoQtYjFEaOhSuopZmUf2D5J9vbF2xGlEIYpla3YCFzj3rLR8shVi75XpjTeA2zzd8P554g1zy8nUJYY4byHeARiK/08m3VgwLuG+7GMz42kITmu38bs93PO5jBs13tuHiLoYD8mmCuE8i+EO4/M1nAA5tIAiQwM/8CmsVpsamXMIAzRAPNGJbxK/piC/s0M7yoPAf3CINKHAqYC5RKG7Exse9dmm62IcC+k8kGCK07kO/svA+Og63vgK73vCxsulidu5Bnyy14BA9LtBiIosedgVpgvAi4KekeEim/CXJOG30/EVUyIg//rjupmLwqv6Iv8aO+4iP4tLO2SzPBvcQt2ZBy90FGhjujEMmX0Jj6wqwqTzHjz6EcXQiND4rReCk2vypyxqkAKcB5eKDxckO9uTQWMzoxr8o7bbQvrxELyKPwyEHCFEpEPcihKMuDR6kEQqirCYim9xxXLzpw5CiAKcQ5dSQN55wcQqv4ubEd1rrMsrxaK7LwwEQ0JswSQJQuQBmwyKkG6ZsQgyEdZDxJjbxb3pRe77RTAKv04csEEBNbVbO6H7OT50DH0wxWbRpaVRmihsvAR8tcajthFziBmznP6pRGGqxFgiCAY5n8QQx26aqWFMLOa4uHlLRnZkpZuYwHj8snUwXBJrrLlMKyxv6sa2iQ9bAcjsEMiFuy+qOsh6SMjuWUiv6q5izENkpCaKjCjKmpN5VMMtuo5o5DdSGceQpCjG4RGT/EZUa7CV5JuZ0rnhOhMHhMiIbKyKwMGiC8p8ZKSQaRZRGcKenDndCCJcgT+DEEvwCwgAIfkEBQoA4AAsAAAAANwAqwAACP8A4Ql89w6eO3ng5oFbyPCeQ4bzIjK05zCfxYsYM2q8yBCcxX0gQfLj168fOH8dwf1bybKlS5QpY3Z0SdNfv5H7LNprd47cuJ/jFgIdSrSo0aIMj5JbyrSp06bgmDIktxBqynPnBGo1iDClw6/2ZIL7urGs2XwdL4YUWbKfv7cwacr9J7auyrn/4PrDmW9eup5AhR4dTJgouMJRn0qFunhpVakdsWbderDrQnxfwdqzp3BhWLJnQ2NsWDGjyJEk4d7Fm9cuQ7qvWesdmc+eu57lOhYmLG434cSKgzvtaHWh5K3w5Fm+nNnh5ueeM4u+WLH5w47WS39EzQ+mP9YrYcb/FB8TfPi9tdulW5r7sO/38HULn0/cMVXj4M7Fi6e8f0d7mN2DUWb4BNicaNk1h12CoG1H0kJwmRcTPycxpNpqsqF3D09Mweehb0LpFtRjUy0WU3HG9ddfZ5s1SB2D2pllXYEPXbcQjC6yddJ3Ela4EIUdXWheeP30tV6HHyYJ4mFiKRZViZDZVc9zLmokoHUDWpmZa6TheKVFI70FYV484gXTSOAA2Z2YGGaYj3o9LaXknEZx+ZiTwA1XV4v36KPPdF5mZydDBgaaz2lu7TikTfzsA+SPay405Er8bPgXe+XQqelQ7jXppH14xsRnn9NZFOhXg3rlEI0wfuQoSSaV/2neXo12FCabec365qVybrppUoKNCCWKoYZF5Vd/AnplZs9tlupEKRXIKoNqoVaSoos2atFC+aDGpl5vzeWPkXH6au5RKTFWn1PNHntlssoS2K6zz4o6bYIYIerdpIyixe2ha3oH7lz8+IXkuXMG22m66t7pWLuFZubnxPCa2ty88z5Lr2ejZmcRvK/CipKssmnrb0XewnXTmnKN6xdgCCsZLKcngpqnVM2eCiPGnEVUj0Qah/Wfs9Qme5rII0+aFz/+juUgd9yF+xI/9vB6MG8xz2wYw/NR9VXE90grNoPzRmS2z2enKrRYMBp9dEliklxy0x51C3Wjr0rtEtVW+/+0W28Ia43UuvMxK+1m+EAsNmZln+14PZDPQ0+9ntmF76Fvu5U0v0xvW/erjuaEeWot32O1b4CfK3idwwbH8+uwOz7Pz2ZDDjk9k6sN3doxMfjn0altni1Hn4uOFkZhylXpbb0WlrqmC+/GtXCwV9+u7bNHfrbttoOTO5dTQrcn4s35OfpIcEfIuedOZ9T+oW4pvyHMMQdGp0xdzxv+Ztz3P6X/AOQe7gY4QKDZyVjiGxqApOUQ82VOc3oDD3pOtpGxoCx+U6ua32ImDnGESGauecrjAhhAhpCwfwNkCO4MKBMWTqRZCkQcjRwYMlhBkHMpsZIFBeQouY2LQ/Xr4Af/Eyas6S1lhCfkXkzqAQ4SioUenaEcODLGsWYZyE9rQR/cdiS3mlAoHwKiDnWmSBGAkWwvpiNHps7VQSF68CfuQVcc4SiYmjUFiUmEnExQiDspBi2BZEQcgBqoj7W8Kn16kSA4jNcgLHVLVm/Zxzxww8Y2CjEp93ONipQzwBPmTo9N9F9d+vg9JtZrbe2K4bEoFhItqiaRLUOJ6KRjsXtY0IwtecubcLNGTVnyktLDJOvqskkCGhN3eVTiEutByj76MXwvFJXiCFnIVrYlbl1kiZhyco8WvQhVHkleLnfZPDpdcnWD8eNCNimPYxKQmZ0E4EJA2ZHuqdOPi7sXDa2l/7mTKJKbFAnjNz+SJpIViUO9/JUwOVXEe3akP+58pzH7N097mjKUTZycM591URM2kUv5nGE1EdXPNtXEI7TsFkjOhyZIVopX5UhowmKyNYemhJMRzen36klPZdKzXj/l6ZRcU6B2NRBzbLnWTOaSJlOVEXhRiw1LXhqnmGayLjV1KE51isydLrOE9ZSiKHmaSrEkDmJ9GqmjlLpUufyomwEFmFLJIyltLu9SMZVpMG1Kua1y1asLoQcT9WhPvppQniYsq13O2iJucYk13OpmRJ76IJnQxa7kKufgUmdYTKbqr6RUITJFWdjDlpajiJ0nz8Ynw2eVTLJm4yGFLju3ef8AcZiuoaNYgtlQmoI2haIl7WlDOdxBOVEsVPQjBCPI1H3cIyLtmGy36jqrflhKs7rdbXZpSjPP2mkcv21mPI8r1KCilqIdjWGBHIpI9YlrkZoREJCyWRM03jYoIzqniHpLU5ls1y7h1egx82ha81JurDJ5jtiepY+F7AMcbVmue1v2o5BhS2nomcdtMvVd/nZWtAEeMFjLm949ugbB0lTwemNCsQYzxE+LTGp7YcnUlDCXc/dwhzna0xEPfviz7nRNJ1OSzOIeOLUffeECWdxiFy8Ei63kp4Rp7FalmalSPOHwj7sr5GN+lsQX7d5giXxPFCd4xSlpMoyfPLEsSvn/muAqUxdvvCj0ZNnDlGNoYBQmmCAbl8gUTTKZ51nmQPtRzRRjs1qjbMMpxxmbE5YguLAMGNf8EqtFTCdQvKzOEZc4rJ8+saErGq1o4QMcp1Z0i9MKDiiDxMExXmuE4QbnVw7MTI+GC6X9JpZL5xa/SCGKlzcKaDuJ2cQFDnVKvCpcZV4GzWJBtJpTYsg3l6TRtrp1fXVtLb2QE8899vFuF0rHTUeUsKPeo+2IXZcTnjeJ9ZJ2i1/c5mpzB3hpYgjSbqwy1FjzO2hcT29/acmYEPx5uv3JuQc7YrHcDrBfdbexkxlvec+7yYbMuJvvtu9cMiokatmH5m6SxoYSPCUH/7dkViu6bmQSt4TK9h7ECf1yAre7yEaWicUntkNqulrjQI8yIslkE25+7R6yvvaGyNHGhRT8nCm/ZBv3nGycGzhV6Lb6p8PMcv8ZK9VExcfObdnzPqV10UHPeLcj9JZGwXYeACpkW7iZjnIUvNdRJzjVKypYrcd84n7/e9VtJ0Owx2S9Mzz7tFEdoB2yMu1AV9OU++FcziinHn1aiz52Yo67gyPvoJ+6bidaZJsGvuHLrPkUF3z4kEoL0avCDAORVW/IZ1HfM76JProJubhXUx/4mOQ4Qk/8pvM5sFkHpSk7KnhRnz7dS0xy7/O5WNcr3k8hZfwMDYnUyD+q0SqjPP/2ZWh2ztS9+ClniK+7G9QSc73Tz0f3iQUdPup3xPCuZ1WLF7exQUI5X0FnK1oUYTixD34SNgZiD/JQd8OHfr7mdOIGbMLSftEnVjhXczB3WgxHWFW0QNJSaoSSfc/WZAh4VhOBGYhWQQzxalB1byGxe2c1Dwu4Rg74gAW3cg4Vf35Hc6XFRPYAQACCapdhVh+IeEPIHA1kdiWIVmpmHWkRcmlXEiABg5zhDgLXgMWHheLWdIPzYcung/D2Ub2HSlMUVCrWes+Sf19zOOSThLsHTqoSIysFciEhhc6VOBp2hQ6YJD+GgWBocwp0WhuTKoZ3f/kXUgqWIIVYRV5STQX/CEZVqIdZyIc5mGw3d3oYiEC8wyU884GGmGAeeIgYI4qohFYX8xVRNoWRyGufF3XQU4lHBoY/eHWg+DqLiIiKQ4q5iIiJ04FWVFRt6Ig4AXx56Degp1B9mIOYKCWusTaIx4adeIjAaIvQKDSjGFKEFDIG2E3MMxSiFzjJ6IVhqDvWCEiuBzvSOI3zgovl+IvaN3tYtDLbaA/rsGNE0UH1M2h+NIjheE8wtDtCk3/omI7RmE8A0o6Fx3jlU03XZoDBV4/1I0c81YzlOEX92IeIw3ibeGoG2Sz7k44dGYpik0AqVoQB0mIgMXe7Nw/1qFcRyVEcE5P8eJFlVpIbyY4i/wmSoshYMBRIOal/jzd3lbdheVWURekr93FKFTmTNGlTnuiM76iOOllU0ng9yveL+eRzDDl3YMSSOyYcVkUYvbJB4+A3SflHZOSTTclXYxgWIjiV5/hsiCglWLk4tAdltOZ2tpEO5hAcRqlX5RAcQ+EYlAOQPrmJa+mPzwiXYtNknkhG1YiYh1WXHPl69QZBN+FcL9MUf2mUQxFTTkEUKEKOsJOYQEVkhceYlumY0HaCgLdaHnh2a6UX4reZamSUXSOYg0mY6lRWM4lmi1gXwZkSZTVUxDVoP8mYPNdqwPeY6pZaAbSOIjWbKmOAVRMnuTkfSnEO7eBQvomYwNmPP/9IXBujRMmpmqZWVJcInXmkYlhEOkSyD/hwG32ZnU9hFHlFDu0wXf4ISOBJk8/IP/tDeCWpmvYXgr24noaGczIUj3pTdDmGG37pmWJJDueQDvcQKRhpmoY4kh1poNIYLfTCfIDoh9FZIA4qZzYRoWq0KRbaDvYQMG/RfBxqJ8DpenIJojopTcdpomJGoknkniKHQedhXZOUUJP4E+SQDvPQLVNGizVafazXoTpapfdnlYPHPZsooCTUoHLHXJE0D+aghfqlfipXltz5SLkGpVEqEyLoplVqoCLKpaCEMVPinNIiTwSKokPKb/tgD+dApuIGgR4EOEs6D0jnaGLCpmv/2ZqMF5W3WJlxip5yOYrnuTg5qqWdmHlwU19Ucw6ZcnKfZ6blkA7tgHTBk2t01aMc2pohupiTCqIIGqc5WiD7E5UtwpBnhB46RoOD6nTjUA4Xag92szKzZhJSwqh9yJi1Gqs6Cqmy2qzn6XspSaRtVxt156vqh6bu0KQ1JBK3F2uvJlTJiKnp6azoOpLJCa1yCpkgiTiu1l6UNz++OnXcWUauAnKeE3JgBE5mxlcH2qzpWqV0ajvU56ye8T8EukDrWG+pOq+bKZrcyUNI5W+i0xFQBnzi869OiaMCm47sGqsF63UrhrBlyKAoOFK0xk0G4xMWaqqICjBqhxpE9Ryo/6eUl2qEHzuwcGl1BbaTHuujXrdA8bqytWGFPXEO7kCs3VeA43pIDdl6p3azg7KLb/qJIcuzBklCIgZo/oMPAHSgKJuy1uQWlAeJ6ZC23RpGGlcrMlErMJagYKastZiaVwunWkuKAMRVNCdzo/VwyfdVXDV9YoeXEKQt3dQO7hBdC2kjdrF7E8N7PjieSEaadmuuUoq5WhtAORUPKQRchTZA8sAf50a0dYhIbgdXbQiNY1i4vYOAXwNKEkG1yHWYOSqEmfuWWQuiIwtP7JYSnksP+5GDuLMfxhu877RAmdentNmvOUm5DydYHuiRCzuLpqQcqgc+Zrgxzom3eZuOXP87c8B7vPEgFuT7RAPkueT7t3dauMzbvJIlSOPpt/TgH0pmvQJkNtgLDgjhbB71VfdLpY66u7A6sPgrQOLLEOS7wAx8vkRmTMfLvu27lYkEoT1zOwuxH8K7R9y7RxGxv10XcQWWXEcYdoe4s3F6wC1XF8MLDg38wgv8wMeEvJqKgikZQf3Ce78LvH8rkmeHgDhrPT15eEQctESYwir8cOYLw0wcwRHXcuNVfzYscjhswcz0wsKrwX3Xvqv5gqvyg1HktULsLKEIUlN6xJNKwn3bEeWrwE0cw078xChEnrGpqy9hwTLIxFHMxYX7czBonF81xl83nOe6mCiMxEwZE2//3MQCtsNC+3Kh+J5EGp8rqRzw0MDt1E5bTHjTgqKRW4IO15bWg7vCKakLBnZ5izGpEsMZzMB++0e2mnyhmFaz+RLzqoCje8kMrCKbfFFLtlihvD+jHLCHTMAEq8oOZUwOlX//k0+Gq6K6F3zyMBDvgMl+pUeANTtu2b1iXJriY64H+r3niMz3REAde8qHszhthj488haZuXkaRs0CscAQ3E7MpIGSaRejnJbifMzkXM59B7AmqYbCGD+M0ijAVw/TDA8E0dDrW7+i28NumVYc2WT6XD0vNKUH288hqcbPlHP1gsoEDWWpijcam8sM3dDV/ND8gVMGSz4YtxYXvVpK/6bRz3jIPPs6bAnSlJOOspl0XvyD00wQ1OzQDBxP03uSahVhM43MBXrGhczROm16PJ2GzYmiIeWwOPE1Qp3SKv3VK228yet6WBSPbdHUHg2ps8rRHZ0x/mmz2ku3JjwxnmyXrkYSevnBKc0OfA0OfM3X7wAOgR3WKQQ5I91g1YqsE3mYQxyQpuyxbK2OBamzl7E7/0tq59zHwCdvGbd7Cu0O8LAOfR0Toy3YYj2ZBolqijekij3CQsx6j22EbA0x0OGomou7Ffls+UyIq7lzhnSAChjaf/3XdkHYKsTHG0l21RpxY5x9ka2LB+ksN1qIwznA96TOO/dz8yiDAiHaw/9d2jIh1hvsPYS3REGossz92swa2QpW2yLNzaXGkRxDyCbc2779gvDsDuuwDg393eygDuogFisNuqx6f0hXrf7wU5pqPa/63IkDjYz1qPhkaoNSwPad3ZFreeugDujQ4QA+3AAe4iGuyOrbERCHghHGJuXV3EHr4A+Oau0t3fTtpvc3q/Wd1RjehGA7zRuOFR4u4kAe5ADuwgIWWOwWd6x9IebN4kX4qOH8vcUMzE6OxjfuzDm+amBLDynN4R3e5V0u5EHODlpMvzuF5O8LE+klzNWDuSGL01YKslJu21hb47Ft5Vf+yTseDwTx3wDu5T8O5urw19X8uRtl2GKH4Bf/kuaCzOb55+aqSS9L1ugiTSggyNs6eecUEzZCPbp6/g7fDej+DdhhHVj2Infpw1aoyeQ76ughWqtrfbchSMTCKbXSiOmZjoDMpBzku+eh3uuCLt7EhuTH+ihLrt5wyeqNjsZsXsqResQC3JhXbetYHsu5vsC87uvDbdTIK72HfqzjGsqjnLM4OqnE+erWXeE33aEoTNeaLe1XXVTwxMDX3utgHdaeOyWmPmvj6mQrromKZe7jrqOpZLUmGdLwHZWotn+e7O6IFlLxbu2eju32HsGChQ+sLZQNtirPCU3/DPDOTe6+GPAGT8rPrn0Mf+X5xERZvOuevhD0PvHIa/He//5qCCiZmhpIaem9De7g1x2pH4h9fdzuJ8+a2nc7+zHxge3yvk7Y3K4PEYbfrYbrG/+dXuvmxoyuEm7wC7/WzAn0Qj/0FHPTg5XFEy8TLx8P9XDoF2+Aa8buNl+9ZLyJ9uTirW7p6ZlmmAr2GF6CeYpRel6+x2v2/k0Q/GEPF6+SDSZSmh7Mca8/Vynu4/zUyV73la7WcdhqqsZzem9xuItmGOzCgk34R0/afS3o1VwP+f70DwZXnjjjjW+Vy3e570rwLX7C9U3yN7JmXX9xmy9vhmdPuXP09p70pO3X7HD63X6slPdgVx00jD2ysk+QtP+Wtq/uNr6IrJb5mi/t2P8tbb/fUd8D8YK9EMTv8mif+gF4ms9vpx/56DBE7sHZvU3uGoi2+2jn/TiuZvQ9OW189AARLx44cAMJviN4UB6+ff0cPtwXUeK+hAn1gbuXEV/FivUI2gMZUqTIevVC4kOZUuVKlSETsoQZEyW4mTQ53uS4EWdFfT199gT3U6LDiD9/ykRptOdGneDoPYVa0KDAgQalxnuXNR69ew0fft0HtGhCimF7RtxZElxJtmwTjjyJlCXcuHLlEmy6U+9epUCFgi1q1G5MjvR2Yn03tSrVrfTs6fP6FSJFyGHJgpsY0S3Btmvb0gUNemVbk/bAuQSJj65MvCxpwny992ZfpZH/J/sVPHOwbNkCC9Izea+yZMkEKZLlN/nhZs9qS4eGDnd0SdAfVUsnHNvma9g1eVukfdarP39EzfYd7J3z3oFas/4uiU888YcV+4GjT5955+fR/cOlrjp70usOr9ZUwikvvWgLarh+yCOvn8AaPEo77nRiai2CDHuKoKo4auypepKyLb/L8MuPOLUS4u+z/1AT6bSQqJNxpAMJ3Mu17zASDjfaInoIwvLOo8mo10Aqrcb12OLwKaoM8xCqEUks0USLKJIsQv08YtGt6DiCq0aQxHSJzJcIy24nHb/rMbyL5ntQSAl9unAmJKm7TjXVTGISKj/9ZEu+oVKkD7yLIhOy/7w4/VmRM7f6o+u0tyL9bswzCVQwp5VyWtBNHxGV06x7YrIU0jzt6fPPDuOTz0FCiUPxPn2aCjJRCBttziO2QpMRpzLB5A1T9W5aczucPOXpLIdsnXMpmFD1DLq2VBWxVSBfrQ+/m+ZkSqdaE5WNNHFNsxTYin6VDcE6u8t03ZqGNbQvgsRzMFGiZp2VVHEDnLEeQKcc0VVsCcpWrzwvQhFCcMhLi7QvP3rrJnJ3FLbbBNXdkUEKM1sWwoecbRcfXfclmdXKrh04ofsqQistkITTdmGGG3Zx3HJNg3hHNYXljtiUdJ7XyKBPHjTUsEaFlyZoHS3ZZJRf3ZYspTDzlf+mripSGCfnmkY3Yq+BhjfNn30Gemg6582saC3NaonTtURsekrIsC0Yp/Py7VG2ATma+SaSJb45zLI1HbvnnWEDuk2ggk776XvzTWlppp0CFO7UhKvSSr3OQxqle+Y9kTd/tP4bzMBtHPzSdl/yGXGdYT67wbTzO3q6fTukfNek5qZ75U592nTznjRScHSOmtZwUpzF7DX1Gy8OO82MEQ4KbY5pD4ulkimXcnfHi3OIt8CG77wpoc376XOqSf+by48sjVHSYFcvNl3peYv9TYElmwh426f1U+4ERbfvjE8fbfqc+YySuceFa1/Je9/yyrS8CGrqcOoqHPSCN71knQz/e3d7lrgAtRYS9U58SsmI+uJ1tlcNxW86e1jzlle/9NikhkCjHngGRZzAkApVIgSOSaiUMtkY8Ccse1PjENUxj9VNa3vxz/uaty7C3aVnrBlcDjf2vcf5EFoAxNP+vhIr3xEsfHyZTVGU+C1bCcl5EYROjayout1UpH7O88lE6FOU8qFkQKj64r4GCLUz2qeQN2kZR8TDwEUl6h+PhOReHqi8OEpqQNe5JMY0eD+34RA8W2ychNjmGtPwKVdCFBQXU0SwmKElkTtBmLIW1cg2tpFmXIuiwTR5Qbu80SIdzKMSz+PH+DVnLYBMiQdNWEaiIPI4LLvbtWrpyFoeL27n/3oRFOVnv4qt7nfxEqZE/EeajmTykov0ynHqAyszjpEsmXlnWPTIxGlmTWYLi5u4OjIyfqFOQKvBYDfLNjXrCfMoInMf4WY1oPlca4cxK5jvIIIZlFV0h1+ppz37ls9rbi1ScQRo4cZ2w+nJi2iNOygUW4Uv3omyZVUyo8ruM1GqRUaVWcqoG63JUeRFK0yVFM2mdENSYs1GYyhNX+dyJKhgmmciFHWnTMlYRqi+KqdyApe2HMLT7eXqRS/qZgZ19qOyZMYo5bsJoKjUOIpKBDPr5MhMo2qcm9ISXMbDCV4fwg+u4mprNstlBWWERaTkCJZkpas40wevf3nPqa98Kv+K4ho+mrLsMvSp58JkU8Z99FUv5OTTV3FGwRuJdJeJU9wCj9M//61OrStVIl3Xt5PwubWteslPRuNpt4kgjznHs6YxKSk4biKoW960X2qDqU5+gFCsG+qetdI2W8vSVpTvNI51cRqnB+FHUYmFbNp4mpaOdGlkPy2m6fb2s6H6MiXKXWSsxLnBfcYHndN9pi/LstuEEWonanSrEq85ufKyaJ8+jVG5uHkmY5VNJRkhK1q+0tx8SS64+OhROG37xmdiCbPZmis0z8Nao/xJn456YXA9aqMJjknBmbzUGx8M38rwg2BrO+CeGrbS+8ZWkUcMGm5NyMrN3e1QPknhqKj/FZVw0aw5LFawkkRi2kwht7QYpvE+knPjCPEjxxa24+6OSD2zahHIPKlu7w4J3rQJrbUpWTLufJkrKKIOkyPR5HM5kmQ+QziYW5ZZl/OFKxYlM3Y/Hh+FzswylzISLGsmcZlj10eUxHnOp0wo4OJ35yljTM8J6XOfhaLllYUqX287nkr090tPCW2Lag7xO/si6SqGZMmXpjOhsVnMX6WmsBcLdZIXCOhAD+nU/pJYMhv0S0UTNH8XJeC88kZRFE57qSP5kzy0ve05twhdLDZQlMm2l2ALe7n8AHSoVOgvKHHmZ2OuntnoRL2zndRxLuTI0TJs5EU78yVlyva2td1t/4d9O8Hhnp/Byp1Cn+RDIujesr2ytxF2JwQ4KzWbIsf6o1hLDXhnfe9eXLm4cjEZHAKXR+pw2WvsqIZiOzO3qHvi8Iig+4zqpji7u1fv/DlYzDgEudVy/GlWLwUnTFbV4OKGOjj62srzwzKNG05zUhfSY/sYVVqBkz4tMptiwzJ0p4KWF/oqWk1Hb3ec2/3ZfDKdTJe89HshzHClUN3mfZOZhLJeGHq8u139vtiFwhx3sS7ujWpfO/tW/mJKyVjuwqG7arWcnO4SZHQRwnqmLi6f13Rd8G7D0Lv+Djqf5wXJ6iv7XtSOYsU/EFLD7drgVsLwyKPT5svi25AUBKUpHf+3ikm7MobseOhgyYZOOsHzuPlucSbrmml/I2513DtjyPv5vrfHa0Iwr8Lc9f7zrDNcmGHSas8vm+B4Us9zk+48k1QqvbKfvedOr4981P+kt8/rkO5BQVQWC3HGlQml4LHFQRikabCdAA624xfCQTl5sDTPeL7fgqA6O7jUmT0+M4r6o7qao7wy+gfLIw9+GJVAgrvoCR6hQorwsDaMMBDeMDm/ERHSOpAGfMCd2gycyTRf4ZXS8xyZm7oNvL1D+sBHCsGFGhn2UhDXERbBgJyb2LuykcEuAb8ZRLn1Uzz1cj/p05kL9MGZA8Ig5AhI+oci3JPN8z3x87SACsAGyRD/w9Il4LIfBqxCVdG1zti1nYCRHQSbHsTAurO7IMw+cHikQPOyPWGVMww+NBwMV1sqXRqWHKQjO8qIlDu5lJOzADowG3yOpgusPYw6c8vAhwvCyksISIKQQkQSGMugO8IURrRA7VgROXuJN8OLHnFAK3xB1vObfupEC6S+2vuJP+xAzSIIMRzDIhzBTEJE1wm+FHTFonJEneASj5DFIhmlbvGJW4OuxINA9hGt9/sOlujDDBTGbAlEU0RGHWEvd2mKiiGoCcy0TMEZ3dAQncuJgzqYnmgS4Fg7ETGwbtxFSPkq+PtF5drAyes4QURHL6O01qAjseqm8vvHbpEcCqqJcYRKvN2JnPZrlX2UxSBiPed7sm8UN6h7POubuokYxp0wxnQ8wQz5NXbsJUUMvcj5IdL6GedwinKSD5XQlaDxyH5ckaGExJEkSR48yb6ov4dLSGM8RoZ0DSQUG5nsSWbEC1oEliR5nvXYSZ7ME1zBh4AAACH5BAUKAOAALAAAAADcAKsAAAj/AM2hQ6euoDp2CBGue8cQXryH8eAhPMju3UN69OrVmzdP4zx57kKKhOdOHkd7KO+BW5lvpUuW+WLum7mPn82b/XLq9MeT58uV/17+G/qzqNChSJP2tBkz3z177dqlO3eOnNVyRrMaFae1q1FyXrsKJGgwoUKG7xxCfDcRocV4GDVu9CgPpDuSIk3OQ2nvnkqWWWXSvIlTZ86ePr0SXekvbNLHQ3ne3Of03jypU6mCDauVa1arnFduDv1zrEGKCReihRiPLTuKb+PW44vy48i8J1GSdjlzJWHDh3saDQo5KLjGjosjRczUKVTMU0fvDgt6+u7NA8miNov27UOJr93G/5OXcTbt2vNC4g2Z257LllrhG7UJDrjw48jBKV9sff+/pUzZc1lU0WFlXVdWSXcgZwOdZlZC3bHWWluxZcQXPvj4hY+AdoWkl27vvdTUiPnQVBM/L9lkH2L37ZfYdP4xx09MAl5W4IIueSZadQhKB5aCXWlX0INuNaTWQ64dtNB45aGEoV9PcShSSfN41RQ4JJZ44k0uFdYPi4gBBZlwxu0W41KU+SWgO1XhWFSCPL4EWoJuOkjkWfDkydo765i1jkPyaASiS1Gml5dRMWGJZZYjDsYlOFyqCNxOyD2GGFL9uSgZP5Q5ZSOQW1EH5zjjfEUnjmXdeVZaatUFzzp9sv+jGjzkCZoVhyDJg+iVjDZqYm9dEiYsP5RWuhxknOWnn6b+9DNZPpe16ZWOOv4EZ49xWhtWqg/Gqlpa49Ulz6uwzkrlbJxV+dM9V8LU66/ArjTTsMN+SaZ/ZWoV5pkAzjhPOuQY6Oa1n4FDJ6iidTWkqqvqKW5dDMHaEJXqEhrTX1r5RaK7jM6k5U/wwovTvvh6BeZxyoHpj78AL6gjwV8Z/KNLPm67XWreokXrw/JElOfPFL90jz76XIxxURpnuWivIf7UscgqCseTf12dPDWzzebTjrTTeQYnwjLLDPa2DLMl8c8P8VzXdztzRCi7TUF59EpyK92rfEgnfbdgwvb/g9/V+CbWLKX44RuZP/dE15k41XLl9ammjja2VwyXKyu4EKktbjwlmeRSX3CPKPdTo4c+4tKKdlU6lHubiNPfhkfmG2E+AR5jP4kHnBXj1a70eLbWTh6aqhJ3x2ramj/8E+i9rs763Zw5X3rr89LHouGN1Xs9vrgDLPBLvBf1+9jAH8hwRd2h3fPDHIlbFOimMyp9/Hh3taGTT85fWZbV13fpmZCqnk0a0xPDdY8cpZoOzNwUlsqxCm3hehg9PPc++PGvU3GbX+k4cx57YCh/0nsaiuxlu5SBgzKO+h+++JE7BUIOHAlkYFZwVrwHZo5nGNGKk54nGBORyHmVGZ1X/zrYwQzpj0TzgtT2XDSjEQ1QZSWMTAtJs0AZdqVcs/pZq3CYQ/sZcWg9hNcPNfgXv3zuJQIiIhFBWLdGlYg+/FiicpyVpSdCcUxTDMs4RlUwK64Eiw8ElPuMYqszelBuRdPSvAZDkzFK71Yu4YgkO2IeNX6Rh0isCaRI6I/AYbApKAITCSHTD3u0TI98jJkfwaEzPUWwK5WkzeqIRrSQhSyD0sNHVuqxkkn6MpYdHN3daAKpOBYwRotKWiibNaxOPoYf/xLeHq0Swze9hFRu0iKtwlLED17SL7QkWlNs6cMgmpE0cqGHLycJTNp8UZwX1CSxjonMNGlsWFqaJ2Sgef/KrJAqQaWqJs2E55UqctObHmSj82gZxl/hUm7uCY1GMLLOX6oRfuEUjCJRNE96mjBNfcmHsFB4ohJCk2tF+WdVBCqn0ZAKm1rZjEzJQRUOXsibHxwdPoimwXD6lJY6HdRLeDlUuRjVJUa15DeHFs5O9Y+TznQRpIL4xuaM05jP3BrCprnS3SQQpi39mlVqeiulYiihl+Rp6RQKzvndL6JF0chPjEpXul4UrVDSB1MTudERctJwU9Wbx5CI1aTwQ6ufoSkCu/LSxsIUrGJNEFXOUVYQ3TWnzsMpZsn4Vr7EFal1Da1cV3JX/E1vnCfynwr3E1i4fdIpoPySUrR2ju//DZSajv2JYx/70h2JdbLnSIcO4Upas15Ss8jdLJTO2kGtEHUloqXrXAW1RjYy1FGq9WhxWNLGi5lTpLKNzIy2ZtsEmQOBuxXoY1fSWN/CCbhTmY5xc5rc+mqWiNOJ7mjnelGc5lUfrpOUHDGln9aGDhyrE2kcDZtH3543vXvkbW/ZC9OvATe46RDubuzqzg3dF60fTCiIQ4xfWMZVv8+FbmnxZ8RaBrhYnYxqgY0zIx5iaXo1ierK5lFbl3D1wbsFqHp9HNaxYjjD8eUML+VSQffoEqEsXvFdU5xf0S5PypilZYDrA9WkFJgxNeZhgnO8nH1s7atjrU5jxcoZycI3/zNklSiTjQLibkq5g+ahsnPnXFT9noe61c1rX7n8Vy+7ZGXO0ZtTEMy6ffRjtu2YqWY2s+YLc23NFqYKnCdbPudy83MlBsedQytnPUcXHHblcKDF6Si/DvjQM+KL6aCE4JgseDn5cEfAjKzml1o4M5F9L4aB+7UNH8izfRYtX/QbFj5DF8XQBrQsXeuonDDGoy9BdEriR2tbR/U/+QAYOcxBlfNS+J/oRfekI6tpYEd2lU1GNmiZjWKJTjfaqk5qMJkaYGJZ+yj5QvTzGklYwPkj3EZeKabT7etgk/vIVTHoLpksVz0fCN/53m+ziYpxuRBR2YfktwA7+iKj9IOqIf/jFEcNnrgMa8axQl54poktcRNDt8rPXTKqjypdkNtDuqUuD75F/Wdpo8Q8GXJx9Qh3lBRRtarO0gmKULYcaEol4qQqR8wb/tsLA5SBFvdKxeu68yVHe9lHJU15hI7i8xDd6N0U+bz+fehl8ccf+1ATu2pir58UB+//UrjWcYvuYHu9080e6onDPu+yk9rsHXcTvps7ZaSDE8BJLEpjHsOYvG9bwQD/O8siHuzS01xBLLX3vU38eGc73sqvzy+qX89zuN8Zr0rXfBRp7JyUiFRMgVvZPdrhDneX/r3F1i28xQ5tWGIc7GS3vdvBwdzzPKmWJl8tpgR+EnYVjvN/p6P/jTh9fMKzNPXLn/epN85sP5qd9malfn+ZavJCc/44nu++amN3OBYOPzrHl1vXNGHpt0sntmHrV4D61k3UJ38eJGL5QzRFYRjaxx+csmgnVFj89x+jFzCD9zW5hX4FOHFld3PW0XrvZ0ULaH0Y4hK6RH1P9kESKIHBAmNRlG3OQnIb2H/QEh3Ell4juCBpd3HRlnieBlrx5xUtRksTSIEDZhxgsoPLIRnQghkvt1tBSISMd4Lrt4UkCFpEx4IfFBpM2BU2KGPEIYVjIiOWER1AeG5Z+IUKOGcaF3YpyHzFhVMeZBQv+BI0uBtRyC+7N4Uqw0JXx3AECFZxiFTpx3FM/+YePzd7djiEzndlN8WHLUgof+gVU5ddUPSJJQSKPOEs/2d+IbiIcZhiOfdZE0dlXmiJ3lQUYzgd8SIph6YyUkdy3yaKAPJ/5UCAqBiMz0VcxmZzjEhnsZiJbiIfreYSOfgoxfQbo3Q4z9g3zMFj6BWM2jh76ZcRftSHu+FTK6F08RIW1jg1AOIxrUZC/GBKBLWNCtiI8PhTM5hR5VQ/7bKOLEJH8RQcLKRh8DiCr6h6e7aKcUiPemVGQ6MSTMMx8lJtnOQs9gQ6GcJ34veOARmQA7lzBQiOP0GP50Q3l8dXieKQWNJqutgslIEeezE0NbGSlJWRMjldkkhvOseNq//kketSS0DVFWXoEnwFEygJVf2wD3pVI7PhkkaZO70zk06JgM/2jWGhZZsYGgd2Qv3mb8GhkkSDD/VgIUzlF2zCOOBAlk95lkp2k9oojrsBTiX5K/QCHJyylD83G1/0LwbyMhiJlmBHjHiYkSEpixmzVw8JNV6SgyaiD/cDJaZUXulQMXy5fHLlJH4pdjKpk1rhXyPJMai1JcMyE0WpVmoCkAYTXPfQiWiJmWAXhht5jPComvGWUIhUNJzZmeSUmAnZmOBwDu2gYCUXmfAGiS2ocWmZbB7ncS+hjHxoZ6ShmRvEaIrmK7dplPgQeOnQmywCnLIIm0oWhtxZkJO3hyv/MYuhIZ7NqVkQ5WRLRT8pxyn6ICDtMA++GSba+RPfmYoYV5fmiVzjKWqQpIT26WEfBok7BET5YI/Pwi7GdDL1iYqVSXvPJ2rgeFY4xUCY2U2dFYZEFEJQZ0f7iJoNep+S2XFHVZkxSJ7Lt2wsSKB3BURzB1XMUT8NCo8kWnFZEWKxWIBHJygU2oIrplxKCaPZCaIzKow1Spwu+IJOkoVoF0tjWFreNDq1JKTKUqQaCaFFSGfbiHZi6E5iCKSYJ6QvQXdW6n7OB3lDx03m2YjzVX0Yal1heh9jOpdlaqTPlqWksaaWuRuXFWIa+qbvFKfZM3JNVKdZSHZYiqju53p5/9pOF+JZbfpfAAYyvlIZhiqQpqaKtDeiSPo+hAR3K/ilCqUP4DCpL0EZCcmYD1qmyokjrtia8NappRaeN6VcCFaGhjGOCflWl2qmvTqrHcdiXwSd9HdC9lKUIumjq/qrVuqFsPqpNSqs0PlTvoEYyIpgzJqtspeZrfoTshGswrpXPFWG1tqJc6Ot6EpImMifL4ER7uquQ1erMpghusoYy9EPpJquT8mo6WdfHvmuAPutaOp4HRaLGBNe/xGaSSqi+ipDmsWvRLWHSuqaN+qvcPWVAfuuVuZzD7ikK4Gw/+A3MNiwqOivfAZ5HVuX1IWiC2tfF5uxAZt2lGiJ4nlrSP8hsg1Islnor17pcxsiKB6HUHPGs2eFVDALsAk4lY72bSGbrzrbkUR7ViAXS0mFUMkZtUN1tBrrrDNbqo5GSnr1tPB2olHboz0rFx5WVyC2nTybtVrLqGS3o4MCYCCbsDw1nGKLI2X7YT2qsrRRtSwLg/5aVFrLds92Z9e3tJbCD+F0DxuSt3q7twj1YdTFYarZtn12tEAnfQWbdIqbFDhLKI8LuecpuXooYh+HpltoX+9zdj7qZyPmkvrkTNb2h7RGupxhusiFP026o44XGppFZ9A2hjw7YjsFmrIVYzmxD0AZTrgLvKxbvAnFc0K1pwjYdntYZ9WVUwDmbzHWE5P/kqvPGxasK7hmS2IY8qxzJV8qG111SbBEK7tCSqVVOr7ryq7S261pqZb7m6Znh1ZTCqNbSYj260XJNZ7JBanLCkvuGpWo1of7daSJGloySLdECWP/0UnbyLAlW18IvLvVyxmF23NHCq+jNVEmnE5Gxb18t49nqMEFXLEHbL6nu8BzVbgCa1Qwm06FuxI4DK8svJWj+ML1G8MfHLwuG8Je8a4SchEaKxs/rLXx4BIQkbF0FcSidIZGnJkLu53mK2+h4a4908Q4LCFSLCFUzBpWzKMYIqgZ/IkiS6RbvBtPlrNHmHMY0cRmDLN63MdovBJ+vLVsfLyfezi4uCgMzK/Z/yqisMnBPpzHfuzEARvJkQwOD2HJZIy0aJu4+kSILlyqTmsUSEuyjsxB/pkVkEzJcMHEqtzHaZzJgmyXbdy9dZvFIsu8qDzKDVvKXMhxqdwa3pHJrezKU/zKapzCSFfBjlbL1oqzRlkUmkvKOkrCGLsWDBHI9DDMTYzJkRzL6BmnlgK+1maUPynKGturl7tKxEWJ1dzK7qrNrPHIOFxXOKVlh6EUQ+wsoKxX+ivP5cGRfkQby9fPQSizKOzOrNzHGQsOUcx2suxNAYyw+dwbdxu4/kyH6gzGVsTLxxZRJ8vQk6zHZ9zDIP3DgAvRAVxAozgTNLirFl3SQmeCRaqMHP9dnu07bxnR0DoNsC7h0F+pw3alWfZMlHNZj7T00iWtyE7Jski9SihIVybNw2vs0OoXbcjVVLq4vM9cquKqIVqRwtrpwcG4oxi3w/oVy0B3p9BmvFgdvs8MVHvl1V8d08BZoU2dou17pHqtqGqtX1ftYpNC0RWdP9i6y0Eo0IbUXHu92CfrvsJawZi3zDrxzOW7ywQtQ7pBXCwq0IzN2H0dWo89y5ENHEvJXBU6x1Y0KJW32B27wlKbVBbn2GytZZI92aDsuCxmn6htHbdH1iTauQIqtErtccYr1E1V2zpxQkfdgnMTyrv9n6AWUf2V1ws4G/S8t++7PGod2vV83Mj/G7pG8YfE9Nx8mtlNStznDWi6e9qe+tnFzb20/d1mGDJkSt5qimeqlt7yGrw0PMMVpLb2Ja4mktxa4dbjbd9DdFFqW3To7d8ty98BylxBW18/RRPgHb4RaRjlyJc1vZo0u71uyt3sKsPsfcSS61MmUn9fIsS2jOD3PV+iOuKRu94oTky4nG28yKAuPlz9BWX7LeMHst6iTY68ceA5np07TmeAGtoiTrzdyrCTy7MImeK8QdsfC76imC9JHt3AncDvDeS529/+ipDYVxTkXKx+8yV/ozL8seVc/uPJiLUWjaItSLZSTuanauZdSa+6F4hanuQ9LuSz2M91/uD2ReaR/12YVI6Vpc2d32tov9rhNgXi96O7BlzHDXjnFV6OiTmdiqmM4G13kG7EsvqnWCa5SsjfdY7SNf4rRU4TU/4rez6mjCHqo17ASt3bTe7gJI7S3R3fA47LsI7oWuaHdzuOy0xA24XrpBabp1625Dvk4STtkY28p8rSCDmSmFcUTusXjvZ992e/aY1Gug7nlX21ZEvs1Q4cr47t6u5iJofLU7p7MVx7KVbu5u7g+DvkO9XqoAkysE7O736quZrmk93C9LnFY6dx+L7rEG7iNIzovwLenS7wiH7tk4KLW6nw425xug7CYC7m9EjfoXubjeu4on3ttX3k9CnHOtvsMv3mz/8OZSHf35tu4d8O8CHjU8vV76+e8SwvHC5PsjCPkzL/o3xb4ujO6hYuvkZh48x747e9kOCI3EGvMuMLezFv6m5H6aat9C276U6v8+SElc4LMix+9fv4vFpv9KVVXDFe6Tl6vzU+9llR9iy91WhPv1CkewRO9CT64b2d9KkO39We810h9Ru+4YxOxFg/gSDz8om6qUd/e3wb7fC96InP6QfO+OGb4x8bvnPJ+A067tBKcc2+Ylz/40rMtrOs+XkOLIx/4M74+WmP5LUfdbJelZDLbA3f5UqM6RGf6Hcf+RQd9VmxIhpf4Acv67fbsF17ar/P+iY66DEI72Eh7PJSqg//CflOeMihb/BavfOfLumRWaOVb/mne7/2SaqkX9+ujuywH/5wHMeLtMwmj/I2LIQ0uvAAUQ9cPYIEwQ08aE/hQob28D20V5CgwocV8TE8CM6ixYwH9XUEGRLkvn0dPx7cdxJcv34d+/nzd5Aly5EkbdrUl1OnznsV7YkEGlToUKJECw48KhFpR4PgGj5dKHGiw40YqW58WFRly44kUZZE+dGmzJkZaQLlh/PmTp49IWIsGlfuXKFSk9plahBqQ7tTrz5s6hRrxYwqReYMmbImuJRjV87kKpQlTrY53VrcS1cuXs1LRfY1KPDg0dEF9/IF7VdhYKSDC+sEarhyV8Zg/8lCFnlTd+Wcgy9C7RyXM13QpfuCTF3vNMPkypmLTvgXX0jYsRGDY/vV9m3IZ2uTzLmbd8+rFDMHJ05PqvDh6xHmBQ21efOQFAlTN1zY4+uTYrc/bsm7fSIDbyfxUtppMKiyQm8ueh48zii8BCINuvlQm684keyb7qCHdiIqv67+IyuoAivTba3eMItqIgYbjOtB9ShU6rO7aPSsRqSSwzBD9zYMqSIQ4xJRMg/xuQ67tu7RKUXK9KmqrxdhJEpGg9Rjjx6EQoNvxwt79BE65H7S6MgPZ/uoSN2E2k4ftyrr6R4mUYSTxYjscojKGCEUSMbRHgQH0IwK0nJG1sKU6v85REkLSbmMBgMxwek6XOyrw5SE8kzLhOStTsykslJMPYUKdSBBM/LTrlDXW7TV5IBy1EzC7unIt6xeNAysNDHVaaPLkISTSXzktPVOgqwcVc96ZBSUz1eNczXawGgMjEONinUoItdow1TOntiylVM3f932LYm0TJZKZpt1VkMvpXV1UB2d+inK1CKiKs8jed1UXKw49PethXzbN91k10U3UECZhbfhCN+FTqFrpwvzqkcfmnPFcC+SaGAGIZKKYIPRY7ajdQM9qFCEHWZZVPccfSrMgifOONNwje2YqokTxUq/NN0auUo/UUU4ZYXXbbnlLpGSmN7VzkWaUZAIm3T/Y5wNJYijO/kcjFb+LAsaKIQTHrvsVZP2sV2XQyPtTmPNNlQubEE9WzScHeWIUo8kDTuksU2Ge2W0w1QbWnmTC5y1oqp6WlWGbzStZ5AQK1JPeS73u2iiA3+8Zc4Fr5BR0D7nc2qhWGxuaHen1hscr702+HLZ5clo9tkTPpp0tRHvXPexdQy9L93FbD0ikcyVuSmpY0uXdpFshx4c28n2vfPUqh9+WhxHZzYe7+P5eyhqo/USacaAAtaw1ulyPiTobZf+9s2x5x170kVHzvEHv+dfcKDeXtRA8KWUooGHdUNaX9jet0D7NdCBZivN4c7FPwp+r2TLS8ixrKdBrGUE/193QpnJlFSfM2lkIZpxnvcOEo/odWSB73tgDGXYKGrJiH/vwOE7+pcqxZUGdIRaFVOeFhLv4Q4kOmuQCt0HP+kd5IVPlNH0Hng5GZZtNExBig29l8Mc7vBYGHQK1ITXro6cECjga9RnigIPNrYxI/CIhwufOEc6ys57sitbHWFIDzzaT1SH0yIXuwg+COXlPR6U2I84OC9Gnep7KcPaqf4IlDZWspIV5J8eNblHPm6SgWOzYOIUx7ZAChKHhOwhtApStQTOCz4qO5XRILmslOkogQdh4xstackKzpGCnrwdMDlJxf0VUZRkklcWi2nKUwJqbX1BJus0gyOxrSxuZf8q0y5ziUttthGTmZwdJn35yxfesY/yYBb0oojOYn7OOfkz1TKZqcPdqUoi68PMXFIJuIVhjXgP6WZABQrHbxb0cuCUxzfLycJzplOKndQi57JGQ2VucZ7GHF5GvKIxfExSfEFRosJcWRF4gGOgJ+1mQVW6UoYmlKHiTCg74UZMemDUbBNFzp9qGo956tCCP4UbdAw4sVsGJ45xnGU0a4WPkqLUqZdk4/d4yVKFfu+gvYypTPMoU5uWTTnrE00pfTrIn4IPk497Daz65Mq4PPJosQoSU036VIFSkJdTpapKr0pOhgaOpl393ZR2JFYdcrGgxaSgs5Tqoa3FUpZpFMkHUU3m0YwEBAA7" /></p>
</div>
<div id="materiais-e-métodos" class="section level2" number="0.2">
<h2><span class="header-section-number">0.2</span> Materiais e métodos</h2>
<p>A base de dados disponibilizada pelo <a href="https://app.anm.gov.br/SIGBM/Publico/ClassificacaoNacionalDaBarragem">SIGBM - Sistema de Gestão de Segurança de Barragem de Mineração</a> apresenta dados referentes à Barragens de Mineração no território brasileiro.</p>
<p><br></p>
</div>
<div id="carregando-os-pacotes" class="section level2" number="0.3">
<h2><span class="header-section-number">0.3</span> Carregando os pacotes</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Carregar pacotes:</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(janitor)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(readxl)</span></code></pre></div>
</div>
<div id="download-e-leitura-da-base" class="section level2" number="0.4">
<h2><span class="header-section-number">0.4</span> Download e leitura da base</h2>
<div id="download" class="section level3" number="0.4.1">
<h3><span class="header-section-number">0.4.1</span> Download</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="do">## ----download-data------------------</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="do">## # Fazer download da base de dados do dia atual:</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="do">## # url para baixar os dados</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>url_request <span class="ot">&lt;-</span> <span class="st">&quot;https://app.anm.gov.br/SIGBM/Publico/ClassificacaoNacionalDaBarragem/ExportarExcel&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="do">## # cria a pasta dados (se não existir)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>fs<span class="sc">::</span><span class="fu">dir_create</span>(<span class="st">&quot;dados&quot;</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="do">## # funcão que baixa os dados</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>httr<span class="sc">::</span><span class="fu">POST</span>(url_request, httr<span class="sc">::</span><span class="fu">write_disk</span>(<span class="st">&quot;dados/sigbm.xlsx&quot;</span>))</span></code></pre></div>
</div>
<div id="leitura" class="section level3" number="0.4.2">
<h3><span class="header-section-number">0.4.2</span> Leitura</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="do">## ----load-data-----------------</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Importar a base de dados:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ler os dados baixados</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>sigbm <span class="ot">&lt;-</span> <span class="fu">read_xlsx</span>(<span class="st">&quot;dados/sigbm.xlsx&quot;</span>, <span class="at">skip =</span> <span class="dv">4</span>) <span class="sc">|&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">clean_names</span>()</span></code></pre></div>
<p>Data de atualização da base</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ----- data de atualização -----</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>data_atualizacao_sigbm <span class="ot">&lt;-</span> <span class="fu">read_xlsx</span>(<span class="st">&quot;dados/sigbm.xlsx&quot;</span>,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">col_names =</span> <span class="cn">FALSE</span>,</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">n_max =</span> <span class="dv">1</span>) <span class="sc">|&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>() <span class="sc">|&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">str_extract</span>(<span class="st">&quot;:.*-&quot;</span>) <span class="sc">|&gt;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">str_remove</span>(<span class="st">&quot;:&quot;</span>) <span class="sc">|&gt;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">str_remove</span>(<span class="st">&quot;-&quot;</span>) <span class="sc">|&gt;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">str_trim</span>()</span></code></pre></div>
</div>
</div>
<div id="barragens-de-mineração-no-brasil" class="section level2" number="0.5">
<h2><span class="header-section-number">0.5</span> Barragens de mineração no Brasil</h2>
<p>A base do SIGBM foi obtida no dia 16/08/2022, e apresentou informações referentes a 911.</p>
</div>
<div id="tabela" class="section level2" number="0.6">
<h2><span class="header-section-number">0.6</span> Tabela</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="do">## ----tabela-top-10-------------------------</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>sigbm <span class="sc">|&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">count</span>(uf, <span class="at">sort =</span> <span class="cn">TRUE</span>) <span class="sc">|&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>) <span class="sc">|&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="st">`</span><span class="at">Estado</span><span class="st">`</span> <span class="ot">=</span> uf, <span class="st">`</span><span class="at">Número de barragens</span><span class="st">`</span> <span class="ot">=</span> n) <span class="sc">|&gt;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  knitr<span class="sc">::</span><span class="fu">kable</span>(<span class="at">caption =</span> <span class="st">&quot;Dez estados brasileiros com mais barragens cadastradas no SIG-BM&quot;</span>)</span></code></pre></div>
<table>
<caption><span id="tab:unnamed-chunk-5">Table 1: </span>Dez estados brasileiros com mais barragens cadastradas no SIG-BM</caption>
<thead>
<tr class="header">
<th align="left">Estado</th>
<th align="right">Número de barragens</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">MG</td>
<td align="right">346</td>
</tr>
<tr class="even">
<td align="left">MT</td>
<td align="right">152</td>
</tr>
<tr class="odd">
<td align="left">PA</td>
<td align="right">114</td>
</tr>
<tr class="even">
<td align="left">BA</td>
<td align="right">82</td>
</tr>
<tr class="odd">
<td align="left">SP</td>
<td align="right">68</td>
</tr>
<tr class="even">
<td align="left">RO</td>
<td align="right">36</td>
</tr>
<tr class="odd">
<td align="left">GO</td>
<td align="right">22</td>
</tr>
<tr class="even">
<td align="left">AP</td>
<td align="right">18</td>
</tr>
<tr class="odd">
<td align="left">MS</td>
<td align="right">18</td>
</tr>
<tr class="even">
<td align="left">AM</td>
<td align="right">15</td>
</tr>
</tbody>
</table>
</div>
<div id="gráfico" class="section level2" number="0.7">
<h2><span class="header-section-number">0.7</span> Gráfico</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="do">## ----plot-dpa---------------------------</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>sigbm <span class="sc">|&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">count</span>(dano_potencial_associado) <span class="sc">|&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">dano_potencial_associado =</span> <span class="fu">if_else</span>(</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>      dano_potencial_associado <span class="sc">==</span> <span class="st">&quot;N/A&quot;</span>,</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Não se aplica&quot;</span>,</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>      dano_potencial_associado</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">dano_potencial_associado =</span> <span class="fu">factor</span>(</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>      dano_potencial_associado,</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>      <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">&quot;Não se aplica&quot;</span>, <span class="st">&quot;Baixo&quot;</span>, <span class="st">&quot;Médio&quot;</span>, <span class="st">&quot;Alto&quot;</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> dano_potencial_associado, <span class="at">y =</span> n) <span class="sc">+</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_col</span>(<span class="at">fill =</span> <span class="st">&quot;lightblue&quot;</span>) <span class="sc">+</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">&quot;Dano potencial associado (DPA)&quot;</span>, <span class="at">y =</span> <span class="st">&quot;Quantidade de barragens&quot;</span>,</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>       <span class="at">title =</span> <span class="st">&quot;Dano potencial associado de barragens de mineração no Brasil&quot;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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CgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0FQMUBLta5IEBCgIdpVF0lVeAfifGW2YQ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" width="672" /></p>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
